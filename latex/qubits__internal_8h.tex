\hypertarget{qubits__internal_8h}{
\subsection{qubits\_\-internal.h File Reference}
\label{qubits__internal_8h}\index{qubits\_\-internal.h@{qubits\_\-internal.h}}
}


Internal functions used to implement the public facing API in \hyperlink{qubits_8h}{qubits.h}.  
{\ttfamily \#include \char`\"{}precision.h\char`\"{}}\par
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}{compactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}{compactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}{unitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}{unitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}{controlledCompactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}{controlledCompactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}{controlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}{controlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}{multiControlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{multiControlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}{sigmaXLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}{sigmaXDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}{sigmaYLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}{sigmaYDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}{hadamardLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}{hadamardDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}{phaseGateLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}{phaseGateDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}{controlledNotLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit)
\item 
void \hyperlink{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}{controlledNotDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{findProbabilityOfZeroLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{findProbabilityOfZeroDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}{collapseToOutcomeLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int measureQubit, REAL totalProbability, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, const REAL totalProbability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Set all amplitudes in one chunk to 0. \item\end{DoxyCompactList}\item 
int \hyperlink{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}{validateMatrixIsUnitary} (\hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
int \hyperlink{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}{validateAlphaBeta} (\hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
int \hyperlink{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}{validateUnitVector} (REAL ux, REAL uy, REAL uz)
\item 
void \hyperlink{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}{phaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}{exitWithError} (int errorCode, const char $\ast$func)
\item 
void \hyperlink{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert} (int isValid, int errorCode, const char $\ast$func)
\end{DoxyCompactItemize}
\subsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \hyperlink{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}{errorCodes} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
Internal functions used to implement the public facing API in \hyperlink{qubits_8h}{qubits.h}. Do not call these functions directly. In general, \hyperlink{qubits__env__local_8c}{qubits\_\-env\_\-local.c} and \hyperlink{qubits__env__mpi_8c}{qubits\_\-env\_\-mpi.c} will implement the public API by choosing the correct function or combination of functions to use from those included here. 

Definition in file \hyperlink{qubits__internal_8h_source}{qubits\_\-internal.h}.

\subsubsection{Function Documentation}
\hypertarget{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}}
\index{collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeDistributedRenorm}]{\setlength{\rightskip}{0pt plus 5cm}REAL collapseToOutcomeDistributedRenorm ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  const REAL {\em totalProbability})}\hfill}
\label{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}


Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that the value 'outcome' has been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being zero \end{DoxyParams}


Definition at line 1871 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1872 {
1873         // ----- temp variables
1874         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1875         long long int numTasks=multiQubit.numAmps;
1876         // (good for shared memory parallelism)
1877 
1878         REAL renorm=1/sqrt(totalProbability);
1879         
1880         REAL *stateVecReal = multiQubit.stateVec.real;
1881         REAL *stateVecImag = multiQubit.stateVec.imag;
1882 
1883 # ifdef _OPENMP
1884 # pragma omp parallel \
1885         shared    (numTasks,stateVecReal,stateVecImag) \
1886         private   (thisTask)
1887 # endif
1888         {
1889 # ifdef _OPENMP
1890                 # pragma omp for schedule  (static)
1891 # endif
1892                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1893                         // summation -- simple implementation
1894                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
1895                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
1896                 }
1897         }
1898         return totalProbability;
1899 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}}
\index{collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeDistributedSetZero}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeDistributedSetZero ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}


Set all amplitudes in one chunk to 0. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that a zero have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}


Definition at line 1913 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1914 {
1915         // ----- temp variables
1916         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1917         long long int numTasks=multiQubit.numAmps;
1918         // (good for shared memory parallelism)
1919 
1920         // ---------------------------------------------------------------- //
1921         //            find probability                                      //
1922         // ---------------------------------------------------------------- //
1923 
1924         REAL *stateVecReal = multiQubit.stateVec.real;
1925         REAL *stateVecImag = multiQubit.stateVec.imag;
1926 
1927 # ifdef _OPENMP
1928 # pragma omp parallel \
1929         shared    (numTasks,stateVecReal,stateVecImag) \
1930         private   (thisTask)
1931 # endif
1932         {
1933 # ifdef _OPENMP
1934                 # pragma omp for schedule  (static)
1935 # endif
1936                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1937                         // summation -- simple implementation
1938                         stateVecReal[thisTask] = 0;
1939                         stateVecImag[thisTask] = 0;
1940                 }
1941         }
1942 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeLocal@{collapseToOutcomeLocal}}
\index{collapseToOutcomeLocal@{collapseToOutcomeLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeLocal}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeLocal ({\bf MultiQubit} {\em multiQubit}, \/  int {\em measureQubit}, \/  REAL {\em totalProbability}, \/  int {\em outcome})}\hfill}
\label{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}


Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. Performs an irreversible change to the state vector: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being either zero or one \item[\mbox{$\leftarrow$} {\em outcome}]to measure the probability of and set the state to -\/-\/ either zero or one \end{DoxyParams}


Definition at line 1789 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1790 {
1791         // ----- sizes
1792         long long int sizeBlock,                                           // siz
      e of blocks
1793         sizeHalfBlock;                                       // size of blocks ha
      lved
1794         // ----- indices
1795         long long int thisBlock,                                           // cur
      rent block
1796              index;                                               // current inde
      x for first half block
1797         // ----- measured probability
1798         REAL   renorm;                                    // probability (returne
      d) value
1799         // ----- temp variables
1800         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1801         // (good for shared memory parallelism)
1802         long long int numTasks=multiQubit.numAmps>>1;
1803 
1804         // ---------------------------------------------------------------- //
1805         //            dimensions                                            //
1806         // ---------------------------------------------------------------- //
1807         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1808         // and then the number to skip
1809         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1810         
1811         renorm=1/sqrt(totalProbability);
1812         REAL *stateVecReal = multiQubit.stateVec.real;
1813         REAL *stateVecImag = multiQubit.stateVec.imag;
1814 
1815 
1816 # ifdef _OPENMP
1817 # pragma omp parallel \
1818         default (none) \
1819         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,re
      norm,outcome) \
1820         private   (thisTask,thisBlock,index)
1821 # endif
1822         {
1823                 if (outcome==0){
1824                         // measure qubit is 0
1825 # ifdef _OPENMP
1826                         # pragma omp for schedule  (static)
1827 # endif
1828                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1829                                 thisBlock = thisTask / sizeHalfBlock;
1830                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
1831                                 stateVecReal[index]=stateVecReal[index]*renorm;
1832                                 stateVecImag[index]=stateVecImag[index]*renorm;
1833 
1834                                 stateVecReal[index+sizeHalfBlock]=0;
1835                                 stateVecImag[index+sizeHalfBlock]=0;
1836                         }
1837                 } else {
1838                         // measure qubit is 1
1839 # ifdef _OPENMP
1840                         # pragma omp for schedule  (static)
1841 # endif
1842                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1843                                 thisBlock = thisTask / sizeHalfBlock;
1844                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
1845                                 stateVecReal[index]=0;
1846                                 stateVecImag[index]=0;
1847 
1848                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[in
      dex+sizeHalfBlock]*renorm;
1849                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[in
      dex+sizeHalfBlock]*renorm;
1850                         }
1851                 }
1852         }
1853 
1854 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!compactUnitaryDistributed@{compactUnitaryDistributed}}
\index{compactUnitaryDistributed@{compactUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{compactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 546 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by compactUnitary().


\begin{DoxyCode}
551 {
552 
553         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
554         long long int thisTask;  
555         const long long int numTasks=multiQubit.numAmps;
556 
557         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
558         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
559         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
560         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
561         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
562 
563 # ifdef _OPENMP
564 # pragma omp parallel \
565         default  (none) \
566         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
567                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
568         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
569 # endif
570         {
571 # ifdef _OPENMP
572                 # pragma omp for schedule (static)
573 # endif
574                 for (thisTask=0; thisTask<numTasks; thisTask++) {
575                         // store current state vector values in temp variables
576                         stateRealUp = stateVecRealUp[thisTask];
577                         stateImagUp = stateVecImagUp[thisTask];
578 
579                         stateRealLo = stateVecRealLo[thisTask];
580                         stateImagLo = stateVecImagLo[thisTask];
581 
582                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
583                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
584                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
585                 }
586         }
587 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!compactUnitaryLocal@{compactUnitaryLocal}}
\index{compactUnitaryLocal@{compactUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{compactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}


Definition at line 417 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by compactUnitary().


\begin{DoxyCode}
418 {
419         long long int sizeBlock, sizeHalfBlock;
420         long long int thisBlock, // current block
421              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
422 
423         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
424         long long int thisTask;         
425         const long long int numTasks=multiQubit.numAmps>>1;
426 
427         // set dimensions
428         sizeHalfBlock = 1LL << targetQubit;  
429         sizeBlock     = 2LL * sizeHalfBlock; 
430 
431         // Can't use multiQubit.stateVec as a private OMP var
432         REAL *stateVecReal = multiQubit.stateVec.real;
433         REAL *stateVecImag = multiQubit.stateVec.imag;
434         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
435         REAL betaImag=beta.imag, betaReal=beta.real;
436 
437 # ifdef _OPENMP
438 # pragma omp parallel \
439         default  (none) \
440         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
441         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
442 # endif
443         {
444 # ifdef _OPENMP
445                 # pragma omp for schedule (static)
446 # endif
447                 for (thisTask=0; thisTask<numTasks; thisTask++) {
448 
449                         thisBlock   = thisTask / sizeHalfBlock;
450                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
451                         indexLo     = indexUp + sizeHalfBlock;
452 
453                         // store current state vector values in temp variables
454                         stateRealUp = stateVecReal[indexUp];
455                         stateImagUp = stateVecImag[indexUp];
456 
457                         stateRealLo = stateVecReal[indexLo];
458                         stateImagLo = stateVecImag[indexLo];
459 
460                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
461                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag
      *stateImagUp 
462                                 - betaReal*stateRealLo - betaImag*stateImagLo;
463                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag
      *stateRealUp 
464                                 - betaReal*stateImagLo + betaImag*stateRealLo;
465 
466                         // state[indexLo] = beta  * state[indexUp] + conj(alpha) 
      * state[indexLo]
467                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*s
      tateImagUp 
468                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
469                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*s
      tateRealUp 
470                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
471                 } 
472         }
473 
474 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}}
\index{controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledCompactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 856 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
861 {
862 
863         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
864         long long int thisTask;  
865         const long long int numTasks=multiQubit.numAmps;
866         const long long int chunkSize=multiQubit.numAmps;
867         const long long int chunkId=multiQubit.chunkId;
868 
869         int controlBit;
870 
871     REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
872         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
873         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
874         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
875         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
876 
877 # ifdef _OPENMP
878 # pragma omp parallel \
879         default  (none) \
880         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
881                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
882         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
883 # endif
884         {
885 # ifdef _OPENMP
886                 # pragma omp for schedule (static)
887 # endif
888                 for (thisTask=0; thisTask<numTasks; thisTask++) {
889                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
890                         if (controlBit){
891                                 // store current state vector values in temp vari
      ables
892                                 stateRealUp = stateVecRealUp[thisTask];
893                                 stateImagUp = stateVecImagUp[thisTask];
894 
895                                 stateRealLo = stateVecRealLo[thisTask];
896                                 stateImagLo = stateVecImagLo[thisTask];
897 
898                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
899                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp 
      - rot1Imag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
900                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp 
      + rot1Imag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
901                         }
902                 }
903         }
904 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}}
\index{controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledCompactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}


Definition at line 647 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
649 {
650         long long int sizeBlock, sizeHalfBlock;
651         long long int thisBlock, // current block
652              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
653 
654         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
655         long long int thisTask;         
656         const long long int numTasks=multiQubit.numAmps>>1;
657         const long long int chunkSize=multiQubit.numAmps;
658         const long long int chunkId=multiQubit.chunkId;
659 
660         int controlBit;
661 
662     // set dimensions
663         sizeHalfBlock = 1LL << targetQubit;  
664         sizeBlock     = 2LL * sizeHalfBlock; 
665 
666         // Can't use multiQubit.stateVec as a private OMP var
667         REAL *stateVecReal = multiQubit.stateVec.real;
668         REAL *stateVecImag = multiQubit.stateVec.imag;
669         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
670         REAL betaImag=beta.imag, betaReal=beta.real;
671 
672 # ifdef _OPENMP
673 # pragma omp parallel \
674         default  (none) \
675         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
676         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
677 # endif
678         {
679 # ifdef _OPENMP
680                 # pragma omp for schedule (static)
681 # endif
682                 for (thisTask=0; thisTask<numTasks; thisTask++) {
683 
684                         thisBlock   = thisTask / sizeHalfBlock;
685                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
686                         indexLo     = indexUp + sizeHalfBlock;
687 
688                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
689                         if (controlBit){
690                                 // store current state vector values in temp vari
      ables
691                                 stateRealUp = stateVecReal[indexUp];
692                                 stateImagUp = stateVecImag[indexUp];
693 
694                                 stateRealLo = stateVecReal[indexLo];
695                                 stateImagLo = stateVecImag[indexLo];
696 
697                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
698                                 stateVecReal[indexUp] = alphaReal*stateRealUp - a
      lphaImag*stateImagUp 
699                                         - betaReal*stateRealLo - betaImag*stateIm
      agLo;
700                                 stateVecImag[indexUp] = alphaReal*stateImagUp + a
      lphaImag*stateRealUp 
701                                         - betaReal*stateImagLo + betaImag*stateRe
      alLo;
702 
703                                 // state[indexLo] = beta  * state[indexUp] + conj
      (alpha) * state[indexLo]
704                                 stateVecReal[indexLo] = betaReal*stateRealUp - be
      taImag*stateImagUp 
705                                         + alphaReal*stateRealLo + alphaImag*state
      ImagLo;
706                                 stateVecImag[indexLo] = betaReal*stateImagUp + be
      taImag*stateRealUp 
707                                         + alphaReal*stateImagLo - alphaImag*state
      RealLo;
708                         }
709                 } 
710         }
711 
712 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledNotDistributed@{controlledNotDistributed}}
\index{controlledNotDistributed@{controlledNotDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledNotDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk. Only perform the rotation for elements where controlQubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1185 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by controlledNot().


\begin{DoxyCode}
1188 {
1189 
1190         long long int thisTask;  
1191         const long long int numTasks=multiQubit.numAmps;
1192         const long long int chunkSize=multiQubit.numAmps;
1193         const long long int chunkId=multiQubit.chunkId;
1194 
1195         int controlBit;
1196 
1197         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1198         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1199 
1200 # ifdef _OPENMP
1201 # pragma omp parallel \
1202         default  (none) \
1203         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1204         private  (thisTask,controlBit)
1205 # endif
1206         {
1207 # ifdef _OPENMP
1208                 # pragma omp for schedule (static)
1209 # endif
1210                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1211                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
1212                         if (controlBit){
1213                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTa
      sk];
1214                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTa
      sk];
1215                         }
1216                 }
1217         }
1218 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledNotLocal@{controlledNotLocal}}
\index{controlledNotLocal@{controlledNotLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledNotLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}


Definition at line 1120 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledNot().


\begin{DoxyCode}
1121 {
1122         long long int sizeBlock, sizeHalfBlock;
1123         long long int thisBlock, // current block
1124              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1125 
1126         REAL stateRealUp,stateImagUp;
1127         long long int thisTask;         
1128         const long long int numTasks=multiQubit.numAmps>>1;
1129         const long long int chunkSize=multiQubit.numAmps;
1130         const long long int chunkId=multiQubit.chunkId;
1131 
1132         int controlBit;
1133 
1134         // set dimensions
1135         sizeHalfBlock = 1LL << targetQubit;  
1136         sizeBlock     = 2LL * sizeHalfBlock; 
1137 
1138 
1139         // Can't use multiQubit.stateVec as a private OMP var
1140         REAL *stateVecReal = multiQubit.stateVec.real;
1141         REAL *stateVecImag = multiQubit.stateVec.imag;
1142 
1143 # ifdef _OPENMP
1144 # pragma omp parallel \
1145         default  (none) \
1146         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1147         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,co
      ntrolBit) 
1148 # endif
1149         {
1150 # ifdef _OPENMP
1151                 # pragma omp for schedule (static)
1152 # endif
1153                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1154                         thisBlock   = thisTask / sizeHalfBlock;
1155                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1156                         indexLo     = indexUp + sizeHalfBlock;
1157 
1158                         controlBit = extractBit(controlQubit, indexUp+chunkId*chu
      nkSize);
1159                         if (controlBit){
1160                                 stateRealUp = stateVecReal[indexUp];
1161                                 stateImagUp = stateVecImag[indexUp];
1162 
1163                                 stateVecReal[indexUp] = stateVecReal[indexLo];
1164                                 stateVecImag[indexUp] = stateVecImag[indexLo];
1165 
1166                                 stateVecReal[indexLo] = stateRealUp;
1167                                 stateVecImag[indexLo] = stateImagUp;
1168                         }
1169                 } 
1170         }
1171 
1172 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledUnitaryDistributed@{controlledUnitaryDistributed}}
\index{controlledUnitaryDistributed@{controlledUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 919 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledUnitary().


\begin{DoxyCode}
924 {
925 
926         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
927         long long int thisTask;  
928         const long long int numTasks=multiQubit.numAmps;
929         const long long int chunkSize=multiQubit.numAmps;
930         const long long int chunkId=multiQubit.chunkId;
931 
932         int controlBit;
933 
934         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
935         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
936         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
937         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
938         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
939 
940 # ifdef _OPENMP
941 # pragma omp parallel \
942         default  (none) \
943         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
944                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
945         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
946 # endif
947         {
948 # ifdef _OPENMP
949                 # pragma omp for schedule (static)
950 # endif
951                 for (thisTask=0; thisTask<numTasks; thisTask++) {
952                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
953                         if (controlBit){
954                                 // store current state vector values in temp vari
      ables
955                                 stateRealUp = stateVecRealUp[thisTask];
956                                 stateImagUp = stateVecImagUp[thisTask];
957 
958                                 stateRealLo = stateVecRealLo[thisTask];
959                                 stateImagLo = stateVecImagLo[thisTask];
960 
961                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
962                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
963                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
964                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
965                         }
966                 }
967         }
968 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledUnitaryLocal@{controlledUnitaryLocal}}
\index{controlledUnitaryLocal@{controlledUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}


Definition at line 777 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledUnitary().


\begin{DoxyCode}
779 {
780         long long int sizeBlock, sizeHalfBlock;
781         long long int thisBlock, // current block
782              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
783 
784         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
785         long long int thisTask;         
786         const long long int numTasks=multiQubit.numAmps>>1;
787         const long long int chunkSize=multiQubit.numAmps;
788         const long long int chunkId=multiQubit.chunkId;
789 
790         int controlBit;
791 
792     // set dimensions
793         sizeHalfBlock = 1LL << targetQubit;  
794         sizeBlock     = 2LL * sizeHalfBlock; 
795 
796         // Can't use multiQubit.stateVec as a private OMP var
797         REAL *stateVecReal = multiQubit.stateVec.real;
798         REAL *stateVecImag = multiQubit.stateVec.imag;
799 
800 # ifdef _OPENMP
801 # pragma omp parallel \
802         default  (none) \
803         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
804         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
805 # endif
806         {
807 # ifdef _OPENMP
808                 # pragma omp for schedule (static)
809 # endif
810                 for (thisTask=0; thisTask<numTasks; thisTask++) {
811 
812                         thisBlock   = thisTask / sizeHalfBlock;
813                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
814                         indexLo     = indexUp + sizeHalfBlock;
815 
816                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
817                         if (controlBit){
818                                 // store current state vector values in temp vari
      ables
819                                 stateRealUp = stateVecReal[indexUp];
820                                 stateImagUp = stateVecImag[indexUp];
821 
822                                 stateRealLo = stateVecReal[indexLo];
823                                 stateImagLo = stateVecImag[indexLo];
824 
825 
826                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
827                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
828                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
829                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
830                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
831 
832                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
833                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
834                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
835                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
836                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
837                         }
838                 } 
839         }
840 
841 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!exitWithError@{exitWithError}}
\index{exitWithError@{exitWithError}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{exitWithError}]{\setlength{\rightskip}{0pt plus 5cm}void exitWithError (int {\em errorCode}, \/  const char $\ast$ {\em func})}\hfill}
\label{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}


Definition at line 234 of file qubits\_\-env\_\-local.c.

References errorCodes.

Referenced by QuESTAssert().


\begin{DoxyCode}
234                                                    {
235     printf("!!!\n");
236     printf("QuEST Error in function %s: %s\n", func, errorCodes[errorCode]);
237     printf("!!!\n");
238     printf("exiting..\n");
239     exit(errorCode);
240 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}}
\index{findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{findProbabilityOfZeroDistributed}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}


Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. Size of regions to skip is a multiple of chunkSize.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1642 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1644 {
1645         // ----- measured probability
1646         REAL   totalProbability;                                    // probabilit
      y (returned) value
1647         // ----- temp variables
1648         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1649         long long int numTasks=multiQubit.numAmps;
1650 
1651         // ---------------------------------------------------------------- //
1652         //            find probability                                      //
1653         // ---------------------------------------------------------------- //
1654 
1655         // initialise returned value
1656         totalProbability = 0.0;
1657 
1658         REAL *stateVecReal = multiQubit.stateVec.real;
1659         REAL *stateVecImag = multiQubit.stateVec.imag;
1660 
1661 # ifdef _OPENMP
1662 # pragma omp parallel \
1663         shared    (numTasks,stateVecReal,stateVecImag) \
1664         private   (thisTask) \
1665         reduction ( +:totalProbability )
1666 # endif
1667         {
1668 # ifdef _OPENMP
1669                 # pragma omp for schedule  (static)
1670 # endif
1671                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1672                         // summation -- simple implementation
1673                         totalProbability += stateVecReal[thisTask]*stateVecReal[t
      hisTask]
1674                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
1675 
1676                         /*
1677                         // summation -- kahan correction
1678                         y = stateVecReal[thisTask]*stateVecReal[thisTask]
1679                         + stateVecImag[thisTask]*stateVecImag[thisTask] - c;
1680                         t = totalProbability + y;
1681                         c = (t - totalProbability) - y;
1682                         totalProbability = t;
1683                         */
1684 
1685                 }
1686         }
1687 
1688         return totalProbability;
1689 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}}
\index{findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{findProbabilityOfZeroLocal}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}


Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1570 of file qubits.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1572 {
1573         // ----- sizes
1574         long long int sizeBlock,                                           // siz
      e of blocks
1575         sizeHalfBlock;                                       // size of blocks ha
      lved
1576         // ----- indices
1577         long long int thisBlock,                                           // cur
      rent block
1578              index;                                               // current inde
      x for first half block
1579         // ----- measured probability
1580         REAL   totalProbability;                                    // probabilit
      y (returned) value
1581         // ----- temp variables
1582         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1583         long long int numTasks=multiQubit.numAmps>>1;
1584 
1585         // ---------------------------------------------------------------- //
1586         //            dimensions                                            //
1587         // ---------------------------------------------------------------- //
1588         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1589         // and then the number to skip
1590         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1591 
1592         // initialise returned value
1593         totalProbability = 0.0;
1594 
1595         // initialise correction for kahan summation
1596         if (DEBUG) printf("sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\n",sizeHa
      lfBlock,sizeBlock,numTasks);
1597 
1598         REAL *stateVecReal = multiQubit.stateVec.real;
1599         REAL *stateVecImag = multiQubit.stateVec.imag;
1600 
1601 # ifdef _OPENMP
1602 # pragma omp parallel \
1603         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
      
1604         private   (thisTask,thisBlock,index) \
1605         reduction ( +:totalProbability )
1606 # endif 
1607         {
1608 # ifdef _OPENMP
1609                 # pragma omp for schedule  (static)
1610 # endif
1611                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1612                         thisBlock = thisTask / sizeHalfBlock;
1613                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
      
1614 
1615                         if (index<0){ printf("ABORTING as index=%Ld with thisBloc
      k = %Ld  thisTask=%Ld \n", index,thisBlock,thisTask); exit(1);}
1616 
1617                         // summation -- simple implementation
1618                         totalProbability += stateVecReal[index]*stateVecReal[inde
      x]
1619                                 + stateVecImag[index]*stateVecImag[index];
1620 
1621                         /*
1622                         // summation -- kahan correction
1623                         y = stateVecReal[index]*stateVecReal[index]
1624                         + stateVecImag[index]*stateVecImag[index] - c;
1625                         t = totalProbability + y;
1626                         c = (t - totalProbability) - y;
1627                         totalProbability = t;
1628                         */
1629 
1630                 }
1631         }
1632         return totalProbability;
1633 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!hadamardDistributed@{hadamardDistributed}}
\index{hadamardDistributed@{hadamardDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{hadamardDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1373 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by hadamard().


\begin{DoxyCode}
1378 {
1379 
1380         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1381         long long int thisTask;  
1382         const long long int numTasks=multiQubit.numAmps;
1383 
1384         int sign;
1385         if (updateUpper) sign=1;
1386         else sign=-1;
1387 
1388         REAL recRoot2 = 1.0/sqrt(2);
1389 
1390         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1391         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1392         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1393 
1394 # ifdef _OPENMP
1395 # pragma omp parallel \
1396         default  (none) \
1397         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1398                         recRoot2, sign) \
1399         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1400 # endif
1401         {
1402 # ifdef _OPENMP
1403                 # pragma omp for schedule (static)
1404 # endif
1405                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1406                         // store current state vector values in temp variables
1407                         stateRealUp = stateVecRealUp[thisTask];
1408                         stateImagUp = stateVecImagUp[thisTask];
1409 
1410                         stateRealLo = stateVecRealLo[thisTask];
1411                         stateImagLo = stateVecImagLo[thisTask];
1412 
1413                         stateVecRealOut[thisTask] = recRoot2*(stateRealUp + sign*
      stateRealLo);
1414                         stateVecImagOut[thisTask] = recRoot2*(stateImagUp + sign*
      stateImagLo);
1415                 }
1416         }
1417 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!hadamardLocal@{hadamardLocal}}
\index{hadamardLocal@{hadamardLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{hadamardLocal}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}


Definition at line 1312 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by hadamard().


\begin{DoxyCode}
1313 {
1314         long long int sizeBlock, sizeHalfBlock;
1315         long long int thisBlock, // current block
1316              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1317 
1318         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1319         long long int thisTask;         
1320         const long long int numTasks=multiQubit.numAmps>>1;
1321 
1322         // set dimensions
1323         sizeHalfBlock = 1LL << targetQubit;  
1324         sizeBlock     = 2LL * sizeHalfBlock; 
1325 
1326         // Can't use multiQubit.stateVec as a private OMP var
1327         REAL *stateVecReal = multiQubit.stateVec.real;
1328         REAL *stateVecImag = multiQubit.stateVec.imag;
1329 
1330         REAL recRoot2 = 1.0/sqrt(2);
1331 
1332 # ifdef _OPENMP
1333 # pragma omp parallel \
1334         default  (none) \
1335         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \
      
1336         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
1337 # endif
1338         {
1339 # ifdef _OPENMP
1340                 # pragma omp for schedule (static)
1341 # endif
1342                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1343                         thisBlock   = thisTask / sizeHalfBlock;
1344                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1345                         indexLo     = indexUp + sizeHalfBlock;
1346 
1347                         stateRealUp = stateVecReal[indexUp];
1348                         stateImagUp = stateVecImag[indexUp];
1349 
1350                         stateRealLo = stateVecReal[indexLo];
1351                         stateImagLo = stateVecImag[indexLo];
1352 
1353                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateReal
      Lo);
1354                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImag
      Lo);
1355 
1356                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateReal
      Lo);
1357                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImag
      Lo);
1358                 } 
1359         }
1360 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}}
\index{multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{multiControlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}


Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where all the control qubits are 1.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 983 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
990 {
991 
992         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
993         long long int thisTask;  
994         const long long int numTasks=multiQubit.numAmps;
995         const long long int chunkSize=multiQubit.numAmps;
996         const long long int chunkId=multiQubit.chunkId;
997 
998         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
999         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
1000         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1001         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1002         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1003 
1004 # ifdef _OPENMP
1005 # pragma omp parallel \
1006         default  (none) \
1007         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1008                         rot1Real,rot1Imag, rot2Real,rot2Imag, mask) \
1009         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1010 # endif
1011         {
1012 # ifdef _OPENMP
1013                 # pragma omp for schedule (static)
1014 # endif
1015                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1016                         if (mask == (mask & (thisTask+chunkId*chunkSize)) ){
1017                                 // store current state vector values in temp vari
      ables
1018                                 stateRealUp = stateVecRealUp[thisTask];
1019                                 stateImagUp = stateVecImagUp[thisTask];
1020 
1021                                 stateRealLo = stateVecRealLo[thisTask];
1022                                 stateImagLo = stateVecImagLo[thisTask];
1023 
1024                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
1025                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
1026                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
1027                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
1028                         }
1029                 }
1030         }
1031 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!multiControlledUnitaryLocal@{multiControlledUnitaryLocal}}
\index{multiControlledUnitaryLocal@{multiControlledUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{multiControlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}


Definition at line 714 of file qubits.c.

References MultiQubit::chunkId, Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
716 {
717         long long int sizeBlock, sizeHalfBlock;
718         long long int thisBlock, // current block
719              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
720 
721         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
722         long long int thisTask;         
723         const long long int numTasks=multiQubit.numAmps>>1;
724         const long long int chunkSize=multiQubit.numAmps;
725         const long long int chunkId=multiQubit.chunkId;
726 
727         // set dimensions
728         sizeHalfBlock = 1LL << targetQubit;  
729         sizeBlock     = 2LL * sizeHalfBlock; 
730 
731         // Can't use multiQubit.stateVec as a private OMP var
732         REAL *stateVecReal = multiQubit.stateVec.real;
733         REAL *stateVecImag = multiQubit.stateVec.imag;
734 
735 # ifdef _OPENMP
736 # pragma omp parallel \
737         default  (none) \
738         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u, mask) \
739         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
740 # endif
741         {
742 # ifdef _OPENMP
743                 # pragma omp for schedule (static)
744 # endif
745                 for (thisTask=0; thisTask<numTasks; thisTask++) {
746 
747                         thisBlock   = thisTask / sizeHalfBlock;
748                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
749                         indexLo     = indexUp + sizeHalfBlock;
750 
751                         if (mask == (mask & (indexUp+chunkId*chunkSize)) ){
752                                 // store current state vector values in temp vari
      ables
753                                 stateRealUp = stateVecReal[indexUp];
754                                 stateImagUp = stateVecImag[indexUp];
755 
756                                 stateRealLo = stateVecReal[indexLo];
757                                 stateImagLo = stateVecImag[indexLo];
758 
759 
760                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
761                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
762                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
763                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
764                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
765 
766                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
767                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
768                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
769                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
770                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
771                         }
772                 } 
773         }
774 
775 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGate@{phaseGate}}
\index{phaseGate@{phaseGate}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}


Definition at line 166 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, phaseGateDistributed(), phaseGateLocal(), and QuESTAssert().

Referenced by sGate(), sigmaZ(), and tGate().


\begin{DoxyCode}
167 {
168     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
169         phaseGateLocal(multiQubit, targetQubit, type);
170 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGateDistributed@{phaseGateDistributed}}
\index{phaseGateDistributed@{phaseGateDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGateDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}


Definition at line 1495 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1496 {
1497         REAL stateRealLo,stateImagLo;
1498         long long int thisTask;         
1499         const long long int numTasks=multiQubit.numAmps;
1500 
1501         // Can't use multiQubit.stateVec as a private OMP var
1502         REAL *stateVecReal = multiQubit.stateVec.real;
1503         REAL *stateVecImag = multiQubit.stateVec.imag;
1504 
1505         REAL recRoot2 = 1.0/sqrt(2);
1506 
1507 # ifdef _OPENMP
1508 # pragma omp parallel \
1509         default  (none) \
1510         shared   (stateVecReal,stateVecImag, recRoot2, type) \
1511         private  (thisTask,stateRealLo,stateImagLo) 
1512 # endif
1513         {
1514                 if (type==SIGMA_Z){
1515 # ifdef _OPENMP
1516                         # pragma omp for schedule (static)
1517 # endif
1518                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1519                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
      
1520                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
      
1521                         } 
1522                 } else if (type==S_GATE){
1523 # ifdef _OPENMP
1524                         # pragma omp for schedule (static)
1525 # endif
1526                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1527                                 stateRealLo = stateVecReal[thisTask];
1528                                 stateImagLo = stateVecImag[thisTask];
1529 
1530                                 stateVecReal[thisTask] = -stateImagLo;
1531                                 stateVecImag[thisTask] = stateRealLo;
1532                         } 
1533                 } else if (type==T_GATE){
1534 # ifdef _OPENMP
1535                         # pragma omp for schedule (static)
1536 # endif
1537                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1538                                 stateRealLo = stateVecReal[thisTask];
1539                                 stateImagLo = stateVecImag[thisTask];
1540 
1541                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo 
      - stateImagLo);
1542                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo 
      + stateImagLo);
1543                         } 
1544                 } else printf("Type %d is an invalid phase gate\n", type);
1545         }
1546 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGateLocal@{phaseGateLocal}}
\index{phaseGateLocal@{phaseGateLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGateLocal}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}


fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod? 

Definition at line 1419 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1420 {
1421         long long int sizeBlock, sizeHalfBlock;
1422         long long int thisBlock, // current block
1423              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1424 
1425         REAL stateRealLo,stateImagLo;
1426         long long int thisTask;         
1427         const long long int numTasks=multiQubit.numAmps>>1;
1428 
1429         // set dimensions
1430         sizeHalfBlock = 1LL << targetQubit;  
1431         sizeBlock     = 2LL * sizeHalfBlock; 
1432 
1433         // Can't use multiQubit.stateVec as a private OMP var
1434         REAL *stateVecReal = multiQubit.stateVec.real;
1435         REAL *stateVecImag = multiQubit.stateVec.imag;
1436 
1437         REAL recRoot2 = 1.0/sqrt(2);
1438 
1439 # ifdef _OPENMP
1440 # pragma omp parallel \
1441         default  (none) \
1442         shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type
      ) \
1443         private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) 
1444 # endif
1445         {
1446                 if (type==SIGMA_Z){
1447 # ifdef _OPENMP
1448                         # pragma omp for schedule (static)
1449 # endif
1450                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1452                                 thisBlock   = thisTask / sizeHalfBlock;
1453                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1454                                 indexLo     = indexUp + sizeHalfBlock;
1455 
1456                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
1457                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
1458                         } 
1459                 } 
1460                 
1461                 else if (type==S_GATE){
1462 # ifdef _OPENMP
1463                         # pragma omp for schedule (static)
1464 # endif
1465                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1467                                 thisBlock   = thisTask / sizeHalfBlock;
1468                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1469                                 indexLo     = indexUp + sizeHalfBlock;
1470                                 stateRealLo = stateVecReal[indexLo];
1471                                 stateImagLo = stateVecImag[indexLo];
1472 
1473                                 stateVecReal[indexLo] = -stateImagLo;
1474                                 stateVecImag[indexLo] = stateRealLo;
1475                         } 
1476                 } else if (type==T_GATE){
1477 # ifdef _OPENMP
1478                         # pragma omp for schedule (static)
1479 # endif
1480                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1482                                 thisBlock   = thisTask / sizeHalfBlock;
1483                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1484                                 indexLo     = indexUp + sizeHalfBlock;
1485                                 stateRealLo = stateVecReal[indexLo];
1486                                 stateImagLo = stateVecImag[indexLo];
1487 
1488                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo -
       stateImagLo);
1489                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo +
       stateImagLo);
1490                         } 
1491                 } else printf("Type %d is an invalid phase gate\n", type);
1492         }
1493 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!QuESTAssert@{QuESTAssert}}
\index{QuESTAssert@{QuESTAssert}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{QuESTAssert}]{\setlength{\rightskip}{0pt plus 5cm}void QuESTAssert (int {\em isValid}, \/  int {\em errorCode}, \/  const char $\ast$ {\em func})}\hfill}
\label{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}


Definition at line 242 of file qubits\_\-env\_\-local.c.

References exitWithError().

Referenced by collapseToOutcome(), compactUnitary(), controlledCompactUnitary(), controlledNot(), controlledPhaseGate(), controlledUnitary(), createMultiQubit(), findProbabilityOfOutcome(), hadamard(), measure(), measureWithStats(), multiControlledPhaseGate(), multiControlledUnitary(), phaseGate(), sigmaX(), sigmaY(), and unitary().


\begin{DoxyCode}
242                                                               {
243     if (!isValid) exitWithError(errorCode, func);
244 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaXDistributed@{sigmaXDistributed}}
\index{sigmaXDistributed@{sigmaXDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaXDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1092 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaX().


\begin{DoxyCode}
1095 {
1096 
1097         long long int thisTask;  
1098         const long long int numTasks=multiQubit.numAmps;
1099 
1100         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1101         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1102 
1103 # ifdef _OPENMP
1104 # pragma omp parallel \
1105         default  (none) \
1106         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1107         private  (thisTask)
1108 # endif
1109         {
1110 # ifdef _OPENMP
1111                 # pragma omp for schedule (static)
1112 # endif
1113                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1114                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
1115                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
1116                 }
1117         }
1118 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaXLocal@{sigmaXLocal}}
\index{sigmaXLocal@{sigmaXLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaXLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}


Definition at line 1033 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaX().


\begin{DoxyCode}
1034 {
1035         long long int sizeBlock, sizeHalfBlock;
1036         long long int thisBlock, // current block
1037              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1038 
1039         REAL stateRealUp,stateImagUp;
1040         long long int thisTask;         
1041         const long long int numTasks=multiQubit.numAmps>>1;
1042 
1043         // set dimensions
1044         sizeHalfBlock = 1LL << targetQubit;  
1045         sizeBlock     = 2LL * sizeHalfBlock; 
1046 
1047         // Can't use multiQubit.stateVec as a private OMP var
1048         REAL *stateVecReal = multiQubit.stateVec.real;
1049         REAL *stateVecImag = multiQubit.stateVec.imag;
1050 
1051 # ifdef _OPENMP
1052 # pragma omp parallel \
1053         default  (none) \
1054         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1055         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1056 # endif
1057         {
1058 # ifdef _OPENMP
1059                 # pragma omp for schedule (static)
1060 # endif
1061                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1062                         thisBlock   = thisTask / sizeHalfBlock;
1063                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1064                         indexLo     = indexUp + sizeHalfBlock;
1065 
1066                         stateRealUp = stateVecReal[indexUp];
1067                         stateImagUp = stateVecImag[indexUp];
1068 
1069                         stateVecReal[indexUp] = stateVecReal[indexLo];
1070                         stateVecImag[indexUp] = stateVecImag[indexLo];
1071 
1072                         stateVecReal[indexLo] = stateRealUp;
1073                         stateVecImag[indexLo] = stateImagUp;
1074                 } 
1075         }
1076 
1077 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaYDistributed@{sigmaYDistributed}}
\index{sigmaYDistributed@{sigmaYDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaYDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1279 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaY().


\begin{DoxyCode}
1283 {
1284 
1285         long long int thisTask;  
1286         const long long int numTasks=multiQubit.numAmps;
1287 
1288         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1289         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1290 
1291         int realSign=1, imagSign=1;
1292         if (updateUpper) imagSign=-1;
1293         else realSign = -1;
1294 
1295 # ifdef _OPENMP
1296 # pragma omp parallel \
1297         default  (none) \
1298         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,r
      ealSign,imagSign) \
1299         private  (thisTask)
1300 # endif
1301         {
1302 # ifdef _OPENMP
1303                 # pragma omp for schedule (static)
1304 # endif
1305                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1306                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisT
      ask];
1307                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisT
      ask];
1308                 }
1309         }
1310 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaYLocal@{sigmaYLocal}}
\index{sigmaYLocal@{sigmaYLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaYLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}


Definition at line 1220 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaY().


\begin{DoxyCode}
1221 {
1222         long long int sizeBlock, sizeHalfBlock;
1223         long long int thisBlock, // current block
1224              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1225 
1226         REAL stateRealUp,stateImagUp;
1227         long long int thisTask;         
1228         const long long int numTasks=multiQubit.numAmps>>1;
1229 
1230         // set dimensions
1231         sizeHalfBlock = 1LL << targetQubit;  
1232         sizeBlock     = 2LL * sizeHalfBlock; 
1233 
1234         // Can't use multiQubit.stateVec as a private OMP var
1235         REAL *stateVecReal = multiQubit.stateVec.real;
1236         REAL *stateVecImag = multiQubit.stateVec.imag;
1237 
1238 # ifdef _OPENMP
1239 # pragma omp parallel \
1240         default  (none) \
1241         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1242         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1243 # endif
1244         {
1245 # ifdef _OPENMP
1246                 # pragma omp for schedule (static)
1247 # endif
1248                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1249                         thisBlock   = thisTask / sizeHalfBlock;
1250                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1251                         indexLo     = indexUp + sizeHalfBlock;
1252 
1253                         stateRealUp = stateVecReal[indexUp];
1254                         stateImagUp = stateVecImag[indexUp];
1255 
1256                         stateVecReal[indexUp] = stateVecImag[indexLo];
1257                         stateVecImag[indexUp] = -stateVecReal[indexLo];
1258 
1259                         stateVecReal[indexLo] = -stateImagUp;
1260                         stateVecImag[indexLo] = stateRealUp;
1261                 } 
1262         }
1263 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!unitaryDistributed@{unitaryDistributed}}
\index{unitaryDistributed@{unitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{unitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}


Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em u}]unitary matrix to apply \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 602 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by unitary().


\begin{DoxyCode}
607 {
608 
609         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
610         long long int thisTask;  
611         const long long int numTasks=multiQubit.numAmps;
612 
613         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
614         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
615         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
616         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
617         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
618 
619 
620 # ifdef _OPENMP
621 # pragma omp parallel \
622         default  (none) \
623         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
624                         rot1Real, rot1Imag, rot2Real, rot2Imag) \
625         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
626 # endif
627         {
628 # ifdef _OPENMP
629                 # pragma omp for schedule (static)
630 # endif
631                 for (thisTask=0; thisTask<numTasks; thisTask++) {
632                         // store current state vector values in temp variables
633                         stateRealUp = stateVecRealUp[thisTask];
634                         stateImagUp = stateVecImagUp[thisTask];
635 
636                         stateRealLo = stateVecRealLo[thisTask];
637                         stateImagLo = stateVecImagLo[thisTask];
638 
639                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp 
640                                 + rot2Real*stateRealLo - rot2Imag*stateImagLo;
641                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp 
642                                 + rot2Real*stateImagLo + rot2Imag*stateRealLo;
643                 }
644         }
645 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!unitaryLocal@{unitaryLocal}}
\index{unitaryLocal@{unitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{unitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}


Definition at line 476 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by unitary().


\begin{DoxyCode}
477 {
478         long long int sizeBlock, sizeHalfBlock;
479         long long int thisBlock, // current block
480              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
481 
482         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
483         long long int thisTask;         
484         const long long int numTasks=multiQubit.numAmps>>1;
485 
486         // set dimensions
487         sizeHalfBlock = 1LL << targetQubit;  
488         sizeBlock     = 2LL * sizeHalfBlock; 
489 
490         // Can't use multiQubit.stateVec as a private OMP var
491         REAL *stateVecReal = multiQubit.stateVec.real;
492         REAL *stateVecImag = multiQubit.stateVec.imag;
493 
494 # ifdef _OPENMP
495 # pragma omp parallel \
496         default  (none) \
497         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
498         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
499 # endif
500         {
501 # ifdef _OPENMP
502                 # pragma omp for schedule (static)
503 # endif
504                 for (thisTask=0; thisTask<numTasks; thisTask++) {
505 
506                         thisBlock   = thisTask / sizeHalfBlock;
507                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
508                         indexLo     = indexUp + sizeHalfBlock;
509 
510                         // store current state vector values in temp variables
511                         stateRealUp = stateVecReal[indexUp];
512                         stateImagUp = stateVecImag[indexUp];
513 
514                         stateRealLo = stateVecReal[indexLo];
515                         stateImagLo = stateVecImag[indexLo];
516 
517 
518                         // state[indexUp] = u00 * state[indexUp] + u01 * state[in
      dexLo]
519                         stateVecReal[indexUp] = u.r0c0.real*stateRealUp - u.r0c0.
      imag*stateImagUp 
520                                 + u.r0c1.real*stateRealLo - u.r0c1.imag*stateImag
      Lo;
521                         stateVecImag[indexUp] = u.r0c0.real*stateImagUp + u.r0c0.
      imag*stateRealUp 
522                                 + u.r0c1.real*stateImagLo + u.r0c1.imag*stateReal
      Lo;
523 
524                         // state[indexLo] = u10  * state[indexUp] + u11 * state[i
      ndexLo]
525                         stateVecReal[indexLo] = u.r1c0.real*stateRealUp  - u.
      r1c0.imag*stateImagUp 
526                                 + u.r1c1.real*stateRealLo  -  u.r1c1.imag*stateIm
      agLo;
527                         stateVecImag[indexLo] = u.r1c0.real*stateImagUp + u.r1c0.
      imag*stateRealUp 
528                                 + u.r1c1.real*stateImagLo + u.r1c1.imag*stateReal
      Lo;
529 
530                 } 
531         }
532 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateAlphaBeta@{validateAlphaBeta}}
\index{validateAlphaBeta@{validateAlphaBeta}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateAlphaBeta}]{\setlength{\rightskip}{0pt plus 5cm}int validateAlphaBeta ({\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}


Definition at line 365 of file qubits.c.

References Complex::imag, Complex::real, and REAL\_\-EPS.

Referenced by compactUnitary(), and controlledCompactUnitary().


\begin{DoxyCode}
365                                                   {
366         if ( fabs(alpha.real*alpha.real 
367                 + alpha.imag*alpha.imag
368                 + beta.real*beta.real 
369                 + beta.imag*beta.imag - 1) > REAL_EPS ) return 0;
370         else return 1;
371 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateMatrixIsUnitary@{validateMatrixIsUnitary}}
\index{validateMatrixIsUnitary@{validateMatrixIsUnitary}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateMatrixIsUnitary}]{\setlength{\rightskip}{0pt plus 5cm}int validateMatrixIsUnitary ({\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}


Definition at line 340 of file qubits.c.

References Complex::imag, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, and REAL\_\-EPS.

Referenced by controlledUnitary(), multiControlledUnitary(), and unitary().


\begin{DoxyCode}
340                                              {
341 
342         if ( fabs(u.r0c0.real*u.r0c0.real 
343                 + u.r0c0.imag*u.r0c0.imag
344                 + u.r1c0.real*u.r1c0.real
345                 + u.r1c0.imag*u.r1c0.imag - 1) > REAL_EPS ) return 0;
346     // check
347         if ( fabs(u.r0c1.real*u.r0c1.real 
348                 + u.r0c1.imag*u.r0c1.imag
349                 + u.r1c1.real*u.r1c1.real
350                 + u.r1c1.imag*u.r1c1.imag - 1) > REAL_EPS ) return 0;
351 
352         if ( fabs(u.r0c0.real*u.r0c1.real 
353                 + u.r0c0.imag*u.r0c1.imag
354                 + u.r1c0.real*u.r1c1.real
355                 + u.r1c0.imag*u.r1c1.imag) > REAL_EPS ) return 0;
356 
357         if ( fabs(u.r0c1.real*u.r0c0.imag
358                 - u.r0c0.real*u.r0c1.imag
359                 + u.r1c1.real*u.r1c0.imag
360                 - u.r1c0.real*u.r1c1.imag) > REAL_EPS ) return 0;
361 
362         return 1;
363 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateUnitVector@{validateUnitVector}}
\index{validateUnitVector@{validateUnitVector}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateUnitVector}]{\setlength{\rightskip}{0pt plus 5cm}int validateUnitVector (REAL {\em ux}, \/  REAL {\em uy}, \/  REAL {\em uz})}\hfill}
\label{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}


Definition at line 373 of file qubits.c.

References REAL\_\-EPS.


\begin{DoxyCode}
373                                                  {
374         if ( fabs(sqrt(ux*ux + uy*uy + uz*uz) - 1) > REAL_EPS ) return 0;
375         else return 1;
376 }
\end{DoxyCode}


\subsubsection{Variable Documentation}
\hypertarget{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!errorCodes@{errorCodes}}
\index{errorCodes@{errorCodes}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{errorCodes}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ {\bf errorCodes}\mbox{[}$\,$\mbox{]}}\hfill}
\label{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}


Definition at line 17 of file qubits.c.

Referenced by exitWithError().