\hypertarget{qubits__internal_8h}{}\subsection{qubits\+\_\+internal.\+h File Reference}
\label{qubits__internal_8h}\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}


Internal functions used to implement the public facing A\+PI in \hyperlink{qubits_8h}{qubits.\+h}.  


{\ttfamily \#include \char`\"{}precision.\+h\char`\"{}}\\*
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}{rotate\+Qubit\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}{rotate\+Qubit\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a824d71bae93236d8a3cd43589044eaee}{control\+Rotate\+Qubit\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, const int control\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments and a control qubit. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ab22d031e2507f1d859292103a99e2378}{control\+Rotate\+Qubit\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, const int control\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_aa9e640bb2d0458c937c6a87dfeca0f23}{sigma\+X\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a5958808b2f2f05937921ba7dabe5a171}{sigma\+X\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_afcbb1dcbe070ad0ed1a72a23251b6a83}{sigma\+Y\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a0471f6b547ce8270ef85170b7f4f0214}{sigma\+Y\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out, int update\+Upper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a0711416fceaf63c67b496e123e845c69}{hadamard\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ac835c194bd547240a35f0b028db1d658}{hadamard\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out, int update\+Upper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a6a736aeb3532898019fe7c27010edc6a}{phase\+Gate\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a38a05c7e749e806b182ef3b89878bfc4}{phase\+Gate\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a2901e2e5531cb77f87ea54b3fc28f51a}{control\+Not\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, const int control\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\} for elements where control\+Qubit is one. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a774dd1217fcc3591a74a74d5667afa29}{control\+Not\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, const int control\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{find\+Probability\+Of\+Zero\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{find\+Probability\+Of\+Zero\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a53614ce19e0a4f2c41b400cf05dc5bd1}{measure\+In\+State\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, int measure\+Qubit, \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} total\+Probability, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__internal_8h_a35e5ac30c8427c482a97b33a4e295535}{measure\+In\+State\+Distributed\+Renorm} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit, const \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} total\+Probability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measure\+Qubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ac39efc9ed939382276ebd0c15dd6a0fa}{measure\+In\+State\+Distributed\+Set\+Zero} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Set all amplitudes in one chunk to 0. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a2d73fd11c1d154640dbf114da8f34c64}{filter\+Out111\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3, const \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} prob\+Of\+Filter)
\begin{DoxyCompactList}\small\item\em Updates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__internal_8h_a096cddbac961f0651a084d2ceb905d1b}{prob\+Of\+Filter\+Out111\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3)
\begin{DoxyCompactList}\small\item\em Evaluates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
Internal functions used to implement the public facing A\+PI in \hyperlink{qubits_8h}{qubits.\+h}. 

Do not call these functions directly. In general, \hyperlink{qubits__env__local_8c}{qubits\+\_\+env\+\_\+local.\+c} and \hyperlink{qubits__env__mpi_8c}{qubits\+\_\+env\+\_\+mpi.\+c} will implement the public A\+PI by choosing the correct function or combination of functions to use from those included here. 

\subsubsection{Function Documentation}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!control\+Not\+Distributed@{control\+Not\+Distributed}}
\index{control\+Not\+Distributed@{control\+Not\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{control\+Not\+Distributed(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, const int control\+Qubit, Complex\+Array state\+Vec\+In, Complex\+Array state\+Vec\+Out)}{controlNotDistributed(MultiQubit multiQubit, const int targetQubit, const int controlQubit, ComplexArray stateVecIn, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void control\+Not\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+In, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a774dd1217fcc3591a74a74d5667afa29}{}\label{qubits__internal_8h_a774dd1217fcc3591a74a74d5667afa29}


Rotate a single qubit by \{\{0,1\},\{1,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk. Only perform the rotation for elements where control\+Qubit is one.

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 799 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and R\+E\+AL.



Referenced by control\+Not().


\begin{DoxyCode}
802 \{
803 
804         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
805         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
806 
807         \textcolor{keywordtype}{int} controlBit;
808 
809         \textcolor{comment}{// test qubit valid}
810         assert (targetQubit >= 0 && targetQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
811 
812         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
813         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
814 
815 \textcolor{preprocessor}{# ifdef \_OPENMP}
816 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
817 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
818 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) \(\backslash\)}
819 \textcolor{preprocessor}{        private  (thisTask,controlBit)}
820 \textcolor{preprocessor}{# endif}
821         \{
822 \textcolor{preprocessor}{# ifdef \_OPENMP}
823 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
824 \textcolor{preprocessor}{# endif}
825                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
826                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, thisTask);
827                         \textcolor{keywordflow}{if} (controlBit)\{
828                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
829                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
830                         \}
831                 \}
832         \}
833 \} 
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!control\+Not\+Local@{control\+Not\+Local}}
\index{control\+Not\+Local@{control\+Not\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{control\+Not\+Local(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, const int control\+Qubit)}{controlNotLocal(MultiQubit multiQubit, const int targetQubit, const int controlQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void control\+Not\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{const int}]{control\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a2901e2e5531cb77f87ea54b3fc28f51a}{}\label{qubits__internal_8h_a2901e2e5531cb77f87ea54b3fc28f51a}


Rotate a single qubit by \{\{0,1\},\{1,0\} for elements where control\+Qubit is one. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & qubit to determine whether or not to perform a rotation \\
\hline
\end{DoxyParams}


Definition at line 724 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by control\+Not().


\begin{DoxyCode}
725 \{
726         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
727         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
728              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
729 
730         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
731         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
732         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
733 
734         \textcolor{keywordtype}{int} controlBit;
735 
736         \textcolor{comment}{// if targetQubit==controlQubit, it is guaranteed that controlQubit==1 when}
737         \textcolor{comment}{// targetQubit==1. As rotations are symmetric, we can instead apply the rotation}
738         \textcolor{comment}{// on all amplitudes where targetQubit==0 as we do here.}
739         \textcolor{keywordtype}{int} rotateAll=(targetQubit==controlQubit);
740 
741         \textcolor{comment}{// test qubit valid}
742         assert (targetQubit >= 0 && targetQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
743 
744         \textcolor{comment}{// set dimensions}
745         sizeHalfBlock = 1LL << targetQubit;  
746         sizeBlock     = 2LL * sizeHalfBlock; 
747 
748 
749         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
750         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
751         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
752 
753 \textcolor{preprocessor}{# ifdef \_OPENMP}
754 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
755 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
756 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,rotateAll) \(\backslash\)}
757 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,controlBit) }
758 \textcolor{preprocessor}{# endif}
759         \{
760 \textcolor{preprocessor}{# ifdef \_OPENMP}
761 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
762 \textcolor{preprocessor}{# endif}
763                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
764                         thisBlock   = thisTask / sizeHalfBlock;
765                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
766                         indexLo     = indexUp + sizeHalfBlock;
767 
768                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit}(controlQubit, indexUp);
769                         \textcolor{keywordflow}{if} (rotateAll || controlBit)\{
770                                 stateRealUp = stateVecReal[indexUp];
771                                 stateImagUp = stateVecImag[indexUp];
772 
773                                 stateVecReal[indexUp] = stateVecReal[indexLo];
774                                 stateVecImag[indexUp] = stateVecImag[indexLo];
775 
776                                 stateVecReal[indexLo] = stateRealUp;
777                                 stateVecImag[indexLo] = stateImagUp;
778                         \}
779                 \} 
780         \}
781 
782 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!control\+Rotate\+Qubit\+Distributed@{control\+Rotate\+Qubit\+Distributed}}
\index{control\+Rotate\+Qubit\+Distributed@{control\+Rotate\+Qubit\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{control\+Rotate\+Qubit\+Distributed(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, const int control\+Qubit, Complex rot1, Complex rot2, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out)}{controlRotateQubitDistributed(MultiQubit multiQubit, const int rotQubit, const int controlQubit, Complex rot1, Complex rot2, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void control\+Rotate\+Qubit\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{{\bf Complex}}]{rot1, }
\item[{{\bf Complex}}]{rot2, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_ab22d031e2507f1d859292103a99e2378}{}\label{qubits__internal_8h_ab22d031e2507f1d859292103a99e2378}


Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. 

Only perform the rotation where the control qubit is one.

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & qubit to determine whether or not to perform a rotation \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 555 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Complex\+::real.



Referenced by control\+Rotate\+Qubit().


\begin{DoxyCode}
560 \{
561 
562         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
563         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
564         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
565 
566         \textcolor{keywordtype}{int} controlBit;
567 
568         \textcolor{comment}{// As rotations are symmetric, we can apply rotations for all elements where}
569         \textcolor{comment}{// targetQubit==0 and controlQubit==1.  }
570         \textcolor{comment}{// However, this means we will skip the case where targetQubit==controlQubit. }
571         \textcolor{comment}{// We check for that here. }
572         \textcolor{comment}{// We could also choose to rotate on targetQubit==1, but are doing it this way }
573         \textcolor{comment}{// to match the regular rotate implementation. }
574         \textcolor{keywordtype}{int} rotateAll=(rotQubit==controlQubit);
575 
576         \textcolor{comment}{// test qubit valid}
577         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
578 
579         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
580         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
581         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
582         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
583         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
584 
585 \textcolor{preprocessor}{# ifdef \_OPENMP}
586 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
587 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
588 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
589 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag,rotateAll) \(\backslash\)}
590 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit)}
591 \textcolor{preprocessor}{# endif}
592         \{
593 \textcolor{preprocessor}{# ifdef \_OPENMP}
594 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
595 \textcolor{preprocessor}{# endif}
596                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
597                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, thisTask);
598                         \textcolor{keywordflow}{if} (rotateAll || controlBit)\{
599                                 \textcolor{comment}{// store current state vector values in temp variables}
600                                 stateRealUp = stateVecRealUp[thisTask];
601                                 stateImagUp = stateVecImagUp[thisTask];
602 
603                                 stateRealLo = stateVecRealLo[thisTask];
604                                 stateImagLo = stateVecImagLo[thisTask];
605 
606                                 \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
607                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp + 
      rot2Real*stateRealLo + rot2Imag*stateImagLo;
608                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp + 
      rot2Real*stateImagLo - rot2Imag*stateRealLo;
609                         \}
610                 \}
611         \}
612 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!control\+Rotate\+Qubit\+Local@{control\+Rotate\+Qubit\+Local}}
\index{control\+Rotate\+Qubit\+Local@{control\+Rotate\+Qubit\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{control\+Rotate\+Qubit\+Local(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, const int control\+Qubit, Complex alpha, Complex beta)}{controlRotateQubitLocal(MultiQubit multiQubit, const int rotQubit, const int controlQubit, Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}void control\+Rotate\+Qubit\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a824d71bae93236d8a3cd43589044eaee}{}\label{qubits__internal_8h_a824d71bae93236d8a3cd43589044eaee}


Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments and a control qubit. 

Only perform the rotation for elements where the control qubit is one. alpha\+Re = cos(angle1) $\ast$ cos(angle2) ~\newline
alpha\+Im = cos(angle1) $\ast$ sin(angle2) ~\newline
 beta\+Re = sin(angle1) $\ast$ cos(angle3) ~\newline
 beta\+Im = sin(angle1) $\ast$ sin(angle3) ~\newline


\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em alpha} & rotation angle \\
\hline
\mbox{\tt in}  & {\em beta} & rotation angle \\
\hline
\end{DoxyParams}


Definition at line 461 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, Complex\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by control\+Rotate\+Qubit().


\begin{DoxyCode}
463 \{
464         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
465         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
466              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
467 
468         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
469         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
470         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
471 
472         \textcolor{keywordtype}{int} controlBit;
473 
474         \textcolor{comment}{// As rotations are symmetric, we can apply rotations for all elements where}
475         \textcolor{comment}{// targetQubit==0 and controlQubit==1.  }
476         \textcolor{comment}{// However, this means we will skip the case where targetQubit==controlQubit. }
477         \textcolor{comment}{// We check for that here. }
478         \textcolor{comment}{// We could also choose to rotate on targetQubit==1, but are doing it this way }
479         \textcolor{comment}{// to match the regular rotate implementation. }
480         \textcolor{keywordtype}{int} rotateAll=(rotQubit==controlQubit);
481 
482         \textcolor{comment}{// test qubit valid}
483         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
484 
485         \textcolor{comment}{// set dimensions}
486         sizeHalfBlock = 1LL << rotQubit;  
487         sizeBlock     = 2LL * sizeHalfBlock; 
488 
489         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
490         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
491         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
492         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} alphaImag=alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, alphaReal=alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
493         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} betaImag=beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, betaReal=beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
494 
495 \textcolor{preprocessor}{# ifdef \_OPENMP}
496 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
497 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
498 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,alphaImag,
       betaReal,betaImag,\(\backslash\)}
499 \textcolor{preprocessor}{                        rotateAll) \(\backslash\)}
500 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo,
       stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit) }
501 \textcolor{preprocessor}{# endif}
502         \{
503 \textcolor{preprocessor}{# ifdef \_OPENMP}
504 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
505 \textcolor{preprocessor}{# endif}
506                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
507 
508                         thisBlock   = thisTask / sizeHalfBlock;
509                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
510                         indexLo     = indexUp + sizeHalfBlock;
511 
512                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, indexUp);
513                         \textcolor{keywordflow}{if} (rotateAll || controlBit)\{
514                                 \textcolor{comment}{// store current state vector values in temp variables}
515                                 stateRealUp = stateVecReal[indexUp];
516                                 stateImagUp = stateVecImag[indexUp];
517 
518                                 stateRealLo = stateVecReal[indexLo];
519                                 stateImagLo = stateVecImag[indexLo];
520 
521                                 \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
522                                 stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag*stateImagUp 
523                                         - betaReal*stateRealLo - betaImag*stateImagLo;
524                                 stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag*stateRealUp 
525                                         - betaReal*stateImagLo + betaImag*stateRealLo;
526 
527                                 \textcolor{comment}{// state[indexLo] = beta  * state[indexUp] + conj(alpha) * state[indexLo]}
528                                 stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*stateImagUp 
529                                         + alphaReal*stateRealLo + alphaImag*stateImagLo;
530                                 stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*stateRealUp 
531                                         + alphaReal*stateImagLo - alphaImag*stateRealLo;
532                         \}
533                 \} 
534         \}
535 
536 \} 
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!filter\+Out111\+Local@{filter\+Out111\+Local}}
\index{filter\+Out111\+Local@{filter\+Out111\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{filter\+Out111\+Local(\+Multi\+Qubit multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3, const R\+E\+A\+L prob\+Of\+Filter)}{filterOut111Local(MultiQubit multiQubit, const int idQubit1, const int idQubit2, const int idQubit3, const REAL probOfFilter)}}]{\setlength{\rightskip}{0pt plus 5cm}void filter\+Out111\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{id\+Qubit1, }
\item[{const int}]{id\+Qubit2, }
\item[{const int}]{id\+Qubit3, }
\item[{const {\bf R\+E\+AL}}]{prob\+Of\+Filter}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a2d73fd11c1d154640dbf114da8f34c64}{}\label{qubits__internal_8h_a2d73fd11c1d154640dbf114da8f34c64}


Updates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3} & specified qubits \\
\hline
\mbox{\tt in}  & {\em prob\+Of\+Filter} & Total probability that the 3 qubits are not all in the 1 state. \\
\hline
\end{DoxyParams}


Definition at line 1709 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, R\+E\+A\+L\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+F\+O\+R\+M\+AT, and Multi\+Qubit\+::state\+Vec.



Referenced by filter\+Out111().


\begin{DoxyCode}
1711 \{
1712         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
1713         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
1714         \textcolor{keywordtype}{int} bit1, bit2, bit3;
1715 
1716         \textcolor{comment}{// ---------------------------------------------------------------- //}
1717         \textcolor{comment}{//            tests                                                 //}
1718         \textcolor{comment}{// ---------------------------------------------------------------- //}
1719         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} && idQubit2 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1720 
1721         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1722 
1723         \textcolor{keywordflow}{if} ( probOfFilter<1e-16 )\{ printf(\textcolor{stringliteral}{"Extremely small or negative profOfFilter="}
      \hyperlink{precision_8h_ad751ac7ddc8ec19f23fb33083c0da8da}{REAL\_STRING\_FORMAT}\textcolor{stringliteral}{"; aborting! \(\backslash\)n"},probOfFilter); exit(1);\}
1724         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} myNorm=1/sqrt(probOfFilter);
1725         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1726         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1727 
1728 \textcolor{preprocessor}{# ifdef \_OPENMP}
1729 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1730 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
1731 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag, myNorm) \(\backslash\)}
1732 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3)                }
1733 \textcolor{preprocessor}{# endif }
1734         \{
1735 \textcolor{preprocessor}{# ifdef \_OPENMP}
1736 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1737 \textcolor{preprocessor}{# endif}
1738                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
1739                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
1740                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
1741                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index);
1742                         \textcolor{keywordflow}{if} ((bit1 && bit2 && bit3)) \{
1743                                 stateVecReal[index]=0;
1744                                 stateVecImag [index]=0;
1745                         \}\textcolor{keywordflow}{else}\{
1746                                 stateVecReal[index] *= myNorm;
1747                                 stateVecImag[index] *= myNorm;
1748                         \}
1749                 \}
1750         \}
1751 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}}
\index{find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{find\+Probability\+Of\+Zero\+Distributed(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit)}{findProbabilityOfZeroDistributed(MultiQubit multiQubit, const int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} find\+Probability\+Of\+Zero\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{}\label{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}


Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. 

Size of regions to skip is a multiple of chunk\+Size.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 1319 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Outcome().


\begin{DoxyCode}
1321 \{
1322         \textcolor{comment}{// ----- measured probability}
1323         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
1324         \textcolor{comment}{// ----- temp variables}
1325         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1326         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1327         \textcolor{comment}{// (good for shared memory parallelism)}
1328 
1329         \textcolor{comment}{// ---------------------------------------------------------------- //}
1330         \textcolor{comment}{//            tests                                                 //}
1331         \textcolor{comment}{// ---------------------------------------------------------------- //}
1332         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1333 
1334         \textcolor{comment}{// ---------------------------------------------------------------- //}
1335         \textcolor{comment}{//            find probability                                      //}
1336         \textcolor{comment}{// ---------------------------------------------------------------- //}
1337 
1338         \textcolor{comment}{// initialise returned value}
1339         totalProbability = 0.0;
1340 
1341         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1342         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1343 
1344 \textcolor{preprocessor}{# ifdef \_OPENMP}
1345 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1346 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1347 \textcolor{preprocessor}{        private   (thisTask) \(\backslash\)}
1348 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
1349 \textcolor{preprocessor}{# endif}
1350         \{
1351 \textcolor{preprocessor}{# ifdef \_OPENMP}
1352 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1353 \textcolor{preprocessor}{# endif}
1354                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1355                         \textcolor{comment}{// summation -- simple implementation}
1356                         totalProbability += stateVecReal[thisTask]*stateVecReal[thisTask]
1357                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
1358 
1359                         \textcolor{comment}{/*}
1360 \textcolor{comment}{                        // summation -- kahan correction}
1361 \textcolor{comment}{                        y = stateVecReal[thisTask]*stateVecReal[thisTask]}
1362 \textcolor{comment}{                        + stateVecImag[thisTask]*stateVecImag[thisTask] - c;}
1363 \textcolor{comment}{                        t = totalProbability + y;}
1364 \textcolor{comment}{                        c = (t - totalProbability) - y;}
1365 \textcolor{comment}{                        totalProbability = t;}
1366 \textcolor{comment}{                        */}
1367 
1368                 \}
1369         \}
1370 
1371         \textcolor{keywordflow}{return} totalProbability;
1372 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}}
\index{find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{find\+Probability\+Of\+Zero\+Local(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit)}{findProbabilityOfZeroLocal(MultiQubit multiQubit, const int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} find\+Probability\+Of\+Zero\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{}\label{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}


Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. 

Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 1240 of file qubits.\+c.



References D\+E\+B\+UG, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Outcome().


\begin{DoxyCode}
1242 \{
1243         \textcolor{comment}{// ----- sizes}
1244         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
1245         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
1246         \textcolor{comment}{// ----- indices}
1247         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
1248              index;                                               \textcolor{comment}{// current index for first half block}
1249         \textcolor{comment}{// ----- measured probability}
1250         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
1251         \textcolor{comment}{// ----- temp variables}
1252         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1253         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1254 
1255         \textcolor{comment}{// ---------------------------------------------------------------- //}
1256         \textcolor{comment}{//            tests                                                 //}
1257         \textcolor{comment}{// ---------------------------------------------------------------- //}
1258         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1259 
1260 
1261         \textcolor{comment}{// ---------------------------------------------------------------- //}
1262         \textcolor{comment}{//            dimensions                                            //}
1263         \textcolor{comment}{// ---------------------------------------------------------------- //}
1264         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
1265         \textcolor{comment}{// and then the number to skip}
1266         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
1267 
1268         \textcolor{comment}{// initialise returned value}
1269         totalProbability = 0.0;
1270 
1271         \textcolor{comment}{// initialise correction for kahan summation}
1272         \textcolor{keywordflow}{if} (\hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\(\backslash\)n"},sizeHalfBlock,sizeBlock,
      numTasks);
1273 
1274         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1275         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1276 
1277 \textcolor{preprocessor}{# ifdef \_OPENMP}
1278 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1279 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
1280 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index) \(\backslash\)}
1281 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
1282 \textcolor{preprocessor}{# endif }
1283         \{
1284 \textcolor{preprocessor}{# ifdef \_OPENMP}
1285 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1286 \textcolor{preprocessor}{# endif}
1287                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1288                         thisBlock = thisTask / sizeHalfBlock;
1289                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1290 
1291                         \textcolor{keywordflow}{if} (index<0)\{ printf(\textcolor{stringliteral}{"ABORTING as index=%Ld with thisBlock = %Ld  thisTask=%Ld \(\backslash\)n"},
       index,thisBlock,thisTask); exit(1);\}
1292 
1293                         \textcolor{comment}{// summation -- simple implementation}
1294                         totalProbability += stateVecReal[index]*stateVecReal[index]
1295                                 + stateVecImag[index]*stateVecImag[index];
1296 
1297                         \textcolor{comment}{/*}
1298 \textcolor{comment}{                        // summation -- kahan correction}
1299 \textcolor{comment}{                        y = stateVecReal[index]*stateVecReal[index]}
1300 \textcolor{comment}{                        + stateVecImag[index]*stateVecImag[index] - c;}
1301 \textcolor{comment}{                        t = totalProbability + y;}
1302 \textcolor{comment}{                        c = (t - totalProbability) - y;}
1303 \textcolor{comment}{                        totalProbability = t;}
1304 \textcolor{comment}{                        */}
1305 
1306                 \}
1307         \}
1308         \textcolor{keywordflow}{return} totalProbability;
1309 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!hadamard\+Distributed@{hadamard\+Distributed}}
\index{hadamard\+Distributed@{hadamard\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{hadamard\+Distributed(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out, int update\+Upper)}{hadamardDistributed(MultiQubit multiQubit, const int rotQubit, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut, int updateUpper)}}]{\setlength{\rightskip}{0pt plus 5cm}void hadamard\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out, }
\item[{int}]{update\+Upper}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_ac835c194bd547240a35f0b028db1d658}{}\label{qubits__internal_8h_ac835c194bd547240a35f0b028db1d658}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt in}  & {\em update\+Upper} & flag, 1\+: updating upper values, 0\+: updating lower values in block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 1018 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and R\+E\+AL.



Referenced by hadamard().


\begin{DoxyCode}
1023 \{
1024 
1025         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1026         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
1027         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1028 
1029         \textcolor{comment}{// test qubit valid}
1030         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1031 
1032         \textcolor{keywordtype}{int} sign;
1033         \textcolor{keywordflow}{if} (updateUpper) sign=1;
1034         \textcolor{keywordflow}{else} sign=-1;
1035 
1036         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1037 
1038         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1039         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1040         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1041 
1042 \textcolor{preprocessor}{# ifdef \_OPENMP}
1043 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1044 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1045 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
1046 \textcolor{preprocessor}{                        recRoot2, sign) \(\backslash\)}
1047 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
1048 \textcolor{preprocessor}{# endif}
1049         \{
1050 \textcolor{preprocessor}{# ifdef \_OPENMP}
1051 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1052 \textcolor{preprocessor}{# endif}
1053                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1054                         \textcolor{comment}{// store current state vector values in temp variables}
1055                         stateRealUp = stateVecRealUp[thisTask];
1056                         stateImagUp = stateVecImagUp[thisTask];
1057 
1058                         stateRealLo = stateVecRealLo[thisTask];
1059                         stateImagLo = stateVecImagLo[thisTask];
1060 
1061                         stateVecRealOut[thisTask] = recRoot2*(stateRealUp + sign*stateRealLo);
1062                         stateVecImagOut[thisTask] = recRoot2*(stateImagUp + sign*stateImagLo);
1063                 \}
1064         \}
1065 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!hadamard\+Local@{hadamard\+Local}}
\index{hadamard\+Local@{hadamard\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{hadamard\+Local(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit)}{hadamardLocal(MultiQubit multiQubit, const int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void hadamard\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a0711416fceaf63c67b496e123e845c69}{}\label{qubits__internal_8h_a0711416fceaf63c67b496e123e845c69}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}


Definition at line 950 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by hadamard().


\begin{DoxyCode}
951 \{
952         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
953         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
954              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
955 
956         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
957         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
958         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
959 
960         \textcolor{comment}{// test qubit valid}
961         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
962 
963         \textcolor{comment}{// set dimensions}
964         sizeHalfBlock = 1LL << rotQubit;  
965         sizeBlock     = 2LL * sizeHalfBlock; 
966 
967         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
968         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
969         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
970 
971         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
972 
973 \textcolor{preprocessor}{# ifdef \_OPENMP}
974 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
975 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
976 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \(\backslash\)}
977 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
978 \textcolor{preprocessor}{# endif}
979         \{
980 \textcolor{preprocessor}{# ifdef \_OPENMP}
981 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
982 \textcolor{preprocessor}{# endif}
983                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
984                         thisBlock   = thisTask / sizeHalfBlock;
985                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
986                         indexLo     = indexUp + sizeHalfBlock;
987 
988                         stateRealUp = stateVecReal[indexUp];
989                         stateImagUp = stateVecImag[indexUp];
990 
991                         stateRealLo = stateVecReal[indexLo];
992                         stateImagLo = stateVecImag[indexLo];
993 
994                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateRealLo);
995                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImagLo);
996 
997                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateRealLo);
998                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImagLo);
999                 \} 
1000         \}
1001 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!measure\+In\+State\+Distributed\+Renorm@{measure\+In\+State\+Distributed\+Renorm}}
\index{measure\+In\+State\+Distributed\+Renorm@{measure\+In\+State\+Distributed\+Renorm}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{measure\+In\+State\+Distributed\+Renorm(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit, const R\+E\+A\+L total\+Probability)}{measureInStateDistributedRenorm(MultiQubit multiQubit, const int measureQubit, const REAL totalProbability)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} measure\+In\+State\+Distributed\+Renorm (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit, }
\item[{const {\bf R\+E\+AL}}]{total\+Probability}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a35e5ac30c8427c482a97b33a4e295535}{}\label{qubits__internal_8h_a35e5ac30c8427c482a97b33a4e295535}


Renormalise parts of the state vector where measure\+Qubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that the value \textquotesingle{}outcome\textquotesingle{} has been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. In the distributed version, one block (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em total\+Probability} & probability of qubit measure\+Qubit being zero \\
\hline
\end{DoxyParams}


Definition at line 1620 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+State().


\begin{DoxyCode}
1621 \{
1622         \textcolor{comment}{// ----- temp variables}
1623         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1624         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1625         \textcolor{comment}{// (good for shared memory parallelism)}
1626 
1627         \textcolor{comment}{// ---------------------------------------------------------------- //}
1628         \textcolor{comment}{//            tests                                                 //}
1629         \textcolor{comment}{// ---------------------------------------------------------------- //}
1630         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1631 
1632         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} renorm=1/sqrt(totalProbability);
1633         
1634         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1635         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1636 
1637 \textcolor{preprocessor}{# ifdef \_OPENMP}
1638 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1639 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1640 \textcolor{preprocessor}{        private   (thisTask)}
1641 \textcolor{preprocessor}{# endif}
1642         \{
1643 \textcolor{preprocessor}{# ifdef \_OPENMP}
1644 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1645 \textcolor{preprocessor}{# endif}
1646                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1647                         \textcolor{comment}{// summation -- simple implementation}
1648                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
1649                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
1650                 \}
1651         \}
1652         \textcolor{keywordflow}{return} totalProbability;
1653 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!measure\+In\+State\+Distributed\+Set\+Zero@{measure\+In\+State\+Distributed\+Set\+Zero}}
\index{measure\+In\+State\+Distributed\+Set\+Zero@{measure\+In\+State\+Distributed\+Set\+Zero}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{measure\+In\+State\+Distributed\+Set\+Zero(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit)}{measureInStateDistributedSetZero(MultiQubit multiQubit, const int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void measure\+In\+State\+Distributed\+Set\+Zero (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_ac39efc9ed939382276ebd0c15dd6a0fa}{}\label{qubits__internal_8h_ac39efc9ed939382276ebd0c15dd6a0fa}


Set all amplitudes in one chunk to 0. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that a zero have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 or 1. In the distributed version, one block (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}


Definition at line 1668 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+State().


\begin{DoxyCode}
1669 \{
1670         \textcolor{comment}{// ----- temp variables}
1671         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1672         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1673         \textcolor{comment}{// (good for shared memory parallelism)}
1674 
1675         \textcolor{comment}{// ---------------------------------------------------------------- //}
1676         \textcolor{comment}{//            tests                                                 //}
1677         \textcolor{comment}{// ---------------------------------------------------------------- //}
1678         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1679 
1680         \textcolor{comment}{// ---------------------------------------------------------------- //}
1681         \textcolor{comment}{//            find probability                                      //}
1682         \textcolor{comment}{// ---------------------------------------------------------------- //}
1683 
1684         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1685         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1686 
1687 \textcolor{preprocessor}{# ifdef \_OPENMP}
1688 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1689 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1690 \textcolor{preprocessor}{        private   (thisTask)}
1691 \textcolor{preprocessor}{# endif}
1692         \{
1693 \textcolor{preprocessor}{# ifdef \_OPENMP}
1694 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1695 \textcolor{preprocessor}{# endif}
1696                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1697                         \textcolor{comment}{// summation -- simple implementation}
1698                         stateVecReal[thisTask] = 0;
1699                         stateVecImag[thisTask] = 0;
1700                 \}
1701         \}
1702 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!measure\+In\+State\+Local@{measure\+In\+State\+Local}}
\index{measure\+In\+State\+Local@{measure\+In\+State\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{measure\+In\+State\+Local(\+Multi\+Qubit multi\+Qubit, int measure\+Qubit, R\+E\+A\+L total\+Probability, int outcome)}{measureInStateLocal(MultiQubit multiQubit, int measureQubit, REAL totalProbability, int outcome)}}]{\setlength{\rightskip}{0pt plus 5cm}void measure\+In\+State\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{int}]{measure\+Qubit, }
\item[{{\bf R\+E\+AL}}]{total\+Probability, }
\item[{int}]{outcome}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a53614ce19e0a4f2c41b400cf05dc5bd1}{}\label{qubits__internal_8h_a53614ce19e0a4f2c41b400cf05dc5bd1}


Update the state vector to be consistent with measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. 

Performs an irreversible change to the state vector\+: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em total\+Probability} & probability of qubit measure\+Qubit being either zero or one \\
\hline
\mbox{\tt in}  & {\em outcome} & to measure the probability of and set the state to -- either zero or one \\
\hline
\end{DoxyParams}


Definition at line 1532 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+State().


\begin{DoxyCode}
1533 \{
1534         \textcolor{comment}{// ----- sizes}
1535         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
1536         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
1537         \textcolor{comment}{// ----- indices}
1538         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
1539              index;                                               \textcolor{comment}{// current index for first half block}
1540         \textcolor{comment}{// ----- measured probability}
1541         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   renorm;                                    \textcolor{comment}{// probability (returned) value}
1542         \textcolor{comment}{// ----- temp variables}
1543         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1544         \textcolor{comment}{// (good for shared memory parallelism)}
1545         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1546 
1547         \textcolor{comment}{// ---------------------------------------------------------------- //}
1548         \textcolor{comment}{//            tests                                                 //}
1549         \textcolor{comment}{// ---------------------------------------------------------------- //}
1550         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1551 
1552         \textcolor{comment}{// ---------------------------------------------------------------- //}
1553         \textcolor{comment}{//            dimensions                                            //}
1554         \textcolor{comment}{// ---------------------------------------------------------------- //}
1555         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
1556         \textcolor{comment}{// and then the number to skip}
1557         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
1558         
1559         renorm=1/sqrt(totalProbability);
1560         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1561         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1562 
1563 
1564 \textcolor{preprocessor}{# ifdef \_OPENMP}
1565 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1566 \textcolor{preprocessor}{        default (none) \(\backslash\)}
1567 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,renorm,outcome) \(\backslash\)}
1568 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index)}
1569 \textcolor{preprocessor}{# endif}
1570         \{
1571                 \textcolor{keywordflow}{if} (outcome==0)\{
1572                         \textcolor{comment}{// measure qubit is 0}
1573 \textcolor{preprocessor}{# ifdef \_OPENMP}
1574 \textcolor{preprocessor}{                        # pragma omp for schedule  (static)}
1575 \textcolor{preprocessor}{# endif}
1576                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1577                                 thisBlock = thisTask / sizeHalfBlock;
1578                                 index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1579                                 stateVecReal[index]=stateVecReal[index]*renorm;
1580                                 stateVecImag[index]=stateVecImag[index]*renorm;
1581 
1582                                 stateVecReal[index+sizeHalfBlock]=0;
1583                                 stateVecImag[index+sizeHalfBlock]=0;
1584                         \}
1585                 \} \textcolor{keywordflow}{else} \{
1586                         \textcolor{comment}{// measure qubit is 1}
1587 \textcolor{preprocessor}{# ifdef \_OPENMP}
1588 \textcolor{preprocessor}{                        # pragma omp for schedule  (static)}
1589 \textcolor{preprocessor}{# endif}
1590                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1591                                 thisBlock = thisTask / sizeHalfBlock;
1592                                 index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1593                                 stateVecReal[index]=0;
1594                                 stateVecImag[index]=0;
1595 
1596                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[index+sizeHalfBlock]*renorm;
1597                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[index+sizeHalfBlock]*renorm;
1598                         \}
1599                 \}
1600         \}
1601 
1602 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!phase\+Gate\+Distributed@{phase\+Gate\+Distributed}}
\index{phase\+Gate\+Distributed@{phase\+Gate\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{phase\+Gate\+Distributed(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, enum phase\+Gate\+Type type)}{phaseGateDistributed(MultiQubit multiQubit, const int rotQubit, enum phaseGateType type)}}]{\setlength{\rightskip}{0pt plus 5cm}void phase\+Gate\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{enum {\bf phase\+Gate\+Type}}]{type}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a38a05c7e749e806b182ef3b89878bfc4}{}\label{qubits__internal_8h_a38a05c7e749e806b182ef3b89878bfc4}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em type} & the type of phase gate to apply -- one of \{S\+I\+G\+M\+A\+\_\+Z, S\+\_\+\+G\+A\+TE, T\+\_\+\+G\+A\+TE\} \\
\hline
\end{DoxyParams}


Definition at line 1160 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, S\+\_\+\+G\+A\+TE, S\+I\+G\+M\+A\+\_\+Z, Multi\+Qubit\+::state\+Vec, and T\+\_\+\+G\+A\+TE.



Referenced by phase\+Gate().


\begin{DoxyCode}
1161 \{
1162         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealLo,stateImagLo;
1163         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1164         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1165 
1166         \textcolor{comment}{// test qubit valid}
1167         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1168 
1169         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1170         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1171         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1172 
1173         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1174 
1175 \textcolor{preprocessor}{# ifdef \_OPENMP}
1176 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1177 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1178 \textcolor{preprocessor}{        shared   (stateVecReal,stateVecImag, recRoot2, type) \(\backslash\)}
1179 \textcolor{preprocessor}{        private  (thisTask,stateRealLo,stateImagLo) }
1180 \textcolor{preprocessor}{# endif}
1181         \{
1182                 \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{SIGMA\_Z})\{
1183 \textcolor{preprocessor}{# ifdef \_OPENMP}
1184 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1185 \textcolor{preprocessor}{# endif}
1186                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1187                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
1188                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
1189                         \} 
1190                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{S\_GATE})\{
1191 \textcolor{preprocessor}{# ifdef \_OPENMP}
1192 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1193 \textcolor{preprocessor}{# endif}
1194                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1195                                 stateRealLo = stateVecReal[thisTask];
1196                                 stateImagLo = stateVecImag[thisTask];
1197 
1198                                 stateVecReal[thisTask] = -stateImagLo;
1199                                 stateVecImag[thisTask] = stateRealLo;
1200                         \} 
1201                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{T\_GATE})\{
1202 \textcolor{preprocessor}{# ifdef \_OPENMP}
1203 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1204 \textcolor{preprocessor}{# endif}
1205                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1206                                 stateRealLo = stateVecReal[thisTask];
1207                                 stateImagLo = stateVecImag[thisTask];
1208 
1209                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo - stateImagLo);
1210                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo + stateImagLo);
1211                         \} 
1212                 \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"Type %d is an invalid phase gate\(\backslash\)n"}, type);
1213         \}
1214 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!phase\+Gate\+Local@{phase\+Gate\+Local}}
\index{phase\+Gate\+Local@{phase\+Gate\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{phase\+Gate\+Local(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, enum phase\+Gate\+Type type)}{phaseGateLocal(MultiQubit multiQubit, const int rotQubit, enum phaseGateType type)}}]{\setlength{\rightskip}{0pt plus 5cm}void phase\+Gate\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{enum {\bf phase\+Gate\+Type}}]{type}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a6a736aeb3532898019fe7c27010edc6a}{}\label{qubits__internal_8h_a6a736aeb3532898019fe7c27010edc6a}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em type} & the type of phase gate to apply -- one of \{S\+I\+G\+M\+A\+\_\+Z, S\+\_\+\+G\+A\+TE, T\+\_\+\+G\+A\+TE\} \\
\hline
\end{DoxyParams}
fix -- can i rewrite this to not use mod?

fix -- can i rewrite this to not use mod?

fix -- can i rewrite this to not use mod? 

Definition at line 1074 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, S\+\_\+\+G\+A\+TE, S\+I\+G\+M\+A\+\_\+Z, Multi\+Qubit\+::state\+Vec, and T\+\_\+\+G\+A\+TE.



Referenced by phase\+Gate().


\begin{DoxyCode}
1075 \{
1076         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
1077         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
1078              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
1079 
1080         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealLo,stateImagLo;
1081         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1082         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1083 
1084         \textcolor{comment}{// test qubit valid}
1085         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1086 
1087         \textcolor{comment}{// set dimensions}
1088         sizeHalfBlock = 1LL << rotQubit;  
1089         sizeBlock     = 2LL * sizeHalfBlock; 
1090 
1091         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1092         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1093         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1094 
1095         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1096 
1097 \textcolor{preprocessor}{# ifdef \_OPENMP}
1098 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1099 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1100 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type) \(\backslash\)}
1101 \textcolor{preprocessor}{        private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) }
1102 \textcolor{preprocessor}{# endif}
1103         \{
1104                 \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{SIGMA\_Z})\{
1105 \textcolor{preprocessor}{# ifdef \_OPENMP}
1106 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1107 \textcolor{preprocessor}{# endif}
1108                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1110                                 thisBlock   = thisTask / sizeHalfBlock;
1111                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1112                                 indexLo     = indexUp + sizeHalfBlock;
1113 
1114                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
1115                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
1116                         \} 
1117                 \} 
1118                 
1119                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{S\_GATE})\{
1120 \textcolor{preprocessor}{# ifdef \_OPENMP}
1121 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1122 \textcolor{preprocessor}{# endif}
1123                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1125                                 thisBlock   = thisTask / sizeHalfBlock;
1126                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1127                                 indexLo     = indexUp + sizeHalfBlock;
1128                                 stateRealLo = stateVecReal[indexLo];
1129                                 stateImagLo = stateVecImag[indexLo];
1130 
1131                                 stateVecReal[indexLo] = -stateImagLo;
1132                                 stateVecImag[indexLo] = stateRealLo;
1133                         \} 
1134                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{T\_GATE})\{
1135 \textcolor{preprocessor}{# ifdef \_OPENMP}
1136 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1137 \textcolor{preprocessor}{# endif}
1138                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1140                                 thisBlock   = thisTask / sizeHalfBlock;
1141                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1142                                 indexLo     = indexUp + sizeHalfBlock;
1143                                 stateRealLo = stateVecReal[indexLo];
1144                                 stateImagLo = stateVecImag[indexLo];
1145 
1146                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo - stateImagLo);
1147                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo + stateImagLo);
1148                         \} 
1149                 \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"Type %d is an invalid phase gate\(\backslash\)n"}, type);
1150         \}
1151 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!prob\+Of\+Filter\+Out111\+Local@{prob\+Of\+Filter\+Out111\+Local}}
\index{prob\+Of\+Filter\+Out111\+Local@{prob\+Of\+Filter\+Out111\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{prob\+Of\+Filter\+Out111\+Local(\+Multi\+Qubit multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3)}{probOfFilterOut111Local(MultiQubit multiQubit, const int idQubit1, const int idQubit2, const int idQubit3)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} prob\+Of\+Filter\+Out111\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{id\+Qubit1, }
\item[{const int}]{id\+Qubit2, }
\item[{const int}]{id\+Qubit3}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a096cddbac961f0651a084d2ceb905d1b}{}\label{qubits__internal_8h_a096cddbac961f0651a084d2ceb905d1b}


Evaluates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. 

The function returns the probability of this outcome across all amplitudes in this chunk (if zero, it will exit with error) 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3} & specified qubits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Total probability that the 3 qubits are not all in the 1 state. 
\end{DoxyReturn}


Definition at line 1759 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by prob\+Of\+Filter\+Out111().


\begin{DoxyCode}
1760 \{
1761         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
1762         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
1763         \textcolor{keywordtype}{int} bit1, bit2, bit3;
1764 
1765         \textcolor{comment}{// ---------------------------------------------------------------- //}
1766         \textcolor{comment}{//            tests                                                 //}
1767         \textcolor{comment}{// ---------------------------------------------------------------- //}
1768         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} && idQubit2 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1769 
1770         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1771         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} probOfFilter=0;
1772         
1773         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1774         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1775 
1776 \textcolor{preprocessor}{# ifdef \_OPENMP}
1777 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1778 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
1779 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag) \(\backslash\)}
1780 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3)                \(\backslash\)}
1781 \textcolor{preprocessor}{        reduction ( +:probOfFilter )}
1782 \textcolor{preprocessor}{# endif}
1783         \{
1784 \textcolor{preprocessor}{# ifdef \_OPENMP}
1785 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1786 \textcolor{preprocessor}{# endif}
1787                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
1788                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
1789                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
1790                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index);
1791                         \textcolor{keywordflow}{if} (!(bit1 && bit2 && bit3)) \{
1792                                 probOfFilter+= stateVecReal[index]*stateVecReal[index] + stateVecImag[index
      ]* stateVecImag [index];
1793                         \}
1794                 \}
1795         \}
1796         \textcolor{keywordflow}{return} probOfFilter;
1797 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!rotate\+Qubit\+Distributed@{rotate\+Qubit\+Distributed}}
\index{rotate\+Qubit\+Distributed@{rotate\+Qubit\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{rotate\+Qubit\+Distributed(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, Complex rot1, Complex rot2, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out)}{rotateQubitDistributed(MultiQubit multiQubit, const int rotQubit, Complex rot1, Complex rot2, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void rotate\+Qubit\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf Complex}}]{rot1, }
\item[{{\bf Complex}}]{rot2, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}{}\label{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}


Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 400 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Complex\+::real.



Referenced by rotate\+Qubit().


\begin{DoxyCode}
405 \{
406 
407         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
408         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
409         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
410 
411         \textcolor{comment}{// test qubit valid}
412         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
413 
414         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
415         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
416         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
417         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
418         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
419 
420 \textcolor{preprocessor}{# ifdef \_OPENMP}
421 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
422 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
423 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
424 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag) \(\backslash\)}
425 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
426 \textcolor{preprocessor}{# endif}
427         \{
428 \textcolor{preprocessor}{# ifdef \_OPENMP}
429 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
430 \textcolor{preprocessor}{# endif}
431                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
432                         \textcolor{comment}{// store current state vector values in temp variables}
433                         stateRealUp = stateVecRealUp[thisTask];
434                         stateImagUp = stateVecImagUp[thisTask];
435 
436                         stateRealLo = stateVecRealLo[thisTask];
437                         stateImagLo = stateVecImagLo[thisTask];
438 
439                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
440                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp + rot2Real*
      stateRealLo + rot2Imag*stateImagLo;
441                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp + rot2Real*
      stateImagLo - rot2Imag*stateRealLo;
442                 \}
443         \}
444 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!rotate\+Qubit\+Local@{rotate\+Qubit\+Local}}
\index{rotate\+Qubit\+Local@{rotate\+Qubit\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{rotate\+Qubit\+Local(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, Complex alpha, Complex beta)}{rotateQubitLocal(MultiQubit multiQubit, const int rotQubit, Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}void rotate\+Qubit\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}{}\label{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}


Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. 

alpha\+Re = cos(angle1) $\ast$ cos(angle2) ~\newline
alpha\+Im = cos(angle1) $\ast$ sin(angle2) ~\newline
 beta\+Re = sin(angle1) $\ast$ cos(angle3) ~\newline
 beta\+Im = sin(angle1) $\ast$ sin(angle3) ~\newline


\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em alpha} & rotation angle \\
\hline
\mbox{\tt in}  & {\em beta} & rotation angle \\
\hline
\end{DoxyParams}


Definition at line 321 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, Complex\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by rotate\+Qubit().


\begin{DoxyCode}
322 \{
323         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
324         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
325              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
326 
327         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
328         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
329         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
330 
331         \textcolor{comment}{// test qubit valid}
332         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
333 
334         \textcolor{comment}{// set dimensions}
335         sizeHalfBlock = 1LL << rotQubit;  
336         sizeBlock     = 2LL * sizeHalfBlock; 
337 
338         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
339         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
340         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
341         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} alphaImag=alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, alphaReal=alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
342         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} betaImag=beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, betaReal=beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
343 
344 \textcolor{preprocessor}{# ifdef \_OPENMP}
345 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
346 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
347 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,alphaImag,
       betaReal,betaImag) \(\backslash\)}
348 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
349 \textcolor{preprocessor}{# endif}
350         \{
351 \textcolor{preprocessor}{# ifdef \_OPENMP}
352 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
353 \textcolor{preprocessor}{# endif}
354                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
355 
356                         thisBlock   = thisTask / sizeHalfBlock;
357                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
358                         indexLo     = indexUp + sizeHalfBlock;
359 
360                         \textcolor{comment}{// store current state vector values in temp variables}
361                         stateRealUp = stateVecReal[indexUp];
362                         stateImagUp = stateVecImag[indexUp];
363 
364                         stateRealLo = stateVecReal[indexLo];
365                         stateImagLo = stateVecImag[indexLo];
366 
367                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
368                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag*stateImagUp 
369                                 - betaReal*stateRealLo - betaImag*stateImagLo;
370                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag*stateRealUp 
371                                 - betaReal*stateImagLo + betaImag*stateRealLo;
372 
373                         \textcolor{comment}{// state[indexLo] = beta  * state[indexUp] + conj(alpha) * state[indexLo]}
374                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*stateImagUp 
375                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
376                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*stateRealUp 
377                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
378                 \} 
379         \}
380 
381 \} 
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!sigma\+X\+Distributed@{sigma\+X\+Distributed}}
\index{sigma\+X\+Distributed@{sigma\+X\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{sigma\+X\+Distributed(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, Complex\+Array state\+Vec\+In, Complex\+Array state\+Vec\+Out)}{sigmaXDistributed(MultiQubit multiQubit, const int rotQubit, ComplexArray stateVecIn, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigma\+X\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+In, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a5958808b2f2f05937921ba7dabe5a171}{}\label{qubits__internal_8h_a5958808b2f2f05937921ba7dabe5a171}


Rotate a single qubit by \{\{0,1\},\{1,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 684 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and R\+E\+AL.



Referenced by sigma\+X().


\begin{DoxyCode}
687 \{
688 
689         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
690         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
691 
692         \textcolor{comment}{// test qubit valid}
693         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
694 
695         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
696         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
697 
698 \textcolor{preprocessor}{# ifdef \_OPENMP}
699 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
700 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
701 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) \(\backslash\)}
702 \textcolor{preprocessor}{        private  (thisTask)}
703 \textcolor{preprocessor}{# endif}
704         \{
705 \textcolor{preprocessor}{# ifdef \_OPENMP}
706 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
707 \textcolor{preprocessor}{# endif}
708                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
709                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
710                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
711                 \}
712         \}
713 \} 
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!sigma\+X\+Local@{sigma\+X\+Local}}
\index{sigma\+X\+Local@{sigma\+X\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{sigma\+X\+Local(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit)}{sigmaXLocal(MultiQubit multiQubit, const int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigma\+X\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_aa9e640bb2d0458c937c6a87dfeca0f23}{}\label{qubits__internal_8h_aa9e640bb2d0458c937c6a87dfeca0f23}


Rotate a single qubit by \{\{0,1\},\{1,0\}. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}


Definition at line 621 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by sigma\+X().


\begin{DoxyCode}
622 \{
623         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
624         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
625              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
626 
627         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
628         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
629         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
630 
631         \textcolor{comment}{// test qubit valid}
632         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
633 
634         \textcolor{comment}{// set dimensions}
635         sizeHalfBlock = 1LL << rotQubit;  
636         sizeBlock     = 2LL * sizeHalfBlock; 
637 
638         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
639         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
640         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
641 
642 \textcolor{preprocessor}{# ifdef \_OPENMP}
643 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
644 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
645 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
646 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) }
647 \textcolor{preprocessor}{# endif}
648         \{
649 \textcolor{preprocessor}{# ifdef \_OPENMP}
650 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
651 \textcolor{preprocessor}{# endif}
652                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
653                         thisBlock   = thisTask / sizeHalfBlock;
654                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
655                         indexLo     = indexUp + sizeHalfBlock;
656 
657                         stateRealUp = stateVecReal[indexUp];
658                         stateImagUp = stateVecImag[indexUp];
659 
660                         stateVecReal[indexUp] = stateVecReal[indexLo];
661                         stateVecImag[indexUp] = stateVecImag[indexLo];
662 
663                         stateVecReal[indexLo] = stateRealUp;
664                         stateVecImag[indexLo] = stateImagUp;
665                 \} 
666         \}
667 
668 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!sigma\+Y\+Distributed@{sigma\+Y\+Distributed}}
\index{sigma\+Y\+Distributed@{sigma\+Y\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{sigma\+Y\+Distributed(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, Complex\+Array state\+Vec\+In, Complex\+Array state\+Vec\+Out, int update\+Upper)}{sigmaYDistributed(MultiQubit multiQubit, const int rotQubit, ComplexArray stateVecIn, ComplexArray stateVecOut, int updateUpper)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigma\+Y\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+In, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out, }
\item[{int}]{update\+Upper}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a0471f6b547ce8270ef85170b7f4f0214}{}\label{qubits__internal_8h_a0471f6b547ce8270ef85170b7f4f0214}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt in}  & {\em update\+Upper} & flag, 1\+: updating upper values, 0\+: updating lower values in block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 907 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and R\+E\+AL.



Referenced by sigma\+Y().


\begin{DoxyCode}
911 \{
912 
913         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
914         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
915 
916         \textcolor{comment}{// test qubit valid}
917         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
918 
919         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
920         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
921 
922         \textcolor{keywordtype}{int} realSign=1, imagSign=1;
923         \textcolor{keywordflow}{if} (updateUpper) imagSign=-1;
924         \textcolor{keywordflow}{else} realSign = -1;
925 
926 \textcolor{preprocessor}{# ifdef \_OPENMP}
927 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
928 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
929 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,realSign,imagSign) \(\backslash\)}
930 \textcolor{preprocessor}{        private  (thisTask)}
931 \textcolor{preprocessor}{# endif}
932         \{
933 \textcolor{preprocessor}{# ifdef \_OPENMP}
934 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
935 \textcolor{preprocessor}{# endif}
936                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
937                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisTask];
938                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisTask];
939                 \}
940         \}
941 \} 
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!sigma\+Y\+Local@{sigma\+Y\+Local}}
\index{sigma\+Y\+Local@{sigma\+Y\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{sigma\+Y\+Local(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit)}{sigmaYLocal(MultiQubit multiQubit, const int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigma\+Y\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_afcbb1dcbe070ad0ed1a72a23251b6a83}{}\label{qubits__internal_8h_afcbb1dcbe070ad0ed1a72a23251b6a83}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}


Definition at line 844 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by sigma\+Y().


\begin{DoxyCode}
845 \{
846         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
847         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
848              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
849 
850         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
851         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
852         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
853 
854         \textcolor{comment}{// test qubit valid}
855         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
856 
857         \textcolor{comment}{// set dimensions}
858         sizeHalfBlock = 1LL << rotQubit;  
859         sizeBlock     = 2LL * sizeHalfBlock; 
860 
861         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
862         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
863         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
864 
865 \textcolor{preprocessor}{# ifdef \_OPENMP}
866 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
867 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
868 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
869 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) }
870 \textcolor{preprocessor}{# endif}
871         \{
872 \textcolor{preprocessor}{# ifdef \_OPENMP}
873 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
874 \textcolor{preprocessor}{# endif}
875                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
876                         thisBlock   = thisTask / sizeHalfBlock;
877                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
878                         indexLo     = indexUp + sizeHalfBlock;
879 
880                         stateRealUp = stateVecReal[indexUp];
881                         stateImagUp = stateVecImag[indexUp];
882 
883                         stateVecReal[indexUp] = stateVecImag[indexLo];
884                         stateVecImag[indexUp] = -stateVecReal[indexLo];
885 
886                         stateVecReal[indexLo] = -stateImagUp;
887                         stateVecImag[indexLo] = stateRealUp;
888                 \} 
889         \}
890 \}
\end{DoxyCode}
