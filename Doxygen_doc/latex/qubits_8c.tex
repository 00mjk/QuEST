\hypertarget{qubits_8c}{
\subsection{qubits.c File Reference}
\label{qubits_8c}\index{qubits.c@{qubits.c}}
}


The core of the QuEST Library.  
{\ttfamily \#include $<$math.h$>$}\par
{\ttfamily \#include $<$stdio.h$>$}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$assert.h$>$}\par
{\ttfamily \#include \char`\"{}precision.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}qubits.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}qubits\_\-internal.h\char`\"{}}\par
{\ttfamily \#include $<$omp.h$>$}\par
\subsubsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}~0
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (const int locationOfBitFromRight, const long long int theEncodedNumber)
\begin{DoxyCompactList}\small\item\em Get the value of the bit at a particular index in a number. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a9c02591bc64c2918503afa231d90d83f}{createMultiQubit} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit, int numQubits, \hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Create a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}{destroyMultiQubit} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, \hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Deallocate a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}{reportState} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Print the current state vector of probability amplitudes for a set of qubits to file. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a842d6884e063a5865a2232cba56b65ac}{reportStateToScreen} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, \hyperlink{structQuESTEnv}{QuESTEnv} env, int reportRank)
\begin{DoxyCompactList}\small\item\em Print the current state vector of probability amplitudes for a set of qubits to standard out. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}{reportMultiQubitParams} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Report metainformation about a set of qubits: number of qubits, number of probability amplitudes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a8f10aabf9f607f19093aee54630caa21}{getEnvironmentString} (\hyperlink{structQuESTEnv}{QuESTEnv} env, \hyperlink{structMultiQubit}{MultiQubit} multiQubit, char str\mbox{[}200\mbox{]})
\item 
void \hyperlink{qubits_8c_acb5b2eff794339090004d29f02a70d9a}{initStateZero} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit)
\begin{DoxyCompactList}\small\item\em Initialise a set of $ N $ qubits to the classical zero state $ {| 0 \rangle}^{\otimes N} $. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}{initStatePlus} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit)
\begin{DoxyCompactList}\small\item\em Initialise a set of $ N $ qubits to the plus state $ {| + \rangle}^{\otimes N} = \frac{1}{\sqrt{2^N}} (| 0 \rangle + | 1 \rangle)^{\otimes N} $. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a7169fd0442cbc3418f3fac4d13363ca2}{initStateOfSingleQubit} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit, int qubitId, int outcome)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes such that one qubit is set to 'outcome' and all other qubits are in an equal superposition of zero and one. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}{initStateDebug} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes to an (unphysical) state with each component of each probability amplitude a unique floating point value. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a433876ee9f3bcc54af346300f571fc3c}{initializeStateFromSingleFile} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit, char filename\mbox{[}200\mbox{]}, \hyperlink{structQuESTEnv}{QuESTEnv} env)
\item 
int \hyperlink{qubits_8c_a793584932ae384c82e7e42db7d35d18d}{compareStates} (\hyperlink{structMultiQubit}{MultiQubit} mq1, \hyperlink{structMultiQubit}{MultiQubit} mq2, REAL precision)
\item 
int \hyperlink{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}{validateMatrixIsUnitary} (\hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
int \hyperlink{qubits_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}{validateAlphaBeta} (\hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
int \hyperlink{qubits_8c_a71c14976f63cfcda70026fa20ee531fe}{validateUnitVector} (REAL ux, REAL uy, REAL uz)
\item 
void \hyperlink{qubits_8c_a8810423457803005fecd415f4299f40d}{rotateAroundAxis} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle, \hyperlink{structVector}{Vector} axis)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around a given vector on the Bloch-\/sphere. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a6cc7fa705a2f2e6b486b49c5589d5df5}{rotateX} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around the X-\/axis of the Bloch-\/sphere. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ace0d3592d38a990e81a434c4e9681500}{rotateY} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around the Y-\/axis of the Bloch-\/sphere. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_abd621412ad30c1b034f4ce153c4afe10}{rotateZ} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around the Z-\/axis of the Bloch-\/sphere (also known as a phase shift gate). \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a9cee2d8716667a3318420a3b672f5b92}{compactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits_8c_ac134fb45b0a7248c5d15e16eb7139a35}{unitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits_8c_a20ee1878a63ae6112e8845f4a8787592}{compactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a2343b7240118e89aa615e2c9140b770b}{unitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_afc77657651d52c47403b44b923a098a8}{controlledCompactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits_8c_a1309eabcba3cb97fbc3cd2e606d17766}{multiControlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits_8c_a8a4afcff70195a306c082b8ed8d4e09a}{controlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits_8c_a717855e835e3161e08c18cdc15325d27}{controlledCompactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a642093063a1f889f61a1311f6d6f2d3f}{controlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{multiControlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a74822fd86bb5d81766e6e8dbdcd62df1}{sigmaXLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits_8c_a2275fff50824fe47485890ff5a857785}{sigmaXDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ad357a43e80e3baf013975b1b70942f4c}{controlledNotLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit)
\item 
void \hyperlink{qubits_8c_a05875a70b539a3efb28d027823403f34}{controlledNotDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a81fbfaed65a742a7dfd622e17652245e}{sigmaYLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits_8c_af5ef5166f00c0572354b4ac53dcf40cf}{sigmaYDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_aa9f0718b4dd794a3e1b143e3b153bfc5}{hadamardLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits_8c_ae6a897066979fc52d977007d959ca09d}{hadamardDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a3a54566b73ac84c312d7da4f56ffbc3b}{phaseGateLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits_8c_af832ed00b02a0597b7fe0b714032c54a}{phaseGateDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits_8c_aebaab86326779de55d335cfea3efde8f}{sigmaZ} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit sigma-\/Z (also known as the Z, Pauli-\/Z or phase-\/flip) gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_adda6c47876a7676488ed0565a19eaa65}{sGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit S gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_af764ea63a2e870098f4e1ce08562942e}{tGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit T gate. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}{findProbabilityOfZeroLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}{findProbabilityOfZeroDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a11a96159191cbf1b01a1080e7f045aac}{controlledPhaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int idQubit1, const int idQubit2)
\begin{DoxyCompactList}\small\item\em Apply the (two-\/qubit) controlled phase gate, also known as the controlled sigmaZ gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_afc1835c6b43b6e59ce7df7b13f274fc7}{multiControlledPhaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int $\ast$controlQubits, int numControlQubits)
\begin{DoxyCompactList}\small\item\em Apply the multiple-\/qubit controlled phase gate, also known as the multiple-\/qubit controlled sigmaZ gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a01d9a8b7ff0e09ec399e158389783aa9}{collapseToOutcomeLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int measureQubit, REAL totalProbability, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, const REAL totalProbability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Set all amplitudes in one chunk to 0. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}{getProbEl} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the probability of the state at an index in the full state vector. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \hyperlink{qubits_8c_aac1637696885c75b73a1ecf381cea713}{errorCodes} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
The core of the QuEST Library. 

Definition in file \hyperlink{qubits_8c_source}{qubits.c}.

\subsubsection{Define Documentation}
\hypertarget{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{
\index{qubits.c@{qubits.c}!DEBUG@{DEBUG}}
\index{DEBUG@{DEBUG}!qubits.c@{qubits.c}}
\paragraph[{DEBUG}]{\setlength{\rightskip}{0pt plus 5cm}\#define DEBUG~0}\hfill}
\label{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}


Definition at line 18 of file qubits.c.

Referenced by calcTotalProbability(), exchangeStateVectors(), findProbabilityOfZeroLocal(), initQuESTEnv(), initStateOfSingleQubit(), initStatePlus(), and initStateZero().

\subsubsection{Function Documentation}
\hypertarget{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{
\index{qubits.c@{qubits.c}!collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}}
\index{collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}!qubits.c@{qubits.c}}
\paragraph[{collapseToOutcomeDistributedRenorm}]{\setlength{\rightskip}{0pt plus 5cm}REAL collapseToOutcomeDistributedRenorm ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  const REAL {\em totalProbability})}\hfill}
\label{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}


Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that the value 'outcome' has been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being zero \end{DoxyParams}


Definition at line 1867 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1868 {
1869         // ----- temp variables
1870         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1871         long long int numTasks=multiQubit.numAmps;
1872         // (good for shared memory parallelism)
1873 
1874         REAL renorm=1/sqrt(totalProbability);
1875         
1876         REAL *stateVecReal = multiQubit.stateVec.real;
1877         REAL *stateVecImag = multiQubit.stateVec.imag;
1878 
1879 # ifdef _OPENMP
1880 # pragma omp parallel \
1881         shared    (numTasks,stateVecReal,stateVecImag) \
1882         private   (thisTask)
1883 # endif
1884         {
1885 # ifdef _OPENMP
1886                 # pragma omp for schedule  (static)
1887 # endif
1888                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1889                         // summation -- simple implementation
1890                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
1891                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
1892                 }
1893         }
1894         return totalProbability;
1895 }
\end{DoxyCode}
\hypertarget{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{
\index{qubits.c@{qubits.c}!collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}}
\index{collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}!qubits.c@{qubits.c}}
\paragraph[{collapseToOutcomeDistributedSetZero}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeDistributedSetZero ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}


Set all amplitudes in one chunk to 0. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that a zero have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}


Definition at line 1909 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1910 {
1911         // ----- temp variables
1912         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1913         long long int numTasks=multiQubit.numAmps;
1914         // (good for shared memory parallelism)
1915 
1916         // ---------------------------------------------------------------- //
1917         //            find probability                                      //
1918         // ---------------------------------------------------------------- //
1919 
1920         REAL *stateVecReal = multiQubit.stateVec.real;
1921         REAL *stateVecImag = multiQubit.stateVec.imag;
1922 
1923 # ifdef _OPENMP
1924 # pragma omp parallel \
1925         shared    (numTasks,stateVecReal,stateVecImag) \
1926         private   (thisTask)
1927 # endif
1928         {
1929 # ifdef _OPENMP
1930                 # pragma omp for schedule  (static)
1931 # endif
1932                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1933                         // summation -- simple implementation
1934                         stateVecReal[thisTask] = 0;
1935                         stateVecImag[thisTask] = 0;
1936                 }
1937         }
1938 }
\end{DoxyCode}
\hypertarget{qubits_8c_a01d9a8b7ff0e09ec399e158389783aa9}{
\index{qubits.c@{qubits.c}!collapseToOutcomeLocal@{collapseToOutcomeLocal}}
\index{collapseToOutcomeLocal@{collapseToOutcomeLocal}!qubits.c@{qubits.c}}
\paragraph[{collapseToOutcomeLocal}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeLocal ({\bf MultiQubit} {\em multiQubit}, \/  int {\em measureQubit}, \/  REAL {\em totalProbability}, \/  int {\em outcome})}\hfill}
\label{qubits_8c_a01d9a8b7ff0e09ec399e158389783aa9}


Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. Performs an irreversible change to the state vector: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being either zero or one \item[\mbox{$\leftarrow$} {\em outcome}]to measure the probability of and set the state to -\/-\/ either zero or one \end{DoxyParams}


Definition at line 1785 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1786 {
1787         // ----- sizes
1788         long long int sizeBlock,                                           // siz
      e of blocks
1789         sizeHalfBlock;                                       // size of blocks ha
      lved
1790         // ----- indices
1791         long long int thisBlock,                                           // cur
      rent block
1792              index;                                               // current inde
      x for first half block
1793         // ----- measured probability
1794         REAL   renorm;                                    // probability (returne
      d) value
1795         // ----- temp variables
1796         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1797         // (good for shared memory parallelism)
1798         long long int numTasks=multiQubit.numAmps>>1;
1799 
1800         // ---------------------------------------------------------------- //
1801         //            dimensions                                            //
1802         // ---------------------------------------------------------------- //
1803         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1804         // and then the number to skip
1805         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1806         
1807         renorm=1/sqrt(totalProbability);
1808         REAL *stateVecReal = multiQubit.stateVec.real;
1809         REAL *stateVecImag = multiQubit.stateVec.imag;
1810 
1811 
1812 # ifdef _OPENMP
1813 # pragma omp parallel \
1814         default (none) \
1815         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,re
      norm,outcome) \
1816         private   (thisTask,thisBlock,index)
1817 # endif
1818         {
1819                 if (outcome==0){
1820                         // measure qubit is 0
1821 # ifdef _OPENMP
1822                         # pragma omp for schedule  (static)
1823 # endif
1824                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1825                                 thisBlock = thisTask / sizeHalfBlock;
1826                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
1827                                 stateVecReal[index]=stateVecReal[index]*renorm;
1828                                 stateVecImag[index]=stateVecImag[index]*renorm;
1829 
1830                                 stateVecReal[index+sizeHalfBlock]=0;
1831                                 stateVecImag[index+sizeHalfBlock]=0;
1832                         }
1833                 } else {
1834                         // measure qubit is 1
1835 # ifdef _OPENMP
1836                         # pragma omp for schedule  (static)
1837 # endif
1838                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1839                                 thisBlock = thisTask / sizeHalfBlock;
1840                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
1841                                 stateVecReal[index]=0;
1842                                 stateVecImag[index]=0;
1843 
1844                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[in
      dex+sizeHalfBlock]*renorm;
1845                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[in
      dex+sizeHalfBlock]*renorm;
1846                         }
1847                 }
1848         }
1849 
1850 }
\end{DoxyCode}
\hypertarget{qubits_8c_a20ee1878a63ae6112e8845f4a8787592}{
\index{qubits.c@{qubits.c}!compactUnitaryDistributed@{compactUnitaryDistributed}}
\index{compactUnitaryDistributed@{compactUnitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{compactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a20ee1878a63ae6112e8845f4a8787592}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 542 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by compactUnitary().


\begin{DoxyCode}
547 {
548 
549         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
550         long long int thisTask;  
551         const long long int numTasks=multiQubit.numAmps;
552 
553         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
554         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
555         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
556         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
557         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
558 
559 # ifdef _OPENMP
560 # pragma omp parallel \
561         default  (none) \
562         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
563                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
564         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
565 # endif
566         {
567 # ifdef _OPENMP
568                 # pragma omp for schedule (static)
569 # endif
570                 for (thisTask=0; thisTask<numTasks; thisTask++) {
571                         // store current state vector values in temp variables
572                         stateRealUp = stateVecRealUp[thisTask];
573                         stateImagUp = stateVecImagUp[thisTask];
574 
575                         stateRealLo = stateVecRealLo[thisTask];
576                         stateImagLo = stateVecImagLo[thisTask];
577 
578                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
579                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
580                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
581                 }
582         }
583 }
\end{DoxyCode}
\hypertarget{qubits_8c_a9cee2d8716667a3318420a3b672f5b92}{
\index{qubits.c@{qubits.c}!compactUnitaryLocal@{compactUnitaryLocal}}
\index{compactUnitaryLocal@{compactUnitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{compactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits_8c_a9cee2d8716667a3318420a3b672f5b92}


Definition at line 413 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by compactUnitary().


\begin{DoxyCode}
414 {
415         long long int sizeBlock, sizeHalfBlock;
416         long long int thisBlock, // current block
417              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
418 
419         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
420         long long int thisTask;         
421         const long long int numTasks=multiQubit.numAmps>>1;
422 
423         // set dimensions
424         sizeHalfBlock = 1LL << targetQubit;  
425         sizeBlock     = 2LL * sizeHalfBlock; 
426 
427         // Can't use multiQubit.stateVec as a private OMP var
428         REAL *stateVecReal = multiQubit.stateVec.real;
429         REAL *stateVecImag = multiQubit.stateVec.imag;
430         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
431         REAL betaImag=beta.imag, betaReal=beta.real;
432 
433 # ifdef _OPENMP
434 # pragma omp parallel \
435         default  (none) \
436         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
437         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
438 # endif
439         {
440 # ifdef _OPENMP
441                 # pragma omp for schedule (static)
442 # endif
443                 for (thisTask=0; thisTask<numTasks; thisTask++) {
444 
445                         thisBlock   = thisTask / sizeHalfBlock;
446                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
447                         indexLo     = indexUp + sizeHalfBlock;
448 
449                         // store current state vector values in temp variables
450                         stateRealUp = stateVecReal[indexUp];
451                         stateImagUp = stateVecImag[indexUp];
452 
453                         stateRealLo = stateVecReal[indexLo];
454                         stateImagLo = stateVecImag[indexLo];
455 
456                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
457                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag
      *stateImagUp 
458                                 - betaReal*stateRealLo - betaImag*stateImagLo;
459                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag
      *stateRealUp 
460                                 - betaReal*stateImagLo + betaImag*stateRealLo;
461 
462                         // state[indexLo] = beta  * state[indexUp] + conj(alpha) 
      * state[indexLo]
463                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*s
      tateImagUp 
464                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
465                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*s
      tateRealUp 
466                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
467                 } 
468         }
469 
470 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a793584932ae384c82e7e42db7d35d18d}{
\index{qubits.c@{qubits.c}!compareStates@{compareStates}}
\index{compareStates@{compareStates}!qubits.c@{qubits.c}}
\paragraph[{compareStates}]{\setlength{\rightskip}{0pt plus 5cm}int compareStates ({\bf MultiQubit} {\em mq1}, \/  {\bf MultiQubit} {\em mq2}, \/  REAL {\em precision})}\hfill}
\label{qubits_8c_a793584932ae384c82e7e42db7d35d18d}


Definition at line 330 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
330                                                                  {
331         REAL diff;
332         int chunkSize = mq1.numAmps;
333         for (int i=0; i<chunkSize; i++){
334                 diff = mq1.stateVec.real[i] - mq2.stateVec.real[i];
335                 if (diff<0) diff *= -1;
336                 if (diff>precision) return 0;
337                 diff = mq1.stateVec.imag[i] - mq2.stateVec.imag[i];
338                 if (diff<0) diff *= -1;
339                 if (diff>precision) return 0;
340         }
341         return 1;
342 }
\end{DoxyCode}
\hypertarget{qubits_8c_a717855e835e3161e08c18cdc15325d27}{
\index{qubits.c@{qubits.c}!controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}}
\index{controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{controlledCompactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a717855e835e3161e08c18cdc15325d27}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 852 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
857 {
858 
859         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
860         long long int thisTask;  
861         const long long int numTasks=multiQubit.numAmps;
862         const long long int chunkSize=multiQubit.numAmps;
863         const long long int chunkId=multiQubit.chunkId;
864 
865         int controlBit;
866 
867     REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
868         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
869         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
870         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
871         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
872 
873 # ifdef _OPENMP
874 # pragma omp parallel \
875         default  (none) \
876         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
877                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
878         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
879 # endif
880         {
881 # ifdef _OPENMP
882                 # pragma omp for schedule (static)
883 # endif
884                 for (thisTask=0; thisTask<numTasks; thisTask++) {
885                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
886                         if (controlBit){
887                                 // store current state vector values in temp vari
      ables
888                                 stateRealUp = stateVecRealUp[thisTask];
889                                 stateImagUp = stateVecImagUp[thisTask];
890 
891                                 stateRealLo = stateVecRealLo[thisTask];
892                                 stateImagLo = stateVecImagLo[thisTask];
893 
894                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
895                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp 
      - rot1Imag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
896                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp 
      + rot1Imag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
897                         }
898                 }
899         }
900 }
\end{DoxyCode}
\hypertarget{qubits_8c_afc77657651d52c47403b44b923a098a8}{
\index{qubits.c@{qubits.c}!controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}}
\index{controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{controlledCompactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits_8c_afc77657651d52c47403b44b923a098a8}


Definition at line 643 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
645 {
646         long long int sizeBlock, sizeHalfBlock;
647         long long int thisBlock, // current block
648              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
649 
650         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
651         long long int thisTask;         
652         const long long int numTasks=multiQubit.numAmps>>1;
653         const long long int chunkSize=multiQubit.numAmps;
654         const long long int chunkId=multiQubit.chunkId;
655 
656         int controlBit;
657 
658     // set dimensions
659         sizeHalfBlock = 1LL << targetQubit;  
660         sizeBlock     = 2LL * sizeHalfBlock; 
661 
662         // Can't use multiQubit.stateVec as a private OMP var
663         REAL *stateVecReal = multiQubit.stateVec.real;
664         REAL *stateVecImag = multiQubit.stateVec.imag;
665         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
666         REAL betaImag=beta.imag, betaReal=beta.real;
667 
668 # ifdef _OPENMP
669 # pragma omp parallel \
670         default  (none) \
671         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
672         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
673 # endif
674         {
675 # ifdef _OPENMP
676                 # pragma omp for schedule (static)
677 # endif
678                 for (thisTask=0; thisTask<numTasks; thisTask++) {
679 
680                         thisBlock   = thisTask / sizeHalfBlock;
681                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
682                         indexLo     = indexUp + sizeHalfBlock;
683 
684                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
685                         if (controlBit){
686                                 // store current state vector values in temp vari
      ables
687                                 stateRealUp = stateVecReal[indexUp];
688                                 stateImagUp = stateVecImag[indexUp];
689 
690                                 stateRealLo = stateVecReal[indexLo];
691                                 stateImagLo = stateVecImag[indexLo];
692 
693                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
694                                 stateVecReal[indexUp] = alphaReal*stateRealUp - a
      lphaImag*stateImagUp 
695                                         - betaReal*stateRealLo - betaImag*stateIm
      agLo;
696                                 stateVecImag[indexUp] = alphaReal*stateImagUp + a
      lphaImag*stateRealUp 
697                                         - betaReal*stateImagLo + betaImag*stateRe
      alLo;
698 
699                                 // state[indexLo] = beta  * state[indexUp] + conj
      (alpha) * state[indexLo]
700                                 stateVecReal[indexLo] = betaReal*stateRealUp - be
      taImag*stateImagUp 
701                                         + alphaReal*stateRealLo + alphaImag*state
      ImagLo;
702                                 stateVecImag[indexLo] = betaReal*stateImagUp + be
      taImag*stateRealUp 
703                                         + alphaReal*stateImagLo - alphaImag*state
      RealLo;
704                         }
705                 } 
706         }
707 
708 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a05875a70b539a3efb28d027823403f34}{
\index{qubits.c@{qubits.c}!controlledNotDistributed@{controlledNotDistributed}}
\index{controlledNotDistributed@{controlledNotDistributed}!qubits.c@{qubits.c}}
\paragraph[{controlledNotDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a05875a70b539a3efb28d027823403f34}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk. Only perform the rotation for elements where controlQubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1181 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by controlledNot().


\begin{DoxyCode}
1184 {
1185 
1186         long long int thisTask;  
1187         const long long int numTasks=multiQubit.numAmps;
1188         const long long int chunkSize=multiQubit.numAmps;
1189         const long long int chunkId=multiQubit.chunkId;
1190 
1191         int controlBit;
1192 
1193         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1194         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1195 
1196 # ifdef _OPENMP
1197 # pragma omp parallel \
1198         default  (none) \
1199         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1200         private  (thisTask,controlBit)
1201 # endif
1202         {
1203 # ifdef _OPENMP
1204                 # pragma omp for schedule (static)
1205 # endif
1206                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1207                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
1208                         if (controlBit){
1209                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTa
      sk];
1210                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTa
      sk];
1211                         }
1212                 }
1213         }
1214 } 
\end{DoxyCode}
\hypertarget{qubits_8c_ad357a43e80e3baf013975b1b70942f4c}{
\index{qubits.c@{qubits.c}!controlledNotLocal@{controlledNotLocal}}
\index{controlledNotLocal@{controlledNotLocal}!qubits.c@{qubits.c}}
\paragraph[{controlledNotLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_ad357a43e80e3baf013975b1b70942f4c}


Definition at line 1116 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledNot().


\begin{DoxyCode}
1117 {
1118         long long int sizeBlock, sizeHalfBlock;
1119         long long int thisBlock, // current block
1120              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1121 
1122         REAL stateRealUp,stateImagUp;
1123         long long int thisTask;         
1124         const long long int numTasks=multiQubit.numAmps>>1;
1125         const long long int chunkSize=multiQubit.numAmps;
1126         const long long int chunkId=multiQubit.chunkId;
1127 
1128         int controlBit;
1129 
1130         // set dimensions
1131         sizeHalfBlock = 1LL << targetQubit;  
1132         sizeBlock     = 2LL * sizeHalfBlock; 
1133 
1134 
1135         // Can't use multiQubit.stateVec as a private OMP var
1136         REAL *stateVecReal = multiQubit.stateVec.real;
1137         REAL *stateVecImag = multiQubit.stateVec.imag;
1138 
1139 # ifdef _OPENMP
1140 # pragma omp parallel \
1141         default  (none) \
1142         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1143         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,co
      ntrolBit) 
1144 # endif
1145         {
1146 # ifdef _OPENMP
1147                 # pragma omp for schedule (static)
1148 # endif
1149                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1150                         thisBlock   = thisTask / sizeHalfBlock;
1151                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1152                         indexLo     = indexUp + sizeHalfBlock;
1153 
1154                         controlBit = extractBit(controlQubit, indexUp+chunkId*chu
      nkSize);
1155                         if (controlBit){
1156                                 stateRealUp = stateVecReal[indexUp];
1157                                 stateImagUp = stateVecImag[indexUp];
1158 
1159                                 stateVecReal[indexUp] = stateVecReal[indexLo];
1160                                 stateVecImag[indexUp] = stateVecImag[indexLo];
1161 
1162                                 stateVecReal[indexLo] = stateRealUp;
1163                                 stateVecImag[indexLo] = stateImagUp;
1164                         }
1165                 } 
1166         }
1167 
1168 }
\end{DoxyCode}
\hypertarget{qubits_8c_a11a96159191cbf1b01a1080e7f045aac}{
\index{qubits.c@{qubits.c}!controlledPhaseGate@{controlledPhaseGate}}
\index{controlledPhaseGate@{controlledPhaseGate}!qubits.c@{qubits.c}}
\paragraph[{controlledPhaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void controlledPhaseGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em idQubit1}, \/  const int {\em idQubit2})}\hfill}
\label{qubits_8c_a11a96159191cbf1b01a1080e7f045aac}


Apply the (two-\/qubit) controlled phase gate, also known as the controlled sigmaZ gate. For each state, if both input qubits have value one, multiply the amplitude of that state by -\/1. This applies the two-\/qubit unitary: \[ \begin{pmatrix} 1 \\ & 1 \\\ & & 1 \\ & & & -1 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {idQubit1}; \node[draw=none] at (-3.5, 0) {idQubit2}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 0); \draw (-2,0) -- (2, 0); \draw[fill=black] (0, 0) circle (.2); \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em idQubit1,idQubit2}]qubits to operate upon \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily idQubit1} or {\ttfamily idQubit2} are outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or are equal \end{DoxyExceptions}


Definition at line 1698 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
1699 {
1700         long long int index;
1701         long long int stateVecSize;
1702         int bit1, bit2;
1703 
1704         const long long int chunkSize=multiQubit.numAmps;
1705         const long long int chunkId=multiQubit.chunkId;
1706 
1707     QuESTAssert(idQubit1 >= 0 && idQubit1 < multiQubit.numQubits, 2, __func__);
1708     QuESTAssert(idQubit2 >= 0 && idQubit2 < multiQubit.numQubits, 1, __func__);
1709     QuESTAssert(idQubit1 != idQubit2, 3, __func__);
1710 
1711         // dimension of the state vector
1712         stateVecSize = multiQubit.numAmps;
1713         REAL *stateVecReal = multiQubit.stateVec.real;
1714         REAL *stateVecImag = multiQubit.stateVec.imag;
1715 
1716 # ifdef _OPENMP
1717 # pragma omp parallel for \
1718         default  (none)                      \
1719         shared   (stateVecSize, stateVecReal,stateVecImag ) \
1720         private  (index,bit1,bit2)                     \
1721         schedule (static)
1722 # endif
1723         for (index=0; index<stateVecSize; index++) {
1724                 bit1 = extractBit (idQubit1, index+chunkId*chunkSize);
1725                 bit2 = extractBit (idQubit2, index+chunkId*chunkSize);
1726                 if (bit1 && bit2) {
1727                         stateVecReal [index] = - stateVecReal [index];
1728                         stateVecImag [index] = - stateVecImag [index];
1729                 }
1730         }
1731 }
\end{DoxyCode}
\hypertarget{qubits_8c_a642093063a1f889f61a1311f6d6f2d3f}{
\index{qubits.c@{qubits.c}!controlledUnitaryDistributed@{controlledUnitaryDistributed}}
\index{controlledUnitaryDistributed@{controlledUnitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{controlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a642093063a1f889f61a1311f6d6f2d3f}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 915 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledUnitary().


\begin{DoxyCode}
920 {
921 
922         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
923         long long int thisTask;  
924         const long long int numTasks=multiQubit.numAmps;
925         const long long int chunkSize=multiQubit.numAmps;
926         const long long int chunkId=multiQubit.chunkId;
927 
928         int controlBit;
929 
930         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
931         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
932         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
933         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
934         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
935 
936 # ifdef _OPENMP
937 # pragma omp parallel \
938         default  (none) \
939         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
940                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
941         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
942 # endif
943         {
944 # ifdef _OPENMP
945                 # pragma omp for schedule (static)
946 # endif
947                 for (thisTask=0; thisTask<numTasks; thisTask++) {
948                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
949                         if (controlBit){
950                                 // store current state vector values in temp vari
      ables
951                                 stateRealUp = stateVecRealUp[thisTask];
952                                 stateImagUp = stateVecImagUp[thisTask];
953 
954                                 stateRealLo = stateVecRealLo[thisTask];
955                                 stateImagLo = stateVecImagLo[thisTask];
956 
957                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
958                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
959                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
960                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
961                         }
962                 }
963         }
964 }
\end{DoxyCode}
\hypertarget{qubits_8c_a8a4afcff70195a306c082b8ed8d4e09a}{
\index{qubits.c@{qubits.c}!controlledUnitaryLocal@{controlledUnitaryLocal}}
\index{controlledUnitaryLocal@{controlledUnitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{controlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8c_a8a4afcff70195a306c082b8ed8d4e09a}


Definition at line 773 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledUnitary().


\begin{DoxyCode}
775 {
776         long long int sizeBlock, sizeHalfBlock;
777         long long int thisBlock, // current block
778              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
779 
780         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
781         long long int thisTask;         
782         const long long int numTasks=multiQubit.numAmps>>1;
783         const long long int chunkSize=multiQubit.numAmps;
784         const long long int chunkId=multiQubit.chunkId;
785 
786         int controlBit;
787 
788     // set dimensions
789         sizeHalfBlock = 1LL << targetQubit;  
790         sizeBlock     = 2LL * sizeHalfBlock; 
791 
792         // Can't use multiQubit.stateVec as a private OMP var
793         REAL *stateVecReal = multiQubit.stateVec.real;
794         REAL *stateVecImag = multiQubit.stateVec.imag;
795 
796 # ifdef _OPENMP
797 # pragma omp parallel \
798         default  (none) \
799         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
800         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
801 # endif
802         {
803 # ifdef _OPENMP
804                 # pragma omp for schedule (static)
805 # endif
806                 for (thisTask=0; thisTask<numTasks; thisTask++) {
807 
808                         thisBlock   = thisTask / sizeHalfBlock;
809                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
810                         indexLo     = indexUp + sizeHalfBlock;
811 
812                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
813                         if (controlBit){
814                                 // store current state vector values in temp vari
      ables
815                                 stateRealUp = stateVecReal[indexUp];
816                                 stateImagUp = stateVecImag[indexUp];
817 
818                                 stateRealLo = stateVecReal[indexLo];
819                                 stateImagLo = stateVecImag[indexLo];
820 
821 
822                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
823                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
824                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
825                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
826                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
827 
828                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
829                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
830                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
831                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
832                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
833                         }
834                 } 
835         }
836 
837 }
\end{DoxyCode}
\hypertarget{qubits_8c_a9c02591bc64c2918503afa231d90d83f}{
\index{qubits.c@{qubits.c}!createMultiQubit@{createMultiQubit}}
\index{createMultiQubit@{createMultiQubit}!qubits.c@{qubits.c}}
\paragraph[{createMultiQubit}]{\setlength{\rightskip}{0pt plus 5cm}void createMultiQubit ({\bf MultiQubit} $\ast$ {\em multiQubit}, \/  int {\em numQubits}, \/  {\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8c_a9c02591bc64c2918503afa231d90d83f}


Create a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. Allocate space for state vector of probability amplitudes, including space for temporary values to be copied from one other chunk if running the distributed version. Define properties related to the size of the set of qubits. initStateZero should be called after this to initialise the qubits to the zero state.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]a pointer to an object representing the set of qubits \item[\mbox{$\leftarrow$} {\em numQubits}]number of qubits in the system \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily numQubits} $<$= 0 \end{DoxyExceptions}


Definition at line 39 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, MultiQubit::numQubits, QuESTEnv::numRanks, MultiQubit::pairStateVec, QuESTAssert(), QuESTEnv::rank, ComplexArray::real, and MultiQubit::stateVec.


\begin{DoxyCode}
40 {
41     QuESTAssert(numQubits>0, 9, __func__);
42         long long int numAmps = 1L << numQubits;
43         long long int numAmpsPerRank = numAmps/env.numRanks;
44 
45         multiQubit->stateVec.real = malloc(numAmpsPerRank * sizeof(*(multiQubit->
      stateVec.real)));
46         multiQubit->stateVec.imag = malloc(numAmpsPerRank * sizeof(*(multiQubit->
      stateVec.imag)));
47         if (env.numRanks>1){
48                 multiQubit->pairStateVec.real = malloc(numAmpsPerRank * sizeof(*(
      multiQubit->pairStateVec.real)));
49                 multiQubit->pairStateVec.imag = malloc(numAmpsPerRank * sizeof(*(
      multiQubit->pairStateVec.imag)));
50         }
51 
52         if ( (!(multiQubit->stateVec.real) || !(multiQubit->stateVec.imag))
53                  && numAmpsPerRank ) {
54                 printf("Could not allocate memory!");
55                 exit (EXIT_FAILURE);
56         }
57 
58         if ( env.numRanks>1 && (!(multiQubit->pairStateVec.real) || !(multiQubit-
      >pairStateVec.imag))
59                  && numAmpsPerRank ) {
60                 printf("Could not allocate memory!");
61                 exit (EXIT_FAILURE);
62         }
63 
64         multiQubit->numQubits = numQubits;
65         multiQubit->numAmps = numAmpsPerRank;
66         multiQubit->chunkId = env.rank;
67         multiQubit->numChunks = env.numRanks;
68 
69 }
\end{DoxyCode}
\hypertarget{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}{
\index{qubits.c@{qubits.c}!destroyMultiQubit@{destroyMultiQubit}}
\index{destroyMultiQubit@{destroyMultiQubit}!qubits.c@{qubits.c}}
\paragraph[{destroyMultiQubit}]{\setlength{\rightskip}{0pt plus 5cm}void destroyMultiQubit ({\bf MultiQubit} {\em multiQubit}, \/  {\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}


Deallocate a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. Free memory allocated to state vector of probability amplitudes, including temporary vector for values copied from another chunk if running the distributed version.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object to be deallocated \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}


Definition at line 71 of file qubits.c.

References ComplexArray::imag, QuESTEnv::numRanks, MultiQubit::pairStateVec, ComplexArray::real, and MultiQubit::stateVec.


\begin{DoxyCode}
71                                                            {
72         free(multiQubit.stateVec.real);
73         free(multiQubit.stateVec.imag);
74         if (env.numRanks>1){
75                 free(multiQubit.pairStateVec.real);
76                 free(multiQubit.pairStateVec.imag);
77         }
78 }
\end{DoxyCode}
\hypertarget{qubits_8c_a100463f6ec212c76a5fad99579000505}{
\index{qubits.c@{qubits.c}!extractBit@{extractBit}}
\index{extractBit@{extractBit}!qubits.c@{qubits.c}}
\paragraph[{extractBit}]{\setlength{\rightskip}{0pt plus 5cm}static int extractBit (const int {\em locationOfBitFromRight}, \/  const long long int {\em theEncodedNumber})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits_8c_a100463f6ec212c76a5fad99579000505}


Get the value of the bit at a particular index in a number. SCB edit: new definition of extractBit is much faster $\ast$$\ast$$\ast$ 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em locationOfBitFromRight}]location of bit in theEncodedNumber \item[\mbox{$\leftarrow$} {\em theEncodedNumber}]number to search \end{DoxyParams}
\begin{DoxyReturn}{Returns}
the value of the bit in theEncodedNumber 
\end{DoxyReturn}


Definition at line 1693 of file qubits.c.

Referenced by controlledCompactUnitaryDistributed(), controlledCompactUnitaryLocal(), controlledNotDistributed(), controlledNotLocal(), controlledPhaseGate(), controlledUnitaryDistributed(), controlledUnitaryLocal(), and initStateOfSingleQubit().


\begin{DoxyCode}
1694 {
1695         return (theEncodedNumber & ( 1LL << locationOfBitFromRight )) >> location
      OfBitFromRight;
1696 }
\end{DoxyCode}
\hypertarget{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}{
\index{qubits.c@{qubits.c}!findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}}
\index{findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}!qubits.c@{qubits.c}}
\paragraph[{findProbabilityOfZeroDistributed}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}


Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. Size of regions to skip is a multiple of chunkSize.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1638 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1640 {
1641         // ----- measured probability
1642         REAL   totalProbability;                                    // probabilit
      y (returned) value
1643         // ----- temp variables
1644         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1645         long long int numTasks=multiQubit.numAmps;
1646 
1647         // ---------------------------------------------------------------- //
1648         //            find probability                                      //
1649         // ---------------------------------------------------------------- //
1650 
1651         // initialise returned value
1652         totalProbability = 0.0;
1653 
1654         REAL *stateVecReal = multiQubit.stateVec.real;
1655         REAL *stateVecImag = multiQubit.stateVec.imag;
1656 
1657 # ifdef _OPENMP
1658 # pragma omp parallel \
1659         shared    (numTasks,stateVecReal,stateVecImag) \
1660         private   (thisTask) \
1661         reduction ( +:totalProbability )
1662 # endif
1663         {
1664 # ifdef _OPENMP
1665                 # pragma omp for schedule  (static)
1666 # endif
1667                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1668                         // summation -- simple implementation
1669                         totalProbability += stateVecReal[thisTask]*stateVecReal[t
      hisTask]
1670                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
1671 
1672                         /*
1673                         // summation -- kahan correction
1674                         y = stateVecReal[thisTask]*stateVecReal[thisTask]
1675                         + stateVecImag[thisTask]*stateVecImag[thisTask] - c;
1676                         t = totalProbability + y;
1677                         c = (t - totalProbability) - y;
1678                         totalProbability = t;
1679                         */
1680 
1681                 }
1682         }
1683 
1684         return totalProbability;
1685 }
\end{DoxyCode}
\hypertarget{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}{
\index{qubits.c@{qubits.c}!findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}}
\index{findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}!qubits.c@{qubits.c}}
\paragraph[{findProbabilityOfZeroLocal}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}


Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1566 of file qubits.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1568 {
1569         // ----- sizes
1570         long long int sizeBlock,                                           // siz
      e of blocks
1571         sizeHalfBlock;                                       // size of blocks ha
      lved
1572         // ----- indices
1573         long long int thisBlock,                                           // cur
      rent block
1574              index;                                               // current inde
      x for first half block
1575         // ----- measured probability
1576         REAL   totalProbability;                                    // probabilit
      y (returned) value
1577         // ----- temp variables
1578         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1579         long long int numTasks=multiQubit.numAmps>>1;
1580 
1581         // ---------------------------------------------------------------- //
1582         //            dimensions                                            //
1583         // ---------------------------------------------------------------- //
1584         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1585         // and then the number to skip
1586         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1587 
1588         // initialise returned value
1589         totalProbability = 0.0;
1590 
1591         // initialise correction for kahan summation
1592         if (DEBUG) printf("sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\n",sizeHa
      lfBlock,sizeBlock,numTasks);
1593 
1594         REAL *stateVecReal = multiQubit.stateVec.real;
1595         REAL *stateVecImag = multiQubit.stateVec.imag;
1596 
1597 # ifdef _OPENMP
1598 # pragma omp parallel \
1599         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
      
1600         private   (thisTask,thisBlock,index) \
1601         reduction ( +:totalProbability )
1602 # endif 
1603         {
1604 # ifdef _OPENMP
1605                 # pragma omp for schedule  (static)
1606 # endif
1607                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1608                         thisBlock = thisTask / sizeHalfBlock;
1609                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
      
1610 
1611                         if (index<0){ printf("ABORTING as index=%Ld with thisBloc
      k = %Ld  thisTask=%Ld \n", index,thisBlock,thisTask); exit(1);}
1612 
1613                         // summation -- simple implementation
1614                         totalProbability += stateVecReal[index]*stateVecReal[inde
      x]
1615                                 + stateVecImag[index]*stateVecImag[index];
1616 
1617                         /*
1618                         // summation -- kahan correction
1619                         y = stateVecReal[index]*stateVecReal[index]
1620                         + stateVecImag[index]*stateVecImag[index] - c;
1621                         t = totalProbability + y;
1622                         c = (t - totalProbability) - y;
1623                         totalProbability = t;
1624                         */
1625 
1626                 }
1627         }
1628         return totalProbability;
1629 }
\end{DoxyCode}
\hypertarget{qubits_8c_a8f10aabf9f607f19093aee54630caa21}{
\index{qubits.c@{qubits.c}!getEnvironmentString@{getEnvironmentString}}
\index{getEnvironmentString@{getEnvironmentString}!qubits.c@{qubits.c}}
\paragraph[{getEnvironmentString}]{\setlength{\rightskip}{0pt plus 5cm}void getEnvironmentString ({\bf QuESTEnv} {\em env}, \/  {\bf MultiQubit} {\em multiQubit}, \/  char {\em str}\mbox{[}200\mbox{]})}\hfill}
\label{qubits_8c_a8f10aabf9f607f19093aee54630caa21}


Definition at line 131 of file qubits.c.

References MultiQubit::numQubits, and QuESTEnv::numRanks.


\begin{DoxyCode}
131                                                                              {
132         int numThreads=1;
133 # ifdef _OPENMP
134         numThreads=omp_get_max_threads(); 
135 # endif
136         sprintf(str, "%dqubits_CPU_%dranksx%dthreads", multiQubit.numQubits, env.
      numRanks, numThreads);
137 }
\end{DoxyCode}
\hypertarget{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}{
\index{qubits.c@{qubits.c}!getProbEl@{getProbEl}}
\index{getProbEl@{getProbEl}!qubits.c@{qubits.c}}
\paragraph[{getProbEl}]{\setlength{\rightskip}{0pt plus 5cm}REAL getProbEl ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})}\hfill}
\label{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}


Get the probability of the state at an index in the full state vector. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \item[\mbox{$\leftarrow$} {\em index}]index in state vector of probability amplitudes \end{DoxyParams}
\begin{DoxyReturn}{Returns}
realEl$\ast$realEl + imagEl$\ast$imagEl 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily index} is outside \mbox{[}0, $2^{N}$) where $N = $ {\ttfamily multiQubit.numQubits} \end{DoxyExceptions}


Definition at line 1940 of file qubits.c.

References getImagAmpEl(), getRealAmpEl(), and REAL.


\begin{DoxyCode}
1940                                                           {
1941         REAL real;
1942         REAL imag;
1943         real = getRealAmpEl(multiQubit, index);
1944         imag = getImagAmpEl(multiQubit, index);
1945         return real*real + imag*imag;
1946 }
\end{DoxyCode}
\hypertarget{qubits_8c_ae6a897066979fc52d977007d959ca09d}{
\index{qubits.c@{qubits.c}!hadamardDistributed@{hadamardDistributed}}
\index{hadamardDistributed@{hadamardDistributed}!qubits.c@{qubits.c}}
\paragraph[{hadamardDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits_8c_ae6a897066979fc52d977007d959ca09d}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1369 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by hadamard().


\begin{DoxyCode}
1374 {
1375 
1376         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1377         long long int thisTask;  
1378         const long long int numTasks=multiQubit.numAmps;
1379 
1380         int sign;
1381         if (updateUpper) sign=1;
1382         else sign=-1;
1383 
1384         REAL recRoot2 = 1.0/sqrt(2);
1385 
1386         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1387         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1388         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1389 
1390 # ifdef _OPENMP
1391 # pragma omp parallel \
1392         default  (none) \
1393         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1394                         recRoot2, sign) \
1395         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1396 # endif
1397         {
1398 # ifdef _OPENMP
1399                 # pragma omp for schedule (static)
1400 # endif
1401                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1402                         // store current state vector values in temp variables
1403                         stateRealUp = stateVecRealUp[thisTask];
1404                         stateImagUp = stateVecImagUp[thisTask];
1405 
1406                         stateRealLo = stateVecRealLo[thisTask];
1407                         stateImagLo = stateVecImagLo[thisTask];
1408 
1409                         stateVecRealOut[thisTask] = recRoot2*(stateRealUp + sign*
      stateRealLo);
1410                         stateVecImagOut[thisTask] = recRoot2*(stateImagUp + sign*
      stateImagLo);
1411                 }
1412         }
1413 }
\end{DoxyCode}
\hypertarget{qubits_8c_aa9f0718b4dd794a3e1b143e3b153bfc5}{
\index{qubits.c@{qubits.c}!hadamardLocal@{hadamardLocal}}
\index{hadamardLocal@{hadamardLocal}!qubits.c@{qubits.c}}
\paragraph[{hadamardLocal}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_aa9f0718b4dd794a3e1b143e3b153bfc5}


Definition at line 1308 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by hadamard().


\begin{DoxyCode}
1309 {
1310         long long int sizeBlock, sizeHalfBlock;
1311         long long int thisBlock, // current block
1312              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1313 
1314         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1315         long long int thisTask;         
1316         const long long int numTasks=multiQubit.numAmps>>1;
1317 
1318         // set dimensions
1319         sizeHalfBlock = 1LL << targetQubit;  
1320         sizeBlock     = 2LL * sizeHalfBlock; 
1321 
1322         // Can't use multiQubit.stateVec as a private OMP var
1323         REAL *stateVecReal = multiQubit.stateVec.real;
1324         REAL *stateVecImag = multiQubit.stateVec.imag;
1325 
1326         REAL recRoot2 = 1.0/sqrt(2);
1327 
1328 # ifdef _OPENMP
1329 # pragma omp parallel \
1330         default  (none) \
1331         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \
      
1332         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
1333 # endif
1334         {
1335 # ifdef _OPENMP
1336                 # pragma omp for schedule (static)
1337 # endif
1338                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1339                         thisBlock   = thisTask / sizeHalfBlock;
1340                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1341                         indexLo     = indexUp + sizeHalfBlock;
1342 
1343                         stateRealUp = stateVecReal[indexUp];
1344                         stateImagUp = stateVecImag[indexUp];
1345 
1346                         stateRealLo = stateVecReal[indexLo];
1347                         stateImagLo = stateVecImag[indexLo];
1348 
1349                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateReal
      Lo);
1350                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImag
      Lo);
1351 
1352                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateReal
      Lo);
1353                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImag
      Lo);
1354                 } 
1355         }
1356 }
\end{DoxyCode}
\hypertarget{qubits_8c_a433876ee9f3bcc54af346300f571fc3c}{
\index{qubits.c@{qubits.c}!initializeStateFromSingleFile@{initializeStateFromSingleFile}}
\index{initializeStateFromSingleFile@{initializeStateFromSingleFile}!qubits.c@{qubits.c}}
\paragraph[{initializeStateFromSingleFile}]{\setlength{\rightskip}{0pt plus 5cm}void initializeStateFromSingleFile ({\bf MultiQubit} $\ast$ {\em multiQubit}, \/  char {\em filename}\mbox{[}200\mbox{]}, \/  {\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8c_a433876ee9f3bcc54af346300f571fc3c}


fix -\/-\/ format needs to work for single precision values 

Definition at line 295 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, MultiQubit::stateVec, and syncQuESTEnv().


\begin{DoxyCode}
295                                                                                  
                 {
296         long long int chunkSize, stateVecSize;
297         long long int indexInChunk, totalIndex;
298 
299         chunkSize = multiQubit->numAmps;
300         stateVecSize = chunkSize*multiQubit->numChunks;
301 
302         REAL *stateVecReal = multiQubit->stateVec.real;
303         REAL *stateVecImag = multiQubit->stateVec.imag;
304         
305         FILE *fp;
306         char line[200];
307 
308         for (int rank=0; rank<(multiQubit->numChunks); rank++){
309                 if (rank==multiQubit->chunkId){
310                         fp = fopen(filename, "r");
311                         indexInChunk = 0; totalIndex = 0;
312                         while (fgets(line, sizeof(char)*200, fp) != NULL && total
      Index<stateVecSize){
313                                 if (line[0]!='#'){
314                                         int chunkId = totalIndex/chunkSize;
315                                         if (chunkId==multiQubit->chunkId){
317                                                 sscanf(line, "%lf, %lf", &(stateV
      ecReal[indexInChunk]), 
318                                                                 &(stateVecImag[in
      dexInChunk]));
319                                                 indexInChunk += 1;
320                                         }
321                                         totalIndex += 1;
322                                 }
323                         }       
324                         fclose(fp);
325                 }
326                 syncQuESTEnv(env);
327         }
328 }
\end{DoxyCode}
\hypertarget{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}{
\index{qubits.c@{qubits.c}!initStateDebug@{initStateDebug}}
\index{initStateDebug@{initStateDebug}!qubits.c@{qubits.c}}
\paragraph[{initStateDebug}]{\setlength{\rightskip}{0pt plus 5cm}void initStateDebug ({\bf MultiQubit} $\ast$ {\em multiQubit})}\hfill}
\label{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}


Initialise the state vector of probability amplitudes to an (unphysical) state with each component of each probability amplitude a unique floating point value. For debugging processes 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \end{DoxyParams}


Definition at line 263 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
264 {
265         long long int chunkSize;
266         long long int index;
267 
268         // dimension of the state vector
269         chunkSize = multiQubit->numAmps;
270 
271         // Can't use multiQubit->stateVec as a private OMP var
272         REAL *stateVecReal = multiQubit->stateVec.real;
273         REAL *stateVecImag = multiQubit->stateVec.imag;
274 
275         REAL chunkOffset = (2.0*chunkSize*multiQubit->chunkId)/10.0;
276 
277         // initialise the state to |0000..0000>
278 # ifdef _OPENMP
279 # pragma omp parallel \
280         default  (none) \
281         shared   (chunkSize, stateVecReal, stateVecImag, chunkOffset) \
282         private  (index) 
283 # endif
284         {
285 # ifdef _OPENMP
286                 # pragma omp for schedule (static)
287 # endif
288                 for (index=0; index<chunkSize; index++) {
289                         stateVecReal[index] = chunkOffset + (index*2.0)/10.0;
290                         stateVecImag[index] = chunkOffset + (index*2.0+1.0)/10.0;
      
291                 }
292         }
293 }
\end{DoxyCode}
\hypertarget{qubits_8c_a7169fd0442cbc3418f3fac4d13363ca2}{
\index{qubits.c@{qubits.c}!initStateOfSingleQubit@{initStateOfSingleQubit}}
\index{initStateOfSingleQubit@{initStateOfSingleQubit}!qubits.c@{qubits.c}}
\paragraph[{initStateOfSingleQubit}]{\setlength{\rightskip}{0pt plus 5cm}void initStateOfSingleQubit ({\bf MultiQubit} $\ast$ {\em multiQubit}, \/  int {\em qubitId}, \/  int {\em outcome})}\hfill}
\label{qubits_8c_a7169fd0442cbc3418f3fac4d13363ca2}


Initialise the state vector of probability amplitudes such that one qubit is set to 'outcome' and all other qubits are in an equal superposition of zero and one. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \item[\mbox{$\leftarrow$} {\em qubitId}]id of qubit to set to state 'outcome' \item[\mbox{$\leftarrow$} {\em value}]of qubit 'qubitId' \end{DoxyParams}


Definition at line 216 of file qubits.c.

References MultiQubit::chunkId, DEBUG, extractBit(), ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
217 {
218         long long int chunkSize, stateVecSize;
219         long long int index;
220         int bit;
221         const long long int chunkId=multiQubit->chunkId;
222 
223         // dimension of the state vector
224         chunkSize = multiQubit->numAmps;
225         stateVecSize = chunkSize*multiQubit->numChunks;
226         REAL normFactor = 1.0/sqrt((REAL)stateVecSize/2.0);
227 
228         // Can't use multiQubit->stateVec as a private OMP var
229         REAL *stateVecReal = multiQubit->stateVec.real;
230         REAL *stateVecImag = multiQubit->stateVec.imag;
231 
232         // initialise the state to |0000..0000>
233 # ifdef _OPENMP
234 # pragma omp parallel \
235         default  (none) \
236         shared   (chunkSize, stateVecReal, stateVecImag, normFactor, qubitId, out
      come) \
237         private  (index, bit) 
238 # endif
239         {
240 # ifdef _OPENMP
241                 # pragma omp for schedule (static)
242 # endif
243                 for (index=0; index<chunkSize; index++) {
244                         bit = extractBit(qubitId, index+chunkId*chunkSize);
245                         if (bit==outcome) {
246                                 stateVecReal[index] = normFactor;
247                                 stateVecImag[index] = 0.0;
248                         } else {
249                                 stateVecReal[index] = 0.0;
250                                 stateVecImag[index] = 0.0;
251                         }
252                 }
253         }
254         if (DEBUG) printf("COMPLETED INIT\n");
255 }
\end{DoxyCode}
\hypertarget{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}{
\index{qubits.c@{qubits.c}!initStatePlus@{initStatePlus}}
\index{initStatePlus@{initStatePlus}!qubits.c@{qubits.c}}
\paragraph[{initStatePlus}]{\setlength{\rightskip}{0pt plus 5cm}void initStatePlus ({\bf MultiQubit} $\ast$ {\em multiQubit})}\hfill}
\label{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}


Initialise a set of $ N $ qubits to the plus state $ {| + \rangle}^{\otimes N} = \frac{1}{\sqrt{2^N}} (| 0 \rangle + | 1 \rangle)^{\otimes N} $. This is the product state of $N$ qubits where every classical state is uniformly populated with real coefficient $\frac{1}{\sqrt{2^N}}$. This is equivalent to applying a Hadamard to every qubit in the zero state: $ \hat{H}^{\otimes N} {|0\rangle}^{\otimes N} $


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]a pointer to the object representing the set of qubits to be initialised \end{DoxyParams}


Definition at line 177 of file qubits.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
178 {
179         long long int chunkSize, stateVecSize;
180         long long int index;
181 
182         // dimension of the state vector
183         chunkSize = multiQubit->numAmps;
184         stateVecSize = chunkSize*multiQubit->numChunks;
185         REAL normFactor = 1.0/sqrt((REAL)stateVecSize);
186 
187         // Can't use multiQubit->stateVec as a private OMP var
188         REAL *stateVecReal = multiQubit->stateVec.real;
189         REAL *stateVecImag = multiQubit->stateVec.imag;
190 
191         // initialise the state to |0000..0000>
192 # ifdef _OPENMP
193 # pragma omp parallel \
194         default  (none) \
195         shared   (chunkSize, stateVecReal, stateVecImag, normFactor) \
196         private  (index) 
197 # endif
198         {
199 # ifdef _OPENMP
200                 # pragma omp for schedule (static)
201 # endif
202                 for (index=0; index<chunkSize; index++) {
203                         stateVecReal[index] = normFactor;
204                         stateVecImag[index] = 0.0;
205                 }
206         }
207         if (DEBUG) printf("COMPLETED INIT\n");
208 }
\end{DoxyCode}
\hypertarget{qubits_8c_acb5b2eff794339090004d29f02a70d9a}{
\index{qubits.c@{qubits.c}!initStateZero@{initStateZero}}
\index{initStateZero@{initStateZero}!qubits.c@{qubits.c}}
\paragraph[{initStateZero}]{\setlength{\rightskip}{0pt plus 5cm}void initStateZero ({\bf MultiQubit} $\ast$ {\em multiQubit})}\hfill}
\label{qubits_8c_acb5b2eff794339090004d29f02a70d9a}


Initialise a set of $ N $ qubits to the classical zero state $ {| 0 \rangle}^{\otimes N} $. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]a pointer to the object representing the set of all qubits to initialise \end{DoxyParams}


Definition at line 139 of file qubits.c.

References MultiQubit::chunkId, DEBUG, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
140 {
141         long long int stateVecSize;
142         long long int index;
143 
144         // dimension of the state vector
145         stateVecSize = multiQubit->numAmps;
146 
147         // Can't use multiQubit->stateVec as a private OMP var
148         REAL *stateVecReal = multiQubit->stateVec.real;
149         REAL *stateVecImag = multiQubit->stateVec.imag;
150 
151         // initialise the state to |0000..0000>
152 # ifdef _OPENMP
153 # pragma omp parallel \
154         default  (none) \
155         shared   (stateVecSize, stateVecReal, stateVecImag) \
156         private  (index) 
157 # endif
158         {
159 # ifdef _OPENMP
160                 # pragma omp for schedule (static)
161 # endif
162                 for (index=0; index<stateVecSize; index++) {
163                         stateVecReal[index] = 0.0;
164                         stateVecImag[index] = 0.0;
165                 }
166         }
167 
168         if (multiQubit->chunkId==0){
169                 // zero state |0000..0000> has probability 1
170                 stateVecReal[0] = 1.0;
171                 stateVecImag[0] = 0.0;
172         }
173 
174         if (DEBUG) printf("COMPLETED INIT\n");
175 }
\end{DoxyCode}
\hypertarget{qubits_8c_afc1835c6b43b6e59ce7df7b13f274fc7}{
\index{qubits.c@{qubits.c}!multiControlledPhaseGate@{multiControlledPhaseGate}}
\index{multiControlledPhaseGate@{multiControlledPhaseGate}!qubits.c@{qubits.c}}
\paragraph[{multiControlledPhaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledPhaseGate ({\bf MultiQubit} {\em multiQubit}, \/  int $\ast$ {\em controlQubits}, \/  int {\em numControlQubits})}\hfill}
\label{qubits_8c_afc1835c6b43b6e59ce7df7b13f274fc7}


Apply the multiple-\/qubit controlled phase gate, also known as the multiple-\/qubit controlled sigmaZ gate. For each state, if all control qubits have value one, multiply the amplitude of that state by -\/1. This applies the many-\/qubit unitary: \[ \begin{pmatrix} 1 \\ & 1 \\\ & & \ddots \\ & & & 1 \\ & & & & -1 \end{pmatrix} \] on the control qubits.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {controls}; \node[draw=none] at (0, 6) {$\vdots$}; \draw (0, 5) -- (0, 4); \draw (-2, 4) -- (2, 4); \draw[fill=black] (0, 4) circle (.2); \draw (0, 4) -- (0, 2); \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 0); \draw (-2,0) -- (2, 0); \draw[fill=black] (0, 0) circle (.2); \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em controlQubits}]array of input qubits \item[\mbox{$\leftarrow$} {\em numControlQubits}]number of input qubits \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily numControlQubits} is outside \mbox{[}1, {\ttfamily multiQubit.numQubits}) \end{DoxyExceptions}


Definition at line 1733 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
1734 {
1735         long long int index;
1736         long long int stateVecSize;
1737         
1738         const long long int chunkSize=multiQubit.numAmps;
1739         const long long int chunkId=multiQubit.chunkId;
1740 
1741     QuESTAssert(numControlQubits > 0 && numControlQubits <= multiQubit.numQubits,
       4, __func__);
1742     long long int mask=0;
1743     for (int i=0; i<numControlQubits; i++) mask = mask | (1LL<<controlQubits[i]);
      
1744     QuESTAssert(mask >=0 && mask <= (1LL<<multiQubit.numQubits)-1, 2, __func__);
1745 
1746         stateVecSize = multiQubit.numAmps;
1747         REAL *stateVecReal = multiQubit.stateVec.real;
1748         REAL *stateVecImag = multiQubit.stateVec.imag;
1749 
1750 # ifdef _OPENMP
1751 # pragma omp parallel \
1752         default  (none)                      \
1753         shared   (stateVecSize, stateVecReal,stateVecImag, mask ) \
1754         private  (index)
1755 # endif
1756         {
1757 # ifdef _OPENMP
1758                 # pragma omp for schedule (static)
1759 # endif
1760                 for (index=0; index<stateVecSize; index++) {
1761                         if (mask == (mask & (index+chunkId*chunkSize)) ){
1762                                 stateVecReal [index] = - stateVecReal [index];
1763                                 stateVecImag [index] = - stateVecImag [index];
1764                         }
1765                 }
1766         }
1767 }
\end{DoxyCode}
\hypertarget{qubits_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{
\index{qubits.c@{qubits.c}!multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}}
\index{multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{multiControlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}


Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where all the control qubits are 1.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 979 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
986 {
987 
988         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
989         long long int thisTask;  
990         const long long int numTasks=multiQubit.numAmps;
991         const long long int chunkSize=multiQubit.numAmps;
992         const long long int chunkId=multiQubit.chunkId;
993 
994         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
995         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
996         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
997         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
998         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
999 
1000 # ifdef _OPENMP
1001 # pragma omp parallel \
1002         default  (none) \
1003         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1004                         rot1Real,rot1Imag, rot2Real,rot2Imag, mask) \
1005         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1006 # endif
1007         {
1008 # ifdef _OPENMP
1009                 # pragma omp for schedule (static)
1010 # endif
1011                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1012                         if (mask == (mask & (thisTask+chunkId*chunkSize)) ){
1013                                 // store current state vector values in temp vari
      ables
1014                                 stateRealUp = stateVecRealUp[thisTask];
1015                                 stateImagUp = stateVecImagUp[thisTask];
1016 
1017                                 stateRealLo = stateVecRealLo[thisTask];
1018                                 stateImagLo = stateVecImagLo[thisTask];
1019 
1020                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
1021                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
1022                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
1023                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
1024                         }
1025                 }
1026         }
1027 }
\end{DoxyCode}
\hypertarget{qubits_8c_a1309eabcba3cb97fbc3cd2e606d17766}{
\index{qubits.c@{qubits.c}!multiControlledUnitaryLocal@{multiControlledUnitaryLocal}}
\index{multiControlledUnitaryLocal@{multiControlledUnitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{multiControlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8c_a1309eabcba3cb97fbc3cd2e606d17766}


Definition at line 710 of file qubits.c.

References MultiQubit::chunkId, Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
712 {
713         long long int sizeBlock, sizeHalfBlock;
714         long long int thisBlock, // current block
715              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
716 
717         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
718         long long int thisTask;         
719         const long long int numTasks=multiQubit.numAmps>>1;
720         const long long int chunkSize=multiQubit.numAmps;
721         const long long int chunkId=multiQubit.chunkId;
722 
723         // set dimensions
724         sizeHalfBlock = 1LL << targetQubit;  
725         sizeBlock     = 2LL * sizeHalfBlock; 
726 
727         // Can't use multiQubit.stateVec as a private OMP var
728         REAL *stateVecReal = multiQubit.stateVec.real;
729         REAL *stateVecImag = multiQubit.stateVec.imag;
730 
731 # ifdef _OPENMP
732 # pragma omp parallel \
733         default  (none) \
734         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u, mask) \
735         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
736 # endif
737         {
738 # ifdef _OPENMP
739                 # pragma omp for schedule (static)
740 # endif
741                 for (thisTask=0; thisTask<numTasks; thisTask++) {
742 
743                         thisBlock   = thisTask / sizeHalfBlock;
744                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
745                         indexLo     = indexUp + sizeHalfBlock;
746 
747                         if (mask == (mask & (indexUp+chunkId*chunkSize)) ){
748                                 // store current state vector values in temp vari
      ables
749                                 stateRealUp = stateVecReal[indexUp];
750                                 stateImagUp = stateVecImag[indexUp];
751 
752                                 stateRealLo = stateVecReal[indexLo];
753                                 stateImagLo = stateVecImag[indexLo];
754 
755 
756                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
757                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
758                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
759                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
760                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
761 
762                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
763                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
764                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
765                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
766                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
767                         }
768                 } 
769         }
770 
771 }
\end{DoxyCode}
\hypertarget{qubits_8c_af832ed00b02a0597b7fe0b714032c54a}{
\index{qubits.c@{qubits.c}!phaseGateDistributed@{phaseGateDistributed}}
\index{phaseGateDistributed@{phaseGateDistributed}!qubits.c@{qubits.c}}
\paragraph[{phaseGateDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits_8c_af832ed00b02a0597b7fe0b714032c54a}


Definition at line 1491 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1492 {
1493         REAL stateRealLo,stateImagLo;
1494         long long int thisTask;         
1495         const long long int numTasks=multiQubit.numAmps;
1496 
1497         // Can't use multiQubit.stateVec as a private OMP var
1498         REAL *stateVecReal = multiQubit.stateVec.real;
1499         REAL *stateVecImag = multiQubit.stateVec.imag;
1500 
1501         REAL recRoot2 = 1.0/sqrt(2);
1502 
1503 # ifdef _OPENMP
1504 # pragma omp parallel \
1505         default  (none) \
1506         shared   (stateVecReal,stateVecImag, recRoot2, type) \
1507         private  (thisTask,stateRealLo,stateImagLo) 
1508 # endif
1509         {
1510                 if (type==SIGMA_Z){
1511 # ifdef _OPENMP
1512                         # pragma omp for schedule (static)
1513 # endif
1514                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1515                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
      
1516                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
      
1517                         } 
1518                 } else if (type==S_GATE){
1519 # ifdef _OPENMP
1520                         # pragma omp for schedule (static)
1521 # endif
1522                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1523                                 stateRealLo = stateVecReal[thisTask];
1524                                 stateImagLo = stateVecImag[thisTask];
1525 
1526                                 stateVecReal[thisTask] = -stateImagLo;
1527                                 stateVecImag[thisTask] = stateRealLo;
1528                         } 
1529                 } else if (type==T_GATE){
1530 # ifdef _OPENMP
1531                         # pragma omp for schedule (static)
1532 # endif
1533                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1534                                 stateRealLo = stateVecReal[thisTask];
1535                                 stateImagLo = stateVecImag[thisTask];
1536 
1537                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo 
      - stateImagLo);
1538                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo 
      + stateImagLo);
1539                         } 
1540                 } else printf("Type %d is an invalid phase gate\n", type);
1541         }
1542 }
\end{DoxyCode}
\hypertarget{qubits_8c_a3a54566b73ac84c312d7da4f56ffbc3b}{
\index{qubits.c@{qubits.c}!phaseGateLocal@{phaseGateLocal}}
\index{phaseGateLocal@{phaseGateLocal}!qubits.c@{qubits.c}}
\paragraph[{phaseGateLocal}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits_8c_a3a54566b73ac84c312d7da4f56ffbc3b}


fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod? 

Definition at line 1415 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1416 {
1417         long long int sizeBlock, sizeHalfBlock;
1418         long long int thisBlock, // current block
1419              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1420 
1421         REAL stateRealLo,stateImagLo;
1422         long long int thisTask;         
1423         const long long int numTasks=multiQubit.numAmps>>1;
1424 
1425         // set dimensions
1426         sizeHalfBlock = 1LL << targetQubit;  
1427         sizeBlock     = 2LL * sizeHalfBlock; 
1428 
1429         // Can't use multiQubit.stateVec as a private OMP var
1430         REAL *stateVecReal = multiQubit.stateVec.real;
1431         REAL *stateVecImag = multiQubit.stateVec.imag;
1432 
1433         REAL recRoot2 = 1.0/sqrt(2);
1434 
1435 # ifdef _OPENMP
1436 # pragma omp parallel \
1437         default  (none) \
1438         shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type
      ) \
1439         private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) 
1440 # endif
1441         {
1442                 if (type==SIGMA_Z){
1443 # ifdef _OPENMP
1444                         # pragma omp for schedule (static)
1445 # endif
1446                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1448                                 thisBlock   = thisTask / sizeHalfBlock;
1449                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1450                                 indexLo     = indexUp + sizeHalfBlock;
1451 
1452                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
1453                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
1454                         } 
1455                 } 
1456                 
1457                 else if (type==S_GATE){
1458 # ifdef _OPENMP
1459                         # pragma omp for schedule (static)
1460 # endif
1461                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1463                                 thisBlock   = thisTask / sizeHalfBlock;
1464                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1465                                 indexLo     = indexUp + sizeHalfBlock;
1466                                 stateRealLo = stateVecReal[indexLo];
1467                                 stateImagLo = stateVecImag[indexLo];
1468 
1469                                 stateVecReal[indexLo] = -stateImagLo;
1470                                 stateVecImag[indexLo] = stateRealLo;
1471                         } 
1472                 } else if (type==T_GATE){
1473 # ifdef _OPENMP
1474                         # pragma omp for schedule (static)
1475 # endif
1476                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1478                                 thisBlock   = thisTask / sizeHalfBlock;
1479                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1480                                 indexLo     = indexUp + sizeHalfBlock;
1481                                 stateRealLo = stateVecReal[indexLo];
1482                                 stateImagLo = stateVecImag[indexLo];
1483 
1484                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo -
       stateImagLo);
1485                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo +
       stateImagLo);
1486                         } 
1487                 } else printf("Type %d is an invalid phase gate\n", type);
1488         }
1489 }
\end{DoxyCode}
\hypertarget{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}{
\index{qubits.c@{qubits.c}!reportMultiQubitParams@{reportMultiQubitParams}}
\index{reportMultiQubitParams@{reportMultiQubitParams}!qubits.c@{qubits.c}}
\paragraph[{reportMultiQubitParams}]{\setlength{\rightskip}{0pt plus 5cm}void reportMultiQubitParams ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}


Report metainformation about a set of qubits: number of qubits, number of probability amplitudes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}


Definition at line 120 of file qubits.c.

References MultiQubit::chunkId, MultiQubit::numChunks, and MultiQubit::numQubits.


\begin{DoxyCode}
120                                                   {
121         long long int numAmps = 1L << multiQubit.numQubits;
122         long long int numAmpsPerRank = numAmps/multiQubit.numChunks;
123         if (multiQubit.chunkId==0){
124                 printf("QUBITS:\n");
125                 printf("Number of qubits is %d.\n", multiQubit.numQubits);
126                 printf("Number of amps is %lld.\n", numAmps);
127                 printf("Number of amps per rank is %lld.\n", numAmpsPerRank);
128         }
129 }
\end{DoxyCode}
\hypertarget{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}{
\index{qubits.c@{qubits.c}!reportState@{reportState}}
\index{reportState@{reportState}!qubits.c@{qubits.c}}
\paragraph[{reportState}]{\setlength{\rightskip}{0pt plus 5cm}void reportState ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}


Print the current state vector of probability amplitudes for a set of qubits to file. File format: \begin{DoxyVerb}
real, imag
realComponent1, imagComponent1
realComponent2, imagComponent2
...
realComponentN, imagComponentN
\end{DoxyVerb}


File naming convention:

For each node that the program runs on, a file 'state\_\-rank\_\-\mbox{[}node\_\-rank\mbox{]}.csv' is generated. If there is more than one node, ranks after the first do not include the header \begin{DoxyVerb}
real, imag
\end{DoxyVerb}
 so that files are easier to combine.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \end{DoxyParams}


Definition at line 81 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL\_\-STRING\_\-FORMAT, and MultiQubit::stateVec.


\begin{DoxyCode}
81                                        {
82         FILE *state;
83         char filename[100];
84         long long int index;
85         sprintf(filename, "state_rank_%d.csv", multiQubit.chunkId);
86         state = fopen(filename, "w");
87         if (multiQubit.chunkId==0) fprintf(state, "real, imag\n");
88 
89         for(index=0; index<multiQubit.numAmps; index++){
90                 fprintf(state, REAL_STRING_FORMAT "," REAL_STRING_FORMAT "\n", mu
      ltiQubit.stateVec.real[index], multiQubit.stateVec.imag[index]);
91         }
92         fclose(state);
93 }
\end{DoxyCode}
\hypertarget{qubits_8c_a842d6884e063a5865a2232cba56b65ac}{
\index{qubits.c@{qubits.c}!reportStateToScreen@{reportStateToScreen}}
\index{reportStateToScreen@{reportStateToScreen}!qubits.c@{qubits.c}}
\paragraph[{reportStateToScreen}]{\setlength{\rightskip}{0pt plus 5cm}void reportStateToScreen ({\bf MultiQubit} {\em multiQubit}, \/  {\bf QuESTEnv} {\em env}, \/  int {\em reportRank})}\hfill}
\label{qubits_8c_a842d6884e063a5865a2232cba56b65ac}


Print the current state vector of probability amplitudes for a set of qubits to standard out. For debugging purposes. Each rank should print output serially. Only print output for systems $<$= 5 qubits 

Definition at line 95 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, MultiQubit::numQubits, ComplexArray::real, REAL\_\-STRING\_\-FORMAT, MultiQubit::stateVec, and syncQuESTEnv().


\begin{DoxyCode}
95                                                                              {
96         long long int index;
97         int rank;
98         if (multiQubit.numQubits<=5){
99                 for (rank=0; rank<multiQubit.numChunks; rank++){
100                         if (multiQubit.chunkId==rank){
101                                 if (reportRank) {
102                                         printf("Reporting state from rank %d [\n"
      , multiQubit.chunkId);
103                                         //printf("\trank, index, real, imag\n");
104                                         printf("real, imag\n");
105                                 } else if (rank==0) {
106                                         printf("Reporting state [\n");
107                                         printf("real, imag\n");
108                                 }
109 
110                                 for(index=0; index<multiQubit.numAmps; index++){
111                                         printf(REAL_STRING_FORMAT ", " 
      REAL_STRING_FORMAT "\n", multiQubit.stateVec.real[index], multiQubit.stateVec.
      imag[index]);
112                                 }
113                                 if (reportRank || rank==multiQubit.numChunks-1) p
      rintf("]\n");
114                         }
115                         syncQuESTEnv(env);
116                 }
117         } else printf("Error: reportStateToScreen will not print output for syste
      ms of more than 5 qubits.\n");
118 }
\end{DoxyCode}
\hypertarget{qubits_8c_a8810423457803005fecd415f4299f40d}{
\index{qubits.c@{qubits.c}!rotateAroundAxis@{rotateAroundAxis}}
\index{rotateAroundAxis@{rotateAroundAxis}!qubits.c@{qubits.c}}
\paragraph[{rotateAroundAxis}]{\setlength{\rightskip}{0pt plus 5cm}void rotateAroundAxis ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle}, \/  {\bf Vector} {\em axis})}\hfill}
\label{qubits_8c_a8810423457803005fecd415f4299f40d}


Rotate a single qubit by a given angle around a given vector on the Bloch-\/sphere. The vector must not be zero (else an error is thrown), but needn't be unit magnitude.

For angle $\theta$ and axis vector $\vec{n}$, applies $R_{\hat{n}} = \exp \left(- i \frac{\theta}{2} \hat{n} \cdot \vec{\sigma} \right) $ where $\vec{\sigma}$ is the vector of Pauli matrices.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \item[\mbox{$\leftarrow$} {\em axis}]vector around which to rotate (can be non-\/unit; will be normalised) \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily rotQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or if {\ttfamily axis} is the zero vector \end{DoxyExceptions}


Definition at line 382 of file qubits.c.

References compactUnitary(), Complex::imag, Complex::real, Vector::x, Vector::y, and Vector::z.

Referenced by rotateX(), rotateY(), and rotateZ().


\begin{DoxyCode}
382                                                                                  
              {
383         
384         double mag = sqrt(pow(axis.x,2) + pow(axis.y,2) + pow(axis.z,2));
385         Vector unitAxis = {axis.x/mag, axis.y/mag, axis.z/mag};
386         
387         Complex alpha, beta;
388         alpha.real = cos(angle/2.0);
389         alpha.imag = -sin(angle/2.0)*unitAxis.z;        
390         beta.real = sin(angle/2.0)*unitAxis.y;
391         beta.imag = -sin(angle/2.0)*unitAxis.x;
392         compactUnitary(multiQubit, rotQubit, alpha, beta);
393 }
\end{DoxyCode}
\hypertarget{qubits_8c_a6cc7fa705a2f2e6b486b49c5589d5df5}{
\index{qubits.c@{qubits.c}!rotateX@{rotateX}}
\index{rotateX@{rotateX}!qubits.c@{qubits.c}}
\paragraph[{rotateX}]{\setlength{\rightskip}{0pt plus 5cm}void rotateX ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8c_a6cc7fa705a2f2e6b486b49c5589d5df5}


Rotate a single qubit by a given angle around the X-\/axis of the Bloch-\/sphere. For angle $\theta$, applies \[ \begin{pmatrix} \cos\theta/2 & -i \sin \theta/2\\ -i \sin \theta/2 & \cos \theta/2 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {rot}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_x(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily rotQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 395 of file qubits.c.

References rotateAroundAxis().


\begin{DoxyCode}
395                                                                    {
396 
397         Vector unitAxis = {1, 0, 0};
398         rotateAroundAxis(multiQubit, rotQubit, angle, unitAxis);
399 }
\end{DoxyCode}
\hypertarget{qubits_8c_ace0d3592d38a990e81a434c4e9681500}{
\index{qubits.c@{qubits.c}!rotateY@{rotateY}}
\index{rotateY@{rotateY}!qubits.c@{qubits.c}}
\paragraph[{rotateY}]{\setlength{\rightskip}{0pt plus 5cm}void rotateY ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8c_ace0d3592d38a990e81a434c4e9681500}


Rotate a single qubit by a given angle around the Y-\/axis of the Bloch-\/sphere. For angle $\theta$, applies \[ \begin{pmatrix} \cos\theta/2 & - \sin \theta/2\\ \sin \theta/2 & \cos \theta/2 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {rot}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_y(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily rotQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 401 of file qubits.c.

References rotateAroundAxis().


\begin{DoxyCode}
401                                                                    {
402         
403         Vector unitAxis = {0, 1, 0};
404         rotateAroundAxis(multiQubit, rotQubit, angle, unitAxis);
405 }
\end{DoxyCode}
\hypertarget{qubits_8c_abd621412ad30c1b034f4ce153c4afe10}{
\index{qubits.c@{qubits.c}!rotateZ@{rotateZ}}
\index{rotateZ@{rotateZ}!qubits.c@{qubits.c}}
\paragraph[{rotateZ}]{\setlength{\rightskip}{0pt plus 5cm}void rotateZ ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8c_abd621412ad30c1b034f4ce153c4afe10}


Rotate a single qubit by a given angle around the Z-\/axis of the Bloch-\/sphere (also known as a phase shift gate). For angle $\theta$, applies \[ \begin{pmatrix} \exp(-i \theta/2) & 0 \\ 0 & \exp(i \theta/2) \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {rot}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_z(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily rotQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 407 of file qubits.c.

References rotateAroundAxis().


\begin{DoxyCode}
407                                                                    {
408         
409         Vector unitAxis = {0, 0, 1};
410         rotateAroundAxis(multiQubit, rotQubit, angle, unitAxis);
411 }
\end{DoxyCode}
\hypertarget{qubits_8c_adda6c47876a7676488ed0565a19eaa65}{
\index{qubits.c@{qubits.c}!sGate@{sGate}}
\index{sGate@{sGate}!qubits.c@{qubits.c}}
\paragraph[{sGate}]{\setlength{\rightskip}{0pt plus 5cm}void sGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_adda6c47876a7676488ed0565a19eaa65}


Apply the single-\/qubit S gate. This is a rotation of $\pi/2$ around the Z-\/axis on the Bloch sphere, or the unitary: \[ \begin{pmatrix} 1 & 0 \\ 0 & i \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {S}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate upon \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) \end{DoxyExceptions}


Definition at line 1549 of file qubits.c.

References phaseGate(), and S\_\-GATE.


\begin{DoxyCode}
1550 {
1551                 phaseGate(multiQubit, targetQubit, S_GATE);
1552 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a2275fff50824fe47485890ff5a857785}{
\index{qubits.c@{qubits.c}!sigmaXDistributed@{sigmaXDistributed}}
\index{sigmaXDistributed@{sigmaXDistributed}!qubits.c@{qubits.c}}
\paragraph[{sigmaXDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a2275fff50824fe47485890ff5a857785}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1088 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaX().


\begin{DoxyCode}
1091 {
1092 
1093         long long int thisTask;  
1094         const long long int numTasks=multiQubit.numAmps;
1095 
1096         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1097         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1098 
1099 # ifdef _OPENMP
1100 # pragma omp parallel \
1101         default  (none) \
1102         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1103         private  (thisTask)
1104 # endif
1105         {
1106 # ifdef _OPENMP
1107                 # pragma omp for schedule (static)
1108 # endif
1109                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1110                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
1111                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
1112                 }
1113         }
1114 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a74822fd86bb5d81766e6e8dbdcd62df1}{
\index{qubits.c@{qubits.c}!sigmaXLocal@{sigmaXLocal}}
\index{sigmaXLocal@{sigmaXLocal}!qubits.c@{qubits.c}}
\paragraph[{sigmaXLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_a74822fd86bb5d81766e6e8dbdcd62df1}


Definition at line 1029 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaX().


\begin{DoxyCode}
1030 {
1031         long long int sizeBlock, sizeHalfBlock;
1032         long long int thisBlock, // current block
1033              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1034 
1035         REAL stateRealUp,stateImagUp;
1036         long long int thisTask;         
1037         const long long int numTasks=multiQubit.numAmps>>1;
1038 
1039         // set dimensions
1040         sizeHalfBlock = 1LL << targetQubit;  
1041         sizeBlock     = 2LL * sizeHalfBlock; 
1042 
1043         // Can't use multiQubit.stateVec as a private OMP var
1044         REAL *stateVecReal = multiQubit.stateVec.real;
1045         REAL *stateVecImag = multiQubit.stateVec.imag;
1046 
1047 # ifdef _OPENMP
1048 # pragma omp parallel \
1049         default  (none) \
1050         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1051         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1052 # endif
1053         {
1054 # ifdef _OPENMP
1055                 # pragma omp for schedule (static)
1056 # endif
1057                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1058                         thisBlock   = thisTask / sizeHalfBlock;
1059                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1060                         indexLo     = indexUp + sizeHalfBlock;
1061 
1062                         stateRealUp = stateVecReal[indexUp];
1063                         stateImagUp = stateVecImag[indexUp];
1064 
1065                         stateVecReal[indexUp] = stateVecReal[indexLo];
1066                         stateVecImag[indexUp] = stateVecImag[indexLo];
1067 
1068                         stateVecReal[indexLo] = stateRealUp;
1069                         stateVecImag[indexLo] = stateImagUp;
1070                 } 
1071         }
1072 
1073 }
\end{DoxyCode}
\hypertarget{qubits_8c_af5ef5166f00c0572354b4ac53dcf40cf}{
\index{qubits.c@{qubits.c}!sigmaYDistributed@{sigmaYDistributed}}
\index{sigmaYDistributed@{sigmaYDistributed}!qubits.c@{qubits.c}}
\paragraph[{sigmaYDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits_8c_af5ef5166f00c0572354b4ac53dcf40cf}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1275 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaY().


\begin{DoxyCode}
1279 {
1280 
1281         long long int thisTask;  
1282         const long long int numTasks=multiQubit.numAmps;
1283 
1284         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1285         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1286 
1287         int realSign=1, imagSign=1;
1288         if (updateUpper) imagSign=-1;
1289         else realSign = -1;
1290 
1291 # ifdef _OPENMP
1292 # pragma omp parallel \
1293         default  (none) \
1294         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,r
      ealSign,imagSign) \
1295         private  (thisTask)
1296 # endif
1297         {
1298 # ifdef _OPENMP
1299                 # pragma omp for schedule (static)
1300 # endif
1301                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1302                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisT
      ask];
1303                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisT
      ask];
1304                 }
1305         }
1306 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a81fbfaed65a742a7dfd622e17652245e}{
\index{qubits.c@{qubits.c}!sigmaYLocal@{sigmaYLocal}}
\index{sigmaYLocal@{sigmaYLocal}!qubits.c@{qubits.c}}
\paragraph[{sigmaYLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_a81fbfaed65a742a7dfd622e17652245e}


Definition at line 1216 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaY().


\begin{DoxyCode}
1217 {
1218         long long int sizeBlock, sizeHalfBlock;
1219         long long int thisBlock, // current block
1220              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1221 
1222         REAL stateRealUp,stateImagUp;
1223         long long int thisTask;         
1224         const long long int numTasks=multiQubit.numAmps>>1;
1225 
1226         // set dimensions
1227         sizeHalfBlock = 1LL << targetQubit;  
1228         sizeBlock     = 2LL * sizeHalfBlock; 
1229 
1230         // Can't use multiQubit.stateVec as a private OMP var
1231         REAL *stateVecReal = multiQubit.stateVec.real;
1232         REAL *stateVecImag = multiQubit.stateVec.imag;
1233 
1234 # ifdef _OPENMP
1235 # pragma omp parallel \
1236         default  (none) \
1237         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1238         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1239 # endif
1240         {
1241 # ifdef _OPENMP
1242                 # pragma omp for schedule (static)
1243 # endif
1244                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1245                         thisBlock   = thisTask / sizeHalfBlock;
1246                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1247                         indexLo     = indexUp + sizeHalfBlock;
1248 
1249                         stateRealUp = stateVecReal[indexUp];
1250                         stateImagUp = stateVecImag[indexUp];
1251 
1252                         stateVecReal[indexUp] = stateVecImag[indexLo];
1253                         stateVecImag[indexUp] = -stateVecReal[indexLo];
1254 
1255                         stateVecReal[indexLo] = -stateImagUp;
1256                         stateVecImag[indexLo] = stateRealUp;
1257                 } 
1258         }
1259 }
\end{DoxyCode}
\hypertarget{qubits_8c_aebaab86326779de55d335cfea3efde8f}{
\index{qubits.c@{qubits.c}!sigmaZ@{sigmaZ}}
\index{sigmaZ@{sigmaZ}!qubits.c@{qubits.c}}
\paragraph[{sigmaZ}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaZ ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_aebaab86326779de55d335cfea3efde8f}


Apply the single-\/qubit sigma-\/Z (also known as the Z, Pauli-\/Z or phase-\/flip) gate. This is a rotation of $\pi$ around the Z-\/axis (a phase shift) on the Bloch sphere. I.e. \[ \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$\sigma_z$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 1544 of file qubits.c.

References phaseGate(), and SIGMA\_\-Z.


\begin{DoxyCode}
1545 {
1546                 phaseGate(multiQubit, targetQubit, SIGMA_Z);
1547 }
\end{DoxyCode}
\hypertarget{qubits_8c_af764ea63a2e870098f4e1ce08562942e}{
\index{qubits.c@{qubits.c}!tGate@{tGate}}
\index{tGate@{tGate}!qubits.c@{qubits.c}}
\paragraph[{tGate}]{\setlength{\rightskip}{0pt plus 5cm}void tGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_af764ea63a2e870098f4e1ce08562942e}


Apply the single-\/qubit T gate. This is a rotation of $\pi/4$ around the Z-\/axis on the Bloch sphere, or the unitary: \[ \begin{pmatrix} 1 & 0 \\ 0 & \exp\left(i \frac{\pi}{4}\right) \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {T}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate upon \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) \end{DoxyExceptions}


Definition at line 1554 of file qubits.c.

References phaseGate(), and T\_\-GATE.


\begin{DoxyCode}
1555 {
1556                 phaseGate(multiQubit, targetQubit, T_GATE);
1557 }
\end{DoxyCode}
\hypertarget{qubits_8c_a2343b7240118e89aa615e2c9140b770b}{
\index{qubits.c@{qubits.c}!unitaryDistributed@{unitaryDistributed}}
\index{unitaryDistributed@{unitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{unitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a2343b7240118e89aa615e2c9140b770b}


Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em u}]unitary matrix to apply \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 598 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by unitary().


\begin{DoxyCode}
603 {
604 
605         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
606         long long int thisTask;  
607         const long long int numTasks=multiQubit.numAmps;
608 
609         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
610         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
611         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
612         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
613         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
614 
615 
616 # ifdef _OPENMP
617 # pragma omp parallel \
618         default  (none) \
619         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
620                         rot1Real, rot1Imag, rot2Real, rot2Imag) \
621         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
622 # endif
623         {
624 # ifdef _OPENMP
625                 # pragma omp for schedule (static)
626 # endif
627                 for (thisTask=0; thisTask<numTasks; thisTask++) {
628                         // store current state vector values in temp variables
629                         stateRealUp = stateVecRealUp[thisTask];
630                         stateImagUp = stateVecImagUp[thisTask];
631 
632                         stateRealLo = stateVecRealLo[thisTask];
633                         stateImagLo = stateVecImagLo[thisTask];
634 
635                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp 
636                                 + rot2Real*stateRealLo - rot2Imag*stateImagLo;
637                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp 
638                                 + rot2Real*stateImagLo + rot2Imag*stateRealLo;
639                 }
640         }
641 }
\end{DoxyCode}
\hypertarget{qubits_8c_ac134fb45b0a7248c5d15e16eb7139a35}{
\index{qubits.c@{qubits.c}!unitaryLocal@{unitaryLocal}}
\index{unitaryLocal@{unitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{unitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8c_ac134fb45b0a7248c5d15e16eb7139a35}


Definition at line 472 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by unitary().


\begin{DoxyCode}
473 {
474         long long int sizeBlock, sizeHalfBlock;
475         long long int thisBlock, // current block
476              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
477 
478         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
479         long long int thisTask;         
480         const long long int numTasks=multiQubit.numAmps>>1;
481 
482         // set dimensions
483         sizeHalfBlock = 1LL << targetQubit;  
484         sizeBlock     = 2LL * sizeHalfBlock; 
485 
486         // Can't use multiQubit.stateVec as a private OMP var
487         REAL *stateVecReal = multiQubit.stateVec.real;
488         REAL *stateVecImag = multiQubit.stateVec.imag;
489 
490 # ifdef _OPENMP
491 # pragma omp parallel \
492         default  (none) \
493         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
494         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
495 # endif
496         {
497 # ifdef _OPENMP
498                 # pragma omp for schedule (static)
499 # endif
500                 for (thisTask=0; thisTask<numTasks; thisTask++) {
501 
502                         thisBlock   = thisTask / sizeHalfBlock;
503                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
504                         indexLo     = indexUp + sizeHalfBlock;
505 
506                         // store current state vector values in temp variables
507                         stateRealUp = stateVecReal[indexUp];
508                         stateImagUp = stateVecImag[indexUp];
509 
510                         stateRealLo = stateVecReal[indexLo];
511                         stateImagLo = stateVecImag[indexLo];
512 
513 
514                         // state[indexUp] = u00 * state[indexUp] + u01 * state[in
      dexLo]
515                         stateVecReal[indexUp] = u.r0c0.real*stateRealUp - u.r0c0.
      imag*stateImagUp 
516                                 + u.r0c1.real*stateRealLo - u.r0c1.imag*stateImag
      Lo;
517                         stateVecImag[indexUp] = u.r0c0.real*stateImagUp + u.r0c0.
      imag*stateRealUp 
518                                 + u.r0c1.real*stateImagLo + u.r0c1.imag*stateReal
      Lo;
519 
520                         // state[indexLo] = u10  * state[indexUp] + u11 * state[i
      ndexLo]
521                         stateVecReal[indexLo] = u.r1c0.real*stateRealUp  - u.
      r1c0.imag*stateImagUp 
522                                 + u.r1c1.real*stateRealLo  -  u.r1c1.imag*stateIm
      agLo;
523                         stateVecImag[indexLo] = u.r1c0.real*stateImagUp + u.r1c0.
      imag*stateRealUp 
524                                 + u.r1c1.real*stateImagLo + u.r1c1.imag*stateReal
      Lo;
525 
526                 } 
527         }
528 } 
\end{DoxyCode}
\hypertarget{qubits_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}{
\index{qubits.c@{qubits.c}!validateAlphaBeta@{validateAlphaBeta}}
\index{validateAlphaBeta@{validateAlphaBeta}!qubits.c@{qubits.c}}
\paragraph[{validateAlphaBeta}]{\setlength{\rightskip}{0pt plus 5cm}int validateAlphaBeta ({\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}


Definition at line 369 of file qubits.c.

References Complex::imag, Complex::real, and REAL\_\-EPS.

Referenced by compactUnitary(), and controlledCompactUnitary().


\begin{DoxyCode}
369                                                   {
370         if ( fabs(alpha.real*alpha.real 
371                 + alpha.imag*alpha.imag
372                 + beta.real*beta.real 
373                 + beta.imag*beta.imag - 1) > REAL_EPS ) return 0;
374         else return 1;
375 }
\end{DoxyCode}
\hypertarget{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}{
\index{qubits.c@{qubits.c}!validateMatrixIsUnitary@{validateMatrixIsUnitary}}
\index{validateMatrixIsUnitary@{validateMatrixIsUnitary}!qubits.c@{qubits.c}}
\paragraph[{validateMatrixIsUnitary}]{\setlength{\rightskip}{0pt plus 5cm}int validateMatrixIsUnitary ({\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}


Definition at line 344 of file qubits.c.

References Complex::imag, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, and REAL\_\-EPS.

Referenced by controlledUnitary(), multiControlledUnitary(), and unitary().


\begin{DoxyCode}
344                                              {
345 
346         if ( fabs(u.r0c0.real*u.r0c0.real 
347                 + u.r0c0.imag*u.r0c0.imag
348                 + u.r1c0.real*u.r1c0.real
349                 + u.r1c0.imag*u.r1c0.imag - 1) > REAL_EPS ) return 0;
350     // check
351         if ( fabs(u.r0c1.real*u.r0c1.real 
352                 + u.r0c1.imag*u.r0c1.imag
353                 + u.r1c1.real*u.r1c1.real
354                 + u.r1c1.imag*u.r1c1.imag - 1) > REAL_EPS ) return 0;
355 
356         if ( fabs(u.r0c0.real*u.r0c1.real 
357                 + u.r0c0.imag*u.r0c1.imag
358                 + u.r1c0.real*u.r1c1.real
359                 + u.r1c0.imag*u.r1c1.imag) > REAL_EPS ) return 0;
360 
361         if ( fabs(u.r0c1.real*u.r0c0.imag
362                 - u.r0c0.real*u.r0c1.imag
363                 + u.r1c1.real*u.r1c0.imag
364                 - u.r1c0.real*u.r1c1.imag) > REAL_EPS ) return 0;
365 
366         return 1;
367 }
\end{DoxyCode}
\hypertarget{qubits_8c_a71c14976f63cfcda70026fa20ee531fe}{
\index{qubits.c@{qubits.c}!validateUnitVector@{validateUnitVector}}
\index{validateUnitVector@{validateUnitVector}!qubits.c@{qubits.c}}
\paragraph[{validateUnitVector}]{\setlength{\rightskip}{0pt plus 5cm}int validateUnitVector (REAL {\em ux}, \/  REAL {\em uy}, \/  REAL {\em uz})}\hfill}
\label{qubits_8c_a71c14976f63cfcda70026fa20ee531fe}


Definition at line 377 of file qubits.c.

References REAL\_\-EPS.


\begin{DoxyCode}
377                                                  {
378         if ( fabs(sqrt(ux*ux + uy*uy + uz*uz) - 1) > REAL_EPS ) return 0;
379         else return 1;
380 }
\end{DoxyCode}


\subsubsection{Variable Documentation}
\hypertarget{qubits_8c_aac1637696885c75b73a1ecf381cea713}{
\index{qubits.c@{qubits.c}!errorCodes@{errorCodes}}
\index{errorCodes@{errorCodes}!qubits.c@{qubits.c}}
\paragraph[{errorCodes}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ {\bf errorCodes}\mbox{[}$\,$\mbox{]}}\hfill}
\label{qubits_8c_aac1637696885c75b73a1ecf381cea713}
{\bfseries Initial value:}
\begin{DoxyCode}
 {
    "Success",                                              
    "Invalid target qubit. Note qubits are zero indexed.",  
    "Invalid control qubit. Note qubits are zero indexed.", 
    "Control qubit cannot equal target qubit.",             
    "Invalid number of control qubits",                     
    "Invalid unitary matrix.",                              
    "Invalid rotation arguments.",                          
    "Invalid system size. Cannot print output for systems greater than 5 qubits."
      , 
    "Can't collapse to state with zero probability.", 
    "Invalid number of qubits.", 
    "Invalid measurement outcome -- must be either 0 or 1." 
}
\end{DoxyCode}


Definition at line 20 of file qubits.c.

Referenced by exitWithError().