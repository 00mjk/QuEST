\hypertarget{qubits__internal_8h}{}\subsection{qubits\+\_\+internal.\+h File Reference}
\label{qubits__internal_8h}\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}


Internal functions used to implement the public facing A\+PI in \hyperlink{qubits_8h}{qubits.\+h}.  


{\ttfamily \#include \char`\"{}precision.\+h\char`\"{}}\\*
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}{compact\+Unitary\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}{compact\+Unitary\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}{unitary\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, \hyperlink{structComplexMatrix2}{Complex\+Matrix2} u)
\item 
void \hyperlink{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}{unitary\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}{controlled\+Compact\+Unitary\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int control\+Qubit, const int target\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}{controlled\+Compact\+Unitary\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int control\+Qubit, const int target\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}{controlled\+Unitary\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int control\+Qubit, const int target\+Qubit, \hyperlink{structComplexMatrix2}{Complex\+Matrix2} u)
\item 
void \hyperlink{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}{controlled\+Unitary\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int control\+Qubit, const int target\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}{multi\+Controlled\+Unitary\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, long long int mask, \hyperlink{structComplexMatrix2}{Complex\+Matrix2} u)
\item 
void \hyperlink{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{multi\+Controlled\+Unitary\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, long long int mask, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}{sigma\+X\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit)
\item 
void \hyperlink{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}{sigma\+X\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}{sigma\+Y\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit)
\item 
void \hyperlink{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}{sigma\+Y\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out, int update\+Upper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}{hadamard\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit)
\item 
void \hyperlink{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}{hadamard\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out, int update\+Upper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}{phase\+Gate\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type} type)
\item 
void \hyperlink{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}{phase\+Gate\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type} type)
\item 
void \hyperlink{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}{controlled\+Not\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int control\+Qubit, const int target\+Qubit)
\item 
void \hyperlink{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}{controlled\+Not\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int control\+Qubit, const int target\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{find\+Probability\+Of\+Zero\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{find\+Probability\+Of\+Zero\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}{collapse\+To\+Outcome\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, int measure\+Qubit, \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} total\+Probability, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapse\+To\+Outcome\+Distributed\+Renorm} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit, const \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} total\+Probability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measure\+Qubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapse\+To\+Outcome\+Distributed\+Set\+Zero} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Set all amplitudes in one chunk to 0. \end{DoxyCompactList}\item 
int \hyperlink{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}{validate\+Matrix\+Is\+Unitary} (\hyperlink{structComplexMatrix2}{Complex\+Matrix2} u)
\item 
int \hyperlink{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}{validate\+Alpha\+Beta} (\hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
int \hyperlink{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}{validate\+Unit\+Vector} (\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} ux, \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} uy, \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} uz)
\item 
void \hyperlink{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}{phase\+Gate} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type} type)
\item 
void \hyperlink{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}{exit\+With\+Error} (int error\+Code, const char $\ast$func)
\item 
void \hyperlink{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}{Qu\+E\+S\+T\+Assert} (int is\+Valid, int error\+Code, const char $\ast$func)
\end{DoxyCompactItemize}
\subsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \hyperlink{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}{error\+Codes} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
Internal functions used to implement the public facing A\+PI in \hyperlink{qubits_8h}{qubits.\+h}. 

Do not call these functions directly. In general, \hyperlink{qubits__env__local_8c}{qubits\+\_\+env\+\_\+local.\+c} and \hyperlink{qubits__env__mpi_8c}{qubits\+\_\+env\+\_\+mpi.\+c} will implement the public A\+PI by choosing the correct function or combination of functions to use from those included here. 

\subsubsection{Function Documentation}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!collapse\+To\+Outcome\+Distributed\+Renorm@{collapse\+To\+Outcome\+Distributed\+Renorm}}
\index{collapse\+To\+Outcome\+Distributed\+Renorm@{collapse\+To\+Outcome\+Distributed\+Renorm}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{collapse\+To\+Outcome\+Distributed\+Renorm(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit, const R\+E\+A\+L total\+Probability)}{collapseToOutcomeDistributedRenorm(MultiQubit multiQubit, const int measureQubit, const REAL totalProbability)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} collapse\+To\+Outcome\+Distributed\+Renorm (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit, }
\item[{const {\bf R\+E\+AL}}]{total\+Probability}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}{}\label{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}


Renormalise parts of the state vector where measure\+Qubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that the value \textquotesingle{}outcome\textquotesingle{} has been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. In the distributed version, one block (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em total\+Probability} & probability of qubit measure\+Qubit being zero \\
\hline
\end{DoxyParams}


Definition at line 1871 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by collapse\+To\+Outcome(), and measure\+With\+Stats().


\begin{DoxyCode}
1872 \{
1873         \textcolor{comment}{// ----- temp variables}
1874         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1875         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1876         \textcolor{comment}{// (good for shared memory parallelism)}
1877 
1878         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} renorm=1/sqrt(totalProbability);
1879         
1880         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1881         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1882 
1883 \textcolor{preprocessor}{# ifdef \_OPENMP}
1884 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1885 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1886 \textcolor{preprocessor}{        private   (thisTask)}
1887 \textcolor{preprocessor}{# endif}
1888         \{
1889 \textcolor{preprocessor}{# ifdef \_OPENMP}
1890 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1891 \textcolor{preprocessor}{# endif}
1892                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1893                         \textcolor{comment}{// summation -- simple implementation}
1894                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
1895                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
1896                 \}
1897         \}
1898         \textcolor{keywordflow}{return} totalProbability;
1899 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!collapse\+To\+Outcome\+Distributed\+Set\+Zero@{collapse\+To\+Outcome\+Distributed\+Set\+Zero}}
\index{collapse\+To\+Outcome\+Distributed\+Set\+Zero@{collapse\+To\+Outcome\+Distributed\+Set\+Zero}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{collapse\+To\+Outcome\+Distributed\+Set\+Zero(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit)}{collapseToOutcomeDistributedSetZero(MultiQubit multiQubit, const int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void collapse\+To\+Outcome\+Distributed\+Set\+Zero (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}{}\label{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}


Set all amplitudes in one chunk to 0. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that a zero have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 or 1. In the distributed version, one block (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}


Definition at line 1913 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by collapse\+To\+Outcome(), and measure\+With\+Stats().


\begin{DoxyCode}
1914 \{
1915         \textcolor{comment}{// ----- temp variables}
1916         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1917         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1918         \textcolor{comment}{// (good for shared memory parallelism)}
1919 
1920         \textcolor{comment}{// ---------------------------------------------------------------- //}
1921         \textcolor{comment}{//            find probability                                      //}
1922         \textcolor{comment}{// ---------------------------------------------------------------- //}
1923 
1924         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1925         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1926 
1927 \textcolor{preprocessor}{# ifdef \_OPENMP}
1928 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1929 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1930 \textcolor{preprocessor}{        private   (thisTask)}
1931 \textcolor{preprocessor}{# endif}
1932         \{
1933 \textcolor{preprocessor}{# ifdef \_OPENMP}
1934 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1935 \textcolor{preprocessor}{# endif}
1936                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1937                         \textcolor{comment}{// summation -- simple implementation}
1938                         stateVecReal[thisTask] = 0;
1939                         stateVecImag[thisTask] = 0;
1940                 \}
1941         \}
1942 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!collapse\+To\+Outcome\+Local@{collapse\+To\+Outcome\+Local}}
\index{collapse\+To\+Outcome\+Local@{collapse\+To\+Outcome\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{collapse\+To\+Outcome\+Local(\+Multi\+Qubit multi\+Qubit, int measure\+Qubit, R\+E\+A\+L total\+Probability, int outcome)}{collapseToOutcomeLocal(MultiQubit multiQubit, int measureQubit, REAL totalProbability, int outcome)}}]{\setlength{\rightskip}{0pt plus 5cm}void collapse\+To\+Outcome\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{int}]{measure\+Qubit, }
\item[{{\bf R\+E\+AL}}]{total\+Probability, }
\item[{int}]{outcome}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}{}\label{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}


Update the state vector to be consistent with measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. 

Performs an irreversible change to the state vector\+: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em total\+Probability} & probability of qubit measure\+Qubit being either zero or one \\
\hline
\mbox{\tt in}  & {\em outcome} & to measure the probability of and set the state to -- either zero or one \\
\hline
\end{DoxyParams}


Definition at line 1789 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by collapse\+To\+Outcome(), and measure\+With\+Stats().


\begin{DoxyCode}
1790 \{
1791         \textcolor{comment}{// ----- sizes}
1792         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
1793         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
1794         \textcolor{comment}{// ----- indices}
1795         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
1796              index;                                               \textcolor{comment}{// current index for first half block}
1797         \textcolor{comment}{// ----- measured probability}
1798         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   renorm;                                    \textcolor{comment}{// probability (returned) value}
1799         \textcolor{comment}{// ----- temp variables}
1800         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1801         \textcolor{comment}{// (good for shared memory parallelism)}
1802         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1803 
1804         \textcolor{comment}{// ---------------------------------------------------------------- //}
1805         \textcolor{comment}{//            dimensions                                            //}
1806         \textcolor{comment}{// ---------------------------------------------------------------- //}
1807         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
1808         \textcolor{comment}{// and then the number to skip}
1809         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
1810         
1811         renorm=1/sqrt(totalProbability);
1812         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1813         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1814 
1815 
1816 \textcolor{preprocessor}{# ifdef \_OPENMP}
1817 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1818 \textcolor{preprocessor}{        default (none) \(\backslash\)}
1819 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,renorm,outcome) \(\backslash\)}
1820 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index)}
1821 \textcolor{preprocessor}{# endif}
1822         \{
1823                 \textcolor{keywordflow}{if} (outcome==0)\{
1824                         \textcolor{comment}{// measure qubit is 0}
1825 \textcolor{preprocessor}{# ifdef \_OPENMP}
1826 \textcolor{preprocessor}{                        # pragma omp for schedule  (static)}
1827 \textcolor{preprocessor}{# endif}
1828                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1829                                 thisBlock = thisTask / sizeHalfBlock;
1830                                 index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1831                                 stateVecReal[index]=stateVecReal[index]*renorm;
1832                                 stateVecImag[index]=stateVecImag[index]*renorm;
1833 
1834                                 stateVecReal[index+sizeHalfBlock]=0;
1835                                 stateVecImag[index+sizeHalfBlock]=0;
1836                         \}
1837                 \} \textcolor{keywordflow}{else} \{
1838                         \textcolor{comment}{// measure qubit is 1}
1839 \textcolor{preprocessor}{# ifdef \_OPENMP}
1840 \textcolor{preprocessor}{                        # pragma omp for schedule  (static)}
1841 \textcolor{preprocessor}{# endif}
1842                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1843                                 thisBlock = thisTask / sizeHalfBlock;
1844                                 index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1845                                 stateVecReal[index]=0;
1846                                 stateVecImag[index]=0;
1847 
1848                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[index+sizeHalfBlock]*renorm;
1849                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[index+sizeHalfBlock]*renorm;
1850                         \}
1851                 \}
1852         \}
1853 
1854 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!compact\+Unitary\+Distributed@{compact\+Unitary\+Distributed}}
\index{compact\+Unitary\+Distributed@{compact\+Unitary\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{compact\+Unitary\+Distributed(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, Complex rot1, Complex rot2, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out)}{compactUnitaryDistributed(MultiQubit multiQubit, const int targetQubit, Complex rot1, Complex rot2, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void compact\+Unitary\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex}}]{rot1, }
\item[{{\bf Complex}}]{rot2, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}{}\label{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 546 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, Complex\+::real, and R\+E\+AL.



Referenced by compact\+Unitary().


\begin{DoxyCode}
551 \{
552 
553         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
554         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
555         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
556 
557         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
558         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
559         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
560         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
561         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
562 
563 \textcolor{preprocessor}{# ifdef \_OPENMP}
564 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
565 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
566 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
567 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag) \(\backslash\)}
568 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
569 \textcolor{preprocessor}{# endif}
570         \{
571 \textcolor{preprocessor}{# ifdef \_OPENMP}
572 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
573 \textcolor{preprocessor}{# endif}
574                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
575                         \textcolor{comment}{// store current state vector values in temp variables}
576                         stateRealUp = stateVecRealUp[thisTask];
577                         stateImagUp = stateVecImagUp[thisTask];
578 
579                         stateRealLo = stateVecRealLo[thisTask];
580                         stateImagLo = stateVecImagLo[thisTask];
581 
582                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
583                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp + rot2Real*
      stateRealLo + rot2Imag*stateImagLo;
584                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp + rot2Real*
      stateImagLo - rot2Imag*stateRealLo;
585                 \}
586         \}
587 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!compact\+Unitary\+Local@{compact\+Unitary\+Local}}
\index{compact\+Unitary\+Local@{compact\+Unitary\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{compact\+Unitary\+Local(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, Complex alpha, Complex beta)}{compactUnitaryLocal(MultiQubit multiQubit, const int targetQubit, Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}void compact\+Unitary\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}{}\label{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}


Definition at line 417 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, Complex\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by compact\+Unitary().


\begin{DoxyCode}
418 \{
419         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
420         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
421              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
422 
423         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
424         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
425         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
426 
427         \textcolor{comment}{// set dimensions}
428         sizeHalfBlock = 1LL << targetQubit;  
429         sizeBlock     = 2LL * sizeHalfBlock; 
430 
431         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
432         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
433         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
434         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} alphaImag=alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, alphaReal=alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
435         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} betaImag=beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, betaReal=beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
436 
437 \textcolor{preprocessor}{# ifdef \_OPENMP}
438 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
439 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
440 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,alphaImag,
       betaReal,betaImag) \(\backslash\)}
441 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
442 \textcolor{preprocessor}{# endif}
443         \{
444 \textcolor{preprocessor}{# ifdef \_OPENMP}
445 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
446 \textcolor{preprocessor}{# endif}
447                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
448 
449                         thisBlock   = thisTask / sizeHalfBlock;
450                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
451                         indexLo     = indexUp + sizeHalfBlock;
452 
453                         \textcolor{comment}{// store current state vector values in temp variables}
454                         stateRealUp = stateVecReal[indexUp];
455                         stateImagUp = stateVecImag[indexUp];
456 
457                         stateRealLo = stateVecReal[indexLo];
458                         stateImagLo = stateVecImag[indexLo];
459 
460                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
461                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag*stateImagUp 
462                                 - betaReal*stateRealLo - betaImag*stateImagLo;
463                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag*stateRealUp 
464                                 - betaReal*stateImagLo + betaImag*stateRealLo;
465 
466                         \textcolor{comment}{// state[indexLo] = beta  * state[indexUp] + conj(alpha) * state[indexLo]}
467                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*stateImagUp 
468                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
469                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*stateRealUp 
470                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
471                 \} 
472         \}
473 
474 \} 
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!controlled\+Compact\+Unitary\+Distributed@{controlled\+Compact\+Unitary\+Distributed}}
\index{controlled\+Compact\+Unitary\+Distributed@{controlled\+Compact\+Unitary\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{controlled\+Compact\+Unitary\+Distributed(\+Multi\+Qubit multi\+Qubit, const int control\+Qubit, const int target\+Qubit, Complex rot1, Complex rot2, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out)}{controlledCompactUnitaryDistributed(MultiQubit multiQubit, const int controlQubit, const int targetQubit, Complex rot1, Complex rot2, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void controlled\+Compact\+Unitary\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex}}]{rot1, }
\item[{{\bf Complex}}]{rot2, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}{}\label{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. 

Only perform the rotation where the control qubit is one.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & qubit to determine whether or not to perform a rotation \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 856 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, Complex\+::real, and R\+E\+AL.



Referenced by controlled\+Compact\+Unitary().


\begin{DoxyCode}
861 \{
862 
863         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
864         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
865         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
866         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
867         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
868 
869         \textcolor{keywordtype}{int} controlBit;
870 
871     \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
872         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
873         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
874         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
875         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
876 
877 \textcolor{preprocessor}{# ifdef \_OPENMP}
878 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
879 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
880 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
881 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag) \(\backslash\)}
882 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit)}
883 \textcolor{preprocessor}{# endif}
884         \{
885 \textcolor{preprocessor}{# ifdef \_OPENMP}
886 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
887 \textcolor{preprocessor}{# endif}
888                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
889                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, thisTask+chunkId*chunkSize);
890                         \textcolor{keywordflow}{if} (controlBit)\{
891                                 \textcolor{comment}{// store current state vector values in temp variables}
892                                 stateRealUp = stateVecRealUp[thisTask];
893                                 stateImagUp = stateVecImagUp[thisTask];
894 
895                                 stateRealLo = stateVecRealLo[thisTask];
896                                 stateImagLo = stateVecImagLo[thisTask];
897 
898                                 \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
899                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp + 
      rot2Real*stateRealLo + rot2Imag*stateImagLo;
900                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp + 
      rot2Real*stateImagLo - rot2Imag*stateRealLo;
901                         \}
902                 \}
903         \}
904 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!controlled\+Compact\+Unitary\+Local@{controlled\+Compact\+Unitary\+Local}}
\index{controlled\+Compact\+Unitary\+Local@{controlled\+Compact\+Unitary\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{controlled\+Compact\+Unitary\+Local(\+Multi\+Qubit multi\+Qubit, const int control\+Qubit, const int target\+Qubit, Complex alpha, Complex beta)}{controlledCompactUnitaryLocal(MultiQubit multiQubit, const int controlQubit, const int targetQubit, Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}void controlled\+Compact\+Unitary\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}{}\label{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}


Definition at line 647 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, Complex\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by controlled\+Compact\+Unitary().


\begin{DoxyCode}
649 \{
650         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
651         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
652              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
653 
654         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
655         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
656         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
657         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
658         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
659 
660         \textcolor{keywordtype}{int} controlBit;
661 
662     \textcolor{comment}{// set dimensions}
663         sizeHalfBlock = 1LL << targetQubit;  
664         sizeBlock     = 2LL * sizeHalfBlock; 
665 
666         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
667         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
668         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
669         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} alphaImag=alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, alphaReal=alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
670         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} betaImag=beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, betaReal=beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
671 
672 \textcolor{preprocessor}{# ifdef \_OPENMP}
673 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
674 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
675 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,alphaImag,
       betaReal,betaImag) \(\backslash\)}
676 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo,
       stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit) }
677 \textcolor{preprocessor}{# endif}
678         \{
679 \textcolor{preprocessor}{# ifdef \_OPENMP}
680 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
681 \textcolor{preprocessor}{# endif}
682                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
683 
684                         thisBlock   = thisTask / sizeHalfBlock;
685                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
686                         indexLo     = indexUp + sizeHalfBlock;
687 
688                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, indexUp+chunkId*chunkSize);
689                         \textcolor{keywordflow}{if} (controlBit)\{
690                                 \textcolor{comment}{// store current state vector values in temp variables}
691                                 stateRealUp = stateVecReal[indexUp];
692                                 stateImagUp = stateVecImag[indexUp];
693 
694                                 stateRealLo = stateVecReal[indexLo];
695                                 stateImagLo = stateVecImag[indexLo];
696 
697                                 \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
698                                 stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag*stateImagUp 
699                                         - betaReal*stateRealLo - betaImag*stateImagLo;
700                                 stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag*stateRealUp 
701                                         - betaReal*stateImagLo + betaImag*stateRealLo;
702 
703                                 \textcolor{comment}{// state[indexLo] = beta  * state[indexUp] + conj(alpha) * state[indexLo]}
704                                 stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*stateImagUp 
705                                         + alphaReal*stateRealLo + alphaImag*stateImagLo;
706                                 stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*stateRealUp 
707                                         + alphaReal*stateImagLo - alphaImag*stateRealLo;
708                         \}
709                 \} 
710         \}
711 
712 \} 
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!controlled\+Not\+Distributed@{controlled\+Not\+Distributed}}
\index{controlled\+Not\+Distributed@{controlled\+Not\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{controlled\+Not\+Distributed(\+Multi\+Qubit multi\+Qubit, const int control\+Qubit, const int target\+Qubit, Complex\+Array state\+Vec\+In, Complex\+Array state\+Vec\+Out)}{controlledNotDistributed(MultiQubit multiQubit, const int controlQubit, const int targetQubit, ComplexArray stateVecIn, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void controlled\+Not\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+In, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}{}\label{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}


Rotate a single qubit by \{\{0,1\},\{1,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk. Only perform the rotation for elements where control\+Qubit is one.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 1185 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, and R\+E\+AL.



Referenced by controlled\+Not().


\begin{DoxyCode}
1188 \{
1189 
1190         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
1191         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1192         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1193         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
1194 
1195         \textcolor{keywordtype}{int} controlBit;
1196 
1197         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1198         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1199 
1200 \textcolor{preprocessor}{# ifdef \_OPENMP}
1201 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1202 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1203 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) \(\backslash\)}
1204 \textcolor{preprocessor}{        private  (thisTask,controlBit)}
1205 \textcolor{preprocessor}{# endif}
1206         \{
1207 \textcolor{preprocessor}{# ifdef \_OPENMP}
1208 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1209 \textcolor{preprocessor}{# endif}
1210                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1211                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, thisTask+chunkId*chunkSize);
1212                         \textcolor{keywordflow}{if} (controlBit)\{
1213                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
1214                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
1215                         \}
1216                 \}
1217         \}
1218 \} 
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!controlled\+Not\+Local@{controlled\+Not\+Local}}
\index{controlled\+Not\+Local@{controlled\+Not\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{controlled\+Not\+Local(\+Multi\+Qubit multi\+Qubit, const int control\+Qubit, const int target\+Qubit)}{controlledNotLocal(MultiQubit multiQubit, const int controlQubit, const int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void controlled\+Not\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{const int}]{target\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}{}\label{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}


Definition at line 1120 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by controlled\+Not().


\begin{DoxyCode}
1121 \{
1122         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
1123         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
1124              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
1125 
1126         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
1127         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1128         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1129         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1130         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
1131 
1132         \textcolor{keywordtype}{int} controlBit;
1133 
1134         \textcolor{comment}{// set dimensions}
1135         sizeHalfBlock = 1LL << targetQubit;  
1136         sizeBlock     = 2LL * sizeHalfBlock; 
1137 
1138 
1139         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1140         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1141         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1142 
1143 \textcolor{preprocessor}{# ifdef \_OPENMP}
1144 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1145 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1146 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
1147 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,controlBit) }
1148 \textcolor{preprocessor}{# endif}
1149         \{
1150 \textcolor{preprocessor}{# ifdef \_OPENMP}
1151 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1152 \textcolor{preprocessor}{# endif}
1153                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1154                         thisBlock   = thisTask / sizeHalfBlock;
1155                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1156                         indexLo     = indexUp + sizeHalfBlock;
1157 
1158                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit}(controlQubit, indexUp+chunkId*chunkSize);
1159                         \textcolor{keywordflow}{if} (controlBit)\{
1160                                 stateRealUp = stateVecReal[indexUp];
1161                                 stateImagUp = stateVecImag[indexUp];
1162 
1163                                 stateVecReal[indexUp] = stateVecReal[indexLo];
1164                                 stateVecImag[indexUp] = stateVecImag[indexLo];
1165 
1166                                 stateVecReal[indexLo] = stateRealUp;
1167                                 stateVecImag[indexLo] = stateImagUp;
1168                         \}
1169                 \} 
1170         \}
1171 
1172 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!controlled\+Unitary\+Distributed@{controlled\+Unitary\+Distributed}}
\index{controlled\+Unitary\+Distributed@{controlled\+Unitary\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{controlled\+Unitary\+Distributed(\+Multi\+Qubit multi\+Qubit, const int control\+Qubit, const int target\+Qubit, Complex rot1, Complex rot2, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out)}{controlledUnitaryDistributed(MultiQubit multiQubit, const int controlQubit, const int targetQubit, Complex rot1, Complex rot2, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void controlled\+Unitary\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex}}]{rot1, }
\item[{{\bf Complex}}]{rot2, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}{}\label{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. 

Only perform the rotation where the control qubit is one.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & qubit to determine whether or not to perform a rotation \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 919 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, Complex\+::real, and R\+E\+AL.



Referenced by controlled\+Unitary().


\begin{DoxyCode}
924 \{
925 
926         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
927         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
928         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
929         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
930         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
931 
932         \textcolor{keywordtype}{int} controlBit;
933 
934         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
935         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
936         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
937         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
938         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
939 
940 \textcolor{preprocessor}{# ifdef \_OPENMP}
941 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
942 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
943 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
944 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag) \(\backslash\)}
945 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit)}
946 \textcolor{preprocessor}{# endif}
947         \{
948 \textcolor{preprocessor}{# ifdef \_OPENMP}
949 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
950 \textcolor{preprocessor}{# endif}
951                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
952                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, thisTask+chunkId*chunkSize);
953                         \textcolor{keywordflow}{if} (controlBit)\{
954                                 \textcolor{comment}{// store current state vector values in temp variables}
955                                 stateRealUp = stateVecRealUp[thisTask];
956                                 stateImagUp = stateVecImagUp[thisTask];
957 
958                                 stateRealLo = stateVecRealLo[thisTask];
959                                 stateImagLo = stateVecImagLo[thisTask];
960 
961                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp 
962                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
963                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp 
964                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
965                         \}
966                 \}
967         \}
968 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!controlled\+Unitary\+Local@{controlled\+Unitary\+Local}}
\index{controlled\+Unitary\+Local@{controlled\+Unitary\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{controlled\+Unitary\+Local(\+Multi\+Qubit multi\+Qubit, const int control\+Qubit, const int target\+Qubit, Complex\+Matrix2 u)}{controlledUnitaryLocal(MultiQubit multiQubit, const int controlQubit, const int targetQubit, ComplexMatrix2 u)}}]{\setlength{\rightskip}{0pt plus 5cm}void controlled\+Unitary\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex\+Matrix2}}]{u}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}{}\label{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}


Definition at line 777 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Matrix2\+::r0c0, Complex\+Matrix2\+::r0c1, Complex\+Matrix2\+::r1c0, Complex\+Matrix2\+::r1c1, Complex\+Array\+::real, Complex\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by controlled\+Unitary().


\begin{DoxyCode}
779 \{
780         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
781         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
782              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
783 
784         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
785         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
786         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
787         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
788         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
789 
790         \textcolor{keywordtype}{int} controlBit;
791 
792     \textcolor{comment}{// set dimensions}
793         sizeHalfBlock = 1LL << targetQubit;  
794         sizeBlock     = 2LL * sizeHalfBlock; 
795 
796         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
797         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
798         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
799 
800 \textcolor{preprocessor}{# ifdef \_OPENMP}
801 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
802 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
803 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \(\backslash\)}
804 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo,
       stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit) }
805 \textcolor{preprocessor}{# endif}
806         \{
807 \textcolor{preprocessor}{# ifdef \_OPENMP}
808 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
809 \textcolor{preprocessor}{# endif}
810                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
811 
812                         thisBlock   = thisTask / sizeHalfBlock;
813                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
814                         indexLo     = indexUp + sizeHalfBlock;
815 
816                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, indexUp+chunkId*chunkSize);
817                         \textcolor{keywordflow}{if} (controlBit)\{
818                                 \textcolor{comment}{// store current state vector values in temp variables}
819                                 stateRealUp = stateVecReal[indexUp];
820                                 stateImagUp = stateVecImag[indexUp];
821 
822                                 stateRealLo = stateVecReal[indexLo];
823                                 stateImagLo = stateVecImag[indexLo];
824 
825 
826                                 \textcolor{comment}{// state[indexUp] = u00 * state[indexUp] + u01 * state[indexLo]}
827                                 stateVecReal[indexUp] = u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealUp - u.
      \hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagUp 
828                                         + u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealLo - u.
      \hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagLo;
829                                 stateVecImag[indexUp] = u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagUp + u.
      \hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealUp 
830                                         + u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagLo + u.
      \hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealLo;
831 
832                                 \textcolor{comment}{// state[indexLo] = u10  * state[indexUp] + u11 * state[indexLo]}
833                                 stateVecReal[indexLo] = u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealUp  - u.
      \hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagUp 
834                                         + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealLo  -  u.
      \hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagLo;
835                                 stateVecImag[indexLo] = u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagUp + u.
      \hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealUp 
836                                         + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagLo + u.
      \hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealLo;
837                         \}
838                 \} 
839         \}
840 
841 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!exit\+With\+Error@{exit\+With\+Error}}
\index{exit\+With\+Error@{exit\+With\+Error}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{exit\+With\+Error(int error\+Code, const char $\ast$func)}{exitWithError(int errorCode, const char *func)}}]{\setlength{\rightskip}{0pt plus 5cm}void exit\+With\+Error (
\begin{DoxyParamCaption}
\item[{int}]{error\+Code, }
\item[{const char $\ast$}]{func}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}{}\label{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}


Definition at line 234 of file qubits\+\_\+env\+\_\+local.\+c.



References error\+Codes.



Referenced by Qu\+E\+S\+T\+Assert().


\begin{DoxyCode}
234                                                    \{
235     printf(\textcolor{stringliteral}{"!!!\(\backslash\)n"});
236     printf(\textcolor{stringliteral}{"QuEST Error in function %s: %s\(\backslash\)n"}, func, \hyperlink{qubits_8c_aac1637696885c75b73a1ecf381cea713}{errorCodes}[errorCode]);
237     printf(\textcolor{stringliteral}{"!!!\(\backslash\)n"});
238     printf(\textcolor{stringliteral}{"exiting..\(\backslash\)n"});
239     exit(errorCode);
240 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}}
\index{find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{find\+Probability\+Of\+Zero\+Distributed(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit)}{findProbabilityOfZeroDistributed(MultiQubit multiQubit, const int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} find\+Probability\+Of\+Zero\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{}\label{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}


Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. 

Size of regions to skip is a multiple of chunk\+Size.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 1642 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Outcome().


\begin{DoxyCode}
1644 \{
1645         \textcolor{comment}{// ----- measured probability}
1646         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
1647         \textcolor{comment}{// ----- temp variables}
1648         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1649         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1650 
1651         \textcolor{comment}{// ---------------------------------------------------------------- //}
1652         \textcolor{comment}{//            find probability                                      //}
1653         \textcolor{comment}{// ---------------------------------------------------------------- //}
1654 
1655         \textcolor{comment}{// initialise returned value}
1656         totalProbability = 0.0;
1657 
1658         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1659         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1660 
1661 \textcolor{preprocessor}{# ifdef \_OPENMP}
1662 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1663 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1664 \textcolor{preprocessor}{        private   (thisTask) \(\backslash\)}
1665 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
1666 \textcolor{preprocessor}{# endif}
1667         \{
1668 \textcolor{preprocessor}{# ifdef \_OPENMP}
1669 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1670 \textcolor{preprocessor}{# endif}
1671                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1672                         \textcolor{comment}{// summation -- simple implementation}
1673                         totalProbability += stateVecReal[thisTask]*stateVecReal[thisTask]
1674                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
1675 
1676                         \textcolor{comment}{/*}
1677 \textcolor{comment}{                        // summation -- kahan correction}
1678 \textcolor{comment}{                        y = stateVecReal[thisTask]*stateVecReal[thisTask]}
1679 \textcolor{comment}{                        + stateVecImag[thisTask]*stateVecImag[thisTask] - c;}
1680 \textcolor{comment}{                        t = totalProbability + y;}
1681 \textcolor{comment}{                        c = (t - totalProbability) - y;}
1682 \textcolor{comment}{                        totalProbability = t;}
1683 \textcolor{comment}{                        */}
1684 
1685                 \}
1686         \}
1687 
1688         \textcolor{keywordflow}{return} totalProbability;
1689 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}}
\index{find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{find\+Probability\+Of\+Zero\+Local(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit)}{findProbabilityOfZeroLocal(MultiQubit multiQubit, const int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} find\+Probability\+Of\+Zero\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{}\label{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}


Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. 

Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 1570 of file qubits.\+c.



References D\+E\+B\+UG, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Outcome().


\begin{DoxyCode}
1572 \{
1573         \textcolor{comment}{// ----- sizes}
1574         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
1575         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
1576         \textcolor{comment}{// ----- indices}
1577         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
1578              index;                                               \textcolor{comment}{// current index for first half block}
1579         \textcolor{comment}{// ----- measured probability}
1580         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
1581         \textcolor{comment}{// ----- temp variables}
1582         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1583         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1584 
1585         \textcolor{comment}{// ---------------------------------------------------------------- //}
1586         \textcolor{comment}{//            dimensions                                            //}
1587         \textcolor{comment}{// ---------------------------------------------------------------- //}
1588         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
1589         \textcolor{comment}{// and then the number to skip}
1590         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
1591 
1592         \textcolor{comment}{// initialise returned value}
1593         totalProbability = 0.0;
1594 
1595         \textcolor{comment}{// initialise correction for kahan summation}
1596         \textcolor{keywordflow}{if} (\hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\(\backslash\)n"},sizeHalfBlock,sizeBlock,
      numTasks);
1597 
1598         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1599         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1600 
1601 \textcolor{preprocessor}{# ifdef \_OPENMP}
1602 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1603 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
1604 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index) \(\backslash\)}
1605 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
1606 \textcolor{preprocessor}{# endif }
1607         \{
1608 \textcolor{preprocessor}{# ifdef \_OPENMP}
1609 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1610 \textcolor{preprocessor}{# endif}
1611                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1612                         thisBlock = thisTask / sizeHalfBlock;
1613                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1614 
1615                         \textcolor{keywordflow}{if} (index<0)\{ printf(\textcolor{stringliteral}{"ABORTING as index=%Ld with thisBlock = %Ld  thisTask=%Ld \(\backslash\)n"},
       index,thisBlock,thisTask); exit(1);\}
1616 
1617                         \textcolor{comment}{// summation -- simple implementation}
1618                         totalProbability += stateVecReal[index]*stateVecReal[index]
1619                                 + stateVecImag[index]*stateVecImag[index];
1620 
1621                         \textcolor{comment}{/*}
1622 \textcolor{comment}{                        // summation -- kahan correction}
1623 \textcolor{comment}{                        y = stateVecReal[index]*stateVecReal[index]}
1624 \textcolor{comment}{                        + stateVecImag[index]*stateVecImag[index] - c;}
1625 \textcolor{comment}{                        t = totalProbability + y;}
1626 \textcolor{comment}{                        c = (t - totalProbability) - y;}
1627 \textcolor{comment}{                        totalProbability = t;}
1628 \textcolor{comment}{                        */}
1629 
1630                 \}
1631         \}
1632         \textcolor{keywordflow}{return} totalProbability;
1633 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!hadamard\+Distributed@{hadamard\+Distributed}}
\index{hadamard\+Distributed@{hadamard\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{hadamard\+Distributed(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out, int update\+Upper)}{hadamardDistributed(MultiQubit multiQubit, const int targetQubit, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut, int updateUpper)}}]{\setlength{\rightskip}{0pt plus 5cm}void hadamard\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out, }
\item[{int}]{update\+Upper}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}{}\label{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt in}  & {\em update\+Upper} & flag, 1\+: updating upper values, 0\+: updating lower values in block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 1373 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, and R\+E\+AL.



Referenced by hadamard().


\begin{DoxyCode}
1378 \{
1379 
1380         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1381         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
1382         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1383 
1384         \textcolor{keywordtype}{int} sign;
1385         \textcolor{keywordflow}{if} (updateUpper) sign=1;
1386         \textcolor{keywordflow}{else} sign=-1;
1387 
1388         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1389 
1390         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1391         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1392         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1393 
1394 \textcolor{preprocessor}{# ifdef \_OPENMP}
1395 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1396 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1397 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
1398 \textcolor{preprocessor}{                        recRoot2, sign) \(\backslash\)}
1399 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
1400 \textcolor{preprocessor}{# endif}
1401         \{
1402 \textcolor{preprocessor}{# ifdef \_OPENMP}
1403 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1404 \textcolor{preprocessor}{# endif}
1405                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1406                         \textcolor{comment}{// store current state vector values in temp variables}
1407                         stateRealUp = stateVecRealUp[thisTask];
1408                         stateImagUp = stateVecImagUp[thisTask];
1409 
1410                         stateRealLo = stateVecRealLo[thisTask];
1411                         stateImagLo = stateVecImagLo[thisTask];
1412 
1413                         stateVecRealOut[thisTask] = recRoot2*(stateRealUp + sign*stateRealLo);
1414                         stateVecImagOut[thisTask] = recRoot2*(stateImagUp + sign*stateImagLo);
1415                 \}
1416         \}
1417 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!hadamard\+Local@{hadamard\+Local}}
\index{hadamard\+Local@{hadamard\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{hadamard\+Local(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit)}{hadamardLocal(MultiQubit multiQubit, const int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void hadamard\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}{}\label{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}


Definition at line 1312 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by hadamard().


\begin{DoxyCode}
1313 \{
1314         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
1315         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
1316              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
1317 
1318         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1319         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1320         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1321 
1322         \textcolor{comment}{// set dimensions}
1323         sizeHalfBlock = 1LL << targetQubit;  
1324         sizeBlock     = 2LL * sizeHalfBlock; 
1325 
1326         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1327         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1328         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1329 
1330         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1331 
1332 \textcolor{preprocessor}{# ifdef \_OPENMP}
1333 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1334 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1335 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \(\backslash\)}
1336 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
1337 \textcolor{preprocessor}{# endif}
1338         \{
1339 \textcolor{preprocessor}{# ifdef \_OPENMP}
1340 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1341 \textcolor{preprocessor}{# endif}
1342                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1343                         thisBlock   = thisTask / sizeHalfBlock;
1344                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1345                         indexLo     = indexUp + sizeHalfBlock;
1346 
1347                         stateRealUp = stateVecReal[indexUp];
1348                         stateImagUp = stateVecImag[indexUp];
1349 
1350                         stateRealLo = stateVecReal[indexLo];
1351                         stateImagLo = stateVecImag[indexLo];
1352 
1353                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateRealLo);
1354                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImagLo);
1355 
1356                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateRealLo);
1357                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImagLo);
1358                 \} 
1359         \}
1360 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!multi\+Controlled\+Unitary\+Distributed@{multi\+Controlled\+Unitary\+Distributed}}
\index{multi\+Controlled\+Unitary\+Distributed@{multi\+Controlled\+Unitary\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{multi\+Controlled\+Unitary\+Distributed(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, long long int mask, Complex rot1, Complex rot2, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out)}{multiControlledUnitaryDistributed(MultiQubit multiQubit, const int targetQubit, long long int mask, Complex rot1, Complex rot2, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void multi\+Controlled\+Unitary\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{long long int}]{mask, }
\item[{{\bf Complex}}]{rot1, }
\item[{{\bf Complex}}]{rot2, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{}\label{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}


Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. 

Only perform the rotation where all the control qubits are 1.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & qubit to determine whether or not to perform a rotation \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 983 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, Complex\+::real, and R\+E\+AL.



Referenced by multi\+Controlled\+Unitary().


\begin{DoxyCode}
990 \{
991 
992         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
993         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
994         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
995         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
996         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
997 
998         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
999         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
1000         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1001         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1002         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1003 
1004 \textcolor{preprocessor}{# ifdef \_OPENMP}
1005 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1006 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1007 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
1008 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag, mask) \(\backslash\)}
1009 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
1010 \textcolor{preprocessor}{# endif}
1011         \{
1012 \textcolor{preprocessor}{# ifdef \_OPENMP}
1013 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1014 \textcolor{preprocessor}{# endif}
1015                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1016                         \textcolor{keywordflow}{if} (mask == (mask & (thisTask+chunkId*chunkSize)) )\{
1017                                 \textcolor{comment}{// store current state vector values in temp variables}
1018                                 stateRealUp = stateVecRealUp[thisTask];
1019                                 stateImagUp = stateVecImagUp[thisTask];
1020 
1021                                 stateRealLo = stateVecRealLo[thisTask];
1022                                 stateImagLo = stateVecImagLo[thisTask];
1023 
1024                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp 
1025                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
1026                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp 
1027                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
1028                         \}
1029                 \}
1030         \}
1031 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!multi\+Controlled\+Unitary\+Local@{multi\+Controlled\+Unitary\+Local}}
\index{multi\+Controlled\+Unitary\+Local@{multi\+Controlled\+Unitary\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{multi\+Controlled\+Unitary\+Local(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, long long int mask, Complex\+Matrix2 u)}{multiControlledUnitaryLocal(MultiQubit multiQubit, const int targetQubit, long long int mask, ComplexMatrix2 u)}}]{\setlength{\rightskip}{0pt plus 5cm}void multi\+Controlled\+Unitary\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{long long int}]{mask, }
\item[{{\bf Complex\+Matrix2}}]{u}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}{}\label{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}


Definition at line 714 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Matrix2\+::r0c0, Complex\+Matrix2\+::r0c1, Complex\+Matrix2\+::r1c0, Complex\+Matrix2\+::r1c1, Complex\+Array\+::real, Complex\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by multi\+Controlled\+Unitary().


\begin{DoxyCode}
716 \{
717         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
718         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
719              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
720 
721         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
722         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
723         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
724         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
725         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
726 
727         \textcolor{comment}{// set dimensions}
728         sizeHalfBlock = 1LL << targetQubit;  
729         sizeBlock     = 2LL * sizeHalfBlock; 
730 
731         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
732         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
733         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
734 
735 \textcolor{preprocessor}{# ifdef \_OPENMP}
736 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
737 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
738 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u, mask) \(\backslash\)}
739 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
740 \textcolor{preprocessor}{# endif}
741         \{
742 \textcolor{preprocessor}{# ifdef \_OPENMP}
743 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
744 \textcolor{preprocessor}{# endif}
745                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
746 
747                         thisBlock   = thisTask / sizeHalfBlock;
748                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
749                         indexLo     = indexUp + sizeHalfBlock;
750 
751                         \textcolor{keywordflow}{if} (mask == (mask & (indexUp+chunkId*chunkSize)) )\{
752                                 \textcolor{comment}{// store current state vector values in temp variables}
753                                 stateRealUp = stateVecReal[indexUp];
754                                 stateImagUp = stateVecImag[indexUp];
755 
756                                 stateRealLo = stateVecReal[indexLo];
757                                 stateImagLo = stateVecImag[indexLo];
758 
759 
760                                 \textcolor{comment}{// state[indexUp] = u00 * state[indexUp] + u01 * state[indexLo]}
761                                 stateVecReal[indexUp] = u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealUp - u.
      \hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagUp 
762                                         + u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealLo - u.
      \hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagLo;
763                                 stateVecImag[indexUp] = u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagUp + u.
      \hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealUp 
764                                         + u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagLo + u.
      \hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealLo;
765 
766                                 \textcolor{comment}{// state[indexLo] = u10  * state[indexUp] + u11 * state[indexLo]}
767                                 stateVecReal[indexLo] = u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealUp  - u.
      \hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagUp 
768                                         + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealLo  -  u.
      \hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagLo;
769                                 stateVecImag[indexLo] = u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagUp + u.
      \hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealUp 
770                                         + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagLo + u.
      \hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealLo;
771                         \}
772                 \} 
773         \}
774 
775 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!phase\+Gate@{phase\+Gate}}
\index{phase\+Gate@{phase\+Gate}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{phase\+Gate(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, enum phase\+Gate\+Type type)}{phaseGate(MultiQubit multiQubit, const int targetQubit, enum phaseGateType type)}}]{\setlength{\rightskip}{0pt plus 5cm}void phase\+Gate (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{enum {\bf phase\+Gate\+Type}}]{type}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}{}\label{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}


Definition at line 166 of file qubits\+\_\+env\+\_\+local.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, phase\+Gate\+Distributed(), phase\+Gate\+Local(), and Qu\+E\+S\+T\+Assert().



Referenced by s\+Gate(), sigma\+Z(), and t\+Gate().


\begin{DoxyCode}
167 \{
168     \hyperlink{qubits__env__local_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(targetQubit >= 0 && targetQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 1, \_\_func\_\_);
169         \hyperlink{qubits_8c_a3a54566b73ac84c312d7da4f56ffbc3b}{phaseGateLocal}(multiQubit, targetQubit, type);
170 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!phase\+Gate\+Distributed@{phase\+Gate\+Distributed}}
\index{phase\+Gate\+Distributed@{phase\+Gate\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{phase\+Gate\+Distributed(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, enum phase\+Gate\+Type type)}{phaseGateDistributed(MultiQubit multiQubit, const int targetQubit, enum phaseGateType type)}}]{\setlength{\rightskip}{0pt plus 5cm}void phase\+Gate\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{enum {\bf phase\+Gate\+Type}}]{type}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}{}\label{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}


Definition at line 1495 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, S\+\_\+\+G\+A\+TE, S\+I\+G\+M\+A\+\_\+Z, Multi\+Qubit\+::state\+Vec, and T\+\_\+\+G\+A\+TE.



Referenced by phase\+Gate().


\begin{DoxyCode}
1496 \{
1497         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealLo,stateImagLo;
1498         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1499         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1500 
1501         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1502         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1503         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1504 
1505         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1506 
1507 \textcolor{preprocessor}{# ifdef \_OPENMP}
1508 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1509 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1510 \textcolor{preprocessor}{        shared   (stateVecReal,stateVecImag, recRoot2, type) \(\backslash\)}
1511 \textcolor{preprocessor}{        private  (thisTask,stateRealLo,stateImagLo) }
1512 \textcolor{preprocessor}{# endif}
1513         \{
1514                 \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{SIGMA\_Z})\{
1515 \textcolor{preprocessor}{# ifdef \_OPENMP}
1516 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1517 \textcolor{preprocessor}{# endif}
1518                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1519                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
1520                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
1521                         \} 
1522                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{S\_GATE})\{
1523 \textcolor{preprocessor}{# ifdef \_OPENMP}
1524 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1525 \textcolor{preprocessor}{# endif}
1526                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1527                                 stateRealLo = stateVecReal[thisTask];
1528                                 stateImagLo = stateVecImag[thisTask];
1529 
1530                                 stateVecReal[thisTask] = -stateImagLo;
1531                                 stateVecImag[thisTask] = stateRealLo;
1532                         \} 
1533                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{T\_GATE})\{
1534 \textcolor{preprocessor}{# ifdef \_OPENMP}
1535 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1536 \textcolor{preprocessor}{# endif}
1537                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1538                                 stateRealLo = stateVecReal[thisTask];
1539                                 stateImagLo = stateVecImag[thisTask];
1540 
1541                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo - stateImagLo);
1542                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo + stateImagLo);
1543                         \} 
1544                 \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"Type %d is an invalid phase gate\(\backslash\)n"}, type);
1545         \}
1546 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!phase\+Gate\+Local@{phase\+Gate\+Local}}
\index{phase\+Gate\+Local@{phase\+Gate\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{phase\+Gate\+Local(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, enum phase\+Gate\+Type type)}{phaseGateLocal(MultiQubit multiQubit, const int targetQubit, enum phaseGateType type)}}]{\setlength{\rightskip}{0pt plus 5cm}void phase\+Gate\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{enum {\bf phase\+Gate\+Type}}]{type}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}{}\label{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}
fix -- can i rewrite this to not use mod?

fix -- can i rewrite this to not use mod?

fix -- can i rewrite this to not use mod? 

Definition at line 1419 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, S\+\_\+\+G\+A\+TE, S\+I\+G\+M\+A\+\_\+Z, Multi\+Qubit\+::state\+Vec, and T\+\_\+\+G\+A\+TE.



Referenced by phase\+Gate().


\begin{DoxyCode}
1420 \{
1421         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
1422         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
1423              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
1424 
1425         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealLo,stateImagLo;
1426         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1427         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1428 
1429         \textcolor{comment}{// set dimensions}
1430         sizeHalfBlock = 1LL << targetQubit;  
1431         sizeBlock     = 2LL * sizeHalfBlock; 
1432 
1433         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1434         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1435         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1436 
1437         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1438 
1439 \textcolor{preprocessor}{# ifdef \_OPENMP}
1440 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1441 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1442 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type) \(\backslash\)}
1443 \textcolor{preprocessor}{        private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) }
1444 \textcolor{preprocessor}{# endif}
1445         \{
1446                 \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{SIGMA\_Z})\{
1447 \textcolor{preprocessor}{# ifdef \_OPENMP}
1448 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1449 \textcolor{preprocessor}{# endif}
1450                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1452                                 thisBlock   = thisTask / sizeHalfBlock;
1453                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1454                                 indexLo     = indexUp + sizeHalfBlock;
1455 
1456                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
1457                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
1458                         \} 
1459                 \} 
1460                 
1461                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{S\_GATE})\{
1462 \textcolor{preprocessor}{# ifdef \_OPENMP}
1463 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1464 \textcolor{preprocessor}{# endif}
1465                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1467                                 thisBlock   = thisTask / sizeHalfBlock;
1468                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1469                                 indexLo     = indexUp + sizeHalfBlock;
1470                                 stateRealLo = stateVecReal[indexLo];
1471                                 stateImagLo = stateVecImag[indexLo];
1472 
1473                                 stateVecReal[indexLo] = -stateImagLo;
1474                                 stateVecImag[indexLo] = stateRealLo;
1475                         \} 
1476                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{T\_GATE})\{
1477 \textcolor{preprocessor}{# ifdef \_OPENMP}
1478 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1479 \textcolor{preprocessor}{# endif}
1480                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1482                                 thisBlock   = thisTask / sizeHalfBlock;
1483                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1484                                 indexLo     = indexUp + sizeHalfBlock;
1485                                 stateRealLo = stateVecReal[indexLo];
1486                                 stateImagLo = stateVecImag[indexLo];
1487 
1488                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo - stateImagLo);
1489                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo + stateImagLo);
1490                         \} 
1491                 \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"Type %d is an invalid phase gate\(\backslash\)n"}, type);
1492         \}
1493 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!Qu\+E\+S\+T\+Assert@{Qu\+E\+S\+T\+Assert}}
\index{Qu\+E\+S\+T\+Assert@{Qu\+E\+S\+T\+Assert}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{Qu\+E\+S\+T\+Assert(int is\+Valid, int error\+Code, const char $\ast$func)}{QuESTAssert(int isValid, int errorCode, const char *func)}}]{\setlength{\rightskip}{0pt plus 5cm}void Qu\+E\+S\+T\+Assert (
\begin{DoxyParamCaption}
\item[{int}]{is\+Valid, }
\item[{int}]{error\+Code, }
\item[{const char $\ast$}]{func}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}{}\label{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}


Definition at line 242 of file qubits\+\_\+env\+\_\+local.\+c.



References exit\+With\+Error().



Referenced by collapse\+To\+Outcome(), compact\+Unitary(), controlled\+Compact\+Unitary(), controlled\+Not(), controlled\+Phase\+Gate(), controlled\+Unitary(), create\+Multi\+Qubit(), find\+Probability\+Of\+Outcome(), hadamard(), measure(), measure\+With\+Stats(), multi\+Controlled\+Phase\+Gate(), multi\+Controlled\+Unitary(), phase\+Gate(), sigma\+X(), sigma\+Y(), and unitary().


\begin{DoxyCode}
242                                                               \{
243     \textcolor{keywordflow}{if} (!isValid) \hyperlink{qubits__env__local_8c_ae5f9019826f35e8b51b1716cfe397b45}{exitWithError}(errorCode, func);
244 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!sigma\+X\+Distributed@{sigma\+X\+Distributed}}
\index{sigma\+X\+Distributed@{sigma\+X\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{sigma\+X\+Distributed(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, Complex\+Array state\+Vec\+In, Complex\+Array state\+Vec\+Out)}{sigmaXDistributed(MultiQubit multiQubit, const int targetQubit, ComplexArray stateVecIn, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigma\+X\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+In, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}{}\label{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}


Rotate a single qubit by \{\{0,1\},\{1,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 1092 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, and R\+E\+AL.



Referenced by sigma\+X().


\begin{DoxyCode}
1095 \{
1096 
1097         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
1098         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1099 
1100         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1101         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1102 
1103 \textcolor{preprocessor}{# ifdef \_OPENMP}
1104 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1105 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1106 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) \(\backslash\)}
1107 \textcolor{preprocessor}{        private  (thisTask)}
1108 \textcolor{preprocessor}{# endif}
1109         \{
1110 \textcolor{preprocessor}{# ifdef \_OPENMP}
1111 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1112 \textcolor{preprocessor}{# endif}
1113                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1114                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
1115                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
1116                 \}
1117         \}
1118 \} 
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!sigma\+X\+Local@{sigma\+X\+Local}}
\index{sigma\+X\+Local@{sigma\+X\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{sigma\+X\+Local(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit)}{sigmaXLocal(MultiQubit multiQubit, const int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigma\+X\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}{}\label{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}


Definition at line 1033 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by sigma\+X().


\begin{DoxyCode}
1034 \{
1035         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
1036         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
1037              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
1038 
1039         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
1040         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1041         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1042 
1043         \textcolor{comment}{// set dimensions}
1044         sizeHalfBlock = 1LL << targetQubit;  
1045         sizeBlock     = 2LL * sizeHalfBlock; 
1046 
1047         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1048         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1049         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1050 
1051 \textcolor{preprocessor}{# ifdef \_OPENMP}
1052 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1053 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1054 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
1055 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) }
1056 \textcolor{preprocessor}{# endif}
1057         \{
1058 \textcolor{preprocessor}{# ifdef \_OPENMP}
1059 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1060 \textcolor{preprocessor}{# endif}
1061                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1062                         thisBlock   = thisTask / sizeHalfBlock;
1063                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1064                         indexLo     = indexUp + sizeHalfBlock;
1065 
1066                         stateRealUp = stateVecReal[indexUp];
1067                         stateImagUp = stateVecImag[indexUp];
1068 
1069                         stateVecReal[indexUp] = stateVecReal[indexLo];
1070                         stateVecImag[indexUp] = stateVecImag[indexLo];
1071 
1072                         stateVecReal[indexLo] = stateRealUp;
1073                         stateVecImag[indexLo] = stateImagUp;
1074                 \} 
1075         \}
1076 
1077 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!sigma\+Y\+Distributed@{sigma\+Y\+Distributed}}
\index{sigma\+Y\+Distributed@{sigma\+Y\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{sigma\+Y\+Distributed(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, Complex\+Array state\+Vec\+In, Complex\+Array state\+Vec\+Out, int update\+Upper)}{sigmaYDistributed(MultiQubit multiQubit, const int targetQubit, ComplexArray stateVecIn, ComplexArray stateVecOut, int updateUpper)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigma\+Y\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+In, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out, }
\item[{int}]{update\+Upper}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}{}\label{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt in}  & {\em update\+Upper} & flag, 1\+: updating upper values, 0\+: updating lower values in block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 1279 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, and R\+E\+AL.



Referenced by sigma\+Y().


\begin{DoxyCode}
1283 \{
1284 
1285         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
1286         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1287 
1288         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1289         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1290 
1291         \textcolor{keywordtype}{int} realSign=1, imagSign=1;
1292         \textcolor{keywordflow}{if} (updateUpper) imagSign=-1;
1293         \textcolor{keywordflow}{else} realSign = -1;
1294 
1295 \textcolor{preprocessor}{# ifdef \_OPENMP}
1296 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1297 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1298 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,realSign,imagSign) \(\backslash\)}
1299 \textcolor{preprocessor}{        private  (thisTask)}
1300 \textcolor{preprocessor}{# endif}
1301         \{
1302 \textcolor{preprocessor}{# ifdef \_OPENMP}
1303 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1304 \textcolor{preprocessor}{# endif}
1305                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1306                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisTask];
1307                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisTask];
1308                 \}
1309         \}
1310 \} 
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!sigma\+Y\+Local@{sigma\+Y\+Local}}
\index{sigma\+Y\+Local@{sigma\+Y\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{sigma\+Y\+Local(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit)}{sigmaYLocal(MultiQubit multiQubit, const int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigma\+Y\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}{}\label{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}


Definition at line 1220 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by sigma\+Y().


\begin{DoxyCode}
1221 \{
1222         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
1223         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
1224              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
1225 
1226         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
1227         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1228         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1229 
1230         \textcolor{comment}{// set dimensions}
1231         sizeHalfBlock = 1LL << targetQubit;  
1232         sizeBlock     = 2LL * sizeHalfBlock; 
1233 
1234         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1235         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1236         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1237 
1238 \textcolor{preprocessor}{# ifdef \_OPENMP}
1239 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1240 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1241 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
1242 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) }
1243 \textcolor{preprocessor}{# endif}
1244         \{
1245 \textcolor{preprocessor}{# ifdef \_OPENMP}
1246 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1247 \textcolor{preprocessor}{# endif}
1248                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1249                         thisBlock   = thisTask / sizeHalfBlock;
1250                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1251                         indexLo     = indexUp + sizeHalfBlock;
1252 
1253                         stateRealUp = stateVecReal[indexUp];
1254                         stateImagUp = stateVecImag[indexUp];
1255 
1256                         stateVecReal[indexUp] = stateVecImag[indexLo];
1257                         stateVecImag[indexUp] = -stateVecReal[indexLo];
1258 
1259                         stateVecReal[indexLo] = -stateImagUp;
1260                         stateVecImag[indexLo] = stateRealUp;
1261                 \} 
1262         \}
1263 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!unitary\+Distributed@{unitary\+Distributed}}
\index{unitary\+Distributed@{unitary\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{unitary\+Distributed(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, Complex rot1, Complex rot2, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out)}{unitaryDistributed(MultiQubit multiQubit, const int targetQubit, Complex rot1, Complex rot2, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void unitary\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex}}]{rot1, }
\item[{{\bf Complex}}]{rot2, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}{}\label{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}


Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em u} & unitary matrix to apply \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 602 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, Complex\+::real, and R\+E\+AL.



Referenced by unitary().


\begin{DoxyCode}
607 \{
608 
609         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
610         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
611         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
612 
613         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
614         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
615         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
616         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
617         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
618 
619 
620 \textcolor{preprocessor}{# ifdef \_OPENMP}
621 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
622 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
623 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
624 \textcolor{preprocessor}{                        rot1Real, rot1Imag, rot2Real, rot2Imag) \(\backslash\)}
625 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
626 \textcolor{preprocessor}{# endif}
627         \{
628 \textcolor{preprocessor}{# ifdef \_OPENMP}
629 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
630 \textcolor{preprocessor}{# endif}
631                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
632                         \textcolor{comment}{// store current state vector values in temp variables}
633                         stateRealUp = stateVecRealUp[thisTask];
634                         stateImagUp = stateVecImagUp[thisTask];
635 
636                         stateRealLo = stateVecRealLo[thisTask];
637                         stateImagLo = stateVecImagLo[thisTask];
638 
639                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp 
640                                 + rot2Real*stateRealLo - rot2Imag*stateImagLo;
641                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp 
642                                 + rot2Real*stateImagLo + rot2Imag*stateRealLo;
643                 \}
644         \}
645 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!unitary\+Local@{unitary\+Local}}
\index{unitary\+Local@{unitary\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{unitary\+Local(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, Complex\+Matrix2 u)}{unitaryLocal(MultiQubit multiQubit, const int targetQubit, ComplexMatrix2 u)}}]{\setlength{\rightskip}{0pt plus 5cm}void unitary\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex\+Matrix2}}]{u}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}{}\label{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}


Definition at line 476 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Matrix2\+::r0c0, Complex\+Matrix2\+::r0c1, Complex\+Matrix2\+::r1c0, Complex\+Matrix2\+::r1c1, Complex\+Array\+::real, Complex\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by unitary().


\begin{DoxyCode}
477 \{
478         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
479         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
480              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
481 
482         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
483         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
484         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
485 
486         \textcolor{comment}{// set dimensions}
487         sizeHalfBlock = 1LL << targetQubit;  
488         sizeBlock     = 2LL * sizeHalfBlock; 
489 
490         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
491         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
492         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
493 
494 \textcolor{preprocessor}{# ifdef \_OPENMP}
495 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
496 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
497 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \(\backslash\)}
498 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
499 \textcolor{preprocessor}{# endif}
500         \{
501 \textcolor{preprocessor}{# ifdef \_OPENMP}
502 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
503 \textcolor{preprocessor}{# endif}
504                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
505 
506                         thisBlock   = thisTask / sizeHalfBlock;
507                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
508                         indexLo     = indexUp + sizeHalfBlock;
509 
510                         \textcolor{comment}{// store current state vector values in temp variables}
511                         stateRealUp = stateVecReal[indexUp];
512                         stateImagUp = stateVecImag[indexUp];
513 
514                         stateRealLo = stateVecReal[indexLo];
515                         stateImagLo = stateVecImag[indexLo];
516 
517 
518                         \textcolor{comment}{// state[indexUp] = u00 * state[indexUp] + u01 * state[indexLo]}
519                         stateVecReal[indexUp] = u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealUp - u.
      \hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagUp 
520                                 + u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealLo - u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.
      \hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagLo;
521                         stateVecImag[indexUp] = u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagUp + u.
      \hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealUp 
522                                 + u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagLo + u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.
      \hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealLo;
523 
524                         \textcolor{comment}{// state[indexLo] = u10  * state[indexUp] + u11 * state[indexLo]}
525                         stateVecReal[indexLo] = u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealUp  - u.
      \hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagUp 
526                                 + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealLo  -  u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.
      \hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagLo;
527                         stateVecImag[indexLo] = u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagUp + u.
      \hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealUp 
528                                 + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagLo + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.
      \hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealLo;
529 
530                 \} 
531         \}
532 \} 
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!validate\+Alpha\+Beta@{validate\+Alpha\+Beta}}
\index{validate\+Alpha\+Beta@{validate\+Alpha\+Beta}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{validate\+Alpha\+Beta(\+Complex alpha, Complex beta)}{validateAlphaBeta(Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}int validate\+Alpha\+Beta (
\begin{DoxyParamCaption}
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}{}\label{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}


Definition at line 365 of file qubits.\+c.



References Complex\+::imag, Complex\+::real, and R\+E\+A\+L\+\_\+\+E\+PS.



Referenced by compact\+Unitary(), and controlled\+Compact\+Unitary().


\begin{DoxyCode}
365                                                   \{
366         \textcolor{keywordflow}{if} ( fabs(alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} 
367                 + alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}
368                 + beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} 
369                 + beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag} - 1) > \hyperlink{precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS} ) \textcolor{keywordflow}{return} 0;
370         \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} 1;
371 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!validate\+Matrix\+Is\+Unitary@{validate\+Matrix\+Is\+Unitary}}
\index{validate\+Matrix\+Is\+Unitary@{validate\+Matrix\+Is\+Unitary}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{validate\+Matrix\+Is\+Unitary(\+Complex\+Matrix2 u)}{validateMatrixIsUnitary(ComplexMatrix2 u)}}]{\setlength{\rightskip}{0pt plus 5cm}int validate\+Matrix\+Is\+Unitary (
\begin{DoxyParamCaption}
\item[{{\bf Complex\+Matrix2}}]{u}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}{}\label{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}


Definition at line 340 of file qubits.\+c.



References Complex\+::imag, Complex\+Matrix2\+::r0c0, Complex\+Matrix2\+::r0c1, Complex\+Matrix2\+::r1c0, Complex\+Matrix2\+::r1c1, Complex\+::real, and R\+E\+A\+L\+\_\+\+E\+PS.



Referenced by controlled\+Unitary(), multi\+Controlled\+Unitary(), and unitary().


\begin{DoxyCode}
340                                              \{
341 
342         \textcolor{keywordflow}{if} ( fabs(u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} 
343                 + u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}
344                 + u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}
345                 + u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag} - 1) > \hyperlink{precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS} ) \textcolor{keywordflow}{return} 0;
346     \textcolor{comment}{// check}
347         \textcolor{keywordflow}{if} ( fabs(u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} 
348                 + u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}
349                 + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}
350                 + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag} - 1) > \hyperlink{precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS} ) \textcolor{keywordflow}{return} 0;
351 
352         \textcolor{keywordflow}{if} ( fabs(u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} 
353                 + u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}
354                 + u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}
355                 + u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}) > \hyperlink{precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS} ) \textcolor{keywordflow}{return} 0;
356 
357         \textcolor{keywordflow}{if} ( fabs(u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}
358                 - u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}
359                 + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}
360                 - u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}) > \hyperlink{precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS} ) \textcolor{keywordflow}{return} 0;
361 
362         \textcolor{keywordflow}{return} 1;
363 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!validate\+Unit\+Vector@{validate\+Unit\+Vector}}
\index{validate\+Unit\+Vector@{validate\+Unit\+Vector}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{validate\+Unit\+Vector(\+R\+E\+A\+L ux, R\+E\+A\+L uy, R\+E\+A\+L uz)}{validateUnitVector(REAL ux, REAL uy, REAL uz)}}]{\setlength{\rightskip}{0pt plus 5cm}int validate\+Unit\+Vector (
\begin{DoxyParamCaption}
\item[{{\bf R\+E\+AL}}]{ux, }
\item[{{\bf R\+E\+AL}}]{uy, }
\item[{{\bf R\+E\+AL}}]{uz}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}{}\label{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}


Definition at line 373 of file qubits.\+c.



References R\+E\+A\+L\+\_\+\+E\+PS.


\begin{DoxyCode}
373                                                  \{
374         \textcolor{keywordflow}{if} ( fabs(sqrt(ux*ux + uy*uy + uz*uz) - 1) > \hyperlink{precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS} ) \textcolor{keywordflow}{return} 0;
375         \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} 1;
376 \}
\end{DoxyCode}


\subsubsection{Variable Documentation}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!error\+Codes@{error\+Codes}}
\index{error\+Codes@{error\+Codes}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{error\+Codes}{errorCodes}}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ error\+Codes\mbox{[}$\,$\mbox{]}}\hypertarget{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}{}\label{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}


Definition at line 17 of file qubits.\+c.



Referenced by exit\+With\+Error().

