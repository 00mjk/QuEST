\hypertarget{qubits__internal_8h}{
\subsection{qubits\_\-internal.h File Reference}
\label{qubits__internal_8h}\index{qubits\_\-internal.h@{qubits\_\-internal.h}}
}


Internal functions used to implement the public facing API in \hyperlink{qubits_8h}{qubits.h}.  
{\ttfamily \#include \char`\"{}precision.h\char`\"{}}\par
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}{compactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}{compactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}{unitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}{unitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}{controlledCompactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}{controlledCompactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}{controlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}{controlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}{multiControlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{multiControlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}{sigmaXLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}{sigmaXDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}{sigmaYLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}{sigmaYDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}{hadamardLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}{hadamardDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}{phaseGateLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}{phaseGateDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}{controlledNotLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit)
\item 
void \hyperlink{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}{controlledNotDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{findProbabilityOfZeroLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{findProbabilityOfZeroDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}{collapseToOutcomeLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int measureQubit, REAL totalProbability, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, const REAL totalProbability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Set all amplitudes in one chunk to 0. \item\end{DoxyCompactList}\item 
int \hyperlink{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}{validateMatrixIsUnitary} (\hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
int \hyperlink{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}{validateAlphaBeta} (\hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
int \hyperlink{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}{validateUnitVector} (REAL ux, REAL uy, REAL uz)
\item 
void \hyperlink{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}{phaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}{exitWithError} (int errorCode, const char $\ast$func)
\item 
void \hyperlink{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert} (int isValid, int errorCode, const char $\ast$func)
\end{DoxyCompactItemize}
\subsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \hyperlink{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}{errorCodes} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
Internal functions used to implement the public facing API in \hyperlink{qubits_8h}{qubits.h}. Do not call these functions directly. In general, \hyperlink{qubits__env__local_8c}{qubits\_\-env\_\-local.c} and \hyperlink{qubits__env__mpi_8c}{qubits\_\-env\_\-mpi.c} will implement the public API by choosing the correct function or combination of functions to use from those included here. 

Definition in file \hyperlink{qubits__internal_8h_source}{qubits\_\-internal.h}.

\subsubsection{Function Documentation}
\hypertarget{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}}
\index{collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeDistributedRenorm}]{\setlength{\rightskip}{0pt plus 5cm}REAL collapseToOutcomeDistributedRenorm ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  const REAL {\em totalProbability})}\hfill}
\label{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}


Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that the value 'outcome' has been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being zero \end{DoxyParams}


Definition at line 1867 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1868 {
1869         // ----- temp variables
1870         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1871         long long int numTasks=multiQubit.numAmps;
1872         // (good for shared memory parallelism)
1873 
1874         REAL renorm=1/sqrt(totalProbability);
1875         
1876         REAL *stateVecReal = multiQubit.stateVec.real;
1877         REAL *stateVecImag = multiQubit.stateVec.imag;
1878 
1879 # ifdef _OPENMP
1880 # pragma omp parallel \
1881         shared    (numTasks,stateVecReal,stateVecImag) \
1882         private   (thisTask)
1883 # endif
1884         {
1885 # ifdef _OPENMP
1886                 # pragma omp for schedule  (static)
1887 # endif
1888                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1889                         // summation -- simple implementation
1890                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
1891                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
1892                 }
1893         }
1894         return totalProbability;
1895 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}}
\index{collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeDistributedSetZero}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeDistributedSetZero ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}


Set all amplitudes in one chunk to 0. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that a zero have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}


Definition at line 1909 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1910 {
1911         // ----- temp variables
1912         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1913         long long int numTasks=multiQubit.numAmps;
1914         // (good for shared memory parallelism)
1915 
1916         // ---------------------------------------------------------------- //
1917         //            find probability                                      //
1918         // ---------------------------------------------------------------- //
1919 
1920         REAL *stateVecReal = multiQubit.stateVec.real;
1921         REAL *stateVecImag = multiQubit.stateVec.imag;
1922 
1923 # ifdef _OPENMP
1924 # pragma omp parallel \
1925         shared    (numTasks,stateVecReal,stateVecImag) \
1926         private   (thisTask)
1927 # endif
1928         {
1929 # ifdef _OPENMP
1930                 # pragma omp for schedule  (static)
1931 # endif
1932                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1933                         // summation -- simple implementation
1934                         stateVecReal[thisTask] = 0;
1935                         stateVecImag[thisTask] = 0;
1936                 }
1937         }
1938 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeLocal@{collapseToOutcomeLocal}}
\index{collapseToOutcomeLocal@{collapseToOutcomeLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeLocal}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeLocal ({\bf MultiQubit} {\em multiQubit}, \/  int {\em measureQubit}, \/  REAL {\em totalProbability}, \/  int {\em outcome})}\hfill}
\label{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}


Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. Performs an irreversible change to the state vector: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being either zero or one \item[\mbox{$\leftarrow$} {\em outcome}]to measure the probability of and set the state to -\/-\/ either zero or one \end{DoxyParams}


Definition at line 1785 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1786 {
1787         // ----- sizes
1788         long long int sizeBlock,                                           // siz
      e of blocks
1789         sizeHalfBlock;                                       // size of blocks ha
      lved
1790         // ----- indices
1791         long long int thisBlock,                                           // cur
      rent block
1792              index;                                               // current inde
      x for first half block
1793         // ----- measured probability
1794         REAL   renorm;                                    // probability (returne
      d) value
1795         // ----- temp variables
1796         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1797         // (good for shared memory parallelism)
1798         long long int numTasks=multiQubit.numAmps>>1;
1799 
1800         // ---------------------------------------------------------------- //
1801         //            dimensions                                            //
1802         // ---------------------------------------------------------------- //
1803         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1804         // and then the number to skip
1805         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1806         
1807         renorm=1/sqrt(totalProbability);
1808         REAL *stateVecReal = multiQubit.stateVec.real;
1809         REAL *stateVecImag = multiQubit.stateVec.imag;
1810 
1811 
1812 # ifdef _OPENMP
1813 # pragma omp parallel \
1814         default (none) \
1815         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,re
      norm,outcome) \
1816         private   (thisTask,thisBlock,index)
1817 # endif
1818         {
1819                 if (outcome==0){
1820                         // measure qubit is 0
1821 # ifdef _OPENMP
1822                         # pragma omp for schedule  (static)
1823 # endif
1824                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1825                                 thisBlock = thisTask / sizeHalfBlock;
1826                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
1827                                 stateVecReal[index]=stateVecReal[index]*renorm;
1828                                 stateVecImag[index]=stateVecImag[index]*renorm;
1829 
1830                                 stateVecReal[index+sizeHalfBlock]=0;
1831                                 stateVecImag[index+sizeHalfBlock]=0;
1832                         }
1833                 } else {
1834                         // measure qubit is 1
1835 # ifdef _OPENMP
1836                         # pragma omp for schedule  (static)
1837 # endif
1838                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1839                                 thisBlock = thisTask / sizeHalfBlock;
1840                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
1841                                 stateVecReal[index]=0;
1842                                 stateVecImag[index]=0;
1843 
1844                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[in
      dex+sizeHalfBlock]*renorm;
1845                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[in
      dex+sizeHalfBlock]*renorm;
1846                         }
1847                 }
1848         }
1849 
1850 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!compactUnitaryDistributed@{compactUnitaryDistributed}}
\index{compactUnitaryDistributed@{compactUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{compactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 542 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by compactUnitary().


\begin{DoxyCode}
547 {
548 
549         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
550         long long int thisTask;  
551         const long long int numTasks=multiQubit.numAmps;
552 
553         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
554         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
555         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
556         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
557         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
558 
559 # ifdef _OPENMP
560 # pragma omp parallel \
561         default  (none) \
562         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
563                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
564         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
565 # endif
566         {
567 # ifdef _OPENMP
568                 # pragma omp for schedule (static)
569 # endif
570                 for (thisTask=0; thisTask<numTasks; thisTask++) {
571                         // store current state vector values in temp variables
572                         stateRealUp = stateVecRealUp[thisTask];
573                         stateImagUp = stateVecImagUp[thisTask];
574 
575                         stateRealLo = stateVecRealLo[thisTask];
576                         stateImagLo = stateVecImagLo[thisTask];
577 
578                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
579                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
580                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
581                 }
582         }
583 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!compactUnitaryLocal@{compactUnitaryLocal}}
\index{compactUnitaryLocal@{compactUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{compactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}


Definition at line 413 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by compactUnitary().


\begin{DoxyCode}
414 {
415         long long int sizeBlock, sizeHalfBlock;
416         long long int thisBlock, // current block
417              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
418 
419         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
420         long long int thisTask;         
421         const long long int numTasks=multiQubit.numAmps>>1;
422 
423         // set dimensions
424         sizeHalfBlock = 1LL << targetQubit;  
425         sizeBlock     = 2LL * sizeHalfBlock; 
426 
427         // Can't use multiQubit.stateVec as a private OMP var
428         REAL *stateVecReal = multiQubit.stateVec.real;
429         REAL *stateVecImag = multiQubit.stateVec.imag;
430         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
431         REAL betaImag=beta.imag, betaReal=beta.real;
432 
433 # ifdef _OPENMP
434 # pragma omp parallel \
435         default  (none) \
436         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
437         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
438 # endif
439         {
440 # ifdef _OPENMP
441                 # pragma omp for schedule (static)
442 # endif
443                 for (thisTask=0; thisTask<numTasks; thisTask++) {
444 
445                         thisBlock   = thisTask / sizeHalfBlock;
446                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
447                         indexLo     = indexUp + sizeHalfBlock;
448 
449                         // store current state vector values in temp variables
450                         stateRealUp = stateVecReal[indexUp];
451                         stateImagUp = stateVecImag[indexUp];
452 
453                         stateRealLo = stateVecReal[indexLo];
454                         stateImagLo = stateVecImag[indexLo];
455 
456                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
457                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag
      *stateImagUp 
458                                 - betaReal*stateRealLo - betaImag*stateImagLo;
459                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag
      *stateRealUp 
460                                 - betaReal*stateImagLo + betaImag*stateRealLo;
461 
462                         // state[indexLo] = beta  * state[indexUp] + conj(alpha) 
      * state[indexLo]
463                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*s
      tateImagUp 
464                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
465                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*s
      tateRealUp 
466                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
467                 } 
468         }
469 
470 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}}
\index{controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledCompactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 852 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
857 {
858 
859         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
860         long long int thisTask;  
861         const long long int numTasks=multiQubit.numAmps;
862         const long long int chunkSize=multiQubit.numAmps;
863         const long long int chunkId=multiQubit.chunkId;
864 
865         int controlBit;
866 
867     REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
868         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
869         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
870         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
871         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
872 
873 # ifdef _OPENMP
874 # pragma omp parallel \
875         default  (none) \
876         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
877                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
878         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
879 # endif
880         {
881 # ifdef _OPENMP
882                 # pragma omp for schedule (static)
883 # endif
884                 for (thisTask=0; thisTask<numTasks; thisTask++) {
885                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
886                         if (controlBit){
887                                 // store current state vector values in temp vari
      ables
888                                 stateRealUp = stateVecRealUp[thisTask];
889                                 stateImagUp = stateVecImagUp[thisTask];
890 
891                                 stateRealLo = stateVecRealLo[thisTask];
892                                 stateImagLo = stateVecImagLo[thisTask];
893 
894                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
895                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp 
      - rot1Imag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
896                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp 
      + rot1Imag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
897                         }
898                 }
899         }
900 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}}
\index{controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledCompactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}


Definition at line 643 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
645 {
646         long long int sizeBlock, sizeHalfBlock;
647         long long int thisBlock, // current block
648              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
649 
650         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
651         long long int thisTask;         
652         const long long int numTasks=multiQubit.numAmps>>1;
653         const long long int chunkSize=multiQubit.numAmps;
654         const long long int chunkId=multiQubit.chunkId;
655 
656         int controlBit;
657 
658     // set dimensions
659         sizeHalfBlock = 1LL << targetQubit;  
660         sizeBlock     = 2LL * sizeHalfBlock; 
661 
662         // Can't use multiQubit.stateVec as a private OMP var
663         REAL *stateVecReal = multiQubit.stateVec.real;
664         REAL *stateVecImag = multiQubit.stateVec.imag;
665         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
666         REAL betaImag=beta.imag, betaReal=beta.real;
667 
668 # ifdef _OPENMP
669 # pragma omp parallel \
670         default  (none) \
671         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
672         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
673 # endif
674         {
675 # ifdef _OPENMP
676                 # pragma omp for schedule (static)
677 # endif
678                 for (thisTask=0; thisTask<numTasks; thisTask++) {
679 
680                         thisBlock   = thisTask / sizeHalfBlock;
681                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
682                         indexLo     = indexUp + sizeHalfBlock;
683 
684                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
685                         if (controlBit){
686                                 // store current state vector values in temp vari
      ables
687                                 stateRealUp = stateVecReal[indexUp];
688                                 stateImagUp = stateVecImag[indexUp];
689 
690                                 stateRealLo = stateVecReal[indexLo];
691                                 stateImagLo = stateVecImag[indexLo];
692 
693                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
694                                 stateVecReal[indexUp] = alphaReal*stateRealUp - a
      lphaImag*stateImagUp 
695                                         - betaReal*stateRealLo - betaImag*stateIm
      agLo;
696                                 stateVecImag[indexUp] = alphaReal*stateImagUp + a
      lphaImag*stateRealUp 
697                                         - betaReal*stateImagLo + betaImag*stateRe
      alLo;
698 
699                                 // state[indexLo] = beta  * state[indexUp] + conj
      (alpha) * state[indexLo]
700                                 stateVecReal[indexLo] = betaReal*stateRealUp - be
      taImag*stateImagUp 
701                                         + alphaReal*stateRealLo + alphaImag*state
      ImagLo;
702                                 stateVecImag[indexLo] = betaReal*stateImagUp + be
      taImag*stateRealUp 
703                                         + alphaReal*stateImagLo - alphaImag*state
      RealLo;
704                         }
705                 } 
706         }
707 
708 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledNotDistributed@{controlledNotDistributed}}
\index{controlledNotDistributed@{controlledNotDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledNotDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk. Only perform the rotation for elements where controlQubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1181 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by controlledNot().


\begin{DoxyCode}
1184 {
1185 
1186         long long int thisTask;  
1187         const long long int numTasks=multiQubit.numAmps;
1188         const long long int chunkSize=multiQubit.numAmps;
1189         const long long int chunkId=multiQubit.chunkId;
1190 
1191         int controlBit;
1192 
1193         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1194         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1195 
1196 # ifdef _OPENMP
1197 # pragma omp parallel \
1198         default  (none) \
1199         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1200         private  (thisTask,controlBit)
1201 # endif
1202         {
1203 # ifdef _OPENMP
1204                 # pragma omp for schedule (static)
1205 # endif
1206                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1207                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
1208                         if (controlBit){
1209                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTa
      sk];
1210                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTa
      sk];
1211                         }
1212                 }
1213         }
1214 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledNotLocal@{controlledNotLocal}}
\index{controlledNotLocal@{controlledNotLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledNotLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}


Definition at line 1116 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledNot().


\begin{DoxyCode}
1117 {
1118         long long int sizeBlock, sizeHalfBlock;
1119         long long int thisBlock, // current block
1120              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1121 
1122         REAL stateRealUp,stateImagUp;
1123         long long int thisTask;         
1124         const long long int numTasks=multiQubit.numAmps>>1;
1125         const long long int chunkSize=multiQubit.numAmps;
1126         const long long int chunkId=multiQubit.chunkId;
1127 
1128         int controlBit;
1129 
1130         // set dimensions
1131         sizeHalfBlock = 1LL << targetQubit;  
1132         sizeBlock     = 2LL * sizeHalfBlock; 
1133 
1134 
1135         // Can't use multiQubit.stateVec as a private OMP var
1136         REAL *stateVecReal = multiQubit.stateVec.real;
1137         REAL *stateVecImag = multiQubit.stateVec.imag;
1138 
1139 # ifdef _OPENMP
1140 # pragma omp parallel \
1141         default  (none) \
1142         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1143         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,co
      ntrolBit) 
1144 # endif
1145         {
1146 # ifdef _OPENMP
1147                 # pragma omp for schedule (static)
1148 # endif
1149                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1150                         thisBlock   = thisTask / sizeHalfBlock;
1151                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1152                         indexLo     = indexUp + sizeHalfBlock;
1153 
1154                         controlBit = extractBit(controlQubit, indexUp+chunkId*chu
      nkSize);
1155                         if (controlBit){
1156                                 stateRealUp = stateVecReal[indexUp];
1157                                 stateImagUp = stateVecImag[indexUp];
1158 
1159                                 stateVecReal[indexUp] = stateVecReal[indexLo];
1160                                 stateVecImag[indexUp] = stateVecImag[indexLo];
1161 
1162                                 stateVecReal[indexLo] = stateRealUp;
1163                                 stateVecImag[indexLo] = stateImagUp;
1164                         }
1165                 } 
1166         }
1167 
1168 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledUnitaryDistributed@{controlledUnitaryDistributed}}
\index{controlledUnitaryDistributed@{controlledUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 915 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledUnitary().


\begin{DoxyCode}
920 {
921 
922         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
923         long long int thisTask;  
924         const long long int numTasks=multiQubit.numAmps;
925         const long long int chunkSize=multiQubit.numAmps;
926         const long long int chunkId=multiQubit.chunkId;
927 
928         int controlBit;
929 
930         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
931         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
932         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
933         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
934         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
935 
936 # ifdef _OPENMP
937 # pragma omp parallel \
938         default  (none) \
939         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
940                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
941         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
942 # endif
943         {
944 # ifdef _OPENMP
945                 # pragma omp for schedule (static)
946 # endif
947                 for (thisTask=0; thisTask<numTasks; thisTask++) {
948                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
949                         if (controlBit){
950                                 // store current state vector values in temp vari
      ables
951                                 stateRealUp = stateVecRealUp[thisTask];
952                                 stateImagUp = stateVecImagUp[thisTask];
953 
954                                 stateRealLo = stateVecRealLo[thisTask];
955                                 stateImagLo = stateVecImagLo[thisTask];
956 
957                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
958                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
959                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
960                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
961                         }
962                 }
963         }
964 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledUnitaryLocal@{controlledUnitaryLocal}}
\index{controlledUnitaryLocal@{controlledUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}


Definition at line 773 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledUnitary().


\begin{DoxyCode}
775 {
776         long long int sizeBlock, sizeHalfBlock;
777         long long int thisBlock, // current block
778              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
779 
780         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
781         long long int thisTask;         
782         const long long int numTasks=multiQubit.numAmps>>1;
783         const long long int chunkSize=multiQubit.numAmps;
784         const long long int chunkId=multiQubit.chunkId;
785 
786         int controlBit;
787 
788     // set dimensions
789         sizeHalfBlock = 1LL << targetQubit;  
790         sizeBlock     = 2LL * sizeHalfBlock; 
791 
792         // Can't use multiQubit.stateVec as a private OMP var
793         REAL *stateVecReal = multiQubit.stateVec.real;
794         REAL *stateVecImag = multiQubit.stateVec.imag;
795 
796 # ifdef _OPENMP
797 # pragma omp parallel \
798         default  (none) \
799         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
800         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
801 # endif
802         {
803 # ifdef _OPENMP
804                 # pragma omp for schedule (static)
805 # endif
806                 for (thisTask=0; thisTask<numTasks; thisTask++) {
807 
808                         thisBlock   = thisTask / sizeHalfBlock;
809                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
810                         indexLo     = indexUp + sizeHalfBlock;
811 
812                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
813                         if (controlBit){
814                                 // store current state vector values in temp vari
      ables
815                                 stateRealUp = stateVecReal[indexUp];
816                                 stateImagUp = stateVecImag[indexUp];
817 
818                                 stateRealLo = stateVecReal[indexLo];
819                                 stateImagLo = stateVecImag[indexLo];
820 
821 
822                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
823                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
824                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
825                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
826                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
827 
828                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
829                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
830                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
831                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
832                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
833                         }
834                 } 
835         }
836 
837 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!exitWithError@{exitWithError}}
\index{exitWithError@{exitWithError}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{exitWithError}]{\setlength{\rightskip}{0pt plus 5cm}void exitWithError (int {\em errorCode}, \/  const char $\ast$ {\em func})}\hfill}
\label{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}


Definition at line 238 of file qubits\_\-env\_\-local.c.

References errorCodes.

Referenced by QuESTAssert().


\begin{DoxyCode}
238                                                    {
239     printf("!!!\n");
240     printf("QuEST Error in function %s: %s\n", func, errorCodes[errorCode]);
241     printf("!!!\n");
242     printf("exiting..\n");
243     exit(errorCode);
244 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}}
\index{findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{findProbabilityOfZeroDistributed}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}


Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. Size of regions to skip is a multiple of chunkSize.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1638 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1640 {
1641         // ----- measured probability
1642         REAL   totalProbability;                                    // probabilit
      y (returned) value
1643         // ----- temp variables
1644         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1645         long long int numTasks=multiQubit.numAmps;
1646 
1647         // ---------------------------------------------------------------- //
1648         //            find probability                                      //
1649         // ---------------------------------------------------------------- //
1650 
1651         // initialise returned value
1652         totalProbability = 0.0;
1653 
1654         REAL *stateVecReal = multiQubit.stateVec.real;
1655         REAL *stateVecImag = multiQubit.stateVec.imag;
1656 
1657 # ifdef _OPENMP
1658 # pragma omp parallel \
1659         shared    (numTasks,stateVecReal,stateVecImag) \
1660         private   (thisTask) \
1661         reduction ( +:totalProbability )
1662 # endif
1663         {
1664 # ifdef _OPENMP
1665                 # pragma omp for schedule  (static)
1666 # endif
1667                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1668                         // summation -- simple implementation
1669                         totalProbability += stateVecReal[thisTask]*stateVecReal[t
      hisTask]
1670                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
1671 
1672                         /*
1673                         // summation -- kahan correction
1674                         y = stateVecReal[thisTask]*stateVecReal[thisTask]
1675                         + stateVecImag[thisTask]*stateVecImag[thisTask] - c;
1676                         t = totalProbability + y;
1677                         c = (t - totalProbability) - y;
1678                         totalProbability = t;
1679                         */
1680 
1681                 }
1682         }
1683 
1684         return totalProbability;
1685 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}}
\index{findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{findProbabilityOfZeroLocal}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}


Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1566 of file qubits.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1568 {
1569         // ----- sizes
1570         long long int sizeBlock,                                           // siz
      e of blocks
1571         sizeHalfBlock;                                       // size of blocks ha
      lved
1572         // ----- indices
1573         long long int thisBlock,                                           // cur
      rent block
1574              index;                                               // current inde
      x for first half block
1575         // ----- measured probability
1576         REAL   totalProbability;                                    // probabilit
      y (returned) value
1577         // ----- temp variables
1578         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1579         long long int numTasks=multiQubit.numAmps>>1;
1580 
1581         // ---------------------------------------------------------------- //
1582         //            dimensions                                            //
1583         // ---------------------------------------------------------------- //
1584         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1585         // and then the number to skip
1586         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1587 
1588         // initialise returned value
1589         totalProbability = 0.0;
1590 
1591         // initialise correction for kahan summation
1592         if (DEBUG) printf("sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\n",sizeHa
      lfBlock,sizeBlock,numTasks);
1593 
1594         REAL *stateVecReal = multiQubit.stateVec.real;
1595         REAL *stateVecImag = multiQubit.stateVec.imag;
1596 
1597 # ifdef _OPENMP
1598 # pragma omp parallel \
1599         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
      
1600         private   (thisTask,thisBlock,index) \
1601         reduction ( +:totalProbability )
1602 # endif 
1603         {
1604 # ifdef _OPENMP
1605                 # pragma omp for schedule  (static)
1606 # endif
1607                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1608                         thisBlock = thisTask / sizeHalfBlock;
1609                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
      
1610 
1611                         if (index<0){ printf("ABORTING as index=%Ld with thisBloc
      k = %Ld  thisTask=%Ld \n", index,thisBlock,thisTask); exit(1);}
1612 
1613                         // summation -- simple implementation
1614                         totalProbability += stateVecReal[index]*stateVecReal[inde
      x]
1615                                 + stateVecImag[index]*stateVecImag[index];
1616 
1617                         /*
1618                         // summation -- kahan correction
1619                         y = stateVecReal[index]*stateVecReal[index]
1620                         + stateVecImag[index]*stateVecImag[index] - c;
1621                         t = totalProbability + y;
1622                         c = (t - totalProbability) - y;
1623                         totalProbability = t;
1624                         */
1625 
1626                 }
1627         }
1628         return totalProbability;
1629 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!hadamardDistributed@{hadamardDistributed}}
\index{hadamardDistributed@{hadamardDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{hadamardDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1369 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by hadamard().


\begin{DoxyCode}
1374 {
1375 
1376         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1377         long long int thisTask;  
1378         const long long int numTasks=multiQubit.numAmps;
1379 
1380         int sign;
1381         if (updateUpper) sign=1;
1382         else sign=-1;
1383 
1384         REAL recRoot2 = 1.0/sqrt(2);
1385 
1386         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1387         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1388         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1389 
1390 # ifdef _OPENMP
1391 # pragma omp parallel \
1392         default  (none) \
1393         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1394                         recRoot2, sign) \
1395         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1396 # endif
1397         {
1398 # ifdef _OPENMP
1399                 # pragma omp for schedule (static)
1400 # endif
1401                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1402                         // store current state vector values in temp variables
1403                         stateRealUp = stateVecRealUp[thisTask];
1404                         stateImagUp = stateVecImagUp[thisTask];
1405 
1406                         stateRealLo = stateVecRealLo[thisTask];
1407                         stateImagLo = stateVecImagLo[thisTask];
1408 
1409                         stateVecRealOut[thisTask] = recRoot2*(stateRealUp + sign*
      stateRealLo);
1410                         stateVecImagOut[thisTask] = recRoot2*(stateImagUp + sign*
      stateImagLo);
1411                 }
1412         }
1413 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!hadamardLocal@{hadamardLocal}}
\index{hadamardLocal@{hadamardLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{hadamardLocal}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}


Definition at line 1308 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by hadamard().


\begin{DoxyCode}
1309 {
1310         long long int sizeBlock, sizeHalfBlock;
1311         long long int thisBlock, // current block
1312              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1313 
1314         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1315         long long int thisTask;         
1316         const long long int numTasks=multiQubit.numAmps>>1;
1317 
1318         // set dimensions
1319         sizeHalfBlock = 1LL << targetQubit;  
1320         sizeBlock     = 2LL * sizeHalfBlock; 
1321 
1322         // Can't use multiQubit.stateVec as a private OMP var
1323         REAL *stateVecReal = multiQubit.stateVec.real;
1324         REAL *stateVecImag = multiQubit.stateVec.imag;
1325 
1326         REAL recRoot2 = 1.0/sqrt(2);
1327 
1328 # ifdef _OPENMP
1329 # pragma omp parallel \
1330         default  (none) \
1331         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \
      
1332         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
1333 # endif
1334         {
1335 # ifdef _OPENMP
1336                 # pragma omp for schedule (static)
1337 # endif
1338                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1339                         thisBlock   = thisTask / sizeHalfBlock;
1340                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1341                         indexLo     = indexUp + sizeHalfBlock;
1342 
1343                         stateRealUp = stateVecReal[indexUp];
1344                         stateImagUp = stateVecImag[indexUp];
1345 
1346                         stateRealLo = stateVecReal[indexLo];
1347                         stateImagLo = stateVecImag[indexLo];
1348 
1349                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateReal
      Lo);
1350                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImag
      Lo);
1351 
1352                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateReal
      Lo);
1353                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImag
      Lo);
1354                 } 
1355         }
1356 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}}
\index{multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{multiControlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}


Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where all the control qubits are 1.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 979 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
986 {
987 
988         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
989         long long int thisTask;  
990         const long long int numTasks=multiQubit.numAmps;
991         const long long int chunkSize=multiQubit.numAmps;
992         const long long int chunkId=multiQubit.chunkId;
993 
994         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
995         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
996         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
997         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
998         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
999 
1000 # ifdef _OPENMP
1001 # pragma omp parallel \
1002         default  (none) \
1003         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1004                         rot1Real,rot1Imag, rot2Real,rot2Imag, mask) \
1005         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1006 # endif
1007         {
1008 # ifdef _OPENMP
1009                 # pragma omp for schedule (static)
1010 # endif
1011                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1012                         if (mask == (mask & (thisTask+chunkId*chunkSize)) ){
1013                                 // store current state vector values in temp vari
      ables
1014                                 stateRealUp = stateVecRealUp[thisTask];
1015                                 stateImagUp = stateVecImagUp[thisTask];
1016 
1017                                 stateRealLo = stateVecRealLo[thisTask];
1018                                 stateImagLo = stateVecImagLo[thisTask];
1019 
1020                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
1021                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
1022                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
1023                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
1024                         }
1025                 }
1026         }
1027 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!multiControlledUnitaryLocal@{multiControlledUnitaryLocal}}
\index{multiControlledUnitaryLocal@{multiControlledUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{multiControlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}


Definition at line 710 of file qubits.c.

References MultiQubit::chunkId, Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
712 {
713         long long int sizeBlock, sizeHalfBlock;
714         long long int thisBlock, // current block
715              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
716 
717         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
718         long long int thisTask;         
719         const long long int numTasks=multiQubit.numAmps>>1;
720         const long long int chunkSize=multiQubit.numAmps;
721         const long long int chunkId=multiQubit.chunkId;
722 
723         // set dimensions
724         sizeHalfBlock = 1LL << targetQubit;  
725         sizeBlock     = 2LL * sizeHalfBlock; 
726 
727         // Can't use multiQubit.stateVec as a private OMP var
728         REAL *stateVecReal = multiQubit.stateVec.real;
729         REAL *stateVecImag = multiQubit.stateVec.imag;
730 
731 # ifdef _OPENMP
732 # pragma omp parallel \
733         default  (none) \
734         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u, mask) \
735         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
736 # endif
737         {
738 # ifdef _OPENMP
739                 # pragma omp for schedule (static)
740 # endif
741                 for (thisTask=0; thisTask<numTasks; thisTask++) {
742 
743                         thisBlock   = thisTask / sizeHalfBlock;
744                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
745                         indexLo     = indexUp + sizeHalfBlock;
746 
747                         if (mask == (mask & (indexUp+chunkId*chunkSize)) ){
748                                 // store current state vector values in temp vari
      ables
749                                 stateRealUp = stateVecReal[indexUp];
750                                 stateImagUp = stateVecImag[indexUp];
751 
752                                 stateRealLo = stateVecReal[indexLo];
753                                 stateImagLo = stateVecImag[indexLo];
754 
755 
756                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
757                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
758                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
759                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
760                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
761 
762                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
763                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
764                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
765                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
766                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
767                         }
768                 } 
769         }
770 
771 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGate@{phaseGate}}
\index{phaseGate@{phaseGate}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}


Definition at line 169 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, phaseGateDistributed(), phaseGateLocal(), and QuESTAssert().

Referenced by sGate(), sigmaZ(), and tGate().


\begin{DoxyCode}
170 {
171     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
172         phaseGateLocal(multiQubit, targetQubit, type);
173 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGateDistributed@{phaseGateDistributed}}
\index{phaseGateDistributed@{phaseGateDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGateDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}


Definition at line 1491 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1492 {
1493         REAL stateRealLo,stateImagLo;
1494         long long int thisTask;         
1495         const long long int numTasks=multiQubit.numAmps;
1496 
1497         // Can't use multiQubit.stateVec as a private OMP var
1498         REAL *stateVecReal = multiQubit.stateVec.real;
1499         REAL *stateVecImag = multiQubit.stateVec.imag;
1500 
1501         REAL recRoot2 = 1.0/sqrt(2);
1502 
1503 # ifdef _OPENMP
1504 # pragma omp parallel \
1505         default  (none) \
1506         shared   (stateVecReal,stateVecImag, recRoot2, type) \
1507         private  (thisTask,stateRealLo,stateImagLo) 
1508 # endif
1509         {
1510                 if (type==SIGMA_Z){
1511 # ifdef _OPENMP
1512                         # pragma omp for schedule (static)
1513 # endif
1514                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1515                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
      
1516                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
      
1517                         } 
1518                 } else if (type==S_GATE){
1519 # ifdef _OPENMP
1520                         # pragma omp for schedule (static)
1521 # endif
1522                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1523                                 stateRealLo = stateVecReal[thisTask];
1524                                 stateImagLo = stateVecImag[thisTask];
1525 
1526                                 stateVecReal[thisTask] = -stateImagLo;
1527                                 stateVecImag[thisTask] = stateRealLo;
1528                         } 
1529                 } else if (type==T_GATE){
1530 # ifdef _OPENMP
1531                         # pragma omp for schedule (static)
1532 # endif
1533                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1534                                 stateRealLo = stateVecReal[thisTask];
1535                                 stateImagLo = stateVecImag[thisTask];
1536 
1537                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo 
      - stateImagLo);
1538                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo 
      + stateImagLo);
1539                         } 
1540                 } else printf("Type %d is an invalid phase gate\n", type);
1541         }
1542 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGateLocal@{phaseGateLocal}}
\index{phaseGateLocal@{phaseGateLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGateLocal}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}


fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod? 

Definition at line 1415 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1416 {
1417         long long int sizeBlock, sizeHalfBlock;
1418         long long int thisBlock, // current block
1419              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1420 
1421         REAL stateRealLo,stateImagLo;
1422         long long int thisTask;         
1423         const long long int numTasks=multiQubit.numAmps>>1;
1424 
1425         // set dimensions
1426         sizeHalfBlock = 1LL << targetQubit;  
1427         sizeBlock     = 2LL * sizeHalfBlock; 
1428 
1429         // Can't use multiQubit.stateVec as a private OMP var
1430         REAL *stateVecReal = multiQubit.stateVec.real;
1431         REAL *stateVecImag = multiQubit.stateVec.imag;
1432 
1433         REAL recRoot2 = 1.0/sqrt(2);
1434 
1435 # ifdef _OPENMP
1436 # pragma omp parallel \
1437         default  (none) \
1438         shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type
      ) \
1439         private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) 
1440 # endif
1441         {
1442                 if (type==SIGMA_Z){
1443 # ifdef _OPENMP
1444                         # pragma omp for schedule (static)
1445 # endif
1446                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1448                                 thisBlock   = thisTask / sizeHalfBlock;
1449                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1450                                 indexLo     = indexUp + sizeHalfBlock;
1451 
1452                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
1453                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
1454                         } 
1455                 } 
1456                 
1457                 else if (type==S_GATE){
1458 # ifdef _OPENMP
1459                         # pragma omp for schedule (static)
1460 # endif
1461                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1463                                 thisBlock   = thisTask / sizeHalfBlock;
1464                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1465                                 indexLo     = indexUp + sizeHalfBlock;
1466                                 stateRealLo = stateVecReal[indexLo];
1467                                 stateImagLo = stateVecImag[indexLo];
1468 
1469                                 stateVecReal[indexLo] = -stateImagLo;
1470                                 stateVecImag[indexLo] = stateRealLo;
1471                         } 
1472                 } else if (type==T_GATE){
1473 # ifdef _OPENMP
1474                         # pragma omp for schedule (static)
1475 # endif
1476                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1478                                 thisBlock   = thisTask / sizeHalfBlock;
1479                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1480                                 indexLo     = indexUp + sizeHalfBlock;
1481                                 stateRealLo = stateVecReal[indexLo];
1482                                 stateImagLo = stateVecImag[indexLo];
1483 
1484                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo -
       stateImagLo);
1485                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo +
       stateImagLo);
1486                         } 
1487                 } else printf("Type %d is an invalid phase gate\n", type);
1488         }
1489 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!QuESTAssert@{QuESTAssert}}
\index{QuESTAssert@{QuESTAssert}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{QuESTAssert}]{\setlength{\rightskip}{0pt plus 5cm}void QuESTAssert (int {\em isValid}, \/  int {\em errorCode}, \/  const char $\ast$ {\em func})}\hfill}
\label{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}


Definition at line 246 of file qubits\_\-env\_\-local.c.

References exitWithError().

Referenced by collapseToOutcome(), compactUnitary(), controlledCompactUnitary(), controlledNot(), controlledPhaseGate(), controlledUnitary(), createMultiQubit(), findProbabilityOfOutcome(), hadamard(), measure(), measureWithStats(), multiControlledPhaseGate(), multiControlledUnitary(), phaseGate(), sigmaX(), sigmaY(), and unitary().


\begin{DoxyCode}
246                                                               {
247     if (!isValid) exitWithError(errorCode, func);
248 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaXDistributed@{sigmaXDistributed}}
\index{sigmaXDistributed@{sigmaXDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaXDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1088 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaX().


\begin{DoxyCode}
1091 {
1092 
1093         long long int thisTask;  
1094         const long long int numTasks=multiQubit.numAmps;
1095 
1096         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1097         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1098 
1099 # ifdef _OPENMP
1100 # pragma omp parallel \
1101         default  (none) \
1102         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1103         private  (thisTask)
1104 # endif
1105         {
1106 # ifdef _OPENMP
1107                 # pragma omp for schedule (static)
1108 # endif
1109                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1110                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
1111                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
1112                 }
1113         }
1114 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaXLocal@{sigmaXLocal}}
\index{sigmaXLocal@{sigmaXLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaXLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}


Definition at line 1029 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaX().


\begin{DoxyCode}
1030 {
1031         long long int sizeBlock, sizeHalfBlock;
1032         long long int thisBlock, // current block
1033              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1034 
1035         REAL stateRealUp,stateImagUp;
1036         long long int thisTask;         
1037         const long long int numTasks=multiQubit.numAmps>>1;
1038 
1039         // set dimensions
1040         sizeHalfBlock = 1LL << targetQubit;  
1041         sizeBlock     = 2LL * sizeHalfBlock; 
1042 
1043         // Can't use multiQubit.stateVec as a private OMP var
1044         REAL *stateVecReal = multiQubit.stateVec.real;
1045         REAL *stateVecImag = multiQubit.stateVec.imag;
1046 
1047 # ifdef _OPENMP
1048 # pragma omp parallel \
1049         default  (none) \
1050         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1051         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1052 # endif
1053         {
1054 # ifdef _OPENMP
1055                 # pragma omp for schedule (static)
1056 # endif
1057                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1058                         thisBlock   = thisTask / sizeHalfBlock;
1059                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1060                         indexLo     = indexUp + sizeHalfBlock;
1061 
1062                         stateRealUp = stateVecReal[indexUp];
1063                         stateImagUp = stateVecImag[indexUp];
1064 
1065                         stateVecReal[indexUp] = stateVecReal[indexLo];
1066                         stateVecImag[indexUp] = stateVecImag[indexLo];
1067 
1068                         stateVecReal[indexLo] = stateRealUp;
1069                         stateVecImag[indexLo] = stateImagUp;
1070                 } 
1071         }
1072 
1073 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaYDistributed@{sigmaYDistributed}}
\index{sigmaYDistributed@{sigmaYDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaYDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1275 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaY().


\begin{DoxyCode}
1279 {
1280 
1281         long long int thisTask;  
1282         const long long int numTasks=multiQubit.numAmps;
1283 
1284         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1285         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1286 
1287         int realSign=1, imagSign=1;
1288         if (updateUpper) imagSign=-1;
1289         else realSign = -1;
1290 
1291 # ifdef _OPENMP
1292 # pragma omp parallel \
1293         default  (none) \
1294         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,r
      ealSign,imagSign) \
1295         private  (thisTask)
1296 # endif
1297         {
1298 # ifdef _OPENMP
1299                 # pragma omp for schedule (static)
1300 # endif
1301                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1302                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisT
      ask];
1303                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisT
      ask];
1304                 }
1305         }
1306 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaYLocal@{sigmaYLocal}}
\index{sigmaYLocal@{sigmaYLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaYLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}


Definition at line 1216 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaY().


\begin{DoxyCode}
1217 {
1218         long long int sizeBlock, sizeHalfBlock;
1219         long long int thisBlock, // current block
1220              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1221 
1222         REAL stateRealUp,stateImagUp;
1223         long long int thisTask;         
1224         const long long int numTasks=multiQubit.numAmps>>1;
1225 
1226         // set dimensions
1227         sizeHalfBlock = 1LL << targetQubit;  
1228         sizeBlock     = 2LL * sizeHalfBlock; 
1229 
1230         // Can't use multiQubit.stateVec as a private OMP var
1231         REAL *stateVecReal = multiQubit.stateVec.real;
1232         REAL *stateVecImag = multiQubit.stateVec.imag;
1233 
1234 # ifdef _OPENMP
1235 # pragma omp parallel \
1236         default  (none) \
1237         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1238         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1239 # endif
1240         {
1241 # ifdef _OPENMP
1242                 # pragma omp for schedule (static)
1243 # endif
1244                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1245                         thisBlock   = thisTask / sizeHalfBlock;
1246                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1247                         indexLo     = indexUp + sizeHalfBlock;
1248 
1249                         stateRealUp = stateVecReal[indexUp];
1250                         stateImagUp = stateVecImag[indexUp];
1251 
1252                         stateVecReal[indexUp] = stateVecImag[indexLo];
1253                         stateVecImag[indexUp] = -stateVecReal[indexLo];
1254 
1255                         stateVecReal[indexLo] = -stateImagUp;
1256                         stateVecImag[indexLo] = stateRealUp;
1257                 } 
1258         }
1259 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!unitaryDistributed@{unitaryDistributed}}
\index{unitaryDistributed@{unitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{unitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}


Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em u}]unitary matrix to apply \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 598 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by unitary().


\begin{DoxyCode}
603 {
604 
605         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
606         long long int thisTask;  
607         const long long int numTasks=multiQubit.numAmps;
608 
609         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
610         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
611         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
612         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
613         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
614 
615 
616 # ifdef _OPENMP
617 # pragma omp parallel \
618         default  (none) \
619         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
620                         rot1Real, rot1Imag, rot2Real, rot2Imag) \
621         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
622 # endif
623         {
624 # ifdef _OPENMP
625                 # pragma omp for schedule (static)
626 # endif
627                 for (thisTask=0; thisTask<numTasks; thisTask++) {
628                         // store current state vector values in temp variables
629                         stateRealUp = stateVecRealUp[thisTask];
630                         stateImagUp = stateVecImagUp[thisTask];
631 
632                         stateRealLo = stateVecRealLo[thisTask];
633                         stateImagLo = stateVecImagLo[thisTask];
634 
635                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp 
636                                 + rot2Real*stateRealLo - rot2Imag*stateImagLo;
637                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp 
638                                 + rot2Real*stateImagLo + rot2Imag*stateRealLo;
639                 }
640         }
641 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!unitaryLocal@{unitaryLocal}}
\index{unitaryLocal@{unitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{unitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}


Definition at line 472 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by unitary().


\begin{DoxyCode}
473 {
474         long long int sizeBlock, sizeHalfBlock;
475         long long int thisBlock, // current block
476              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
477 
478         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
479         long long int thisTask;         
480         const long long int numTasks=multiQubit.numAmps>>1;
481 
482         // set dimensions
483         sizeHalfBlock = 1LL << targetQubit;  
484         sizeBlock     = 2LL * sizeHalfBlock; 
485 
486         // Can't use multiQubit.stateVec as a private OMP var
487         REAL *stateVecReal = multiQubit.stateVec.real;
488         REAL *stateVecImag = multiQubit.stateVec.imag;
489 
490 # ifdef _OPENMP
491 # pragma omp parallel \
492         default  (none) \
493         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
494         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
495 # endif
496         {
497 # ifdef _OPENMP
498                 # pragma omp for schedule (static)
499 # endif
500                 for (thisTask=0; thisTask<numTasks; thisTask++) {
501 
502                         thisBlock   = thisTask / sizeHalfBlock;
503                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
504                         indexLo     = indexUp + sizeHalfBlock;
505 
506                         // store current state vector values in temp variables
507                         stateRealUp = stateVecReal[indexUp];
508                         stateImagUp = stateVecImag[indexUp];
509 
510                         stateRealLo = stateVecReal[indexLo];
511                         stateImagLo = stateVecImag[indexLo];
512 
513 
514                         // state[indexUp] = u00 * state[indexUp] + u01 * state[in
      dexLo]
515                         stateVecReal[indexUp] = u.r0c0.real*stateRealUp - u.r0c0.
      imag*stateImagUp 
516                                 + u.r0c1.real*stateRealLo - u.r0c1.imag*stateImag
      Lo;
517                         stateVecImag[indexUp] = u.r0c0.real*stateImagUp + u.r0c0.
      imag*stateRealUp 
518                                 + u.r0c1.real*stateImagLo + u.r0c1.imag*stateReal
      Lo;
519 
520                         // state[indexLo] = u10  * state[indexUp] + u11 * state[i
      ndexLo]
521                         stateVecReal[indexLo] = u.r1c0.real*stateRealUp  - u.
      r1c0.imag*stateImagUp 
522                                 + u.r1c1.real*stateRealLo  -  u.r1c1.imag*stateIm
      agLo;
523                         stateVecImag[indexLo] = u.r1c0.real*stateImagUp + u.r1c0.
      imag*stateRealUp 
524                                 + u.r1c1.real*stateImagLo + u.r1c1.imag*stateReal
      Lo;
525 
526                 } 
527         }
528 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateAlphaBeta@{validateAlphaBeta}}
\index{validateAlphaBeta@{validateAlphaBeta}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateAlphaBeta}]{\setlength{\rightskip}{0pt plus 5cm}int validateAlphaBeta ({\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}


Definition at line 369 of file qubits.c.

References Complex::imag, Complex::real, and REAL\_\-EPS.

Referenced by compactUnitary(), and controlledCompactUnitary().


\begin{DoxyCode}
369                                                   {
370         if ( fabs(alpha.real*alpha.real 
371                 + alpha.imag*alpha.imag
372                 + beta.real*beta.real 
373                 + beta.imag*beta.imag - 1) > REAL_EPS ) return 0;
374         else return 1;
375 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateMatrixIsUnitary@{validateMatrixIsUnitary}}
\index{validateMatrixIsUnitary@{validateMatrixIsUnitary}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateMatrixIsUnitary}]{\setlength{\rightskip}{0pt plus 5cm}int validateMatrixIsUnitary ({\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}


Definition at line 344 of file qubits.c.

References Complex::imag, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, and REAL\_\-EPS.

Referenced by controlledUnitary(), multiControlledUnitary(), and unitary().


\begin{DoxyCode}
344                                              {
345 
346         if ( fabs(u.r0c0.real*u.r0c0.real 
347                 + u.r0c0.imag*u.r0c0.imag
348                 + u.r1c0.real*u.r1c0.real
349                 + u.r1c0.imag*u.r1c0.imag - 1) > REAL_EPS ) return 0;
350     // check
351         if ( fabs(u.r0c1.real*u.r0c1.real 
352                 + u.r0c1.imag*u.r0c1.imag
353                 + u.r1c1.real*u.r1c1.real
354                 + u.r1c1.imag*u.r1c1.imag - 1) > REAL_EPS ) return 0;
355 
356         if ( fabs(u.r0c0.real*u.r0c1.real 
357                 + u.r0c0.imag*u.r0c1.imag
358                 + u.r1c0.real*u.r1c1.real
359                 + u.r1c0.imag*u.r1c1.imag) > REAL_EPS ) return 0;
360 
361         if ( fabs(u.r0c1.real*u.r0c0.imag
362                 - u.r0c0.real*u.r0c1.imag
363                 + u.r1c1.real*u.r1c0.imag
364                 - u.r1c0.real*u.r1c1.imag) > REAL_EPS ) return 0;
365 
366         return 1;
367 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateUnitVector@{validateUnitVector}}
\index{validateUnitVector@{validateUnitVector}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateUnitVector}]{\setlength{\rightskip}{0pt plus 5cm}int validateUnitVector (REAL {\em ux}, \/  REAL {\em uy}, \/  REAL {\em uz})}\hfill}
\label{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}


Definition at line 377 of file qubits.c.

References REAL\_\-EPS.


\begin{DoxyCode}
377                                                  {
378         if ( fabs(sqrt(ux*ux + uy*uy + uz*uz) - 1) > REAL_EPS ) return 0;
379         else return 1;
380 }
\end{DoxyCode}


\subsubsection{Variable Documentation}
\hypertarget{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!errorCodes@{errorCodes}}
\index{errorCodes@{errorCodes}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{errorCodes}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ {\bf errorCodes}\mbox{[}$\,$\mbox{]}}\hfill}
\label{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}


Definition at line 20 of file qubits.c.

Referenced by exitWithError().