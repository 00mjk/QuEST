\hypertarget{qubits__internal_8h}{}\subsection{qubits\+\_\+internal.\+h File Reference}
\label{qubits__internal_8h}\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}


Internal functions used to implement the public facing A\+PI in \hyperlink{qubits_8h}{qubits.\+h}.  


{\ttfamily \#include \char`\"{}precision.\+h\char`\"{}}\newline
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}{rotate\+Qubit\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}{rotate\+Qubit\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a824d71bae93236d8a3cd43589044eaee}{control\+Rotate\+Qubit\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, const int control\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments and a control qubit. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ab22d031e2507f1d859292103a99e2378}{control\+Rotate\+Qubit\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, const int control\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_aa9e640bb2d0458c937c6a87dfeca0f23}{sigma\+X\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a5958808b2f2f05937921ba7dabe5a171}{sigma\+X\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_afcbb1dcbe070ad0ed1a72a23251b6a83}{sigma\+Y\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a0471f6b547ce8270ef85170b7f4f0214}{sigma\+Y\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out, int update\+Upper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a0711416fceaf63c67b496e123e845c69}{hadamard\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ad6bac7e3c280211e103a031c4773d930}{hadamard\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\item 
void \hyperlink{qubits__internal_8h_a6a736aeb3532898019fe7c27010edc6a}{phase\+Gate\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a38a05c7e749e806b182ef3b89878bfc4}{phase\+Gate\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a2901e2e5531cb77f87ea54b3fc28f51a}{control\+Not\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, const int control\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\} for elements where control\+Qubit is one. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a774dd1217fcc3591a74a74d5667afa29}{control\+Not\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, const int control\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{find\+Probability\+Of\+Zero\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{find\+Probability\+Of\+Zero\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a53614ce19e0a4f2c41b400cf05dc5bd1}{measure\+In\+State\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, int measure\+Qubit, \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} total\+Probability, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__internal_8h_a35e5ac30c8427c482a97b33a4e295535}{measure\+In\+State\+Distributed\+Renorm} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit, const \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} total\+Probability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measure\+Qubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ac39efc9ed939382276ebd0c15dd6a0fa}{measure\+In\+State\+Distributed\+Set\+Zero} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Set all amplitudes in one chunk to 0. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a2d73fd11c1d154640dbf114da8f34c64}{filter\+Out111\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3, const \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} prob\+Of\+Filter)
\begin{DoxyCompactList}\small\item\em Updates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__internal_8h_a096cddbac961f0651a084d2ceb905d1b}{prob\+Of\+Filter\+Out111\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3)
\begin{DoxyCompactList}\small\item\em Evaluates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
Internal functions used to implement the public facing A\+PI in \hyperlink{qubits_8h}{qubits.\+h}. 

Do not call these functions directly. In general, \hyperlink{qubits__env__local_8c}{qubits\+\_\+env\+\_\+local.\+c} and \hyperlink{qubits__env__mpi_8c}{qubits\+\_\+env\+\_\+mpi.\+c} will implement the public A\+PI by choosing the correct function or combination of functions to use from those included here. 

\subsubsection{Function Documentation}
\mbox{\Hypertarget{qubits__internal_8h_a774dd1217fcc3591a74a74d5667afa29}\label{qubits__internal_8h_a774dd1217fcc3591a74a74d5667afa29}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!control\+Not\+Distributed@{control\+Not\+Distributed}}
\index{control\+Not\+Distributed@{control\+Not\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{control\+Not\+Distributed()}{controlNotDistributed()}}
{\footnotesize\ttfamily void control\+Not\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{target\+Qubit,  }\item[{const int}]{control\+Qubit,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+In,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Out }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{0,1\},\{1,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk. Only perform the rotation for elements where control\+Qubit is one.

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 742 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and R\+E\+AL.



Referenced by control\+Not().


\begin{DoxyCode}
745 \{
746 
747         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
748         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
749 
750         \textcolor{keywordtype}{int} controlBit;
751 
752         \textcolor{comment}{// test qubit valid}
753         assert (targetQubit >= 0 && targetQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
754 
755         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
756         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
757 
758 \textcolor{preprocessor}{# ifdef \_OPENMP}
759 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
760 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
761 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) \(\backslash\)}
762 \textcolor{preprocessor}{        private  (thisTask,controlBit)}
763 \textcolor{preprocessor}{# endif}
764         \{
765 \textcolor{preprocessor}{# ifdef \_OPENMP}
766 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
767 \textcolor{preprocessor}{# endif}
768                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
769                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, thisTask);
770                         \textcolor{keywordflow}{if} (controlBit)\{
771                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
772                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
773                         \}
774                 \}
775         \}
776 \} 
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a2901e2e5531cb77f87ea54b3fc28f51a}\label{qubits__internal_8h_a2901e2e5531cb77f87ea54b3fc28f51a}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!control\+Not\+Local@{control\+Not\+Local}}
\index{control\+Not\+Local@{control\+Not\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{control\+Not\+Local()}{controlNotLocal()}}
{\footnotesize\ttfamily void control\+Not\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{target\+Qubit,  }\item[{const int}]{control\+Qubit }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{0,1\},\{1,0\} for elements where control\+Qubit is one. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & qubit to determine whether or not to perform a rotation \\
\hline
\end{DoxyParams}


Definition at line 667 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by control\+Not().


\begin{DoxyCode}
668 \{
669         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
670         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
671              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
672 
673         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
674         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
675         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
676 
677         \textcolor{keywordtype}{int} controlBit;
678 
679         \textcolor{comment}{// if targetQubit==controlQubit, it is guaranteed that controlQubit==1 when}
680         \textcolor{comment}{// targetQubit==1. As rotations are symmetric, we can instead apply the rotation}
681         \textcolor{comment}{// on all amplitudes where targetQubit==0 as we do here.}
682         \textcolor{keywordtype}{int} rotateAll=(targetQubit==controlQubit);
683 
684         \textcolor{comment}{// test qubit valid}
685         assert (targetQubit >= 0 && targetQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
686 
687         \textcolor{comment}{// set dimensions}
688         sizeHalfBlock = 1LL << targetQubit;  
689         sizeBlock     = 2LL * sizeHalfBlock; 
690 
691 
692         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
693         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
694         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
695 
696 \textcolor{preprocessor}{# ifdef \_OPENMP}
697 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
698 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
699 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,rotateAll) \(\backslash\)}
700 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,controlBit) }
701 \textcolor{preprocessor}{# endif}
702         \{
703 \textcolor{preprocessor}{# ifdef \_OPENMP}
704 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
705 \textcolor{preprocessor}{# endif}
706                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
707                         thisBlock   = thisTask / sizeHalfBlock;
708                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
709                         indexLo     = indexUp + sizeHalfBlock;
710 
711                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit}(controlQubit, indexUp);
712                         \textcolor{keywordflow}{if} (rotateAll || controlBit)\{
713                                 stateRealUp = stateVecReal[indexUp];
714                                 stateImagUp = stateVecImag[indexUp];
715 
716                                 stateVecReal[indexUp] = stateVecReal[indexLo];
717                                 stateVecImag[indexUp] = stateVecImag[indexLo];
718 
719                                 stateVecReal[indexLo] = stateRealUp;
720                                 stateVecImag[indexLo] = stateImagUp;
721                         \}
722                 \} 
723         \}
724 
725 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_ab22d031e2507f1d859292103a99e2378}\label{qubits__internal_8h_ab22d031e2507f1d859292103a99e2378}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!control\+Rotate\+Qubit\+Distributed@{control\+Rotate\+Qubit\+Distributed}}
\index{control\+Rotate\+Qubit\+Distributed@{control\+Rotate\+Qubit\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{control\+Rotate\+Qubit\+Distributed()}{controlRotateQubitDistributed()}}
{\footnotesize\ttfamily void control\+Rotate\+Qubit\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{const int}]{control\+Qubit,  }\item[{\hyperlink{structComplex}{Complex}}]{rot1,  }\item[{\hyperlink{structComplex}{Complex}}]{rot2,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Up,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Lo,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Out }\end{DoxyParamCaption})}



Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. 

Only perform the rotation where the control qubit is one.

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & qubit to determine whether or not to perform a rotation \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 506 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Complex\+::real.



Referenced by control\+Rotate\+Qubit().


\begin{DoxyCode}
511 \{
512 
513         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
514         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
515         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
516 
517         \textcolor{keywordtype}{int} controlBit;
518 
519         \textcolor{comment}{// test qubit valid}
520         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
521 
522         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
523         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
524         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
525         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
526         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
527 
528 \textcolor{preprocessor}{# ifdef \_OPENMP}
529 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
530 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
531 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
532 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag) \(\backslash\)}
533 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit)}
534 \textcolor{preprocessor}{# endif}
535         \{
536 \textcolor{preprocessor}{# ifdef \_OPENMP}
537 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
538 \textcolor{preprocessor}{# endif}
539                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
540                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, thisTask);
541                         \textcolor{keywordflow}{if} (controlBit)\{
542                                 \textcolor{comment}{// store current state vector values in temp variables}
543                                 stateRealUp = stateVecRealUp[thisTask];
544                                 stateImagUp = stateVecImagUp[thisTask];
545 
546                                 stateRealLo = stateVecRealLo[thisTask];
547                                 stateImagLo = stateVecImagLo[thisTask];
548 
549                                 \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
550                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp + 
      rot2Real*stateRealLo + rot2Imag*stateImagLo;
551                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp + 
      rot2Real*stateImagLo - rot2Imag*stateRealLo;
552                         \}
553                 \}
554         \}
555 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a824d71bae93236d8a3cd43589044eaee}\label{qubits__internal_8h_a824d71bae93236d8a3cd43589044eaee}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!control\+Rotate\+Qubit\+Local@{control\+Rotate\+Qubit\+Local}}
\index{control\+Rotate\+Qubit\+Local@{control\+Rotate\+Qubit\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{control\+Rotate\+Qubit\+Local()}{controlRotateQubitLocal()}}
{\footnotesize\ttfamily void control\+Rotate\+Qubit\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{const int}]{control\+Qubit,  }\item[{\hyperlink{structComplex}{Complex}}]{alpha,  }\item[{\hyperlink{structComplex}{Complex}}]{beta }\end{DoxyParamCaption})}



Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments and a control qubit. 

Only perform the rotation for elements where the control qubit is one. alpha\+Re = cos(angle1) $\ast$ cos(angle2) ~\newline
alpha\+Im = cos(angle1) $\ast$ sin(angle2) ~\newline
 beta\+Re = sin(angle1) $\ast$ cos(angle3) ~\newline
 beta\+Im = sin(angle1) $\ast$ sin(angle3) ~\newline


\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em alpha} & rotation angle \\
\hline
\mbox{\tt in}  & {\em beta} & rotation angle \\
\hline
\end{DoxyParams}


Definition at line 415 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, Complex\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by control\+Rotate\+Qubit().


\begin{DoxyCode}
417 \{
418         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
419         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
420              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
421 
422         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
423         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
424         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
425 
426         \textcolor{keywordtype}{int} controlBit;
427 
428         \textcolor{comment}{// if targetQubit==controlQubit, it is guaranteed that controlQubit==1 when}
429         \textcolor{comment}{// targetQubit==1. As rotations are symmetric, we can instead apply the rotation}
430         \textcolor{comment}{// on all amplitudes where targetQubit==0 as we do here.}
431         \textcolor{keywordtype}{int} rotateAll=(rotQubit==controlQubit);
432 
433         \textcolor{comment}{// test qubit valid}
434         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
435 
436         \textcolor{comment}{// set dimensions}
437         sizeHalfBlock = 1LL << rotQubit;  
438         sizeBlock     = 2LL * sizeHalfBlock; 
439 
440         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
441         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
442         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
443         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} alphaImag=alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, alphaReal=alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
444         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} betaImag=beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, betaReal=beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
445 
446 \textcolor{preprocessor}{# ifdef \_OPENMP}
447 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
448 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
449 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,alphaImag,
       betaReal,betaImag,\(\backslash\)}
450 \textcolor{preprocessor}{                        rotateAll) \(\backslash\)}
451 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo,
       stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit) }
452 \textcolor{preprocessor}{# endif}
453         \{
454 \textcolor{preprocessor}{# ifdef \_OPENMP}
455 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
456 \textcolor{preprocessor}{# endif}
457                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
458 
459                         thisBlock   = thisTask / sizeHalfBlock;
460                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
461                         indexLo     = indexUp + sizeHalfBlock;
462 
463                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, indexUp);
464                         \textcolor{keywordflow}{if} (rotateAll || controlBit)\{
465                                 \textcolor{comment}{// store current state vector values in temp variables}
466                                 stateRealUp = stateVecReal[indexUp];
467                                 stateImagUp = stateVecImag[indexUp];
468 
469                                 stateRealLo = stateVecReal[indexLo];
470                                 stateImagLo = stateVecImag[indexLo];
471 
472                                 \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
473                                 stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag*stateImagUp 
474                                         - betaReal*stateRealLo - betaImag*stateImagLo;
475                                 stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag*stateRealUp 
476                                         - betaReal*stateImagLo + betaImag*stateRealLo;
477 
478                                 \textcolor{comment}{// state[indexLo] = beta  * state[indexUp] + conj(alpha) * state[indexLo]}
479                                 stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*stateImagUp 
480                                         + alphaReal*stateRealLo + alphaImag*stateImagLo;
481                                 stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*stateRealUp 
482                                         + alphaReal*stateImagLo - alphaImag*stateRealLo;
483                         \}
484                 \} 
485         \}
486 
487 \} 
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a2d73fd11c1d154640dbf114da8f34c64}\label{qubits__internal_8h_a2d73fd11c1d154640dbf114da8f34c64}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!filter\+Out111\+Local@{filter\+Out111\+Local}}
\index{filter\+Out111\+Local@{filter\+Out111\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{filter\+Out111\+Local()}{filterOut111Local()}}
{\footnotesize\ttfamily void filter\+Out111\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{id\+Qubit1,  }\item[{const int}]{id\+Qubit2,  }\item[{const int}]{id\+Qubit3,  }\item[{const \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}}]{prob\+Of\+Filter }\end{DoxyParamCaption})}



Updates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3} & specified qubits \\
\hline
\mbox{\tt in}  & {\em prob\+Of\+Filter} & Total probability that the 3 qubits are not all in the 1 state. \\
\hline
\end{DoxyParams}


Definition at line 1652 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, R\+E\+A\+L\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+F\+O\+R\+M\+AT, and Multi\+Qubit\+::state\+Vec.



Referenced by filter\+Out111().


\begin{DoxyCode}
1654 \{
1655         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
1656         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
1657         \textcolor{keywordtype}{int} bit1, bit2, bit3;
1658 
1659         \textcolor{comment}{// ---------------------------------------------------------------- //}
1660         \textcolor{comment}{//            tests                                                 //}
1661         \textcolor{comment}{// ---------------------------------------------------------------- //}
1662         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} && idQubit2 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1663 
1664         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1665 
1666         \textcolor{keywordflow}{if} ( probOfFilter<1e-16 )\{ printf(\textcolor{stringliteral}{"Extremely small or negative profOfFilter="}
      \hyperlink{precision_8h_ad751ac7ddc8ec19f23fb33083c0da8da}{REAL\_STRING\_FORMAT}\textcolor{stringliteral}{"; aborting! \(\backslash\)n"},probOfFilter); exit(1);\}
1667         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} myNorm=1/sqrt(probOfFilter);
1668         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1669         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1670 
1671 \textcolor{preprocessor}{# ifdef \_OPENMP}
1672 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1673 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
1674 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag, myNorm) \(\backslash\)}
1675 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3)                }
1676 \textcolor{preprocessor}{# endif }
1677         \{
1678 \textcolor{preprocessor}{# ifdef \_OPENMP}
1679 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1680 \textcolor{preprocessor}{# endif}
1681                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
1682                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
1683                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
1684                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index);
1685                         \textcolor{keywordflow}{if} ((bit1 && bit2 && bit3)) \{
1686                                 stateVecReal[index]=0;
1687                                 stateVecImag [index]=0;
1688                         \}\textcolor{keywordflow}{else}\{
1689                                 stateVecReal[index] *= myNorm;
1690                                 stateVecImag[index] *= myNorm;
1691                         \}
1692                 \}
1693         \}
1694 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}\label{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}}
\index{find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{find\+Probability\+Of\+Zero\+Distributed()}{findProbabilityOfZeroDistributed()}}
{\footnotesize\ttfamily \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} find\+Probability\+Of\+Zero\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit }\end{DoxyParamCaption})}



Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. 

Size of regions to skip is a multiple of chunk\+Size.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 1262 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Outcome().


\begin{DoxyCode}
1264 \{
1265         \textcolor{comment}{// ----- measured probability}
1266         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
1267         \textcolor{comment}{// ----- temp variables}
1268         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1269         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1270         \textcolor{comment}{// (good for shared memory parallelism)}
1271 
1272         \textcolor{comment}{// ---------------------------------------------------------------- //}
1273         \textcolor{comment}{//            tests                                                 //}
1274         \textcolor{comment}{// ---------------------------------------------------------------- //}
1275         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1276 
1277         \textcolor{comment}{// ---------------------------------------------------------------- //}
1278         \textcolor{comment}{//            find probability                                      //}
1279         \textcolor{comment}{// ---------------------------------------------------------------- //}
1280 
1281         \textcolor{comment}{// initialise returned value}
1282         totalProbability = 0.0;
1283 
1284         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1285         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1286 
1287 \textcolor{preprocessor}{# ifdef \_OPENMP}
1288 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1289 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1290 \textcolor{preprocessor}{        private   (thisTask) \(\backslash\)}
1291 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
1292 \textcolor{preprocessor}{# endif}
1293         \{
1294 \textcolor{preprocessor}{# ifdef \_OPENMP}
1295 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1296 \textcolor{preprocessor}{# endif}
1297                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1298                         \textcolor{comment}{// summation -- simple implementation}
1299                         totalProbability += stateVecReal[thisTask]*stateVecReal[thisTask]
1300                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
1301 
1302                         \textcolor{comment}{/*}
1303 \textcolor{comment}{                        // summation -- kahan correction}
1304 \textcolor{comment}{                        y = stateVecReal[thisTask]*stateVecReal[thisTask]}
1305 \textcolor{comment}{                        + stateVecImag[thisTask]*stateVecImag[thisTask] - c;}
1306 \textcolor{comment}{                        t = totalProbability + y;}
1307 \textcolor{comment}{                        c = (t - totalProbability) - y;}
1308 \textcolor{comment}{                        totalProbability = t;}
1309 \textcolor{comment}{                        */}
1310 
1311                 \}
1312         \}
1313 
1314         \textcolor{keywordflow}{return} totalProbability;
1315 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}\label{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}}
\index{find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{find\+Probability\+Of\+Zero\+Local()}{findProbabilityOfZeroLocal()}}
{\footnotesize\ttfamily \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} find\+Probability\+Of\+Zero\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit }\end{DoxyParamCaption})}



Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. 

Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 1183 of file qubits.\+c.



References D\+E\+B\+UG, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Outcome().


\begin{DoxyCode}
1185 \{
1186         \textcolor{comment}{// ----- sizes}
1187         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
1188         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
1189         \textcolor{comment}{// ----- indices}
1190         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
1191              index;                                               \textcolor{comment}{// current index for first half block}
1192         \textcolor{comment}{// ----- measured probability}
1193         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
1194         \textcolor{comment}{// ----- temp variables}
1195         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1196         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1197 
1198         \textcolor{comment}{// ---------------------------------------------------------------- //}
1199         \textcolor{comment}{//            tests                                                 //}
1200         \textcolor{comment}{// ---------------------------------------------------------------- //}
1201         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1202 
1203 
1204         \textcolor{comment}{// ---------------------------------------------------------------- //}
1205         \textcolor{comment}{//            dimensions                                            //}
1206         \textcolor{comment}{// ---------------------------------------------------------------- //}
1207         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
1208         \textcolor{comment}{// and then the number to skip}
1209         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
1210 
1211         \textcolor{comment}{// initialise returned value}
1212         totalProbability = 0.0;
1213 
1214         \textcolor{comment}{// initialise correction for kahan summation}
1215         \textcolor{keywordflow}{if} (\hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\(\backslash\)n"},sizeHalfBlock,sizeBlock,
      numTasks);
1216 
1217         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1218         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1219 
1220 \textcolor{preprocessor}{# ifdef \_OPENMP}
1221 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1222 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
1223 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index) \(\backslash\)}
1224 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
1225 \textcolor{preprocessor}{# endif }
1226         \{
1227 \textcolor{preprocessor}{# ifdef \_OPENMP}
1228 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1229 \textcolor{preprocessor}{# endif}
1230                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1231                         thisBlock = thisTask / sizeHalfBlock;
1232                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1233 
1234                         \textcolor{keywordflow}{if} (index<0)\{ printf(\textcolor{stringliteral}{"ABORTING as index=%Ld with thisBlock = %Ld  thisTask=%Ld \(\backslash\)n"},
       index,thisBlock,thisTask); exit(1);\}
1235 
1236                         \textcolor{comment}{// summation -- simple implementation}
1237                         totalProbability += stateVecReal[index]*stateVecReal[index]
1238                                 + stateVecImag[index]*stateVecImag[index];
1239 
1240                         \textcolor{comment}{/*}
1241 \textcolor{comment}{                        // summation -- kahan correction}
1242 \textcolor{comment}{                        y = stateVecReal[index]*stateVecReal[index]}
1243 \textcolor{comment}{                        + stateVecImag[index]*stateVecImag[index] - c;}
1244 \textcolor{comment}{                        t = totalProbability + y;}
1245 \textcolor{comment}{                        c = (t - totalProbability) - y;}
1246 \textcolor{comment}{                        totalProbability = t;}
1247 \textcolor{comment}{                        */}
1248 
1249                 \}
1250         \}
1251         \textcolor{keywordflow}{return} totalProbability;
1252 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_ad6bac7e3c280211e103a031c4773d930}\label{qubits__internal_8h_ad6bac7e3c280211e103a031c4773d930}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!hadamard\+Distributed@{hadamard\+Distributed}}
\index{hadamard\+Distributed@{hadamard\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{hadamard\+Distributed()}{hadamardDistributed()}}
{\footnotesize\ttfamily void hadamard\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Up,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Lo,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Out }\end{DoxyParamCaption})}

\mbox{\Hypertarget{qubits__internal_8h_a0711416fceaf63c67b496e123e845c69}\label{qubits__internal_8h_a0711416fceaf63c67b496e123e845c69}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!hadamard\+Local@{hadamard\+Local}}
\index{hadamard\+Local@{hadamard\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{hadamard\+Local()}{hadamardLocal()}}
{\footnotesize\ttfamily void hadamard\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}


Definition at line 893 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by hadamard().


\begin{DoxyCode}
894 \{
895         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
896         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
897              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
898 
899         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
900         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
901         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
902 
903         \textcolor{comment}{// test qubit valid}
904         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
905 
906         \textcolor{comment}{// set dimensions}
907         sizeHalfBlock = 1LL << rotQubit;  
908         sizeBlock     = 2LL * sizeHalfBlock; 
909 
910         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
911         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
912         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
913 
914         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
915 
916 \textcolor{preprocessor}{# ifdef \_OPENMP}
917 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
918 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
919 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \(\backslash\)}
920 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
921 \textcolor{preprocessor}{# endif}
922         \{
923 \textcolor{preprocessor}{# ifdef \_OPENMP}
924 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
925 \textcolor{preprocessor}{# endif}
926                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
927                         thisBlock   = thisTask / sizeHalfBlock;
928                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
929                         indexLo     = indexUp + sizeHalfBlock;
930 
931                         stateRealUp = stateVecReal[indexUp];
932                         stateImagUp = stateVecImag[indexUp];
933 
934                         stateRealLo = stateVecReal[indexLo];
935                         stateImagLo = stateVecImag[indexLo];
936 
937                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateRealLo);
938                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImagLo);
939 
940                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateRealLo);
941                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImagLo);
942                 \} 
943         \}
944 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a35e5ac30c8427c482a97b33a4e295535}\label{qubits__internal_8h_a35e5ac30c8427c482a97b33a4e295535}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!measure\+In\+State\+Distributed\+Renorm@{measure\+In\+State\+Distributed\+Renorm}}
\index{measure\+In\+State\+Distributed\+Renorm@{measure\+In\+State\+Distributed\+Renorm}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{measure\+In\+State\+Distributed\+Renorm()}{measureInStateDistributedRenorm()}}
{\footnotesize\ttfamily \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} measure\+In\+State\+Distributed\+Renorm (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit,  }\item[{const \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}}]{total\+Probability }\end{DoxyParamCaption})}



Renormalise parts of the state vector where measure\+Qubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that the value \textquotesingle{}outcome\textquotesingle{} has been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. In the distributed version, one block (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em total\+Probability} & probability of qubit measure\+Qubit being zero \\
\hline
\end{DoxyParams}


Definition at line 1563 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+State().


\begin{DoxyCode}
1564 \{
1565         \textcolor{comment}{// ----- temp variables}
1566         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1567         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1568         \textcolor{comment}{// (good for shared memory parallelism)}
1569 
1570         \textcolor{comment}{// ---------------------------------------------------------------- //}
1571         \textcolor{comment}{//            tests                                                 //}
1572         \textcolor{comment}{// ---------------------------------------------------------------- //}
1573         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1574 
1575         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} renorm=1/sqrt(totalProbability);
1576         
1577         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1578         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1579 
1580 \textcolor{preprocessor}{# ifdef \_OPENMP}
1581 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1582 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1583 \textcolor{preprocessor}{        private   (thisTask)}
1584 \textcolor{preprocessor}{# endif}
1585         \{
1586 \textcolor{preprocessor}{# ifdef \_OPENMP}
1587 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1588 \textcolor{preprocessor}{# endif}
1589                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1590                         \textcolor{comment}{// summation -- simple implementation}
1591                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
1592                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
1593                 \}
1594         \}
1595         \textcolor{keywordflow}{return} totalProbability;
1596 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_ac39efc9ed939382276ebd0c15dd6a0fa}\label{qubits__internal_8h_ac39efc9ed939382276ebd0c15dd6a0fa}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!measure\+In\+State\+Distributed\+Set\+Zero@{measure\+In\+State\+Distributed\+Set\+Zero}}
\index{measure\+In\+State\+Distributed\+Set\+Zero@{measure\+In\+State\+Distributed\+Set\+Zero}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{measure\+In\+State\+Distributed\+Set\+Zero()}{measureInStateDistributedSetZero()}}
{\footnotesize\ttfamily void measure\+In\+State\+Distributed\+Set\+Zero (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit }\end{DoxyParamCaption})}



Set all amplitudes in one chunk to 0. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that a zero have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 or 1. In the distributed version, one block (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}


Definition at line 1611 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+State().


\begin{DoxyCode}
1612 \{
1613         \textcolor{comment}{// ----- temp variables}
1614         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1615         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1616         \textcolor{comment}{// (good for shared memory parallelism)}
1617 
1618         \textcolor{comment}{// ---------------------------------------------------------------- //}
1619         \textcolor{comment}{//            tests                                                 //}
1620         \textcolor{comment}{// ---------------------------------------------------------------- //}
1621         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1622 
1623         \textcolor{comment}{// ---------------------------------------------------------------- //}
1624         \textcolor{comment}{//            find probability                                      //}
1625         \textcolor{comment}{// ---------------------------------------------------------------- //}
1626 
1627         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1628         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1629 
1630 \textcolor{preprocessor}{# ifdef \_OPENMP}
1631 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1632 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1633 \textcolor{preprocessor}{        private   (thisTask)}
1634 \textcolor{preprocessor}{# endif}
1635         \{
1636 \textcolor{preprocessor}{# ifdef \_OPENMP}
1637 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1638 \textcolor{preprocessor}{# endif}
1639                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1640                         \textcolor{comment}{// summation -- simple implementation}
1641                         stateVecReal[thisTask] = 0;
1642                         stateVecImag[thisTask] = 0;
1643                 \}
1644         \}
1645 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a53614ce19e0a4f2c41b400cf05dc5bd1}\label{qubits__internal_8h_a53614ce19e0a4f2c41b400cf05dc5bd1}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!measure\+In\+State\+Local@{measure\+In\+State\+Local}}
\index{measure\+In\+State\+Local@{measure\+In\+State\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{measure\+In\+State\+Local()}{measureInStateLocal()}}
{\footnotesize\ttfamily void measure\+In\+State\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{int}]{measure\+Qubit,  }\item[{\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}}]{total\+Probability,  }\item[{int}]{outcome }\end{DoxyParamCaption})}



Update the state vector to be consistent with measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. 

Performs an irreversible change to the state vector\+: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em total\+Probability} & probability of qubit measure\+Qubit being either zero or one \\
\hline
\mbox{\tt in}  & {\em outcome} & to measure the probability of and set the state to -- either zero or one \\
\hline
\end{DoxyParams}


Definition at line 1475 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+State().


\begin{DoxyCode}
1476 \{
1477         \textcolor{comment}{// ----- sizes}
1478         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
1479         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
1480         \textcolor{comment}{// ----- indices}
1481         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
1482              index;                                               \textcolor{comment}{// current index for first half block}
1483         \textcolor{comment}{// ----- measured probability}
1484         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   renorm;                                    \textcolor{comment}{// probability (returned) value}
1485         \textcolor{comment}{// ----- temp variables}
1486         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1487         \textcolor{comment}{// (good for shared memory parallelism)}
1488         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1489 
1490         \textcolor{comment}{// ---------------------------------------------------------------- //}
1491         \textcolor{comment}{//            tests                                                 //}
1492         \textcolor{comment}{// ---------------------------------------------------------------- //}
1493         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1494 
1495         \textcolor{comment}{// ---------------------------------------------------------------- //}
1496         \textcolor{comment}{//            dimensions                                            //}
1497         \textcolor{comment}{// ---------------------------------------------------------------- //}
1498         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
1499         \textcolor{comment}{// and then the number to skip}
1500         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
1501         
1502         renorm=1/sqrt(totalProbability);
1503         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1504         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1505 
1506 
1507 \textcolor{preprocessor}{# ifdef \_OPENMP}
1508 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1509 \textcolor{preprocessor}{        default (none) \(\backslash\)}
1510 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,renorm,outcome) \(\backslash\)}
1511 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index)}
1512 \textcolor{preprocessor}{# endif}
1513         \{
1514                 \textcolor{keywordflow}{if} (outcome==0)\{
1515                         \textcolor{comment}{// measure qubit is 0}
1516 \textcolor{preprocessor}{# ifdef \_OPENMP}
1517 \textcolor{preprocessor}{                        # pragma omp for schedule  (static)}
1518 \textcolor{preprocessor}{# endif}
1519                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1520                                 thisBlock = thisTask / sizeHalfBlock;
1521                                 index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1522                                 stateVecReal[index]=stateVecReal[index]*renorm;
1523                                 stateVecImag[index]=stateVecImag[index]*renorm;
1524 
1525                                 stateVecReal[index+sizeHalfBlock]=0;
1526                                 stateVecImag[index+sizeHalfBlock]=0;
1527                         \}
1528                 \} \textcolor{keywordflow}{else} \{
1529                         \textcolor{comment}{// measure qubit is 1}
1530 \textcolor{preprocessor}{# ifdef \_OPENMP}
1531 \textcolor{preprocessor}{                        # pragma omp for schedule  (static)}
1532 \textcolor{preprocessor}{# endif}
1533                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1534                                 thisBlock = thisTask / sizeHalfBlock;
1535                                 index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1536                                 stateVecReal[index]=0;
1537                                 stateVecImag[index]=0;
1538 
1539                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[index+sizeHalfBlock]*renorm;
1540                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[index+sizeHalfBlock]*renorm;
1541                         \}
1542                 \}
1543         \}
1544 
1545 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a38a05c7e749e806b182ef3b89878bfc4}\label{qubits__internal_8h_a38a05c7e749e806b182ef3b89878bfc4}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!phase\+Gate\+Distributed@{phase\+Gate\+Distributed}}
\index{phase\+Gate\+Distributed@{phase\+Gate\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{phase\+Gate\+Distributed()}{phaseGateDistributed()}}
{\footnotesize\ttfamily void phase\+Gate\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type}}]{type }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em type} & the type of phase gate to apply -- one of \{S\+I\+G\+M\+A\+\_\+Z, S\+\_\+\+G\+A\+TE, T\+\_\+\+G\+A\+TE\} \\
\hline
\end{DoxyParams}


Definition at line 1103 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, S\+\_\+\+G\+A\+TE, S\+I\+G\+M\+A\+\_\+Z, Multi\+Qubit\+::state\+Vec, and T\+\_\+\+G\+A\+TE.



Referenced by phase\+Gate().


\begin{DoxyCode}
1104 \{
1105         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealLo,stateImagLo;
1106         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1107         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1108 
1109         \textcolor{comment}{// test qubit valid}
1110         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1111 
1112         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1113         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1114         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1115 
1116         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1117 
1118 \textcolor{preprocessor}{# ifdef \_OPENMP}
1119 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1120 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1121 \textcolor{preprocessor}{        shared   (stateVecReal,stateVecImag, recRoot2, type) \(\backslash\)}
1122 \textcolor{preprocessor}{        private  (thisTask,stateRealLo,stateImagLo) }
1123 \textcolor{preprocessor}{# endif}
1124         \{
1125                 \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{SIGMA\_Z})\{
1126 \textcolor{preprocessor}{# ifdef \_openmp}
1127 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1128 \textcolor{preprocessor}{# endif}
1129                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1130                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
1131                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
1132                         \} 
1133                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{S\_GATE})\{
1134 \textcolor{preprocessor}{# ifdef \_openmp}
1135 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1136 \textcolor{preprocessor}{# endif}
1137                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1138                                 stateRealLo = stateVecReal[thisTask];
1139                                 stateImagLo = stateVecImag[thisTask];
1140 
1141                                 stateVecReal[thisTask] = -stateImagLo;
1142                                 stateVecImag[thisTask] = stateRealLo;
1143                         \} 
1144                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{T\_GATE})\{
1145 \textcolor{preprocessor}{# ifdef \_OPENMP}
1146 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1147 \textcolor{preprocessor}{# endif}
1148                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1149                                 stateRealLo = stateVecReal[thisTask];
1150                                 stateImagLo = stateVecImag[thisTask];
1151 
1152                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo - stateImagLo);
1153                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo + stateImagLo);
1154                         \} 
1155                 \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"Type %d is an invalid phase gate\(\backslash\)n"}, type);
1156         \}
1157 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a6a736aeb3532898019fe7c27010edc6a}\label{qubits__internal_8h_a6a736aeb3532898019fe7c27010edc6a}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!phase\+Gate\+Local@{phase\+Gate\+Local}}
\index{phase\+Gate\+Local@{phase\+Gate\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{phase\+Gate\+Local()}{phaseGateLocal()}}
{\footnotesize\ttfamily void phase\+Gate\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type}}]{type }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em type} & the type of phase gate to apply -- one of \{S\+I\+G\+M\+A\+\_\+Z, S\+\_\+\+G\+A\+TE, T\+\_\+\+G\+A\+TE\} \\
\hline
\end{DoxyParams}
fix -- can i rewrite this to not use mod?

fix -- can i rewrite this to not use mod?

fix -- can i rewrite this to not use mod? 

Definition at line 1017 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, S\+\_\+\+G\+A\+TE, S\+I\+G\+M\+A\+\_\+Z, Multi\+Qubit\+::state\+Vec, and T\+\_\+\+G\+A\+TE.



Referenced by phase\+Gate().


\begin{DoxyCode}
1018 \{
1019         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
1020         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
1021              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
1022 
1023         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealLo,stateImagLo;
1024         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1025         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1026 
1027         \textcolor{comment}{// test qubit valid}
1028         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1029 
1030         \textcolor{comment}{// set dimensions}
1031         sizeHalfBlock = 1LL << rotQubit;  
1032         sizeBlock     = 2LL * sizeHalfBlock; 
1033 
1034         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1035         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1036         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1037 
1038         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1039 
1040 \textcolor{preprocessor}{# ifdef \_OPENMP}
1041 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1042 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1043 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type) \(\backslash\)}
1044 \textcolor{preprocessor}{        private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) }
1045 \textcolor{preprocessor}{# endif}
1046         \{
1047                 \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{SIGMA\_Z})\{
1048 \textcolor{preprocessor}{# ifdef \_OPENMP}
1049 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1050 \textcolor{preprocessor}{# endif}
1051                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1053                                 thisBlock   = thisTask / sizeHalfBlock;
1054                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1055                                 indexLo     = indexUp + sizeHalfBlock;
1056 
1057                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
1058                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
1059                         \} 
1060                 \} 
1061                 
1062                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{S\_GATE})\{
1063 \textcolor{preprocessor}{# ifdef \_OPENMP}
1064 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1065 \textcolor{preprocessor}{# endif}
1066                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1068                                 thisBlock   = thisTask / sizeHalfBlock;
1069                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1070                                 indexLo     = indexUp + sizeHalfBlock;
1071                                 stateRealLo = stateVecReal[indexLo];
1072                                 stateImagLo = stateVecImag[indexLo];
1073 
1074                                 stateVecReal[indexLo] = -stateImagLo;
1075                                 stateVecImag[indexLo] = stateRealLo;
1076                         \} 
1077                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{T\_GATE})\{
1078 \textcolor{preprocessor}{# ifdef \_OPENMP}
1079 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1080 \textcolor{preprocessor}{# endif}
1081                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1083                                 thisBlock   = thisTask / sizeHalfBlock;
1084                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1085                                 indexLo     = indexUp + sizeHalfBlock;
1086                                 stateRealLo = stateVecReal[indexLo];
1087                                 stateImagLo = stateVecImag[indexLo];
1088 
1089                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo - stateImagLo);
1090                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo + stateImagLo);
1091                         \} 
1092                 \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"Type %d is an invalid phase gate\(\backslash\)n"}, type);
1093         \}
1094 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a096cddbac961f0651a084d2ceb905d1b}\label{qubits__internal_8h_a096cddbac961f0651a084d2ceb905d1b}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!prob\+Of\+Filter\+Out111\+Local@{prob\+Of\+Filter\+Out111\+Local}}
\index{prob\+Of\+Filter\+Out111\+Local@{prob\+Of\+Filter\+Out111\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{prob\+Of\+Filter\+Out111\+Local()}{probOfFilterOut111Local()}}
{\footnotesize\ttfamily \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} prob\+Of\+Filter\+Out111\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{id\+Qubit1,  }\item[{const int}]{id\+Qubit2,  }\item[{const int}]{id\+Qubit3 }\end{DoxyParamCaption})}



Evaluates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. 

The function returns the probability of this outcome across all amplitudes in this chunk (if zero, it will exit with error) 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3} & specified qubits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Total probability that the 3 qubits are not all in the 1 state. 
\end{DoxyReturn}


Definition at line 1702 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by prob\+Of\+Filter\+Out111().


\begin{DoxyCode}
1703 \{
1704         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
1705         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
1706         \textcolor{keywordtype}{int} bit1, bit2, bit3;
1707 
1708         \textcolor{comment}{// ---------------------------------------------------------------- //}
1709         \textcolor{comment}{//            tests                                                 //}
1710         \textcolor{comment}{// ---------------------------------------------------------------- //}
1711         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} && idQubit2 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1712 
1713         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1714         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} probOfFilter=0;
1715         
1716         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1717         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1718 
1719 \textcolor{preprocessor}{# ifdef \_OPENMP}
1720 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1721 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
1722 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag) \(\backslash\)}
1723 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3)                \(\backslash\)}
1724 \textcolor{preprocessor}{        reduction ( +:probOfFilter )}
1725 \textcolor{preprocessor}{# endif}
1726         \{
1727 \textcolor{preprocessor}{# ifdef \_OPENMP}
1728 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1729 \textcolor{preprocessor}{# endif}
1730                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
1731                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
1732                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
1733                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index);
1734                         \textcolor{keywordflow}{if} (!(bit1 && bit2 && bit3)) \{
1735                                 probOfFilter+= stateVecReal[index]*stateVecReal[index] + stateVecImag[index
      ]* stateVecImag [index];
1736                         \}
1737                 \}
1738         \}
1739         \textcolor{keywordflow}{return} probOfFilter;
1740 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}\label{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!rotate\+Qubit\+Distributed@{rotate\+Qubit\+Distributed}}
\index{rotate\+Qubit\+Distributed@{rotate\+Qubit\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{rotate\+Qubit\+Distributed()}{rotateQubitDistributed()}}
{\footnotesize\ttfamily void rotate\+Qubit\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{\hyperlink{structComplex}{Complex}}]{rot1,  }\item[{\hyperlink{structComplex}{Complex}}]{rot2,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Up,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Lo,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Out }\end{DoxyParamCaption})}



Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 354 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Complex\+::real.



Referenced by rotate\+Qubit().


\begin{DoxyCode}
359 \{
360 
361         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
362         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
363         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
364 
365         \textcolor{comment}{// test qubit valid}
366         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
367 
368         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
369         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
370         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
371         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
372         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
373 
374 \textcolor{preprocessor}{# ifdef \_OPENMP}
375 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
376 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
377 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
378 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag) \(\backslash\)}
379 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
380 \textcolor{preprocessor}{# endif}
381         \{
382 \textcolor{preprocessor}{# ifdef \_OPENMP}
383 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
384 \textcolor{preprocessor}{# endif}
385                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
386                         \textcolor{comment}{// store current state vector values in temp variables}
387                         stateRealUp = stateVecRealUp[thisTask];
388                         stateImagUp = stateVecImagUp[thisTask];
389 
390                         stateRealLo = stateVecRealLo[thisTask];
391                         stateImagLo = stateVecImagLo[thisTask];
392 
393                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
394                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp + rot2Real*
      stateRealLo + rot2Imag*stateImagLo;
395                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp + rot2Real*
      stateImagLo - rot2Imag*stateRealLo;
396                 \}
397         \}
398 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}\label{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!rotate\+Qubit\+Local@{rotate\+Qubit\+Local}}
\index{rotate\+Qubit\+Local@{rotate\+Qubit\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{rotate\+Qubit\+Local()}{rotateQubitLocal()}}
{\footnotesize\ttfamily void rotate\+Qubit\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{\hyperlink{structComplex}{Complex}}]{alpha,  }\item[{\hyperlink{structComplex}{Complex}}]{beta }\end{DoxyParamCaption})}



Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. 

alpha\+Re = cos(angle1) $\ast$ cos(angle2) ~\newline
alpha\+Im = cos(angle1) $\ast$ sin(angle2) ~\newline
 beta\+Re = sin(angle1) $\ast$ cos(angle3) ~\newline
 beta\+Im = sin(angle1) $\ast$ sin(angle3) ~\newline


\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em alpha} & rotation angle \\
\hline
\mbox{\tt in}  & {\em beta} & rotation angle \\
\hline
\end{DoxyParams}


Definition at line 275 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, Complex\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by rotate\+Qubit().


\begin{DoxyCode}
276 \{
277         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
278         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
279              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
280 
281         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
282         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
283         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
284 
285         \textcolor{comment}{// test qubit valid}
286         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
287 
288         \textcolor{comment}{// set dimensions}
289         sizeHalfBlock = 1LL << rotQubit;  
290         sizeBlock     = 2LL * sizeHalfBlock; 
291 
292         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
293         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
294         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
295         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} alphaImag=alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, alphaReal=alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
296         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} betaImag=beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, betaReal=beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
297 
298 \textcolor{preprocessor}{# ifdef \_OPENMP}
299 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
300 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
301 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,alphaImag,
       betaReal,betaImag) \(\backslash\)}
302 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
303 \textcolor{preprocessor}{# endif}
304         \{
305 \textcolor{preprocessor}{# ifdef \_OPENMP}
306 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
307 \textcolor{preprocessor}{# endif}
308                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
309 
310                         thisBlock   = thisTask / sizeHalfBlock;
311                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
312                         indexLo     = indexUp + sizeHalfBlock;
313 
314                         \textcolor{comment}{// store current state vector values in temp variables}
315                         stateRealUp = stateVecReal[indexUp];
316                         stateImagUp = stateVecImag[indexUp];
317 
318                         stateRealLo = stateVecReal[indexLo];
319                         stateImagLo = stateVecImag[indexLo];
320 
321                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
322                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag*stateImagUp 
323                                 - betaReal*stateRealLo - betaImag*stateImagLo;
324                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag*stateRealUp 
325                                 - betaReal*stateImagLo + betaImag*stateRealLo;
326 
327                         \textcolor{comment}{// state[indexLo] = beta  * state[indexUp] + conj(alpha) * state[indexLo]}
328                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*stateImagUp 
329                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
330                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*stateRealUp 
331                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
332                 \} 
333         \}
334 
335 \} 
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a5958808b2f2f05937921ba7dabe5a171}\label{qubits__internal_8h_a5958808b2f2f05937921ba7dabe5a171}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!sigma\+X\+Distributed@{sigma\+X\+Distributed}}
\index{sigma\+X\+Distributed@{sigma\+X\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{sigma\+X\+Distributed()}{sigmaXDistributed()}}
{\footnotesize\ttfamily void sigma\+X\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+In,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Out }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{0,1\},\{1,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 627 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and R\+E\+AL.



Referenced by sigma\+X().


\begin{DoxyCode}
630 \{
631 
632         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
633         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
634 
635         \textcolor{comment}{// test qubit valid}
636         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
637 
638         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
639         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
640 
641 \textcolor{preprocessor}{# ifdef \_OPENMP}
642 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
643 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
644 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) \(\backslash\)}
645 \textcolor{preprocessor}{        private  (thisTask)}
646 \textcolor{preprocessor}{# endif}
647         \{
648 \textcolor{preprocessor}{# ifdef \_OPENMP}
649 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
650 \textcolor{preprocessor}{# endif}
651                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
652                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
653                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
654                 \}
655         \}
656 \} 
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_aa9e640bb2d0458c937c6a87dfeca0f23}\label{qubits__internal_8h_aa9e640bb2d0458c937c6a87dfeca0f23}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!sigma\+X\+Local@{sigma\+X\+Local}}
\index{sigma\+X\+Local@{sigma\+X\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{sigma\+X\+Local()}{sigmaXLocal()}}
{\footnotesize\ttfamily void sigma\+X\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{0,1\},\{1,0\}. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}


Definition at line 564 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by sigma\+X().


\begin{DoxyCode}
565 \{
566         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
567         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
568              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
569 
570         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
571         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
572         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
573 
574         \textcolor{comment}{// test qubit valid}
575         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
576 
577         \textcolor{comment}{// set dimensions}
578         sizeHalfBlock = 1LL << rotQubit;  
579         sizeBlock     = 2LL * sizeHalfBlock; 
580 
581         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
582         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
583         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
584 
585 \textcolor{preprocessor}{# ifdef \_OPENMP}
586 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
587 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
588 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
589 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) }
590 \textcolor{preprocessor}{# endif}
591         \{
592 \textcolor{preprocessor}{# ifdef \_OPENMP}
593 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
594 \textcolor{preprocessor}{# endif}
595                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
596                         thisBlock   = thisTask / sizeHalfBlock;
597                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
598                         indexLo     = indexUp + sizeHalfBlock;
599 
600                         stateRealUp = stateVecReal[indexUp];
601                         stateImagUp = stateVecImag[indexUp];
602 
603                         stateVecReal[indexUp] = stateVecReal[indexLo];
604                         stateVecImag[indexUp] = stateVecImag[indexLo];
605 
606                         stateVecReal[indexLo] = stateRealUp;
607                         stateVecImag[indexLo] = stateImagUp;
608                 \} 
609         \}
610 
611 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a0471f6b547ce8270ef85170b7f4f0214}\label{qubits__internal_8h_a0471f6b547ce8270ef85170b7f4f0214}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!sigma\+Y\+Distributed@{sigma\+Y\+Distributed}}
\index{sigma\+Y\+Distributed@{sigma\+Y\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{sigma\+Y\+Distributed()}{sigmaYDistributed()}}
{\footnotesize\ttfamily void sigma\+Y\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+In,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Out,  }\item[{int}]{update\+Upper }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt in}  & {\em update\+Upper} & flag, 1\+: updating upper values, 0\+: updating lower values in block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 850 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and R\+E\+AL.



Referenced by sigma\+Y().


\begin{DoxyCode}
854 \{
855 
856         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
857         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
858 
859         \textcolor{comment}{// test qubit valid}
860         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
861 
862         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
863         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
864 
865         \textcolor{keywordtype}{int} realSign=1, imagSign=1;
866         \textcolor{keywordflow}{if} (updateUpper) imagSign=-1;
867         \textcolor{keywordflow}{else} realSign = -1;
868 
869 \textcolor{preprocessor}{# ifdef \_OPENMP}
870 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
871 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
872 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,realSign,imagSign) \(\backslash\)}
873 \textcolor{preprocessor}{        private  (thisTask)}
874 \textcolor{preprocessor}{# endif}
875         \{
876 \textcolor{preprocessor}{# ifdef \_OPENMP}
877 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
878 \textcolor{preprocessor}{# endif}
879                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
880                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisTask];
881                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisTask];
882                 \}
883         \}
884 \} 
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_afcbb1dcbe070ad0ed1a72a23251b6a83}\label{qubits__internal_8h_afcbb1dcbe070ad0ed1a72a23251b6a83}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!sigma\+Y\+Local@{sigma\+Y\+Local}}
\index{sigma\+Y\+Local@{sigma\+Y\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{sigma\+Y\+Local()}{sigmaYLocal()}}
{\footnotesize\ttfamily void sigma\+Y\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}


Definition at line 787 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by sigma\+Y().


\begin{DoxyCode}
788 \{
789         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
790         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
791              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
792 
793         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
794         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
795         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
796 
797         \textcolor{comment}{// test qubit valid}
798         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
799 
800         \textcolor{comment}{// set dimensions}
801         sizeHalfBlock = 1LL << rotQubit;  
802         sizeBlock     = 2LL * sizeHalfBlock; 
803 
804         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
805         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
806         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
807 
808 \textcolor{preprocessor}{# ifdef \_OPENMP}
809 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
810 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
811 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
812 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) }
813 \textcolor{preprocessor}{# endif}
814         \{
815 \textcolor{preprocessor}{# ifdef \_OPENMP}
816 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
817 \textcolor{preprocessor}{# endif}
818                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
819                         thisBlock   = thisTask / sizeHalfBlock;
820                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
821                         indexLo     = indexUp + sizeHalfBlock;
822 
823                         stateRealUp = stateVecReal[indexUp];
824                         stateImagUp = stateVecImag[indexUp];
825 
826                         stateVecReal[indexUp] = stateVecImag[indexLo];
827                         stateVecImag[indexUp] = -stateVecReal[indexLo];
828 
829                         stateVecReal[indexLo] = -stateImagUp;
830                         stateVecImag[indexLo] = stateRealUp;
831                 \} 
832         \}
833 \}
\end{DoxyCode}
