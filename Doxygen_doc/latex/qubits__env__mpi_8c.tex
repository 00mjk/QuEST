\hypertarget{qubits__env__mpi_8c}{}\subsection{qubits\+\_\+env\+\_\+mpi.\+c File Reference}
\label{qubits__env__mpi_8c}\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}


An implementation of the A\+PI in \hyperlink{qubits_8h}{qubits.\+h} for an M\+PI environment.  


{\ttfamily \#include $<$mpi.\+h$>$}\\*
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include \char`\"{}qubits.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}qubits\+\_\+internal.\+h\char`\"{}}\\*
\subsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{D\+E\+B\+UG}~0
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{qubits__env__mpi_8c_a7cad4a087e3fc919efeb9d22ec451481}{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero} (int chunk\+Id, int chunk\+Size, int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Find chunks to skip when calculating probability of qubit being zero. \end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_ac6f2d948c6afc21ecd934a9794f27271}{chunk\+Is\+Upper} (int chunk\+Id, int chunk\+Size, int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Returns whether a given chunk in position chunk\+Id is in the upper or lower half of a block. \end{DoxyCompactList}\item 
static void \hyperlink{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{get\+Rot\+Angle} (int \hyperlink{qubits__env__mpi_8c_ac6f2d948c6afc21ecd934a9794f27271}{chunk\+Is\+Upper}, \hyperlink{structComplex}{Complex} $\ast$rot1, \hyperlink{structComplex}{Complex} $\ast$rot2, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Get rotation values for a given chunk. \end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_af639d6bba9782cb708fb7f9bc406f28b}{get\+Chunk\+Pair\+Id} (int \hyperlink{qubits__env__mpi_8c_ac6f2d948c6afc21ecd934a9794f27271}{chunk\+Is\+Upper}, int chunk\+Id, int chunk\+Size, int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em get position of corresponding chunk, holding values required to update values in my chunk (with chunk\+Id) when rotating rot\+Qubit. \end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_acb89022e532cdb58441d5e2254a08dfb}{half\+Matrix\+Block\+Fits\+In\+Chunk} (int chunk\+Size, int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em return whether the current qubit rotation will use blocks that fit within a single chunk. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a652d8c53f8f1cfb096133791de2b219d}{init\+Q\+U\+E\+S\+T\+Env} (\hyperlink{structQUESTEnv}{Q\+U\+E\+S\+T\+Env} $\ast$env)
\begin{DoxyCompactList}\small\item\em Initialize Q\+U\+E\+ST environment. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a83dffc500bf5b4e41dd63ba1ea9422ae}{sync\+Q\+U\+E\+S\+T\+Env} (\hyperlink{structQUESTEnv}{Q\+U\+E\+S\+T\+Env} env)
\begin{DoxyCompactList}\small\item\em Guarantees that all code up to the given point has been executed on all nodes. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ad7494473d827399d7fd9c327ea3a23e6}{close\+Q\+U\+E\+S\+T\+Env} (\hyperlink{structQUESTEnv}{Q\+U\+E\+S\+T\+Env} env)
\begin{DoxyCompactList}\small\item\em Close Q\+U\+E\+ST environment. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_aa5d0566a6ef6519ff7b5241915fbf170}{report\+Q\+U\+E\+S\+T\+Env} (\hyperlink{structQUESTEnv}{Q\+U\+E\+S\+T\+Env} env)
\begin{DoxyCompactList}\small\item\em Report information about the Q\+U\+E\+ST environment. \end{DoxyCompactList}\item 
double \hyperlink{qubits__env__mpi_8c_a2205c8fde15213df52040dc3df233090}{calc\+Total\+Probability} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Calculate the probability of being in any state by taking the norm of the entire state vector. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a4ba468aa69f812efd1f964e10a45ca2f}{rotate\+Qubit} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. \end{DoxyCompactList}\item 
double \hyperlink{qubits__env__mpi_8c_af31016680d01044cee9321d4cae32703}{find\+Probability\+Of\+Zero} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
An implementation of the A\+PI in \hyperlink{qubits_8h}{qubits.\+h} for an M\+PI environment. 



\subsubsection{Macro Definition Documentation}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!D\+E\+B\+UG@{D\+E\+B\+UG}}
\index{D\+E\+B\+UG@{D\+E\+B\+UG}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{D\+E\+B\+UG}{DEBUG}}]{\setlength{\rightskip}{0pt plus 5cm}\#define D\+E\+B\+UG~0}\hypertarget{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{}\label{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}


Definition at line 10 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by calc\+Total\+Probability(), and init\+Q\+U\+E\+S\+T\+Env().



\subsubsection{Function Documentation}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!calc\+Total\+Probability@{calc\+Total\+Probability}}
\index{calc\+Total\+Probability@{calc\+Total\+Probability}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{calc\+Total\+Probability(\+Multi\+Qubit multi\+Qubit)}{calcTotalProbability(MultiQubit multiQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}double calc\+Total\+Probability (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a2205c8fde15213df52040dc3df233090}{}\label{qubits__env__mpi_8c_a2205c8fde15213df52040dc3df233090}


Calculate the probability of being in any state by taking the norm of the entire state vector. 

Should be equal to 1. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing a set of qubits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
total probability 
\end{DoxyReturn}


Definition at line 82 of file qubits\+\_\+env\+\_\+mpi.\+c.



References D\+E\+B\+UG, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Chunks, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by main().


\begin{DoxyCode}
82                                                   \{
83         \textcolor{keywordtype}{double} pTotal=0; 
84         \textcolor{keywordtype}{double} allRankTotals=0;
85         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
86         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numAmpsPerRank = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
87         \textcolor{keywordflow}{for} (index=0; index<numAmpsPerRank; index++)\{ 
88                 pTotal+=multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}[index]*multiQubit.
      \hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}[index];      
89                 pTotal+=multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag}[index]*multiQubit.
      \hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag}[index];      
90         \} 
91         \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"before calc prob. %d\(\backslash\)n"}, multiQubit.\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks});
92         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks}>1) MPI\_Allreduce(&pTotal, &allRankTotals, 1, MPI\_DOUBLE, MPI\_SUM,
       MPI\_COMM\_WORLD);
93         \textcolor{keywordflow}{else} allRankTotals=pTotal;
94 
95         \textcolor{keywordflow}{return} allRankTotals;
96 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!chunk\+Is\+Upper@{chunk\+Is\+Upper}}
\index{chunk\+Is\+Upper@{chunk\+Is\+Upper}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{chunk\+Is\+Upper(int chunk\+Id, int chunk\+Size, int rot\+Qubit)}{chunkIsUpper(int chunkId, int chunkSize, int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}static int chunk\+Is\+Upper (
\begin{DoxyParamCaption}
\item[{int}]{chunk\+Id, }
\item[{int}]{chunk\+Size, }
\item[{int}]{rot\+Qubit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_ac6f2d948c6afc21ecd934a9794f27271}{}\label{qubits__env__mpi_8c_ac6f2d948c6afc21ecd934a9794f27271}


Returns whether a given chunk in position chunk\+Id is in the upper or lower half of a block. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Id} & id of chunk in state vector \\
\hline
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit being rotated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1\+: chunk is in upper half of block, 0\+: chunk is in lower half of block 
\end{DoxyReturn}


Definition at line 107 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by rotate\+Qubit().


\begin{DoxyCode}
108 \{       
109         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (rotQubit);
110         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock = sizeHalfBlock*2;
111         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} posInBlock = (chunkId*chunkSize) % sizeBlock;
112         \textcolor{keywordflow}{return} posInBlock<sizeHalfBlock;
113 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!close\+Q\+U\+E\+S\+T\+Env@{close\+Q\+U\+E\+S\+T\+Env}}
\index{close\+Q\+U\+E\+S\+T\+Env@{close\+Q\+U\+E\+S\+T\+Env}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{close\+Q\+U\+E\+S\+T\+Env(\+Q\+U\+E\+S\+T\+Env env)}{closeQUESTEnv(QUESTEnv env)}}]{\setlength{\rightskip}{0pt plus 5cm}void close\+Q\+U\+E\+S\+T\+Env (
\begin{DoxyParamCaption}
\item[{{\bf Q\+U\+E\+S\+T\+Env}}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_ad7494473d827399d7fd9c327ea3a23e6}{}\label{qubits__env__mpi_8c_ad7494473d827399d7fd9c327ea3a23e6}


Close Q\+U\+E\+ST environment. 

If something needs to be done to clean up the execution environment, such as finalizing M\+PI when running in distributed mode, it is handled here 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 41 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by main().


\begin{DoxyCode}
41                                 \{
42         \textcolor{keywordtype}{int} finalized;
43         MPI\_Finalized(&finalized);
44         \textcolor{keywordflow}{if} (!finalized) MPI\_Finalize();
45         \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"ERROR: Trying to close QUESTEnv multiple times. Ignoring\(\backslash\)n"});
46 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!find\+Probability\+Of\+Zero@{find\+Probability\+Of\+Zero}}
\index{find\+Probability\+Of\+Zero@{find\+Probability\+Of\+Zero}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{find\+Probability\+Of\+Zero(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit)}{findProbabilityOfZero(MultiQubit multiQubit, const int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}double find\+Probability\+Of\+Zero (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_af31016680d01044cee9321d4cae32703}{}\label{qubits__env__mpi_8c_af31016680d01044cee9321d4cae32703}


Measure the probability of a specified qubit being in the zero state. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits to be initialised \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 226 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, find\+Probability\+Of\+Zero\+Distributed(), find\+Probability\+Of\+Zero\+Local(), half\+Matrix\+Block\+Fits\+In\+Chunk(), is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero(), and Multi\+Qubit\+::num\+Amps.


\begin{DoxyCode}
228 \{
229         \textcolor{keywordtype}{double} stateProb=0, totalStateProb=0;
230         \textcolor{keywordtype}{int} skipValuesWithinRank = \hyperlink{qubits__env__mpi_8c_acb89022e532cdb58441d5e2254a08dfb}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, measureQubit);
231         \textcolor{keywordflow}{if} (skipValuesWithinRank) \{
232                 stateProb = \hyperlink{qubits_8c_a1c0a25823add0bd9f925a9164dc21870}{findProbabilityOfZeroLocal}(multiQubit, measureQubit);
233         \} \textcolor{keywordflow}{else} \{
234                 \textcolor{keywordflow}{if} (!\hyperlink{qubits__env__mpi_8c_a7cad4a087e3fc919efeb9d22ec451481}{isChunkToSkipInFindPZero}(multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, measureQubit))\{
235                         stateProb = \hyperlink{qubits_8c_a2d302738d123129a388edf81b845fd89}{findProbabilityOfZeroDistributed}(
      multiQubit, measureQubit);
236                 \} \textcolor{keywordflow}{else} stateProb = 0;
237         \}
238         MPI\_Allreduce(&stateProb, &totalStateProb, 1, MPI\_DOUBLE, MPI\_SUM, MPI\_COMM\_WORLD);
239         \textcolor{keywordflow}{return} totalStateProb;
240 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Chunk\+Pair\+Id@{get\+Chunk\+Pair\+Id}}
\index{get\+Chunk\+Pair\+Id@{get\+Chunk\+Pair\+Id}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{get\+Chunk\+Pair\+Id(int chunk\+Is\+Upper, int chunk\+Id, int chunk\+Size, int rot\+Qubit)}{getChunkPairId(int chunkIsUpper, int chunkId, int chunkSize, int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}static int get\+Chunk\+Pair\+Id (
\begin{DoxyParamCaption}
\item[{int}]{chunk\+Is\+Upper, }
\item[{int}]{chunk\+Id, }
\item[{int}]{chunk\+Size, }
\item[{int}]{rot\+Qubit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_af639d6bba9782cb708fb7f9bc406f28b}{}\label{qubits__env__mpi_8c_af639d6bba9782cb708fb7f9bc406f28b}


get position of corresponding chunk, holding values required to update values in my chunk (with chunk\+Id) when rotating rot\+Qubit. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Is\+Upper} & 1\+: chunk is in upper half of block, 0\+: chunk is in lower half \\
\hline
\mbox{\tt in}  & {\em chunk\+Id} & id of chunk in state vector \\
\hline
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit being rotated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
chunk\+Id of chunk required to rotate rot\+Qubit 
\end{DoxyReturn}


Definition at line 149 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by rotate\+Qubit().


\begin{DoxyCode}
150 \{
151         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (rotQubit);
152         \textcolor{keywordtype}{int} chunksPerHalfBlock = sizeHalfBlock/chunkSize;
153         \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_ac6f2d948c6afc21ecd934a9794f27271}{chunkIsUpper})\{
154                 \textcolor{keywordflow}{return} chunkId + chunksPerHalfBlock;
155         \} \textcolor{keywordflow}{else} \{
156                 \textcolor{keywordflow}{return} chunkId - chunksPerHalfBlock;
157         \}
158 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Rot\+Angle@{get\+Rot\+Angle}}
\index{get\+Rot\+Angle@{get\+Rot\+Angle}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{get\+Rot\+Angle(int chunk\+Is\+Upper, Complex $\ast$rot1, Complex $\ast$rot2, Complex alpha, Complex beta)}{getRotAngle(int chunkIsUpper, Complex *rot1, Complex *rot2, Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}static void get\+Rot\+Angle (
\begin{DoxyParamCaption}
\item[{int}]{chunk\+Is\+Upper, }
\item[{{\bf Complex} $\ast$}]{rot1, }
\item[{{\bf Complex} $\ast$}]{rot2, }
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{}\label{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}


Get rotation values for a given chunk. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Is\+Upper} & 1\+: chunk is in upper half of block, 0\+: chunk is in lower half\\
\hline
\mbox{\tt out}  & {\em rot1,rot2} & rotation values to use, allocated for upper/lower such that \begin{DoxyVerb}stateUpper = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 or \begin{DoxyVerb}stateLower = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 \\
\hline
\mbox{\tt in}  & {\em alpha,beta} & initial rotation values \\
\hline
\end{DoxyParams}


Definition at line 128 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Complex\+::imag, and Complex\+::real.



Referenced by rotate\+Qubit().


\begin{DoxyCode}
129 \{
130         \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_ac6f2d948c6afc21ecd934a9794f27271}{chunkIsUpper})\{
131                 *rot1=alpha;
132                 rot2->\hyperlink{structComplex_a0138f5fe2b2c6180b8fcda77a7aa51c5}{real}=-beta.\hyperlink{structComplex_a0138f5fe2b2c6180b8fcda77a7aa51c5}{real};
133                 rot2->\hyperlink{structComplex_a2bb90cc563599c3c8bdec9acf9ea40a6}{imag}=-beta.\hyperlink{structComplex_a2bb90cc563599c3c8bdec9acf9ea40a6}{imag};
134         \} \textcolor{keywordflow}{else} \{
135                 *rot1=beta;
136                 *rot2=alpha;
137         \}
138 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!half\+Matrix\+Block\+Fits\+In\+Chunk@{half\+Matrix\+Block\+Fits\+In\+Chunk}}
\index{half\+Matrix\+Block\+Fits\+In\+Chunk@{half\+Matrix\+Block\+Fits\+In\+Chunk}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{half\+Matrix\+Block\+Fits\+In\+Chunk(int chunk\+Size, int rot\+Qubit)}{halfMatrixBlockFitsInChunk(int chunkSize, int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}static int half\+Matrix\+Block\+Fits\+In\+Chunk (
\begin{DoxyParamCaption}
\item[{int}]{chunk\+Size, }
\item[{int}]{rot\+Qubit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_acb89022e532cdb58441d5e2254a08dfb}{}\label{qubits__env__mpi_8c_acb89022e532cdb58441d5e2254a08dfb}


return whether the current qubit rotation will use blocks that fit within a single chunk. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit being rotated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1\+: one chunk fits in one block 0\+: chunk is larger than block 
\end{DoxyReturn}


Definition at line 168 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by find\+Probability\+Of\+Zero(), and rotate\+Qubit().


\begin{DoxyCode}
169 \{
170         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (rotQubit);
171         \textcolor{keywordflow}{if} (chunkSize > sizeHalfBlock) \textcolor{keywordflow}{return} 1;
172         \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} 0;
173 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!init\+Q\+U\+E\+S\+T\+Env@{init\+Q\+U\+E\+S\+T\+Env}}
\index{init\+Q\+U\+E\+S\+T\+Env@{init\+Q\+U\+E\+S\+T\+Env}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{init\+Q\+U\+E\+S\+T\+Env(\+Q\+U\+E\+S\+T\+Env $\ast$env)}{initQUESTEnv(QUESTEnv *env)}}]{\setlength{\rightskip}{0pt plus 5cm}void init\+Q\+U\+E\+S\+T\+Env (
\begin{DoxyParamCaption}
\item[{{\bf Q\+U\+E\+S\+T\+Env} $\ast$}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a652d8c53f8f1cfb096133791de2b219d}{}\label{qubits__env__mpi_8c_a652d8c53f8f1cfb096133791de2b219d}


Initialize Q\+U\+E\+ST environment. 

If something needs to be done to set up the execution environment, such as initializing M\+PI when running in distributed mode, it is handled here 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 17 of file qubits\+\_\+env\+\_\+mpi.\+c.



References D\+E\+B\+UG, Q\+U\+E\+S\+T\+Env\+::num\+Ranks, and Q\+U\+E\+S\+T\+Env\+::rank.



Referenced by main().


\begin{DoxyCode}
17                                 \{
18         \textcolor{comment}{// init MPI environment}
19         \textcolor{keywordtype}{int} rank, numRanks, initialized;
20         MPI\_Initialized(&initialized);
21         \textcolor{keywordflow}{if} (!initialized)\{
22                 MPI\_Init(NULL, NULL);
23                 MPI\_Comm\_size(MPI\_COMM\_WORLD, &numRanks);
24                 MPI\_Comm\_rank(MPI\_COMM\_WORLD, &rank);
25 
26                 \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) \{
27                         \textcolor{keywordtype}{char} hostName[256];
28                         \textcolor{keywordtype}{int} hostNameLen;
29                         MPI\_Get\_processor\_name(hostName, &hostNameLen);
30                         printf(\textcolor{stringliteral}{"rank %d on host %s\(\backslash\)n"}, rank, hostName);
31                 \}
32                 env->\hyperlink{structQUESTEnv_a1bdb6d425a2ce6a468f93929c0b26d73}{rank}=rank;
33                 env->\hyperlink{structQUESTEnv_ab9d9ce82e2d5f1b39aa9efc3accb3742}{numRanks}=numRanks;
34         \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"ERROR: Trying to initialize QUESTEnv multiple times. Ignoring\(\backslash\)n"});
35 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero@{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero}}
\index{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero@{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero(int chunk\+Id, int chunk\+Size, int measure\+Qubit)}{isChunkToSkipInFindPZero(int chunkId, int chunkSize, int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}static int is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero (
\begin{DoxyParamCaption}
\item[{int}]{chunk\+Id, }
\item[{int}]{chunk\+Size, }
\item[{int}]{measure\+Qubit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_a7cad4a087e3fc919efeb9d22ec451481}{}\label{qubits__env__mpi_8c_a7cad4a087e3fc919efeb9d22ec451481}


Find chunks to skip when calculating probability of qubit being zero. 

When calculating probability of a bit q being zero, sum up 2$^\wedge$q values, then skip 2$^\wedge$q values, etc. This function finds if an entire chunk is in the range of values to be skipped


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Id} & id of chunk in state vector \\
\hline
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em measure\+Qubi} & qubit being measured \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int -- 1\+: skip, 0\+: don\textquotesingle{}t skip 
\end{DoxyReturn}


Definition at line 74 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by find\+Probability\+Of\+Zero().


\begin{DoxyCode}
74                                                                                  \{
75         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (measureQubit);
76         \textcolor{keywordtype}{int} numChunksToSkip = sizeHalfBlock/chunkSize;
77         \textcolor{comment}{// calculate probability by summing over numChunksToSkip, then skipping numChunksToSkip, etc}
78         \textcolor{keywordtype}{int} bitToCheck = chunkId & numChunksToSkip;
79         \textcolor{keywordflow}{return} bitToCheck;
80 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!report\+Q\+U\+E\+S\+T\+Env@{report\+Q\+U\+E\+S\+T\+Env}}
\index{report\+Q\+U\+E\+S\+T\+Env@{report\+Q\+U\+E\+S\+T\+Env}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{report\+Q\+U\+E\+S\+T\+Env(\+Q\+U\+E\+S\+T\+Env env)}{reportQUESTEnv(QUESTEnv env)}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+Q\+U\+E\+S\+T\+Env (
\begin{DoxyParamCaption}
\item[{{\bf Q\+U\+E\+S\+T\+Env}}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_aa5d0566a6ef6519ff7b5241915fbf170}{}\label{qubits__env__mpi_8c_aa5d0566a6ef6519ff7b5241915fbf170}


Report information about the Q\+U\+E\+ST environment. 



Definition at line 48 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Q\+U\+E\+S\+T\+Env\+::num\+Ranks, and Q\+U\+E\+S\+T\+Env\+::rank.



Referenced by main().


\begin{DoxyCode}
48                                  \{
49         \textcolor{keywordflow}{if} (env.\hyperlink{structQUESTEnv_a1bdb6d425a2ce6a468f93929c0b26d73}{rank}==0)\{
50                 printf(\textcolor{stringliteral}{"EXECUTION ENVIRONMENT:\(\backslash\)n"}); 
51                 printf(\textcolor{stringliteral}{"Running distributed (MPI) version\(\backslash\)n"});
52                 printf(\textcolor{stringliteral}{"Number of ranks is %d\(\backslash\)n"}, env.\hyperlink{structQUESTEnv_ab9d9ce82e2d5f1b39aa9efc3accb3742}{numRanks});
53 \textcolor{preprocessor}{# ifdef \_OPENMP}
54                 printf(\textcolor{stringliteral}{"OpenMP enabled\(\backslash\)n"});
55                 printf(\textcolor{stringliteral}{"Number of threads available is %d\(\backslash\)n"}, omp\_get\_max\_threads());
56 \textcolor{preprocessor}{# else}
57                 printf(\textcolor{stringliteral}{"OpenMP disabled\(\backslash\)n"});
58 \textcolor{preprocessor}{# endif }
59         \}
60 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!rotate\+Qubit@{rotate\+Qubit}}
\index{rotate\+Qubit@{rotate\+Qubit}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{rotate\+Qubit(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, Complex alpha, Complex beta)}{rotateQubit(MultiQubit multiQubit, const int rotQubit, Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}void rotate\+Qubit (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a4ba468aa69f812efd1f964e10a45ca2f}{}\label{qubits__env__mpi_8c_a4ba468aa69f812efd1f964e10a45ca2f}


Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. 

alpha\+Re = cos(angle1) $\ast$ cos(angle2) ~\newline
alpha\+Im = cos(angle1) $\ast$ sin(angle2) ~\newline
 beta\+Re = sin(angle1) $\ast$ cos(angle3) ~\newline
 beta\+Im = sin(angle1) $\ast$ sin(angle3) ~\newline


\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits to be initialised \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em alpha} & rotation angle \\
\hline
\mbox{\tt in}  & {\em beta} & rotation angle \\
\hline
\end{DoxyParams}


Definition at line 175 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), get\+Chunk\+Pair\+Id(), get\+Rot\+Angle(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::pair\+State\+Vec, Complex\+Array\+::real, rotate\+Qubit\+Distributed(), rotate\+Qubit\+Local(), and Multi\+Qubit\+::state\+Vec.



Referenced by main().


\begin{DoxyCode}
177 \{
178         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
179         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_acb89022e532cdb58441d5e2254a08dfb}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
180         \hyperlink{structComplex}{Complex} rot1, rot2;
181 
182         \textcolor{comment}{// rank's chunk is in upper half of block }
183         \textcolor{keywordtype}{int} rankIsUpper;
184         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
185 
186         \textcolor{comment}{// MPI send/receive vars}
187         \textcolor{keywordtype}{int} TAG=100;
188         MPI\_Status status;
189 
190         \textcolor{keywordtype}{double} *stateVecReal, stateVecImag, stateVecRealPair, stateVecImagPair;
191         
192 
193         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
194                 \textcolor{comment}{// all values required to update state vector lie in this rank}
195                 \hyperlink{qubits_8c_acb059cbcb8c7910a5fc43d21da4f5dea}{rotateQubitLocal}(multiQubit, rotQubit, alpha, beta);
196         \} \textcolor{keywordflow}{else} \{
197                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
198                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_ac6f2d948c6afc21ecd934a9794f27271}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
199                 \hyperlink{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{getRotAngle}(rankIsUpper, &rot1, &rot2, alpha, beta);
200                 pairRank = \hyperlink{qubits__env__mpi_8c_af639d6bba9782cb708fb7f9bc406f28b}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
201                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
202                 \textcolor{comment}{// get corresponding values from my pair}
203                 MPI\_Sendrecv(multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, MPI\_DOUBLE, pairRank, TAG,
204                                  multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, MPI\_DOUBLE, pairRank, TAG,
205                                  MPI\_COMM\_WORLD, &status);
206                 \textcolor{comment}{//printf("rank: %d err: %d\(\backslash\)n", multiQubit.rank, err);}
207                 MPI\_Sendrecv(multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, MPI\_DOUBLE, pairRank, TAG,
208                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, MPI\_DOUBLE, pairRank, TAG,
209                                 MPI\_COMM\_WORLD, &status);
210                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. send values to
       rotateQubitDistributed}
211                 \textcolor{comment}{// in the correct order}
212                 \textcolor{keywordflow}{if} (rankIsUpper)\{
213                         \hyperlink{qubits_8c_a6ff67d25363f39fd57a4e76621a4bfd5}{rotateQubitDistributed}(multiQubit,rotQubit,rot1,rot2,
214                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//upper}
215                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//lower}
216                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
217                 \} \textcolor{keywordflow}{else} \{
218                         \hyperlink{qubits_8c_a6ff67d25363f39fd57a4e76621a4bfd5}{rotateQubitDistributed}(multiQubit,rotQubit,rot1,rot2,
219                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//upper}
220                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//lower}
221                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
222                 \}
223         \}
224 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!sync\+Q\+U\+E\+S\+T\+Env@{sync\+Q\+U\+E\+S\+T\+Env}}
\index{sync\+Q\+U\+E\+S\+T\+Env@{sync\+Q\+U\+E\+S\+T\+Env}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{sync\+Q\+U\+E\+S\+T\+Env(\+Q\+U\+E\+S\+T\+Env env)}{syncQUESTEnv(QUESTEnv env)}}]{\setlength{\rightskip}{0pt plus 5cm}void sync\+Q\+U\+E\+S\+T\+Env (
\begin{DoxyParamCaption}
\item[{{\bf Q\+U\+E\+S\+T\+Env}}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a83dffc500bf5b4e41dd63ba1ea9422ae}{}\label{qubits__env__mpi_8c_a83dffc500bf5b4e41dd63ba1ea9422ae}


Guarantees that all code up to the given point has been executed on all nodes. 



Definition at line 37 of file qubits\+\_\+env\+\_\+mpi.\+c.


\begin{DoxyCode}
37                                \{
38         MPI\_Barrier(MPI\_COMM\_WORLD);
39 \}
\end{DoxyCode}
