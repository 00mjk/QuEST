\hypertarget{qubits_8c}{
\subsection{qubits.c File Reference}
\label{qubits_8c}\index{qubits.c@{qubits.c}}
}


The core of the QuEST Library.  
{\ttfamily \#include $<$math.h$>$}\par
{\ttfamily \#include $<$stdio.h$>$}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$assert.h$>$}\par
{\ttfamily \#include \char`\"{}precision.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}qubits.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}qubits\_\-internal.h\char`\"{}}\par
{\ttfamily \#include $<$omp.h$>$}\par
\subsubsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}~0
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (const int locationOfBitFromRight, const long long int theEncodedNumber)
\begin{DoxyCompactList}\small\item\em Get the value of the bit at a particular index in a number. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a9c02591bc64c2918503afa231d90d83f}{createMultiQubit} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit, int numQubits, \hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Create a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}{destroyMultiQubit} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, \hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Deallocate a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}{reportState} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Print the current state vector of probability amplitudes for a set of qubits to file. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a842d6884e063a5865a2232cba56b65ac}{reportStateToScreen} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, \hyperlink{structQuESTEnv}{QuESTEnv} env, int reportRank)
\begin{DoxyCompactList}\small\item\em Print the current state vector of probability amplitudes for a set of qubits to standard out. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}{reportMultiQubitParams} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Report metainformation about a set of qubits: number of qubits, number of probability amplitudes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a8f10aabf9f607f19093aee54630caa21}{getEnvironmentString} (\hyperlink{structQuESTEnv}{QuESTEnv} env, \hyperlink{structMultiQubit}{MultiQubit} multiQubit, char str\mbox{[}200\mbox{]})
\item 
void \hyperlink{qubits_8c_acb5b2eff794339090004d29f02a70d9a}{initStateZero} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit)
\begin{DoxyCompactList}\small\item\em Initialise a set of $ N $ qubits to the classical zero state $ {| 0 \rangle}^{\otimes N} $. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}{initStatePlus} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit)
\begin{DoxyCompactList}\small\item\em Initialise a set of $ N $ qubits to the plus state $ {| + \rangle}^{\otimes N} = \frac{1}{\sqrt{2^N}} (| 0 \rangle + | 1 \rangle)^{\otimes N} $. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a7169fd0442cbc3418f3fac4d13363ca2}{initStateOfSingleQubit} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit, int qubitId, int outcome)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes such that one qubit is set to 'outcome' and all other qubits are in an equal superposition of zero and one. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}{initStateDebug} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes to an (unphysical) state with each component of each probability amplitude a unique floating point value. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a433876ee9f3bcc54af346300f571fc3c}{initializeStateFromSingleFile} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit, char filename\mbox{[}200\mbox{]}, \hyperlink{structQuESTEnv}{QuESTEnv} env)
\item 
int \hyperlink{qubits_8c_a793584932ae384c82e7e42db7d35d18d}{compareStates} (\hyperlink{structMultiQubit}{MultiQubit} mq1, \hyperlink{structMultiQubit}{MultiQubit} mq2, REAL precision)
\item 
int \hyperlink{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}{validateMatrixIsUnitary} (\hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
int \hyperlink{qubits_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}{validateAlphaBeta} (\hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
int \hyperlink{qubits_8c_a71c14976f63cfcda70026fa20ee531fe}{validateUnitVector} (REAL ux, REAL uy, REAL uz)
\item 
void \hyperlink{qubits_8c_a8810423457803005fecd415f4299f40d}{rotateAroundAxis} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle, \hyperlink{structVector}{Vector} axis)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around a given vector on the Bloch-\/sphere. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a6cc7fa705a2f2e6b486b49c5589d5df5}{rotateX} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around the X-\/axis of the Bloch-\/sphere. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ace0d3592d38a990e81a434c4e9681500}{rotateY} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around the Y-\/axis of the Bloch-\/sphere. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_abd621412ad30c1b034f4ce153c4afe10}{rotateZ} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around the Z-\/axis of the Bloch-\/sphere (also known as a phase shift gate). \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ad41f82b41149393a642391b67b3a287e}{controlledRotateAroundAxis} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, REAL angle, \hyperlink{structVector}{Vector} axis)
\item 
void \hyperlink{qubits_8c_ac6923ac57e67d9a21096e06f6a9012f6}{controlledRotateX} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, REAL angle)
\item 
void \hyperlink{qubits_8c_a71e90a2f7292116338c062934f9d1202}{controlledRotateY} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, REAL angle)
\item 
void \hyperlink{qubits_8c_a668e5d2634b02e98bc73675ccb11d61c}{controlledRotateZ} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, REAL angle)
\item 
void \hyperlink{qubits_8c_a9cee2d8716667a3318420a3b672f5b92}{compactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits_8c_ac134fb45b0a7248c5d15e16eb7139a35}{unitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits_8c_a20ee1878a63ae6112e8845f4a8787592}{compactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a2343b7240118e89aa615e2c9140b770b}{unitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_afc77657651d52c47403b44b923a098a8}{controlledCompactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits_8c_a1309eabcba3cb97fbc3cd2e606d17766}{multiControlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits_8c_a8a4afcff70195a306c082b8ed8d4e09a}{controlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits_8c_a717855e835e3161e08c18cdc15325d27}{controlledCompactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a642093063a1f889f61a1311f6d6f2d3f}{controlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{multiControlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a74822fd86bb5d81766e6e8dbdcd62df1}{sigmaXLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits_8c_a2275fff50824fe47485890ff5a857785}{sigmaXDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ad357a43e80e3baf013975b1b70942f4c}{controlledNotLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit)
\item 
void \hyperlink{qubits_8c_a05875a70b539a3efb28d027823403f34}{controlledNotDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a81fbfaed65a742a7dfd622e17652245e}{sigmaYLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits_8c_af5ef5166f00c0572354b4ac53dcf40cf}{sigmaYDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_aa9f0718b4dd794a3e1b143e3b153bfc5}{hadamardLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits_8c_ae6a897066979fc52d977007d959ca09d}{hadamardDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a3a54566b73ac84c312d7da4f56ffbc3b}{phaseGateLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits_8c_af832ed00b02a0597b7fe0b714032c54a}{phaseGateDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits_8c_aebaab86326779de55d335cfea3efde8f}{sigmaZ} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit sigma-\/Z (also known as the Z, Pauli-\/Z or phase-\/flip) gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_adda6c47876a7676488ed0565a19eaa65}{sGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit S gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_af764ea63a2e870098f4e1ce08562942e}{tGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit T gate. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}{findProbabilityOfZeroLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}{findProbabilityOfZeroDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a11a96159191cbf1b01a1080e7f045aac}{controlledPhaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int idQubit1, const int idQubit2)
\begin{DoxyCompactList}\small\item\em Apply the (two-\/qubit) controlled phase gate, also known as the controlled sigmaZ gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_afc1835c6b43b6e59ce7df7b13f274fc7}{multiControlledPhaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int $\ast$controlQubits, int numControlQubits)
\begin{DoxyCompactList}\small\item\em Apply the multiple-\/qubit controlled phase gate, also known as the multiple-\/qubit controlled sigmaZ gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a01d9a8b7ff0e09ec399e158389783aa9}{collapseToOutcomeLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int measureQubit, REAL totalProbability, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, const REAL totalProbability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Set all amplitudes in one chunk to 0. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}{getProbEl} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the probability of the state at an index in the full state vector. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \hyperlink{qubits_8c_aac1637696885c75b73a1ecf381cea713}{errorCodes} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
The core of the QuEST Library. 

Definition in file \hyperlink{qubits_8c_source}{qubits.c}.

\subsubsection{Define Documentation}
\hypertarget{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{
\index{qubits.c@{qubits.c}!DEBUG@{DEBUG}}
\index{DEBUG@{DEBUG}!qubits.c@{qubits.c}}
\paragraph[{DEBUG}]{\setlength{\rightskip}{0pt plus 5cm}\#define DEBUG~0}\hfill}
\label{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}


Definition at line 18 of file qubits.c.

Referenced by calcTotalProbability(), exchangeStateVectors(), findProbabilityOfZeroLocal(), initQuESTEnv(), initStateOfSingleQubit(), initStatePlus(), and initStateZero().

\subsubsection{Function Documentation}
\hypertarget{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{
\index{qubits.c@{qubits.c}!collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}}
\index{collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}!qubits.c@{qubits.c}}
\paragraph[{collapseToOutcomeDistributedRenorm}]{\setlength{\rightskip}{0pt plus 5cm}REAL collapseToOutcomeDistributedRenorm ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  const REAL {\em totalProbability})}\hfill}
\label{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}


Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that the value 'outcome' has been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being zero \end{DoxyParams}


Definition at line 1898 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1899 {
1900         // ----- temp variables
1901         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1902         long long int numTasks=multiQubit.numAmps;
1903         // (good for shared memory parallelism)
1904 
1905         REAL renorm=1/sqrt(totalProbability);
1906         
1907         REAL *stateVecReal = multiQubit.stateVec.real;
1908         REAL *stateVecImag = multiQubit.stateVec.imag;
1909 
1910 # ifdef _OPENMP
1911 # pragma omp parallel \
1912         shared    (numTasks,stateVecReal,stateVecImag) \
1913         private   (thisTask)
1914 # endif
1915         {
1916 # ifdef _OPENMP
1917                 # pragma omp for schedule  (static)
1918 # endif
1919                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1920                         // summation -- simple implementation
1921                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
1922                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
1923                 }
1924         }
1925         return totalProbability;
1926 }
\end{DoxyCode}
\hypertarget{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{
\index{qubits.c@{qubits.c}!collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}}
\index{collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}!qubits.c@{qubits.c}}
\paragraph[{collapseToOutcomeDistributedSetZero}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeDistributedSetZero ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}


Set all amplitudes in one chunk to 0. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that a zero have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}


Definition at line 1940 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1941 {
1942         // ----- temp variables
1943         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1944         long long int numTasks=multiQubit.numAmps;
1945         // (good for shared memory parallelism)
1946 
1947         // ---------------------------------------------------------------- //
1948         //            find probability                                      //
1949         // ---------------------------------------------------------------- //
1950 
1951         REAL *stateVecReal = multiQubit.stateVec.real;
1952         REAL *stateVecImag = multiQubit.stateVec.imag;
1953 
1954 # ifdef _OPENMP
1955 # pragma omp parallel \
1956         shared    (numTasks,stateVecReal,stateVecImag) \
1957         private   (thisTask)
1958 # endif
1959         {
1960 # ifdef _OPENMP
1961                 # pragma omp for schedule  (static)
1962 # endif
1963                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1964                         // summation -- simple implementation
1965                         stateVecReal[thisTask] = 0;
1966                         stateVecImag[thisTask] = 0;
1967                 }
1968         }
1969 }
\end{DoxyCode}
\hypertarget{qubits_8c_a01d9a8b7ff0e09ec399e158389783aa9}{
\index{qubits.c@{qubits.c}!collapseToOutcomeLocal@{collapseToOutcomeLocal}}
\index{collapseToOutcomeLocal@{collapseToOutcomeLocal}!qubits.c@{qubits.c}}
\paragraph[{collapseToOutcomeLocal}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeLocal ({\bf MultiQubit} {\em multiQubit}, \/  int {\em measureQubit}, \/  REAL {\em totalProbability}, \/  int {\em outcome})}\hfill}
\label{qubits_8c_a01d9a8b7ff0e09ec399e158389783aa9}


Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. Performs an irreversible change to the state vector: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being either zero or one \item[\mbox{$\leftarrow$} {\em outcome}]to measure the probability of and set the state to -\/-\/ either zero or one \end{DoxyParams}


Definition at line 1816 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1817 {
1818         // ----- sizes
1819         long long int sizeBlock,                                           // siz
      e of blocks
1820         sizeHalfBlock;                                       // size of blocks ha
      lved
1821         // ----- indices
1822         long long int thisBlock,                                           // cur
      rent block
1823              index;                                               // current inde
      x for first half block
1824         // ----- measured probability
1825         REAL   renorm;                                    // probability (returne
      d) value
1826         // ----- temp variables
1827         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1828         // (good for shared memory parallelism)
1829         long long int numTasks=multiQubit.numAmps>>1;
1830 
1831         // ---------------------------------------------------------------- //
1832         //            dimensions                                            //
1833         // ---------------------------------------------------------------- //
1834         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1835         // and then the number to skip
1836         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1837         
1838         renorm=1/sqrt(totalProbability);
1839         REAL *stateVecReal = multiQubit.stateVec.real;
1840         REAL *stateVecImag = multiQubit.stateVec.imag;
1841 
1842 
1843 # ifdef _OPENMP
1844 # pragma omp parallel \
1845         default (none) \
1846         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,re
      norm,outcome) \
1847         private   (thisTask,thisBlock,index)
1848 # endif
1849         {
1850                 if (outcome==0){
1851                         // measure qubit is 0
1852 # ifdef _OPENMP
1853                         # pragma omp for schedule  (static)
1854 # endif
1855                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1856                                 thisBlock = thisTask / sizeHalfBlock;
1857                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
1858                                 stateVecReal[index]=stateVecReal[index]*renorm;
1859                                 stateVecImag[index]=stateVecImag[index]*renorm;
1860 
1861                                 stateVecReal[index+sizeHalfBlock]=0;
1862                                 stateVecImag[index+sizeHalfBlock]=0;
1863                         }
1864                 } else {
1865                         // measure qubit is 1
1866 # ifdef _OPENMP
1867                         # pragma omp for schedule  (static)
1868 # endif
1869                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1870                                 thisBlock = thisTask / sizeHalfBlock;
1871                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
1872                                 stateVecReal[index]=0;
1873                                 stateVecImag[index]=0;
1874 
1875                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[in
      dex+sizeHalfBlock]*renorm;
1876                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[in
      dex+sizeHalfBlock]*renorm;
1877                         }
1878                 }
1879         }
1880 
1881 }
\end{DoxyCode}
\hypertarget{qubits_8c_a20ee1878a63ae6112e8845f4a8787592}{
\index{qubits.c@{qubits.c}!compactUnitaryDistributed@{compactUnitaryDistributed}}
\index{compactUnitaryDistributed@{compactUnitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{compactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a20ee1878a63ae6112e8845f4a8787592}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 573 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by compactUnitary().


\begin{DoxyCode}
578 {
579 
580         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
581         long long int thisTask;  
582         const long long int numTasks=multiQubit.numAmps;
583 
584         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
585         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
586         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
587         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
588         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
589 
590 # ifdef _OPENMP
591 # pragma omp parallel \
592         default  (none) \
593         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
594                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
595         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
596 # endif
597         {
598 # ifdef _OPENMP
599                 # pragma omp for schedule (static)
600 # endif
601                 for (thisTask=0; thisTask<numTasks; thisTask++) {
602                         // store current state vector values in temp variables
603                         stateRealUp = stateVecRealUp[thisTask];
604                         stateImagUp = stateVecImagUp[thisTask];
605 
606                         stateRealLo = stateVecRealLo[thisTask];
607                         stateImagLo = stateVecImagLo[thisTask];
608 
609                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
610                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
611                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
612                 }
613         }
614 }
\end{DoxyCode}
\hypertarget{qubits_8c_a9cee2d8716667a3318420a3b672f5b92}{
\index{qubits.c@{qubits.c}!compactUnitaryLocal@{compactUnitaryLocal}}
\index{compactUnitaryLocal@{compactUnitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{compactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits_8c_a9cee2d8716667a3318420a3b672f5b92}


Definition at line 444 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by compactUnitary().


\begin{DoxyCode}
445 {
446         long long int sizeBlock, sizeHalfBlock;
447         long long int thisBlock, // current block
448              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
449 
450         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
451         long long int thisTask;         
452         const long long int numTasks=multiQubit.numAmps>>1;
453 
454         // set dimensions
455         sizeHalfBlock = 1LL << targetQubit;  
456         sizeBlock     = 2LL * sizeHalfBlock; 
457 
458         // Can't use multiQubit.stateVec as a private OMP var
459         REAL *stateVecReal = multiQubit.stateVec.real;
460         REAL *stateVecImag = multiQubit.stateVec.imag;
461         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
462         REAL betaImag=beta.imag, betaReal=beta.real;
463 
464 # ifdef _OPENMP
465 # pragma omp parallel \
466         default  (none) \
467         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
468         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
469 # endif
470         {
471 # ifdef _OPENMP
472                 # pragma omp for schedule (static)
473 # endif
474                 for (thisTask=0; thisTask<numTasks; thisTask++) {
475 
476                         thisBlock   = thisTask / sizeHalfBlock;
477                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
478                         indexLo     = indexUp + sizeHalfBlock;
479 
480                         // store current state vector values in temp variables
481                         stateRealUp = stateVecReal[indexUp];
482                         stateImagUp = stateVecImag[indexUp];
483 
484                         stateRealLo = stateVecReal[indexLo];
485                         stateImagLo = stateVecImag[indexLo];
486 
487                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
488                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag
      *stateImagUp 
489                                 - betaReal*stateRealLo - betaImag*stateImagLo;
490                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag
      *stateRealUp 
491                                 - betaReal*stateImagLo + betaImag*stateRealLo;
492 
493                         // state[indexLo] = beta  * state[indexUp] + conj(alpha) 
      * state[indexLo]
494                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*s
      tateImagUp 
495                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
496                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*s
      tateRealUp 
497                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
498                 } 
499         }
500 
501 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a793584932ae384c82e7e42db7d35d18d}{
\index{qubits.c@{qubits.c}!compareStates@{compareStates}}
\index{compareStates@{compareStates}!qubits.c@{qubits.c}}
\paragraph[{compareStates}]{\setlength{\rightskip}{0pt plus 5cm}int compareStates ({\bf MultiQubit} {\em mq1}, \/  {\bf MultiQubit} {\em mq2}, \/  REAL {\em precision})}\hfill}
\label{qubits_8c_a793584932ae384c82e7e42db7d35d18d}


Definition at line 330 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
330                                                                  {
331         REAL diff;
332         int chunkSize = mq1.numAmps;
333         for (int i=0; i<chunkSize; i++){
334                 diff = mq1.stateVec.real[i] - mq2.stateVec.real[i];
335                 if (diff<0) diff *= -1;
336                 if (diff>precision) return 0;
337                 diff = mq1.stateVec.imag[i] - mq2.stateVec.imag[i];
338                 if (diff<0) diff *= -1;
339                 if (diff>precision) return 0;
340         }
341         return 1;
342 }
\end{DoxyCode}
\hypertarget{qubits_8c_a717855e835e3161e08c18cdc15325d27}{
\index{qubits.c@{qubits.c}!controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}}
\index{controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{controlledCompactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a717855e835e3161e08c18cdc15325d27}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 883 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
888 {
889 
890         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
891         long long int thisTask;  
892         const long long int numTasks=multiQubit.numAmps;
893         const long long int chunkSize=multiQubit.numAmps;
894         const long long int chunkId=multiQubit.chunkId;
895 
896         int controlBit;
897 
898     REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
899         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
900         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
901         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
902         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
903 
904 # ifdef _OPENMP
905 # pragma omp parallel \
906         default  (none) \
907         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
908                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
909         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
910 # endif
911         {
912 # ifdef _OPENMP
913                 # pragma omp for schedule (static)
914 # endif
915                 for (thisTask=0; thisTask<numTasks; thisTask++) {
916                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
917                         if (controlBit){
918                                 // store current state vector values in temp vari
      ables
919                                 stateRealUp = stateVecRealUp[thisTask];
920                                 stateImagUp = stateVecImagUp[thisTask];
921 
922                                 stateRealLo = stateVecRealLo[thisTask];
923                                 stateImagLo = stateVecImagLo[thisTask];
924 
925                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
926                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp 
      - rot1Imag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
927                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp 
      + rot1Imag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
928                         }
929                 }
930         }
931 }
\end{DoxyCode}
\hypertarget{qubits_8c_afc77657651d52c47403b44b923a098a8}{
\index{qubits.c@{qubits.c}!controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}}
\index{controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{controlledCompactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits_8c_afc77657651d52c47403b44b923a098a8}


Definition at line 674 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
676 {
677         long long int sizeBlock, sizeHalfBlock;
678         long long int thisBlock, // current block
679              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
680 
681         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
682         long long int thisTask;         
683         const long long int numTasks=multiQubit.numAmps>>1;
684         const long long int chunkSize=multiQubit.numAmps;
685         const long long int chunkId=multiQubit.chunkId;
686 
687         int controlBit;
688 
689     // set dimensions
690         sizeHalfBlock = 1LL << targetQubit;  
691         sizeBlock     = 2LL * sizeHalfBlock; 
692 
693         // Can't use multiQubit.stateVec as a private OMP var
694         REAL *stateVecReal = multiQubit.stateVec.real;
695         REAL *stateVecImag = multiQubit.stateVec.imag;
696         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
697         REAL betaImag=beta.imag, betaReal=beta.real;
698 
699 # ifdef _OPENMP
700 # pragma omp parallel \
701         default  (none) \
702         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
703         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
704 # endif
705         {
706 # ifdef _OPENMP
707                 # pragma omp for schedule (static)
708 # endif
709                 for (thisTask=0; thisTask<numTasks; thisTask++) {
710 
711                         thisBlock   = thisTask / sizeHalfBlock;
712                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
713                         indexLo     = indexUp + sizeHalfBlock;
714 
715                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
716                         if (controlBit){
717                                 // store current state vector values in temp vari
      ables
718                                 stateRealUp = stateVecReal[indexUp];
719                                 stateImagUp = stateVecImag[indexUp];
720 
721                                 stateRealLo = stateVecReal[indexLo];
722                                 stateImagLo = stateVecImag[indexLo];
723 
724                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
725                                 stateVecReal[indexUp] = alphaReal*stateRealUp - a
      lphaImag*stateImagUp 
726                                         - betaReal*stateRealLo - betaImag*stateIm
      agLo;
727                                 stateVecImag[indexUp] = alphaReal*stateImagUp + a
      lphaImag*stateRealUp 
728                                         - betaReal*stateImagLo + betaImag*stateRe
      alLo;
729 
730                                 // state[indexLo] = beta  * state[indexUp] + conj
      (alpha) * state[indexLo]
731                                 stateVecReal[indexLo] = betaReal*stateRealUp - be
      taImag*stateImagUp 
732                                         + alphaReal*stateRealLo + alphaImag*state
      ImagLo;
733                                 stateVecImag[indexLo] = betaReal*stateImagUp + be
      taImag*stateRealUp 
734                                         + alphaReal*stateImagLo - alphaImag*state
      RealLo;
735                         }
736                 } 
737         }
738 
739 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a05875a70b539a3efb28d027823403f34}{
\index{qubits.c@{qubits.c}!controlledNotDistributed@{controlledNotDistributed}}
\index{controlledNotDistributed@{controlledNotDistributed}!qubits.c@{qubits.c}}
\paragraph[{controlledNotDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a05875a70b539a3efb28d027823403f34}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk. Only perform the rotation for elements where controlQubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1212 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by controlledNot().


\begin{DoxyCode}
1215 {
1216 
1217         long long int thisTask;  
1218         const long long int numTasks=multiQubit.numAmps;
1219         const long long int chunkSize=multiQubit.numAmps;
1220         const long long int chunkId=multiQubit.chunkId;
1221 
1222         int controlBit;
1223 
1224         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1225         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1226 
1227 # ifdef _OPENMP
1228 # pragma omp parallel \
1229         default  (none) \
1230         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1231         private  (thisTask,controlBit)
1232 # endif
1233         {
1234 # ifdef _OPENMP
1235                 # pragma omp for schedule (static)
1236 # endif
1237                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1238                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
1239                         if (controlBit){
1240                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTa
      sk];
1241                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTa
      sk];
1242                         }
1243                 }
1244         }
1245 } 
\end{DoxyCode}
\hypertarget{qubits_8c_ad357a43e80e3baf013975b1b70942f4c}{
\index{qubits.c@{qubits.c}!controlledNotLocal@{controlledNotLocal}}
\index{controlledNotLocal@{controlledNotLocal}!qubits.c@{qubits.c}}
\paragraph[{controlledNotLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_ad357a43e80e3baf013975b1b70942f4c}


Definition at line 1147 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledNot().


\begin{DoxyCode}
1148 {
1149         long long int sizeBlock, sizeHalfBlock;
1150         long long int thisBlock, // current block
1151              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1152 
1153         REAL stateRealUp,stateImagUp;
1154         long long int thisTask;         
1155         const long long int numTasks=multiQubit.numAmps>>1;
1156         const long long int chunkSize=multiQubit.numAmps;
1157         const long long int chunkId=multiQubit.chunkId;
1158 
1159         int controlBit;
1160 
1161         // set dimensions
1162         sizeHalfBlock = 1LL << targetQubit;  
1163         sizeBlock     = 2LL * sizeHalfBlock; 
1164 
1165 
1166         // Can't use multiQubit.stateVec as a private OMP var
1167         REAL *stateVecReal = multiQubit.stateVec.real;
1168         REAL *stateVecImag = multiQubit.stateVec.imag;
1169 
1170 # ifdef _OPENMP
1171 # pragma omp parallel \
1172         default  (none) \
1173         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1174         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,co
      ntrolBit) 
1175 # endif
1176         {
1177 # ifdef _OPENMP
1178                 # pragma omp for schedule (static)
1179 # endif
1180                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1181                         thisBlock   = thisTask / sizeHalfBlock;
1182                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1183                         indexLo     = indexUp + sizeHalfBlock;
1184 
1185                         controlBit = extractBit(controlQubit, indexUp+chunkId*chu
      nkSize);
1186                         if (controlBit){
1187                                 stateRealUp = stateVecReal[indexUp];
1188                                 stateImagUp = stateVecImag[indexUp];
1189 
1190                                 stateVecReal[indexUp] = stateVecReal[indexLo];
1191                                 stateVecImag[indexUp] = stateVecImag[indexLo];
1192 
1193                                 stateVecReal[indexLo] = stateRealUp;
1194                                 stateVecImag[indexLo] = stateImagUp;
1195                         }
1196                 } 
1197         }
1198 
1199 }
\end{DoxyCode}
\hypertarget{qubits_8c_a11a96159191cbf1b01a1080e7f045aac}{
\index{qubits.c@{qubits.c}!controlledPhaseGate@{controlledPhaseGate}}
\index{controlledPhaseGate@{controlledPhaseGate}!qubits.c@{qubits.c}}
\paragraph[{controlledPhaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void controlledPhaseGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em idQubit1}, \/  const int {\em idQubit2})}\hfill}
\label{qubits_8c_a11a96159191cbf1b01a1080e7f045aac}


Apply the (two-\/qubit) controlled phase gate, also known as the controlled sigmaZ gate. For each state, if both input qubits have value one, multiply the amplitude of that state by -\/1. This applies the two-\/qubit unitary: \[ \begin{pmatrix} 1 \\ & 1 \\\ & & 1 \\ & & & -1 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {idQubit1}; \node[draw=none] at (-3.5, 0) {idQubit2}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 0); \draw (-2,0) -- (2, 0); \draw[fill=black] (0, 0) circle (.2); \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em idQubit1,idQubit2}]qubits to operate upon \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily idQubit1} or {\ttfamily idQubit2} are outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or are equal \end{DoxyExceptions}


Definition at line 1729 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
1730 {
1731         long long int index;
1732         long long int stateVecSize;
1733         int bit1, bit2;
1734 
1735         const long long int chunkSize=multiQubit.numAmps;
1736         const long long int chunkId=multiQubit.chunkId;
1737 
1738     QuESTAssert(idQubit1 >= 0 && idQubit1 < multiQubit.numQubits, 2, __func__);
1739     QuESTAssert(idQubit2 >= 0 && idQubit2 < multiQubit.numQubits, 1, __func__);
1740     QuESTAssert(idQubit1 != idQubit2, 3, __func__);
1741 
1742         // dimension of the state vector
1743         stateVecSize = multiQubit.numAmps;
1744         REAL *stateVecReal = multiQubit.stateVec.real;
1745         REAL *stateVecImag = multiQubit.stateVec.imag;
1746 
1747 # ifdef _OPENMP
1748 # pragma omp parallel for \
1749         default  (none)                      \
1750         shared   (stateVecSize, stateVecReal,stateVecImag ) \
1751         private  (index,bit1,bit2)                     \
1752         schedule (static)
1753 # endif
1754         for (index=0; index<stateVecSize; index++) {
1755                 bit1 = extractBit (idQubit1, index+chunkId*chunkSize);
1756                 bit2 = extractBit (idQubit2, index+chunkId*chunkSize);
1757                 if (bit1 && bit2) {
1758                         stateVecReal [index] = - stateVecReal [index];
1759                         stateVecImag [index] = - stateVecImag [index];
1760                 }
1761         }
1762 }
\end{DoxyCode}
\hypertarget{qubits_8c_ad41f82b41149393a642391b67b3a287e}{
\index{qubits.c@{qubits.c}!controlledRotateAroundAxis@{controlledRotateAroundAxis}}
\index{controlledRotateAroundAxis@{controlledRotateAroundAxis}!qubits.c@{qubits.c}}
\paragraph[{controlledRotateAroundAxis}]{\setlength{\rightskip}{0pt plus 5cm}void controlledRotateAroundAxis ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  REAL {\em angle}, \/  {\bf Vector} {\em axis})}\hfill}
\label{qubits_8c_ad41f82b41149393a642391b67b3a287e}


Definition at line 413 of file qubits.c.

References controlledCompactUnitary(), Complex::imag, Complex::real, Vector::x, Vector::y, and Vector::z.

Referenced by controlledRotateX(), controlledRotateY(), and controlledRotateZ().


\begin{DoxyCode}
413                                                                                  
                                                   {
414         
415         double mag = sqrt(pow(axis.x,2) + pow(axis.y,2) + pow(axis.z,2));
416         Vector unitAxis = {axis.x/mag, axis.y/mag, axis.z/mag};
417         
418         Complex alpha, beta;
419         alpha.real = cos(angle/2.0);
420         alpha.imag = -sin(angle/2.0)*unitAxis.z;        
421         beta.real = sin(angle/2.0)*unitAxis.y;
422         beta.imag = -sin(angle/2.0)*unitAxis.x;
423         controlledCompactUnitary(multiQubit, controlQubit, targetQubit, alpha, be
      ta);
424 }
\end{DoxyCode}
\hypertarget{qubits_8c_ac6923ac57e67d9a21096e06f6a9012f6}{
\index{qubits.c@{qubits.c}!controlledRotateX@{controlledRotateX}}
\index{controlledRotateX@{controlledRotateX}!qubits.c@{qubits.c}}
\paragraph[{controlledRotateX}]{\setlength{\rightskip}{0pt plus 5cm}void controlledRotateX ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8c_ac6923ac57e67d9a21096e06f6a9012f6}


Definition at line 426 of file qubits.c.

References controlledRotateAroundAxis().


\begin{DoxyCode}
426                                                                                  
                             {
427 
428         Vector unitAxis = {1, 0, 0};
429         controlledRotateAroundAxis(multiQubit, controlQubit, targetQubit, angle, 
      unitAxis);
430 }
\end{DoxyCode}
\hypertarget{qubits_8c_a71e90a2f7292116338c062934f9d1202}{
\index{qubits.c@{qubits.c}!controlledRotateY@{controlledRotateY}}
\index{controlledRotateY@{controlledRotateY}!qubits.c@{qubits.c}}
\paragraph[{controlledRotateY}]{\setlength{\rightskip}{0pt plus 5cm}void controlledRotateY ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8c_a71e90a2f7292116338c062934f9d1202}


Definition at line 432 of file qubits.c.

References controlledRotateAroundAxis().


\begin{DoxyCode}
432                                                                                  
                             {
433 
434         Vector unitAxis = {0, 1, 0};
435         controlledRotateAroundAxis(multiQubit, controlQubit, targetQubit, angle, 
      unitAxis);
436 }
\end{DoxyCode}
\hypertarget{qubits_8c_a668e5d2634b02e98bc73675ccb11d61c}{
\index{qubits.c@{qubits.c}!controlledRotateZ@{controlledRotateZ}}
\index{controlledRotateZ@{controlledRotateZ}!qubits.c@{qubits.c}}
\paragraph[{controlledRotateZ}]{\setlength{\rightskip}{0pt plus 5cm}void controlledRotateZ ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8c_a668e5d2634b02e98bc73675ccb11d61c}


Definition at line 438 of file qubits.c.

References controlledRotateAroundAxis().


\begin{DoxyCode}
438                                                                                  
                             {
439 
440         Vector unitAxis = {0, 0, 1};
441         controlledRotateAroundAxis(multiQubit, controlQubit, targetQubit, angle, 
      unitAxis);
442 }
\end{DoxyCode}
\hypertarget{qubits_8c_a642093063a1f889f61a1311f6d6f2d3f}{
\index{qubits.c@{qubits.c}!controlledUnitaryDistributed@{controlledUnitaryDistributed}}
\index{controlledUnitaryDistributed@{controlledUnitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{controlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a642093063a1f889f61a1311f6d6f2d3f}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 946 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledUnitary().


\begin{DoxyCode}
951 {
952 
953         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
954         long long int thisTask;  
955         const long long int numTasks=multiQubit.numAmps;
956         const long long int chunkSize=multiQubit.numAmps;
957         const long long int chunkId=multiQubit.chunkId;
958 
959         int controlBit;
960 
961         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
962         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
963         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
964         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
965         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
966 
967 # ifdef _OPENMP
968 # pragma omp parallel \
969         default  (none) \
970         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
971                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
972         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
973 # endif
974         {
975 # ifdef _OPENMP
976                 # pragma omp for schedule (static)
977 # endif
978                 for (thisTask=0; thisTask<numTasks; thisTask++) {
979                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
980                         if (controlBit){
981                                 // store current state vector values in temp vari
      ables
982                                 stateRealUp = stateVecRealUp[thisTask];
983                                 stateImagUp = stateVecImagUp[thisTask];
984 
985                                 stateRealLo = stateVecRealLo[thisTask];
986                                 stateImagLo = stateVecImagLo[thisTask];
987 
988                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
989                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
990                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
991                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
992                         }
993                 }
994         }
995 }
\end{DoxyCode}
\hypertarget{qubits_8c_a8a4afcff70195a306c082b8ed8d4e09a}{
\index{qubits.c@{qubits.c}!controlledUnitaryLocal@{controlledUnitaryLocal}}
\index{controlledUnitaryLocal@{controlledUnitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{controlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8c_a8a4afcff70195a306c082b8ed8d4e09a}


Definition at line 804 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledUnitary().


\begin{DoxyCode}
806 {
807         long long int sizeBlock, sizeHalfBlock;
808         long long int thisBlock, // current block
809              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
810 
811         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
812         long long int thisTask;         
813         const long long int numTasks=multiQubit.numAmps>>1;
814         const long long int chunkSize=multiQubit.numAmps;
815         const long long int chunkId=multiQubit.chunkId;
816 
817         int controlBit;
818 
819     // set dimensions
820         sizeHalfBlock = 1LL << targetQubit;  
821         sizeBlock     = 2LL * sizeHalfBlock; 
822 
823         // Can't use multiQubit.stateVec as a private OMP var
824         REAL *stateVecReal = multiQubit.stateVec.real;
825         REAL *stateVecImag = multiQubit.stateVec.imag;
826 
827 # ifdef _OPENMP
828 # pragma omp parallel \
829         default  (none) \
830         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
831         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
832 # endif
833         {
834 # ifdef _OPENMP
835                 # pragma omp for schedule (static)
836 # endif
837                 for (thisTask=0; thisTask<numTasks; thisTask++) {
838 
839                         thisBlock   = thisTask / sizeHalfBlock;
840                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
841                         indexLo     = indexUp + sizeHalfBlock;
842 
843                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
844                         if (controlBit){
845                                 // store current state vector values in temp vari
      ables
846                                 stateRealUp = stateVecReal[indexUp];
847                                 stateImagUp = stateVecImag[indexUp];
848 
849                                 stateRealLo = stateVecReal[indexLo];
850                                 stateImagLo = stateVecImag[indexLo];
851 
852 
853                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
854                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
855                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
856                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
857                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
858 
859                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
860                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
861                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
862                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
863                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
864                         }
865                 } 
866         }
867 
868 }
\end{DoxyCode}
\hypertarget{qubits_8c_a9c02591bc64c2918503afa231d90d83f}{
\index{qubits.c@{qubits.c}!createMultiQubit@{createMultiQubit}}
\index{createMultiQubit@{createMultiQubit}!qubits.c@{qubits.c}}
\paragraph[{createMultiQubit}]{\setlength{\rightskip}{0pt plus 5cm}void createMultiQubit ({\bf MultiQubit} $\ast$ {\em multiQubit}, \/  int {\em numQubits}, \/  {\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8c_a9c02591bc64c2918503afa231d90d83f}


Create a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. Allocate space for state vector of probability amplitudes, including space for temporary values to be copied from one other chunk if running the distributed version. Define properties related to the size of the set of qubits. initStateZero should be called after this to initialise the qubits to the zero state.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]a pointer to an object representing the set of qubits \item[\mbox{$\leftarrow$} {\em numQubits}]number of qubits in the system \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily numQubits} $<$= 0 \end{DoxyExceptions}


Definition at line 39 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, MultiQubit::numQubits, QuESTEnv::numRanks, MultiQubit::pairStateVec, QuESTAssert(), QuESTEnv::rank, ComplexArray::real, and MultiQubit::stateVec.


\begin{DoxyCode}
40 {
41     QuESTAssert(numQubits>0, 9, __func__);
42         long long int numAmps = 1L << numQubits;
43         long long int numAmpsPerRank = numAmps/env.numRanks;
44 
45         multiQubit->stateVec.real = malloc(numAmpsPerRank * sizeof(*(multiQubit->
      stateVec.real)));
46         multiQubit->stateVec.imag = malloc(numAmpsPerRank * sizeof(*(multiQubit->
      stateVec.imag)));
47         if (env.numRanks>1){
48                 multiQubit->pairStateVec.real = malloc(numAmpsPerRank * sizeof(*(
      multiQubit->pairStateVec.real)));
49                 multiQubit->pairStateVec.imag = malloc(numAmpsPerRank * sizeof(*(
      multiQubit->pairStateVec.imag)));
50         }
51 
52         if ( (!(multiQubit->stateVec.real) || !(multiQubit->stateVec.imag))
53                  && numAmpsPerRank ) {
54                 printf("Could not allocate memory!");
55                 exit (EXIT_FAILURE);
56         }
57 
58         if ( env.numRanks>1 && (!(multiQubit->pairStateVec.real) || !(multiQubit-
      >pairStateVec.imag))
59                  && numAmpsPerRank ) {
60                 printf("Could not allocate memory!");
61                 exit (EXIT_FAILURE);
62         }
63 
64         multiQubit->numQubits = numQubits;
65         multiQubit->numAmps = numAmpsPerRank;
66         multiQubit->chunkId = env.rank;
67         multiQubit->numChunks = env.numRanks;
68 
69 }
\end{DoxyCode}
\hypertarget{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}{
\index{qubits.c@{qubits.c}!destroyMultiQubit@{destroyMultiQubit}}
\index{destroyMultiQubit@{destroyMultiQubit}!qubits.c@{qubits.c}}
\paragraph[{destroyMultiQubit}]{\setlength{\rightskip}{0pt plus 5cm}void destroyMultiQubit ({\bf MultiQubit} {\em multiQubit}, \/  {\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}


Deallocate a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. Free memory allocated to state vector of probability amplitudes, including temporary vector for values copied from another chunk if running the distributed version.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object to be deallocated \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}


Definition at line 71 of file qubits.c.

References ComplexArray::imag, QuESTEnv::numRanks, MultiQubit::pairStateVec, ComplexArray::real, and MultiQubit::stateVec.


\begin{DoxyCode}
71                                                            {
72         free(multiQubit.stateVec.real);
73         free(multiQubit.stateVec.imag);
74         if (env.numRanks>1){
75                 free(multiQubit.pairStateVec.real);
76                 free(multiQubit.pairStateVec.imag);
77         }
78 }
\end{DoxyCode}
\hypertarget{qubits_8c_a100463f6ec212c76a5fad99579000505}{
\index{qubits.c@{qubits.c}!extractBit@{extractBit}}
\index{extractBit@{extractBit}!qubits.c@{qubits.c}}
\paragraph[{extractBit}]{\setlength{\rightskip}{0pt plus 5cm}static int extractBit (const int {\em locationOfBitFromRight}, \/  const long long int {\em theEncodedNumber})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits_8c_a100463f6ec212c76a5fad99579000505}


Get the value of the bit at a particular index in a number. SCB edit: new definition of extractBit is much faster $\ast$$\ast$$\ast$ 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em locationOfBitFromRight}]location of bit in theEncodedNumber \item[\mbox{$\leftarrow$} {\em theEncodedNumber}]number to search \end{DoxyParams}
\begin{DoxyReturn}{Returns}
the value of the bit in theEncodedNumber 
\end{DoxyReturn}


Definition at line 1724 of file qubits.c.

Referenced by controlledCompactUnitaryDistributed(), controlledCompactUnitaryLocal(), controlledNotDistributed(), controlledNotLocal(), controlledPhaseGate(), controlledUnitaryDistributed(), controlledUnitaryLocal(), and initStateOfSingleQubit().


\begin{DoxyCode}
1725 {
1726         return (theEncodedNumber & ( 1LL << locationOfBitFromRight )) >> location
      OfBitFromRight;
1727 }
\end{DoxyCode}
\hypertarget{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}{
\index{qubits.c@{qubits.c}!findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}}
\index{findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}!qubits.c@{qubits.c}}
\paragraph[{findProbabilityOfZeroDistributed}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}


Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. Size of regions to skip is a multiple of chunkSize.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1669 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1671 {
1672         // ----- measured probability
1673         REAL   totalProbability;                                    // probabilit
      y (returned) value
1674         // ----- temp variables
1675         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1676         long long int numTasks=multiQubit.numAmps;
1677 
1678         // ---------------------------------------------------------------- //
1679         //            find probability                                      //
1680         // ---------------------------------------------------------------- //
1681 
1682         // initialise returned value
1683         totalProbability = 0.0;
1684 
1685         REAL *stateVecReal = multiQubit.stateVec.real;
1686         REAL *stateVecImag = multiQubit.stateVec.imag;
1687 
1688 # ifdef _OPENMP
1689 # pragma omp parallel \
1690         shared    (numTasks,stateVecReal,stateVecImag) \
1691         private   (thisTask) \
1692         reduction ( +:totalProbability )
1693 # endif
1694         {
1695 # ifdef _OPENMP
1696                 # pragma omp for schedule  (static)
1697 # endif
1698                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1699                         // summation -- simple implementation
1700                         totalProbability += stateVecReal[thisTask]*stateVecReal[t
      hisTask]
1701                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
1702 
1703                         /*
1704                         // summation -- kahan correction
1705                         y = stateVecReal[thisTask]*stateVecReal[thisTask]
1706                         + stateVecImag[thisTask]*stateVecImag[thisTask] - c;
1707                         t = totalProbability + y;
1708                         c = (t - totalProbability) - y;
1709                         totalProbability = t;
1710                         */
1711 
1712                 }
1713         }
1714 
1715         return totalProbability;
1716 }
\end{DoxyCode}
\hypertarget{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}{
\index{qubits.c@{qubits.c}!findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}}
\index{findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}!qubits.c@{qubits.c}}
\paragraph[{findProbabilityOfZeroLocal}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}


Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1597 of file qubits.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1599 {
1600         // ----- sizes
1601         long long int sizeBlock,                                           // siz
      e of blocks
1602         sizeHalfBlock;                                       // size of blocks ha
      lved
1603         // ----- indices
1604         long long int thisBlock,                                           // cur
      rent block
1605              index;                                               // current inde
      x for first half block
1606         // ----- measured probability
1607         REAL   totalProbability;                                    // probabilit
      y (returned) value
1608         // ----- temp variables
1609         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1610         long long int numTasks=multiQubit.numAmps>>1;
1611 
1612         // ---------------------------------------------------------------- //
1613         //            dimensions                                            //
1614         // ---------------------------------------------------------------- //
1615         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1616         // and then the number to skip
1617         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1618 
1619         // initialise returned value
1620         totalProbability = 0.0;
1621 
1622         // initialise correction for kahan summation
1623         if (DEBUG) printf("sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\n",sizeHa
      lfBlock,sizeBlock,numTasks);
1624 
1625         REAL *stateVecReal = multiQubit.stateVec.real;
1626         REAL *stateVecImag = multiQubit.stateVec.imag;
1627 
1628 # ifdef _OPENMP
1629 # pragma omp parallel \
1630         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
      
1631         private   (thisTask,thisBlock,index) \
1632         reduction ( +:totalProbability )
1633 # endif 
1634         {
1635 # ifdef _OPENMP
1636                 # pragma omp for schedule  (static)
1637 # endif
1638                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1639                         thisBlock = thisTask / sizeHalfBlock;
1640                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
      
1641 
1642                         if (index<0){ printf("ABORTING as index=%Ld with thisBloc
      k = %Ld  thisTask=%Ld \n", index,thisBlock,thisTask); exit(1);}
1643 
1644                         // summation -- simple implementation
1645                         totalProbability += stateVecReal[index]*stateVecReal[inde
      x]
1646                                 + stateVecImag[index]*stateVecImag[index];
1647 
1648                         /*
1649                         // summation -- kahan correction
1650                         y = stateVecReal[index]*stateVecReal[index]
1651                         + stateVecImag[index]*stateVecImag[index] - c;
1652                         t = totalProbability + y;
1653                         c = (t - totalProbability) - y;
1654                         totalProbability = t;
1655                         */
1656 
1657                 }
1658         }
1659         return totalProbability;
1660 }
\end{DoxyCode}
\hypertarget{qubits_8c_a8f10aabf9f607f19093aee54630caa21}{
\index{qubits.c@{qubits.c}!getEnvironmentString@{getEnvironmentString}}
\index{getEnvironmentString@{getEnvironmentString}!qubits.c@{qubits.c}}
\paragraph[{getEnvironmentString}]{\setlength{\rightskip}{0pt plus 5cm}void getEnvironmentString ({\bf QuESTEnv} {\em env}, \/  {\bf MultiQubit} {\em multiQubit}, \/  char {\em str}\mbox{[}200\mbox{]})}\hfill}
\label{qubits_8c_a8f10aabf9f607f19093aee54630caa21}


Definition at line 131 of file qubits.c.

References MultiQubit::numQubits, and QuESTEnv::numRanks.


\begin{DoxyCode}
131                                                                              {
132         int numThreads=1;
133 # ifdef _OPENMP
134         numThreads=omp_get_max_threads(); 
135 # endif
136         sprintf(str, "%dqubits_CPU_%dranksx%dthreads", multiQubit.numQubits, env.
      numRanks, numThreads);
137 }
\end{DoxyCode}
\hypertarget{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}{
\index{qubits.c@{qubits.c}!getProbEl@{getProbEl}}
\index{getProbEl@{getProbEl}!qubits.c@{qubits.c}}
\paragraph[{getProbEl}]{\setlength{\rightskip}{0pt plus 5cm}REAL getProbEl ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})}\hfill}
\label{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}


Get the probability of the state at an index in the full state vector. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \item[\mbox{$\leftarrow$} {\em index}]index in state vector of probability amplitudes \end{DoxyParams}
\begin{DoxyReturn}{Returns}
realEl$\ast$realEl + imagEl$\ast$imagEl 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily index} is outside \mbox{[}0, $2^{N}$) where $N = $ {\ttfamily multiQubit.numQubits} \end{DoxyExceptions}


Definition at line 1971 of file qubits.c.

References getImagAmpEl(), getRealAmpEl(), and REAL.


\begin{DoxyCode}
1971                                                           {
1972         REAL real;
1973         REAL imag;
1974         real = getRealAmpEl(multiQubit, index);
1975         imag = getImagAmpEl(multiQubit, index);
1976         return real*real + imag*imag;
1977 }
\end{DoxyCode}
\hypertarget{qubits_8c_ae6a897066979fc52d977007d959ca09d}{
\index{qubits.c@{qubits.c}!hadamardDistributed@{hadamardDistributed}}
\index{hadamardDistributed@{hadamardDistributed}!qubits.c@{qubits.c}}
\paragraph[{hadamardDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits_8c_ae6a897066979fc52d977007d959ca09d}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1400 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by hadamard().


\begin{DoxyCode}
1405 {
1406 
1407         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1408         long long int thisTask;  
1409         const long long int numTasks=multiQubit.numAmps;
1410 
1411         int sign;
1412         if (updateUpper) sign=1;
1413         else sign=-1;
1414 
1415         REAL recRoot2 = 1.0/sqrt(2);
1416 
1417         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1418         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1419         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1420 
1421 # ifdef _OPENMP
1422 # pragma omp parallel \
1423         default  (none) \
1424         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1425                         recRoot2, sign) \
1426         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1427 # endif
1428         {
1429 # ifdef _OPENMP
1430                 # pragma omp for schedule (static)
1431 # endif
1432                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1433                         // store current state vector values in temp variables
1434                         stateRealUp = stateVecRealUp[thisTask];
1435                         stateImagUp = stateVecImagUp[thisTask];
1436 
1437                         stateRealLo = stateVecRealLo[thisTask];
1438                         stateImagLo = stateVecImagLo[thisTask];
1439 
1440                         stateVecRealOut[thisTask] = recRoot2*(stateRealUp + sign*
      stateRealLo);
1441                         stateVecImagOut[thisTask] = recRoot2*(stateImagUp + sign*
      stateImagLo);
1442                 }
1443         }
1444 }
\end{DoxyCode}
\hypertarget{qubits_8c_aa9f0718b4dd794a3e1b143e3b153bfc5}{
\index{qubits.c@{qubits.c}!hadamardLocal@{hadamardLocal}}
\index{hadamardLocal@{hadamardLocal}!qubits.c@{qubits.c}}
\paragraph[{hadamardLocal}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_aa9f0718b4dd794a3e1b143e3b153bfc5}


Definition at line 1339 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by hadamard().


\begin{DoxyCode}
1340 {
1341         long long int sizeBlock, sizeHalfBlock;
1342         long long int thisBlock, // current block
1343              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1344 
1345         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1346         long long int thisTask;         
1347         const long long int numTasks=multiQubit.numAmps>>1;
1348 
1349         // set dimensions
1350         sizeHalfBlock = 1LL << targetQubit;  
1351         sizeBlock     = 2LL * sizeHalfBlock; 
1352 
1353         // Can't use multiQubit.stateVec as a private OMP var
1354         REAL *stateVecReal = multiQubit.stateVec.real;
1355         REAL *stateVecImag = multiQubit.stateVec.imag;
1356 
1357         REAL recRoot2 = 1.0/sqrt(2);
1358 
1359 # ifdef _OPENMP
1360 # pragma omp parallel \
1361         default  (none) \
1362         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \
      
1363         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
1364 # endif
1365         {
1366 # ifdef _OPENMP
1367                 # pragma omp for schedule (static)
1368 # endif
1369                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1370                         thisBlock   = thisTask / sizeHalfBlock;
1371                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1372                         indexLo     = indexUp + sizeHalfBlock;
1373 
1374                         stateRealUp = stateVecReal[indexUp];
1375                         stateImagUp = stateVecImag[indexUp];
1376 
1377                         stateRealLo = stateVecReal[indexLo];
1378                         stateImagLo = stateVecImag[indexLo];
1379 
1380                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateReal
      Lo);
1381                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImag
      Lo);
1382 
1383                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateReal
      Lo);
1384                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImag
      Lo);
1385                 } 
1386         }
1387 }
\end{DoxyCode}
\hypertarget{qubits_8c_a433876ee9f3bcc54af346300f571fc3c}{
\index{qubits.c@{qubits.c}!initializeStateFromSingleFile@{initializeStateFromSingleFile}}
\index{initializeStateFromSingleFile@{initializeStateFromSingleFile}!qubits.c@{qubits.c}}
\paragraph[{initializeStateFromSingleFile}]{\setlength{\rightskip}{0pt plus 5cm}void initializeStateFromSingleFile ({\bf MultiQubit} $\ast$ {\em multiQubit}, \/  char {\em filename}\mbox{[}200\mbox{]}, \/  {\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8c_a433876ee9f3bcc54af346300f571fc3c}


fix -\/-\/ format needs to work for single precision values 

Definition at line 295 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, MultiQubit::stateVec, and syncQuESTEnv().


\begin{DoxyCode}
295                                                                                  
                 {
296         long long int chunkSize, stateVecSize;
297         long long int indexInChunk, totalIndex;
298 
299         chunkSize = multiQubit->numAmps;
300         stateVecSize = chunkSize*multiQubit->numChunks;
301 
302         REAL *stateVecReal = multiQubit->stateVec.real;
303         REAL *stateVecImag = multiQubit->stateVec.imag;
304         
305         FILE *fp;
306         char line[200];
307 
308         for (int rank=0; rank<(multiQubit->numChunks); rank++){
309                 if (rank==multiQubit->chunkId){
310                         fp = fopen(filename, "r");
311                         indexInChunk = 0; totalIndex = 0;
312                         while (fgets(line, sizeof(char)*200, fp) != NULL && total
      Index<stateVecSize){
313                                 if (line[0]!='#'){
314                                         int chunkId = totalIndex/chunkSize;
315                                         if (chunkId==multiQubit->chunkId){
317                                                 sscanf(line, "%lf, %lf", &(stateV
      ecReal[indexInChunk]), 
318                                                                 &(stateVecImag[in
      dexInChunk]));
319                                                 indexInChunk += 1;
320                                         }
321                                         totalIndex += 1;
322                                 }
323                         }       
324                         fclose(fp);
325                 }
326                 syncQuESTEnv(env);
327         }
328 }
\end{DoxyCode}
\hypertarget{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}{
\index{qubits.c@{qubits.c}!initStateDebug@{initStateDebug}}
\index{initStateDebug@{initStateDebug}!qubits.c@{qubits.c}}
\paragraph[{initStateDebug}]{\setlength{\rightskip}{0pt plus 5cm}void initStateDebug ({\bf MultiQubit} $\ast$ {\em multiQubit})}\hfill}
\label{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}


Initialise the state vector of probability amplitudes to an (unphysical) state with each component of each probability amplitude a unique floating point value. For debugging processes 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \end{DoxyParams}


Definition at line 263 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
264 {
265         long long int chunkSize;
266         long long int index;
267 
268         // dimension of the state vector
269         chunkSize = multiQubit->numAmps;
270 
271         // Can't use multiQubit->stateVec as a private OMP var
272         REAL *stateVecReal = multiQubit->stateVec.real;
273         REAL *stateVecImag = multiQubit->stateVec.imag;
274 
275         REAL chunkOffset = (2.0*chunkSize*multiQubit->chunkId)/10.0;
276 
277         // initialise the state to |0000..0000>
278 # ifdef _OPENMP
279 # pragma omp parallel \
280         default  (none) \
281         shared   (chunkSize, stateVecReal, stateVecImag, chunkOffset) \
282         private  (index) 
283 # endif
284         {
285 # ifdef _OPENMP
286                 # pragma omp for schedule (static)
287 # endif
288                 for (index=0; index<chunkSize; index++) {
289                         stateVecReal[index] = chunkOffset + (index*2.0)/10.0;
290                         stateVecImag[index] = chunkOffset + (index*2.0+1.0)/10.0;
      
291                 }
292         }
293 }
\end{DoxyCode}
\hypertarget{qubits_8c_a7169fd0442cbc3418f3fac4d13363ca2}{
\index{qubits.c@{qubits.c}!initStateOfSingleQubit@{initStateOfSingleQubit}}
\index{initStateOfSingleQubit@{initStateOfSingleQubit}!qubits.c@{qubits.c}}
\paragraph[{initStateOfSingleQubit}]{\setlength{\rightskip}{0pt plus 5cm}void initStateOfSingleQubit ({\bf MultiQubit} $\ast$ {\em multiQubit}, \/  int {\em qubitId}, \/  int {\em outcome})}\hfill}
\label{qubits_8c_a7169fd0442cbc3418f3fac4d13363ca2}


Initialise the state vector of probability amplitudes such that one qubit is set to 'outcome' and all other qubits are in an equal superposition of zero and one. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \item[\mbox{$\leftarrow$} {\em qubitId}]id of qubit to set to state 'outcome' \item[\mbox{$\leftarrow$} {\em value}]of qubit 'qubitId' \end{DoxyParams}


Definition at line 216 of file qubits.c.

References MultiQubit::chunkId, DEBUG, extractBit(), ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
217 {
218         long long int chunkSize, stateVecSize;
219         long long int index;
220         int bit;
221         const long long int chunkId=multiQubit->chunkId;
222 
223         // dimension of the state vector
224         chunkSize = multiQubit->numAmps;
225         stateVecSize = chunkSize*multiQubit->numChunks;
226         REAL normFactor = 1.0/sqrt((REAL)stateVecSize/2.0);
227 
228         // Can't use multiQubit->stateVec as a private OMP var
229         REAL *stateVecReal = multiQubit->stateVec.real;
230         REAL *stateVecImag = multiQubit->stateVec.imag;
231 
232         // initialise the state to |0000..0000>
233 # ifdef _OPENMP
234 # pragma omp parallel \
235         default  (none) \
236         shared   (chunkSize, stateVecReal, stateVecImag, normFactor, qubitId, out
      come) \
237         private  (index, bit) 
238 # endif
239         {
240 # ifdef _OPENMP
241                 # pragma omp for schedule (static)
242 # endif
243                 for (index=0; index<chunkSize; index++) {
244                         bit = extractBit(qubitId, index+chunkId*chunkSize);
245                         if (bit==outcome) {
246                                 stateVecReal[index] = normFactor;
247                                 stateVecImag[index] = 0.0;
248                         } else {
249                                 stateVecReal[index] = 0.0;
250                                 stateVecImag[index] = 0.0;
251                         }
252                 }
253         }
254         if (DEBUG) printf("COMPLETED INIT\n");
255 }
\end{DoxyCode}
\hypertarget{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}{
\index{qubits.c@{qubits.c}!initStatePlus@{initStatePlus}}
\index{initStatePlus@{initStatePlus}!qubits.c@{qubits.c}}
\paragraph[{initStatePlus}]{\setlength{\rightskip}{0pt plus 5cm}void initStatePlus ({\bf MultiQubit} $\ast$ {\em multiQubit})}\hfill}
\label{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}


Initialise a set of $ N $ qubits to the plus state $ {| + \rangle}^{\otimes N} = \frac{1}{\sqrt{2^N}} (| 0 \rangle + | 1 \rangle)^{\otimes N} $. This is the product state of $N$ qubits where every classical state is uniformly populated with real coefficient $\frac{1}{\sqrt{2^N}}$. This is equivalent to applying a Hadamard to every qubit in the zero state: $ \hat{H}^{\otimes N} {|0\rangle}^{\otimes N} $


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]a pointer to the object representing the set of qubits to be initialised \end{DoxyParams}


Definition at line 177 of file qubits.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
178 {
179         long long int chunkSize, stateVecSize;
180         long long int index;
181 
182         // dimension of the state vector
183         chunkSize = multiQubit->numAmps;
184         stateVecSize = chunkSize*multiQubit->numChunks;
185         REAL normFactor = 1.0/sqrt((REAL)stateVecSize);
186 
187         // Can't use multiQubit->stateVec as a private OMP var
188         REAL *stateVecReal = multiQubit->stateVec.real;
189         REAL *stateVecImag = multiQubit->stateVec.imag;
190 
191         // initialise the state to |0000..0000>
192 # ifdef _OPENMP
193 # pragma omp parallel \
194         default  (none) \
195         shared   (chunkSize, stateVecReal, stateVecImag, normFactor) \
196         private  (index) 
197 # endif
198         {
199 # ifdef _OPENMP
200                 # pragma omp for schedule (static)
201 # endif
202                 for (index=0; index<chunkSize; index++) {
203                         stateVecReal[index] = normFactor;
204                         stateVecImag[index] = 0.0;
205                 }
206         }
207         if (DEBUG) printf("COMPLETED INIT\n");
208 }
\end{DoxyCode}
\hypertarget{qubits_8c_acb5b2eff794339090004d29f02a70d9a}{
\index{qubits.c@{qubits.c}!initStateZero@{initStateZero}}
\index{initStateZero@{initStateZero}!qubits.c@{qubits.c}}
\paragraph[{initStateZero}]{\setlength{\rightskip}{0pt plus 5cm}void initStateZero ({\bf MultiQubit} $\ast$ {\em multiQubit})}\hfill}
\label{qubits_8c_acb5b2eff794339090004d29f02a70d9a}


Initialise a set of $ N $ qubits to the classical zero state $ {| 0 \rangle}^{\otimes N} $. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]a pointer to the object representing the set of all qubits to initialise \end{DoxyParams}


Definition at line 139 of file qubits.c.

References MultiQubit::chunkId, DEBUG, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
140 {
141         long long int stateVecSize;
142         long long int index;
143 
144         // dimension of the state vector
145         stateVecSize = multiQubit->numAmps;
146 
147         // Can't use multiQubit->stateVec as a private OMP var
148         REAL *stateVecReal = multiQubit->stateVec.real;
149         REAL *stateVecImag = multiQubit->stateVec.imag;
150 
151         // initialise the state to |0000..0000>
152 # ifdef _OPENMP
153 # pragma omp parallel \
154         default  (none) \
155         shared   (stateVecSize, stateVecReal, stateVecImag) \
156         private  (index) 
157 # endif
158         {
159 # ifdef _OPENMP
160                 # pragma omp for schedule (static)
161 # endif
162                 for (index=0; index<stateVecSize; index++) {
163                         stateVecReal[index] = 0.0;
164                         stateVecImag[index] = 0.0;
165                 }
166         }
167 
168         if (multiQubit->chunkId==0){
169                 // zero state |0000..0000> has probability 1
170                 stateVecReal[0] = 1.0;
171                 stateVecImag[0] = 0.0;
172         }
173 
174         if (DEBUG) printf("COMPLETED INIT\n");
175 }
\end{DoxyCode}
\hypertarget{qubits_8c_afc1835c6b43b6e59ce7df7b13f274fc7}{
\index{qubits.c@{qubits.c}!multiControlledPhaseGate@{multiControlledPhaseGate}}
\index{multiControlledPhaseGate@{multiControlledPhaseGate}!qubits.c@{qubits.c}}
\paragraph[{multiControlledPhaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledPhaseGate ({\bf MultiQubit} {\em multiQubit}, \/  int $\ast$ {\em controlQubits}, \/  int {\em numControlQubits})}\hfill}
\label{qubits_8c_afc1835c6b43b6e59ce7df7b13f274fc7}


Apply the multiple-\/qubit controlled phase gate, also known as the multiple-\/qubit controlled sigmaZ gate. For each state, if all control qubits have value one, multiply the amplitude of that state by -\/1. This applies the many-\/qubit unitary: \[ \begin{pmatrix} 1 \\ & 1 \\\ & & \ddots \\ & & & 1 \\ & & & & -1 \end{pmatrix} \] on the control qubits.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {controls}; \node[draw=none] at (0, 6) {$\vdots$}; \draw (0, 5) -- (0, 4); \draw (-2, 4) -- (2, 4); \draw[fill=black] (0, 4) circle (.2); \draw (0, 4) -- (0, 2); \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 0); \draw (-2,0) -- (2, 0); \draw[fill=black] (0, 0) circle (.2); \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em controlQubits}]array of input qubits \item[\mbox{$\leftarrow$} {\em numControlQubits}]number of input qubits \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily numControlQubits} is outside \mbox{[}1, {\ttfamily multiQubit.numQubits}) \end{DoxyExceptions}


Definition at line 1764 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
1765 {
1766         long long int index;
1767         long long int stateVecSize;
1768         
1769         const long long int chunkSize=multiQubit.numAmps;
1770         const long long int chunkId=multiQubit.chunkId;
1771 
1772     QuESTAssert(numControlQubits > 0 && numControlQubits <= multiQubit.numQubits,
       4, __func__);
1773     long long int mask=0;
1774     for (int i=0; i<numControlQubits; i++) mask = mask | (1LL<<controlQubits[i]);
      
1775     QuESTAssert(mask >=0 && mask <= (1LL<<multiQubit.numQubits)-1, 2, __func__);
1776 
1777         stateVecSize = multiQubit.numAmps;
1778         REAL *stateVecReal = multiQubit.stateVec.real;
1779         REAL *stateVecImag = multiQubit.stateVec.imag;
1780 
1781 # ifdef _OPENMP
1782 # pragma omp parallel \
1783         default  (none)                      \
1784         shared   (stateVecSize, stateVecReal,stateVecImag, mask ) \
1785         private  (index)
1786 # endif
1787         {
1788 # ifdef _OPENMP
1789                 # pragma omp for schedule (static)
1790 # endif
1791                 for (index=0; index<stateVecSize; index++) {
1792                         if (mask == (mask & (index+chunkId*chunkSize)) ){
1793                                 stateVecReal [index] = - stateVecReal [index];
1794                                 stateVecImag [index] = - stateVecImag [index];
1795                         }
1796                 }
1797         }
1798 }
\end{DoxyCode}
\hypertarget{qubits_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{
\index{qubits.c@{qubits.c}!multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}}
\index{multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{multiControlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}


Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where all the control qubits are 1.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1010 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
1017 {
1018 
1019         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1020         long long int thisTask;  
1021         const long long int numTasks=multiQubit.numAmps;
1022         const long long int chunkSize=multiQubit.numAmps;
1023         const long long int chunkId=multiQubit.chunkId;
1024 
1025         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
1026         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
1027         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1028         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1029         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1030 
1031 # ifdef _OPENMP
1032 # pragma omp parallel \
1033         default  (none) \
1034         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1035                         rot1Real,rot1Imag, rot2Real,rot2Imag, mask) \
1036         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1037 # endif
1038         {
1039 # ifdef _OPENMP
1040                 # pragma omp for schedule (static)
1041 # endif
1042                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1043                         if (mask == (mask & (thisTask+chunkId*chunkSize)) ){
1044                                 // store current state vector values in temp vari
      ables
1045                                 stateRealUp = stateVecRealUp[thisTask];
1046                                 stateImagUp = stateVecImagUp[thisTask];
1047 
1048                                 stateRealLo = stateVecRealLo[thisTask];
1049                                 stateImagLo = stateVecImagLo[thisTask];
1050 
1051                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
1052                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
1053                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
1054                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
1055                         }
1056                 }
1057         }
1058 }
\end{DoxyCode}
\hypertarget{qubits_8c_a1309eabcba3cb97fbc3cd2e606d17766}{
\index{qubits.c@{qubits.c}!multiControlledUnitaryLocal@{multiControlledUnitaryLocal}}
\index{multiControlledUnitaryLocal@{multiControlledUnitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{multiControlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8c_a1309eabcba3cb97fbc3cd2e606d17766}


Definition at line 741 of file qubits.c.

References MultiQubit::chunkId, Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
743 {
744         long long int sizeBlock, sizeHalfBlock;
745         long long int thisBlock, // current block
746              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
747 
748         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
749         long long int thisTask;         
750         const long long int numTasks=multiQubit.numAmps>>1;
751         const long long int chunkSize=multiQubit.numAmps;
752         const long long int chunkId=multiQubit.chunkId;
753 
754         // set dimensions
755         sizeHalfBlock = 1LL << targetQubit;  
756         sizeBlock     = 2LL * sizeHalfBlock; 
757 
758         // Can't use multiQubit.stateVec as a private OMP var
759         REAL *stateVecReal = multiQubit.stateVec.real;
760         REAL *stateVecImag = multiQubit.stateVec.imag;
761 
762 # ifdef _OPENMP
763 # pragma omp parallel \
764         default  (none) \
765         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u, mask) \
766         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
767 # endif
768         {
769 # ifdef _OPENMP
770                 # pragma omp for schedule (static)
771 # endif
772                 for (thisTask=0; thisTask<numTasks; thisTask++) {
773 
774                         thisBlock   = thisTask / sizeHalfBlock;
775                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
776                         indexLo     = indexUp + sizeHalfBlock;
777 
778                         if (mask == (mask & (indexUp+chunkId*chunkSize)) ){
779                                 // store current state vector values in temp vari
      ables
780                                 stateRealUp = stateVecReal[indexUp];
781                                 stateImagUp = stateVecImag[indexUp];
782 
783                                 stateRealLo = stateVecReal[indexLo];
784                                 stateImagLo = stateVecImag[indexLo];
785 
786 
787                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
788                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
789                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
790                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
791                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
792 
793                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
794                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
795                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
796                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
797                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
798                         }
799                 } 
800         }
801 
802 }
\end{DoxyCode}
\hypertarget{qubits_8c_af832ed00b02a0597b7fe0b714032c54a}{
\index{qubits.c@{qubits.c}!phaseGateDistributed@{phaseGateDistributed}}
\index{phaseGateDistributed@{phaseGateDistributed}!qubits.c@{qubits.c}}
\paragraph[{phaseGateDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits_8c_af832ed00b02a0597b7fe0b714032c54a}


Definition at line 1522 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1523 {
1524         REAL stateRealLo,stateImagLo;
1525         long long int thisTask;         
1526         const long long int numTasks=multiQubit.numAmps;
1527 
1528         // Can't use multiQubit.stateVec as a private OMP var
1529         REAL *stateVecReal = multiQubit.stateVec.real;
1530         REAL *stateVecImag = multiQubit.stateVec.imag;
1531 
1532         REAL recRoot2 = 1.0/sqrt(2);
1533 
1534 # ifdef _OPENMP
1535 # pragma omp parallel \
1536         default  (none) \
1537         shared   (stateVecReal,stateVecImag, recRoot2, type) \
1538         private  (thisTask,stateRealLo,stateImagLo) 
1539 # endif
1540         {
1541                 if (type==SIGMA_Z){
1542 # ifdef _OPENMP
1543                         # pragma omp for schedule (static)
1544 # endif
1545                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1546                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
      
1547                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
      
1548                         } 
1549                 } else if (type==S_GATE){
1550 # ifdef _OPENMP
1551                         # pragma omp for schedule (static)
1552 # endif
1553                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1554                                 stateRealLo = stateVecReal[thisTask];
1555                                 stateImagLo = stateVecImag[thisTask];
1556 
1557                                 stateVecReal[thisTask] = -stateImagLo;
1558                                 stateVecImag[thisTask] = stateRealLo;
1559                         } 
1560                 } else if (type==T_GATE){
1561 # ifdef _OPENMP
1562                         # pragma omp for schedule (static)
1563 # endif
1564                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1565                                 stateRealLo = stateVecReal[thisTask];
1566                                 stateImagLo = stateVecImag[thisTask];
1567 
1568                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo 
      - stateImagLo);
1569                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo 
      + stateImagLo);
1570                         } 
1571                 } else printf("Type %d is an invalid phase gate\n", type);
1572         }
1573 }
\end{DoxyCode}
\hypertarget{qubits_8c_a3a54566b73ac84c312d7da4f56ffbc3b}{
\index{qubits.c@{qubits.c}!phaseGateLocal@{phaseGateLocal}}
\index{phaseGateLocal@{phaseGateLocal}!qubits.c@{qubits.c}}
\paragraph[{phaseGateLocal}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits_8c_a3a54566b73ac84c312d7da4f56ffbc3b}


fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod? 

Definition at line 1446 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1447 {
1448         long long int sizeBlock, sizeHalfBlock;
1449         long long int thisBlock, // current block
1450              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1451 
1452         REAL stateRealLo,stateImagLo;
1453         long long int thisTask;         
1454         const long long int numTasks=multiQubit.numAmps>>1;
1455 
1456         // set dimensions
1457         sizeHalfBlock = 1LL << targetQubit;  
1458         sizeBlock     = 2LL * sizeHalfBlock; 
1459 
1460         // Can't use multiQubit.stateVec as a private OMP var
1461         REAL *stateVecReal = multiQubit.stateVec.real;
1462         REAL *stateVecImag = multiQubit.stateVec.imag;
1463 
1464         REAL recRoot2 = 1.0/sqrt(2);
1465 
1466 # ifdef _OPENMP
1467 # pragma omp parallel \
1468         default  (none) \
1469         shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type
      ) \
1470         private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) 
1471 # endif
1472         {
1473                 if (type==SIGMA_Z){
1474 # ifdef _OPENMP
1475                         # pragma omp for schedule (static)
1476 # endif
1477                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1479                                 thisBlock   = thisTask / sizeHalfBlock;
1480                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1481                                 indexLo     = indexUp + sizeHalfBlock;
1482 
1483                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
1484                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
1485                         } 
1486                 } 
1487                 
1488                 else if (type==S_GATE){
1489 # ifdef _OPENMP
1490                         # pragma omp for schedule (static)
1491 # endif
1492                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1494                                 thisBlock   = thisTask / sizeHalfBlock;
1495                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1496                                 indexLo     = indexUp + sizeHalfBlock;
1497                                 stateRealLo = stateVecReal[indexLo];
1498                                 stateImagLo = stateVecImag[indexLo];
1499 
1500                                 stateVecReal[indexLo] = -stateImagLo;
1501                                 stateVecImag[indexLo] = stateRealLo;
1502                         } 
1503                 } else if (type==T_GATE){
1504 # ifdef _OPENMP
1505                         # pragma omp for schedule (static)
1506 # endif
1507                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1509                                 thisBlock   = thisTask / sizeHalfBlock;
1510                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1511                                 indexLo     = indexUp + sizeHalfBlock;
1512                                 stateRealLo = stateVecReal[indexLo];
1513                                 stateImagLo = stateVecImag[indexLo];
1514 
1515                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo -
       stateImagLo);
1516                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo +
       stateImagLo);
1517                         } 
1518                 } else printf("Type %d is an invalid phase gate\n", type);
1519         }
1520 }
\end{DoxyCode}
\hypertarget{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}{
\index{qubits.c@{qubits.c}!reportMultiQubitParams@{reportMultiQubitParams}}
\index{reportMultiQubitParams@{reportMultiQubitParams}!qubits.c@{qubits.c}}
\paragraph[{reportMultiQubitParams}]{\setlength{\rightskip}{0pt plus 5cm}void reportMultiQubitParams ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}


Report metainformation about a set of qubits: number of qubits, number of probability amplitudes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}


Definition at line 120 of file qubits.c.

References MultiQubit::chunkId, MultiQubit::numChunks, and MultiQubit::numQubits.


\begin{DoxyCode}
120                                                   {
121         long long int numAmps = 1L << multiQubit.numQubits;
122         long long int numAmpsPerRank = numAmps/multiQubit.numChunks;
123         if (multiQubit.chunkId==0){
124                 printf("QUBITS:\n");
125                 printf("Number of qubits is %d.\n", multiQubit.numQubits);
126                 printf("Number of amps is %lld.\n", numAmps);
127                 printf("Number of amps per rank is %lld.\n", numAmpsPerRank);
128         }
129 }
\end{DoxyCode}
\hypertarget{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}{
\index{qubits.c@{qubits.c}!reportState@{reportState}}
\index{reportState@{reportState}!qubits.c@{qubits.c}}
\paragraph[{reportState}]{\setlength{\rightskip}{0pt plus 5cm}void reportState ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}


Print the current state vector of probability amplitudes for a set of qubits to file. File format: \begin{DoxyVerb}
real, imag
realComponent1, imagComponent1
realComponent2, imagComponent2
...
realComponentN, imagComponentN
\end{DoxyVerb}


File naming convention:

For each node that the program runs on, a file 'state\_\-rank\_\-\mbox{[}node\_\-rank\mbox{]}.csv' is generated. If there is more than one node, ranks after the first do not include the header \begin{DoxyVerb}
real, imag
\end{DoxyVerb}
 so that files are easier to combine.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \end{DoxyParams}


Definition at line 81 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL\_\-STRING\_\-FORMAT, and MultiQubit::stateVec.


\begin{DoxyCode}
81                                        {
82         FILE *state;
83         char filename[100];
84         long long int index;
85         sprintf(filename, "state_rank_%d.csv", multiQubit.chunkId);
86         state = fopen(filename, "w");
87         if (multiQubit.chunkId==0) fprintf(state, "real, imag\n");
88 
89         for(index=0; index<multiQubit.numAmps; index++){
90                 fprintf(state, REAL_STRING_FORMAT "," REAL_STRING_FORMAT "\n", mu
      ltiQubit.stateVec.real[index], multiQubit.stateVec.imag[index]);
91         }
92         fclose(state);
93 }
\end{DoxyCode}
\hypertarget{qubits_8c_a842d6884e063a5865a2232cba56b65ac}{
\index{qubits.c@{qubits.c}!reportStateToScreen@{reportStateToScreen}}
\index{reportStateToScreen@{reportStateToScreen}!qubits.c@{qubits.c}}
\paragraph[{reportStateToScreen}]{\setlength{\rightskip}{0pt plus 5cm}void reportStateToScreen ({\bf MultiQubit} {\em multiQubit}, \/  {\bf QuESTEnv} {\em env}, \/  int {\em reportRank})}\hfill}
\label{qubits_8c_a842d6884e063a5865a2232cba56b65ac}


Print the current state vector of probability amplitudes for a set of qubits to standard out. For debugging purposes. Each rank should print output serially. Only print output for systems $<$= 5 qubits 

Definition at line 95 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, MultiQubit::numQubits, ComplexArray::real, REAL\_\-STRING\_\-FORMAT, MultiQubit::stateVec, and syncQuESTEnv().


\begin{DoxyCode}
95                                                                              {
96         long long int index;
97         int rank;
98         if (multiQubit.numQubits<=5){
99                 for (rank=0; rank<multiQubit.numChunks; rank++){
100                         if (multiQubit.chunkId==rank){
101                                 if (reportRank) {
102                                         printf("Reporting state from rank %d [\n"
      , multiQubit.chunkId);
103                                         //printf("\trank, index, real, imag\n");
104                                         printf("real, imag\n");
105                                 } else if (rank==0) {
106                                         printf("Reporting state [\n");
107                                         printf("real, imag\n");
108                                 }
109 
110                                 for(index=0; index<multiQubit.numAmps; index++){
111                                         printf(REAL_STRING_FORMAT ", " 
      REAL_STRING_FORMAT "\n", multiQubit.stateVec.real[index], multiQubit.stateVec.
      imag[index]);
112                                 }
113                                 if (reportRank || rank==multiQubit.numChunks-1) p
      rintf("]\n");
114                         }
115                         syncQuESTEnv(env);
116                 }
117         } else printf("Error: reportStateToScreen will not print output for syste
      ms of more than 5 qubits.\n");
118 }
\end{DoxyCode}
\hypertarget{qubits_8c_a8810423457803005fecd415f4299f40d}{
\index{qubits.c@{qubits.c}!rotateAroundAxis@{rotateAroundAxis}}
\index{rotateAroundAxis@{rotateAroundAxis}!qubits.c@{qubits.c}}
\paragraph[{rotateAroundAxis}]{\setlength{\rightskip}{0pt plus 5cm}void rotateAroundAxis ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle}, \/  {\bf Vector} {\em axis})}\hfill}
\label{qubits_8c_a8810423457803005fecd415f4299f40d}


Rotate a single qubit by a given angle around a given vector on the Bloch-\/sphere. The vector must not be zero (else an error is thrown), but needn't be unit magnitude.

For angle $\theta$ and axis vector $\vec{n}$, applies $R_{\hat{n}} = \exp \left(- i \frac{\theta}{2} \hat{n} \cdot \vec{\sigma} \right) $ where $\vec{\sigma}$ is the vector of Pauli matrices.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \item[\mbox{$\leftarrow$} {\em axis}]vector around which to rotate (can be non-\/unit; will be normalised) \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily rotQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or if {\ttfamily axis} is the zero vector \end{DoxyExceptions}


Definition at line 382 of file qubits.c.

References compactUnitary(), Complex::imag, Complex::real, Vector::x, Vector::y, and Vector::z.

Referenced by rotateX(), rotateY(), and rotateZ().


\begin{DoxyCode}
382                                                                                  
              {
383         
384         double mag = sqrt(pow(axis.x,2) + pow(axis.y,2) + pow(axis.z,2));
385         Vector unitAxis = {axis.x/mag, axis.y/mag, axis.z/mag};
386         
387         Complex alpha, beta;
388         alpha.real = cos(angle/2.0);
389         alpha.imag = -sin(angle/2.0)*unitAxis.z;        
390         beta.real = sin(angle/2.0)*unitAxis.y;
391         beta.imag = -sin(angle/2.0)*unitAxis.x;
392         compactUnitary(multiQubit, rotQubit, alpha, beta);
393 }
\end{DoxyCode}
\hypertarget{qubits_8c_a6cc7fa705a2f2e6b486b49c5589d5df5}{
\index{qubits.c@{qubits.c}!rotateX@{rotateX}}
\index{rotateX@{rotateX}!qubits.c@{qubits.c}}
\paragraph[{rotateX}]{\setlength{\rightskip}{0pt plus 5cm}void rotateX ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8c_a6cc7fa705a2f2e6b486b49c5589d5df5}


Rotate a single qubit by a given angle around the X-\/axis of the Bloch-\/sphere. For angle $\theta$, applies \[ \begin{pmatrix} \cos\theta/2 & -i \sin \theta/2\\ -i \sin \theta/2 & \cos \theta/2 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {rot}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_x(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily rotQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 395 of file qubits.c.

References rotateAroundAxis().


\begin{DoxyCode}
395                                                                    {
396 
397         Vector unitAxis = {1, 0, 0};
398         rotateAroundAxis(multiQubit, rotQubit, angle, unitAxis);
399 }
\end{DoxyCode}
\hypertarget{qubits_8c_ace0d3592d38a990e81a434c4e9681500}{
\index{qubits.c@{qubits.c}!rotateY@{rotateY}}
\index{rotateY@{rotateY}!qubits.c@{qubits.c}}
\paragraph[{rotateY}]{\setlength{\rightskip}{0pt plus 5cm}void rotateY ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8c_ace0d3592d38a990e81a434c4e9681500}


Rotate a single qubit by a given angle around the Y-\/axis of the Bloch-\/sphere. For angle $\theta$, applies \[ \begin{pmatrix} \cos\theta/2 & - \sin \theta/2\\ \sin \theta/2 & \cos \theta/2 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {rot}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_y(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily rotQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 401 of file qubits.c.

References rotateAroundAxis().


\begin{DoxyCode}
401                                                                    {
402         
403         Vector unitAxis = {0, 1, 0};
404         rotateAroundAxis(multiQubit, rotQubit, angle, unitAxis);
405 }
\end{DoxyCode}
\hypertarget{qubits_8c_abd621412ad30c1b034f4ce153c4afe10}{
\index{qubits.c@{qubits.c}!rotateZ@{rotateZ}}
\index{rotateZ@{rotateZ}!qubits.c@{qubits.c}}
\paragraph[{rotateZ}]{\setlength{\rightskip}{0pt plus 5cm}void rotateZ ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8c_abd621412ad30c1b034f4ce153c4afe10}


Rotate a single qubit by a given angle around the Z-\/axis of the Bloch-\/sphere (also known as a phase shift gate). For angle $\theta$, applies \[ \begin{pmatrix} \exp(-i \theta/2) & 0 \\ 0 & \exp(i \theta/2) \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {rot}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_z(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily rotQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 407 of file qubits.c.

References rotateAroundAxis().


\begin{DoxyCode}
407                                                                    {
408         
409         Vector unitAxis = {0, 0, 1};
410         rotateAroundAxis(multiQubit, rotQubit, angle, unitAxis);
411 }
\end{DoxyCode}
\hypertarget{qubits_8c_adda6c47876a7676488ed0565a19eaa65}{
\index{qubits.c@{qubits.c}!sGate@{sGate}}
\index{sGate@{sGate}!qubits.c@{qubits.c}}
\paragraph[{sGate}]{\setlength{\rightskip}{0pt plus 5cm}void sGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_adda6c47876a7676488ed0565a19eaa65}


Apply the single-\/qubit S gate. This is a rotation of $\pi/2$ around the Z-\/axis on the Bloch sphere, or the unitary: \[ \begin{pmatrix} 1 & 0 \\ 0 & i \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {S}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate upon \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) \end{DoxyExceptions}


Definition at line 1580 of file qubits.c.

References phaseGate(), and S\_\-GATE.


\begin{DoxyCode}
1581 {
1582                 phaseGate(multiQubit, targetQubit, S_GATE);
1583 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a2275fff50824fe47485890ff5a857785}{
\index{qubits.c@{qubits.c}!sigmaXDistributed@{sigmaXDistributed}}
\index{sigmaXDistributed@{sigmaXDistributed}!qubits.c@{qubits.c}}
\paragraph[{sigmaXDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a2275fff50824fe47485890ff5a857785}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1119 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaX().


\begin{DoxyCode}
1122 {
1123 
1124         long long int thisTask;  
1125         const long long int numTasks=multiQubit.numAmps;
1126 
1127         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1128         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1129 
1130 # ifdef _OPENMP
1131 # pragma omp parallel \
1132         default  (none) \
1133         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1134         private  (thisTask)
1135 # endif
1136         {
1137 # ifdef _OPENMP
1138                 # pragma omp for schedule (static)
1139 # endif
1140                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1141                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
1142                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
1143                 }
1144         }
1145 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a74822fd86bb5d81766e6e8dbdcd62df1}{
\index{qubits.c@{qubits.c}!sigmaXLocal@{sigmaXLocal}}
\index{sigmaXLocal@{sigmaXLocal}!qubits.c@{qubits.c}}
\paragraph[{sigmaXLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_a74822fd86bb5d81766e6e8dbdcd62df1}


Definition at line 1060 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaX().


\begin{DoxyCode}
1061 {
1062         long long int sizeBlock, sizeHalfBlock;
1063         long long int thisBlock, // current block
1064              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1065 
1066         REAL stateRealUp,stateImagUp;
1067         long long int thisTask;         
1068         const long long int numTasks=multiQubit.numAmps>>1;
1069 
1070         // set dimensions
1071         sizeHalfBlock = 1LL << targetQubit;  
1072         sizeBlock     = 2LL * sizeHalfBlock; 
1073 
1074         // Can't use multiQubit.stateVec as a private OMP var
1075         REAL *stateVecReal = multiQubit.stateVec.real;
1076         REAL *stateVecImag = multiQubit.stateVec.imag;
1077 
1078 # ifdef _OPENMP
1079 # pragma omp parallel \
1080         default  (none) \
1081         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1082         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1083 # endif
1084         {
1085 # ifdef _OPENMP
1086                 # pragma omp for schedule (static)
1087 # endif
1088                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1089                         thisBlock   = thisTask / sizeHalfBlock;
1090                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1091                         indexLo     = indexUp + sizeHalfBlock;
1092 
1093                         stateRealUp = stateVecReal[indexUp];
1094                         stateImagUp = stateVecImag[indexUp];
1095 
1096                         stateVecReal[indexUp] = stateVecReal[indexLo];
1097                         stateVecImag[indexUp] = stateVecImag[indexLo];
1098 
1099                         stateVecReal[indexLo] = stateRealUp;
1100                         stateVecImag[indexLo] = stateImagUp;
1101                 } 
1102         }
1103 
1104 }
\end{DoxyCode}
\hypertarget{qubits_8c_af5ef5166f00c0572354b4ac53dcf40cf}{
\index{qubits.c@{qubits.c}!sigmaYDistributed@{sigmaYDistributed}}
\index{sigmaYDistributed@{sigmaYDistributed}!qubits.c@{qubits.c}}
\paragraph[{sigmaYDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits_8c_af5ef5166f00c0572354b4ac53dcf40cf}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1306 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaY().


\begin{DoxyCode}
1310 {
1311 
1312         long long int thisTask;  
1313         const long long int numTasks=multiQubit.numAmps;
1314 
1315         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1316         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1317 
1318         int realSign=1, imagSign=1;
1319         if (updateUpper) imagSign=-1;
1320         else realSign = -1;
1321 
1322 # ifdef _OPENMP
1323 # pragma omp parallel \
1324         default  (none) \
1325         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,r
      ealSign,imagSign) \
1326         private  (thisTask)
1327 # endif
1328         {
1329 # ifdef _OPENMP
1330                 # pragma omp for schedule (static)
1331 # endif
1332                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1333                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisT
      ask];
1334                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisT
      ask];
1335                 }
1336         }
1337 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a81fbfaed65a742a7dfd622e17652245e}{
\index{qubits.c@{qubits.c}!sigmaYLocal@{sigmaYLocal}}
\index{sigmaYLocal@{sigmaYLocal}!qubits.c@{qubits.c}}
\paragraph[{sigmaYLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_a81fbfaed65a742a7dfd622e17652245e}


Definition at line 1247 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaY().


\begin{DoxyCode}
1248 {
1249         long long int sizeBlock, sizeHalfBlock;
1250         long long int thisBlock, // current block
1251              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1252 
1253         REAL stateRealUp,stateImagUp;
1254         long long int thisTask;         
1255         const long long int numTasks=multiQubit.numAmps>>1;
1256 
1257         // set dimensions
1258         sizeHalfBlock = 1LL << targetQubit;  
1259         sizeBlock     = 2LL * sizeHalfBlock; 
1260 
1261         // Can't use multiQubit.stateVec as a private OMP var
1262         REAL *stateVecReal = multiQubit.stateVec.real;
1263         REAL *stateVecImag = multiQubit.stateVec.imag;
1264 
1265 # ifdef _OPENMP
1266 # pragma omp parallel \
1267         default  (none) \
1268         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1269         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1270 # endif
1271         {
1272 # ifdef _OPENMP
1273                 # pragma omp for schedule (static)
1274 # endif
1275                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1276                         thisBlock   = thisTask / sizeHalfBlock;
1277                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1278                         indexLo     = indexUp + sizeHalfBlock;
1279 
1280                         stateRealUp = stateVecReal[indexUp];
1281                         stateImagUp = stateVecImag[indexUp];
1282 
1283                         stateVecReal[indexUp] = stateVecImag[indexLo];
1284                         stateVecImag[indexUp] = -stateVecReal[indexLo];
1285 
1286                         stateVecReal[indexLo] = -stateImagUp;
1287                         stateVecImag[indexLo] = stateRealUp;
1288                 } 
1289         }
1290 }
\end{DoxyCode}
\hypertarget{qubits_8c_aebaab86326779de55d335cfea3efde8f}{
\index{qubits.c@{qubits.c}!sigmaZ@{sigmaZ}}
\index{sigmaZ@{sigmaZ}!qubits.c@{qubits.c}}
\paragraph[{sigmaZ}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaZ ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_aebaab86326779de55d335cfea3efde8f}


Apply the single-\/qubit sigma-\/Z (also known as the Z, Pauli-\/Z or phase-\/flip) gate. This is a rotation of $\pi$ around the Z-\/axis (a phase shift) on the Bloch sphere. I.e. \[ \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$\sigma_z$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 1575 of file qubits.c.

References phaseGate(), and SIGMA\_\-Z.


\begin{DoxyCode}
1576 {
1577                 phaseGate(multiQubit, targetQubit, SIGMA_Z);
1578 }
\end{DoxyCode}
\hypertarget{qubits_8c_af764ea63a2e870098f4e1ce08562942e}{
\index{qubits.c@{qubits.c}!tGate@{tGate}}
\index{tGate@{tGate}!qubits.c@{qubits.c}}
\paragraph[{tGate}]{\setlength{\rightskip}{0pt plus 5cm}void tGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_af764ea63a2e870098f4e1ce08562942e}


Apply the single-\/qubit T gate. This is a rotation of $\pi/4$ around the Z-\/axis on the Bloch sphere, or the unitary: \[ \begin{pmatrix} 1 & 0 \\ 0 & \exp\left(i \frac{\pi}{4}\right) \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {T}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate upon \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) \end{DoxyExceptions}


Definition at line 1585 of file qubits.c.

References phaseGate(), and T\_\-GATE.


\begin{DoxyCode}
1586 {
1587                 phaseGate(multiQubit, targetQubit, T_GATE);
1588 }
\end{DoxyCode}
\hypertarget{qubits_8c_a2343b7240118e89aa615e2c9140b770b}{
\index{qubits.c@{qubits.c}!unitaryDistributed@{unitaryDistributed}}
\index{unitaryDistributed@{unitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{unitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a2343b7240118e89aa615e2c9140b770b}


Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em u}]unitary matrix to apply \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 629 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by unitary().


\begin{DoxyCode}
634 {
635 
636         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
637         long long int thisTask;  
638         const long long int numTasks=multiQubit.numAmps;
639 
640         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
641         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
642         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
643         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
644         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
645 
646 
647 # ifdef _OPENMP
648 # pragma omp parallel \
649         default  (none) \
650         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
651                         rot1Real, rot1Imag, rot2Real, rot2Imag) \
652         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
653 # endif
654         {
655 # ifdef _OPENMP
656                 # pragma omp for schedule (static)
657 # endif
658                 for (thisTask=0; thisTask<numTasks; thisTask++) {
659                         // store current state vector values in temp variables
660                         stateRealUp = stateVecRealUp[thisTask];
661                         stateImagUp = stateVecImagUp[thisTask];
662 
663                         stateRealLo = stateVecRealLo[thisTask];
664                         stateImagLo = stateVecImagLo[thisTask];
665 
666                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp 
667                                 + rot2Real*stateRealLo - rot2Imag*stateImagLo;
668                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp 
669                                 + rot2Real*stateImagLo + rot2Imag*stateRealLo;
670                 }
671         }
672 }
\end{DoxyCode}
\hypertarget{qubits_8c_ac134fb45b0a7248c5d15e16eb7139a35}{
\index{qubits.c@{qubits.c}!unitaryLocal@{unitaryLocal}}
\index{unitaryLocal@{unitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{unitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8c_ac134fb45b0a7248c5d15e16eb7139a35}


Definition at line 503 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by unitary().


\begin{DoxyCode}
504 {
505         long long int sizeBlock, sizeHalfBlock;
506         long long int thisBlock, // current block
507              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
508 
509         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
510         long long int thisTask;         
511         const long long int numTasks=multiQubit.numAmps>>1;
512 
513         // set dimensions
514         sizeHalfBlock = 1LL << targetQubit;  
515         sizeBlock     = 2LL * sizeHalfBlock; 
516 
517         // Can't use multiQubit.stateVec as a private OMP var
518         REAL *stateVecReal = multiQubit.stateVec.real;
519         REAL *stateVecImag = multiQubit.stateVec.imag;
520 
521 # ifdef _OPENMP
522 # pragma omp parallel \
523         default  (none) \
524         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
525         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
526 # endif
527         {
528 # ifdef _OPENMP
529                 # pragma omp for schedule (static)
530 # endif
531                 for (thisTask=0; thisTask<numTasks; thisTask++) {
532 
533                         thisBlock   = thisTask / sizeHalfBlock;
534                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
535                         indexLo     = indexUp + sizeHalfBlock;
536 
537                         // store current state vector values in temp variables
538                         stateRealUp = stateVecReal[indexUp];
539                         stateImagUp = stateVecImag[indexUp];
540 
541                         stateRealLo = stateVecReal[indexLo];
542                         stateImagLo = stateVecImag[indexLo];
543 
544 
545                         // state[indexUp] = u00 * state[indexUp] + u01 * state[in
      dexLo]
546                         stateVecReal[indexUp] = u.r0c0.real*stateRealUp - u.r0c0.
      imag*stateImagUp 
547                                 + u.r0c1.real*stateRealLo - u.r0c1.imag*stateImag
      Lo;
548                         stateVecImag[indexUp] = u.r0c0.real*stateImagUp + u.r0c0.
      imag*stateRealUp 
549                                 + u.r0c1.real*stateImagLo + u.r0c1.imag*stateReal
      Lo;
550 
551                         // state[indexLo] = u10  * state[indexUp] + u11 * state[i
      ndexLo]
552                         stateVecReal[indexLo] = u.r1c0.real*stateRealUp  - u.
      r1c0.imag*stateImagUp 
553                                 + u.r1c1.real*stateRealLo  -  u.r1c1.imag*stateIm
      agLo;
554                         stateVecImag[indexLo] = u.r1c0.real*stateImagUp + u.r1c0.
      imag*stateRealUp 
555                                 + u.r1c1.real*stateImagLo + u.r1c1.imag*stateReal
      Lo;
556 
557                 } 
558         }
559 } 
\end{DoxyCode}
\hypertarget{qubits_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}{
\index{qubits.c@{qubits.c}!validateAlphaBeta@{validateAlphaBeta}}
\index{validateAlphaBeta@{validateAlphaBeta}!qubits.c@{qubits.c}}
\paragraph[{validateAlphaBeta}]{\setlength{\rightskip}{0pt plus 5cm}int validateAlphaBeta ({\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}


Definition at line 369 of file qubits.c.

References Complex::imag, Complex::real, and REAL\_\-EPS.

Referenced by compactUnitary(), and controlledCompactUnitary().


\begin{DoxyCode}
369                                                   {
370         if ( fabs(alpha.real*alpha.real 
371                 + alpha.imag*alpha.imag
372                 + beta.real*beta.real 
373                 + beta.imag*beta.imag - 1) > REAL_EPS ) return 0;
374         else return 1;
375 }
\end{DoxyCode}
\hypertarget{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}{
\index{qubits.c@{qubits.c}!validateMatrixIsUnitary@{validateMatrixIsUnitary}}
\index{validateMatrixIsUnitary@{validateMatrixIsUnitary}!qubits.c@{qubits.c}}
\paragraph[{validateMatrixIsUnitary}]{\setlength{\rightskip}{0pt plus 5cm}int validateMatrixIsUnitary ({\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}


Definition at line 344 of file qubits.c.

References Complex::imag, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, and REAL\_\-EPS.

Referenced by controlledUnitary(), multiControlledUnitary(), and unitary().


\begin{DoxyCode}
344                                              {
345 
346         if ( fabs(u.r0c0.real*u.r0c0.real 
347                 + u.r0c0.imag*u.r0c0.imag
348                 + u.r1c0.real*u.r1c0.real
349                 + u.r1c0.imag*u.r1c0.imag - 1) > REAL_EPS ) return 0;
350     // check
351         if ( fabs(u.r0c1.real*u.r0c1.real 
352                 + u.r0c1.imag*u.r0c1.imag
353                 + u.r1c1.real*u.r1c1.real
354                 + u.r1c1.imag*u.r1c1.imag - 1) > REAL_EPS ) return 0;
355 
356         if ( fabs(u.r0c0.real*u.r0c1.real 
357                 + u.r0c0.imag*u.r0c1.imag
358                 + u.r1c0.real*u.r1c1.real
359                 + u.r1c0.imag*u.r1c1.imag) > REAL_EPS ) return 0;
360 
361         if ( fabs(u.r0c1.real*u.r0c0.imag
362                 - u.r0c0.real*u.r0c1.imag
363                 + u.r1c1.real*u.r1c0.imag
364                 - u.r1c0.real*u.r1c1.imag) > REAL_EPS ) return 0;
365 
366         return 1;
367 }
\end{DoxyCode}
\hypertarget{qubits_8c_a71c14976f63cfcda70026fa20ee531fe}{
\index{qubits.c@{qubits.c}!validateUnitVector@{validateUnitVector}}
\index{validateUnitVector@{validateUnitVector}!qubits.c@{qubits.c}}
\paragraph[{validateUnitVector}]{\setlength{\rightskip}{0pt plus 5cm}int validateUnitVector (REAL {\em ux}, \/  REAL {\em uy}, \/  REAL {\em uz})}\hfill}
\label{qubits_8c_a71c14976f63cfcda70026fa20ee531fe}


Definition at line 377 of file qubits.c.

References REAL\_\-EPS.


\begin{DoxyCode}
377                                                  {
378         if ( fabs(sqrt(ux*ux + uy*uy + uz*uz) - 1) > REAL_EPS ) return 0;
379         else return 1;
380 }
\end{DoxyCode}


\subsubsection{Variable Documentation}
\hypertarget{qubits_8c_aac1637696885c75b73a1ecf381cea713}{
\index{qubits.c@{qubits.c}!errorCodes@{errorCodes}}
\index{errorCodes@{errorCodes}!qubits.c@{qubits.c}}
\paragraph[{errorCodes}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ {\bf errorCodes}\mbox{[}$\,$\mbox{]}}\hfill}
\label{qubits_8c_aac1637696885c75b73a1ecf381cea713}
{\bfseries Initial value:}
\begin{DoxyCode}
 {
    "Success",                                              
    "Invalid target qubit. Note qubits are zero indexed.",  
    "Invalid control qubit. Note qubits are zero indexed.", 
    "Control qubit cannot equal target qubit.",             
    "Invalid number of control qubits",                     
    "Invalid unitary matrix.",                              
    "Invalid rotation arguments.",                          
    "Invalid system size. Cannot print output for systems greater than 5 qubits."
      , 
    "Can't collapse to state with zero probability.", 
    "Invalid number of qubits.", 
    "Invalid measurement outcome -- must be either 0 or 1." 
}
\end{DoxyCode}


Definition at line 20 of file qubits.c.

Referenced by exitWithError().