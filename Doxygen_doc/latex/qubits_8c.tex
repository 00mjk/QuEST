\hypertarget{qubits_8c}{}\subsection{qubits.\+c File Reference}
\label{qubits_8c}\index{qubits.\+c@{qubits.\+c}}


The core of the Qu\+E\+ST Library.  


{\ttfamily \#include $<$math.\+h$>$}\\*
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$assert.\+h$>$}\\*
{\ttfamily \#include \char`\"{}precision.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}qubits.\+h\char`\"{}}\\*
{\ttfamily \#include $<$omp.\+h$>$}\\*
\subsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{D\+E\+B\+UG}~0
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extract\+Bit} (const int location\+Of\+Bit\+From\+Right, const long long int the\+Encoded\+Number)
\begin{DoxyCompactList}\small\item\em Get the value of the bit at a particular index in a number. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a9c02591bc64c2918503afa231d90d83f}{create\+Multi\+Qubit} (\hyperlink{structMultiQubit}{Multi\+Qubit} $\ast$multi\+Qubit, int num\+Qubits, \hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Create a \hyperlink{structMultiQubit}{Multi\+Qubit} object representing a set of qubits. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}{destroy\+Multi\+Qubit} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, \hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Deallocate a \hyperlink{structMultiQubit}{Multi\+Qubit} object representing a set of qubits Free memory allocated to state vector of probability amplitudes, including temporary vector for values copied from another chunk if running the distributed version. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}{report\+State} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Print the current state vector of probability amplitudes for a set of qubits to file. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a842d6884e063a5865a2232cba56b65ac}{report\+State\+To\+Screen} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, \hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env}, int report\+Rank)
\begin{DoxyCompactList}\small\item\em Print the current state vector of probability amplitudes for a set of qubits to standard out. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}{report\+Multi\+Qubit\+Params} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Report metainformation about a set of qubits\+: number of qubits, number of probability amplitudes. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_acb5b2eff794339090004d29f02a70d9a}{init\+State\+Zero} (\hyperlink{structMultiQubit}{Multi\+Qubit} $\ast$multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes for a set of qubits to the zero state\+: $\vert$000...00$>$ \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}{init\+State\+Plus} (\hyperlink{structMultiQubit}{Multi\+Qubit} $\ast$multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes for a set of qubits to an equal real superposition of all amplitudes\+: $\vert$+++...++$>$ \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}{init\+State\+Debug} (\hyperlink{structMultiQubit}{Multi\+Qubit} $\ast$multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes to an (unphysical) state with each component of each probability amplitude a unique floating point value. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a9c8dad2ac76ac04b74caa059b399d576}{initialize\+State\+From\+Single\+File} (\hyperlink{structMultiQubit}{Multi\+Qubit} $\ast$multi\+Qubit, char filename\mbox{[}200\mbox{]})
\item 
int \hyperlink{qubits_8c_a793584932ae384c82e7e42db7d35d18d}{compare\+States} (\hyperlink{structMultiQubit}{Multi\+Qubit} mq1, \hyperlink{structMultiQubit}{Multi\+Qubit} mq2, \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} precision)
\item 
void \hyperlink{qubits_8c_acb059cbcb8c7910a5fc43d21da4f5dea}{rotate\+Qubit\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a6ff67d25363f39fd57a4e76621a4bfd5}{rotate\+Qubit\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a824d71bae93236d8a3cd43589044eaee}{control\+Rotate\+Qubit\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, const int control\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments and a control qubit. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ab22d031e2507f1d859292103a99e2378}{control\+Rotate\+Qubit\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, const int control\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_aa9e640bb2d0458c937c6a87dfeca0f23}{sigma\+X\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a5958808b2f2f05937921ba7dabe5a171}{sigma\+X\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a2901e2e5531cb77f87ea54b3fc28f51a}{control\+Not\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, const int control\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\} for elements where control\+Qubit is one. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a774dd1217fcc3591a74a74d5667afa29}{control\+Not\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, const int control\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_afcbb1dcbe070ad0ed1a72a23251b6a83}{sigma\+Y\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a0471f6b547ce8270ef85170b7f4f0214}{sigma\+Y\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out, int update\+Upper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a0711416fceaf63c67b496e123e845c69}{hadamard\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ac835c194bd547240a35f0b028db1d658}{hadamard\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out, int update\+Upper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a6a736aeb3532898019fe7c27010edc6a}{phase\+Gate\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a38a05c7e749e806b182ef3b89878bfc4}{phase\+Gate\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a9c90f8302e4f1d8fda23def8753e50fe}{sigmaZ} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{\{0,-\/1\}\} -- apply a phase of -\/1 to $\vert$1$>$. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a1086d84d6a3d5b79137e2f27f18e67e0}{s\+Gate} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\item 
void \hyperlink{qubits_8c_a5f33ddd690383fd09cc79bf143e383fb}{t\+Gate} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}{find\+Probability\+Of\+Zero\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}{find\+Probability\+Of\+Zero\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a0ad4584e44f567c140b653ed36d26ccf}{control\+Phase\+Gate} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2)
\begin{DoxyCompactList}\small\item\em The control phase (the two qubit phase gate). \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_aca7765bd500718f98700a172351748cc}{quad\+C\+Phase\+Gate} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3, const int id\+Qubit4)
\begin{DoxyCompactList}\small\item\em The control not gate. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a53614ce19e0a4f2c41b400cf05dc5bd1}{measure\+In\+State\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, int measure\+Qubit, \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} total\+Probability, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits_8c_a35e5ac30c8427c482a97b33a4e295535}{measure\+In\+State\+Distributed\+Renorm} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit, const \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} total\+Probability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measure\+Qubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ac39efc9ed939382276ebd0c15dd6a0fa}{measure\+In\+State\+Distributed\+Set\+Zero} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Set all amplitudes in one chunk to 0. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a2d73fd11c1d154640dbf114da8f34c64}{filter\+Out111\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3, const \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} prob\+Of\+Filter)
\begin{DoxyCompactList}\small\item\em Updates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits_8c_a096cddbac961f0651a084d2ceb905d1b}{prob\+Of\+Filter\+Out111\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3)
\begin{DoxyCompactList}\small\item\em Evaluates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}{get\+Prob\+El} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get probability of the state at an index in the state vector. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
The core of the Qu\+E\+ST Library. 



\subsubsection{Macro Definition Documentation}
\index{qubits.\+c@{qubits.\+c}!D\+E\+B\+UG@{D\+E\+B\+UG}}
\index{D\+E\+B\+UG@{D\+E\+B\+UG}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{D\+E\+B\+UG}{DEBUG}}]{\setlength{\rightskip}{0pt plus 5cm}\#define D\+E\+B\+UG~0}\hypertarget{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{}\label{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}


Definition at line 14 of file qubits.\+c.



Referenced by find\+Probability\+Of\+Zero\+Local(), init\+State\+Debug(), init\+State\+Plus(), and init\+State\+Zero().



\subsubsection{Function Documentation}
\index{qubits.\+c@{qubits.\+c}!compare\+States@{compare\+States}}
\index{compare\+States@{compare\+States}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{compare\+States(\+Multi\+Qubit mq1, Multi\+Qubit mq2, R\+E\+A\+L precision)}{compareStates(MultiQubit mq1, MultiQubit mq2, REAL precision)}}]{\setlength{\rightskip}{0pt plus 5cm}int compare\+States (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{mq1, }
\item[{{\bf Multi\+Qubit}}]{mq2, }
\item[{{\bf R\+E\+AL}}]{precision}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a793584932ae384c82e7e42db7d35d18d}{}\label{qubits_8c_a793584932ae384c82e7e42db7d35d18d}


Definition at line 293 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by test\+\_\+control\+Not(), test\+\_\+control\+Phase\+Gate(), test\+\_\+hadamard(), test\+\_\+init\+State\+Plus(), test\+\_\+init\+State\+Zero(), test\+\_\+s\+Gate(), test\+\_\+sigma\+X(), test\+\_\+sigma\+Y(), test\+\_\+sigma\+Z(), and test\+\_\+t\+Gate().


\begin{DoxyCode}
293                                                                  \{
294         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} diff;
295         \textcolor{keywordtype}{int} chunkSize = mq1.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
296         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<chunkSize; i++)\{
297                 diff = mq1.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[i] - mq2.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.
      \hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[i];
298                 \textcolor{keywordflow}{if} (diff<0) diff *= -1;
299                 \textcolor{keywordflow}{if} (diff>precision) \textcolor{keywordflow}{return} 0;
300                 diff = mq1.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[i] - mq2.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[i];
301                 \textcolor{keywordflow}{if} (diff<0) diff *= -1;
302                 \textcolor{keywordflow}{if} (diff>precision) \textcolor{keywordflow}{return} 0;
303         \}
304         \textcolor{keywordflow}{return} 1;
305 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!control\+Not\+Distributed@{control\+Not\+Distributed}}
\index{control\+Not\+Distributed@{control\+Not\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{control\+Not\+Distributed(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, const int control\+Qubit, Complex\+Array state\+Vec\+In, Complex\+Array state\+Vec\+Out)}{controlNotDistributed(MultiQubit multiQubit, const int targetQubit, const int controlQubit, ComplexArray stateVecIn, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void control\+Not\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+In, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a774dd1217fcc3591a74a74d5667afa29}{}\label{qubits_8c_a774dd1217fcc3591a74a74d5667afa29}


Rotate a single qubit by \{\{0,1\},\{1,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk. Only perform the rotation for elements where control\+Qubit is one.

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 799 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and R\+E\+AL.



Referenced by control\+Not().


\begin{DoxyCode}
802 \{
803 
804         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
805         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
806 
807         \textcolor{keywordtype}{int} controlBit;
808 
809         \textcolor{comment}{// test qubit valid}
810         assert (targetQubit >= 0 && targetQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
811 
812         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
813         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
814 
815 \textcolor{preprocessor}{# ifdef \_OPENMP}
816 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
817 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
818 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) \(\backslash\)}
819 \textcolor{preprocessor}{        private  (thisTask,controlBit)}
820 \textcolor{preprocessor}{# endif}
821         \{
822 \textcolor{preprocessor}{# ifdef \_OPENMP}
823 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
824 \textcolor{preprocessor}{# endif}
825                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
826                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, thisTask);
827                         \textcolor{keywordflow}{if} (controlBit)\{
828                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
829                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
830                         \}
831                 \}
832         \}
833 \} 
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!control\+Not\+Local@{control\+Not\+Local}}
\index{control\+Not\+Local@{control\+Not\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{control\+Not\+Local(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, const int control\+Qubit)}{controlNotLocal(MultiQubit multiQubit, const int targetQubit, const int controlQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void control\+Not\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{const int}]{control\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a2901e2e5531cb77f87ea54b3fc28f51a}{}\label{qubits_8c_a2901e2e5531cb77f87ea54b3fc28f51a}


Rotate a single qubit by \{\{0,1\},\{1,0\} for elements where control\+Qubit is one. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & qubit to determine whether or not to perform a rotation \\
\hline
\end{DoxyParams}


Definition at line 724 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by control\+Not().


\begin{DoxyCode}
725 \{
726         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
727         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
728              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
729 
730         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
731         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
732         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
733 
734         \textcolor{keywordtype}{int} controlBit;
735 
736         \textcolor{comment}{// if targetQubit==controlQubit, it is guaranteed that controlQubit==1 when}
737         \textcolor{comment}{// targetQubit==1. As rotations are symmetric, we can instead apply the rotation}
738         \textcolor{comment}{// on all amplitudes where targetQubit==0 as we do here.}
739         \textcolor{keywordtype}{int} rotateAll=(targetQubit==controlQubit);
740 
741         \textcolor{comment}{// test qubit valid}
742         assert (targetQubit >= 0 && targetQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
743 
744         \textcolor{comment}{// set dimensions}
745         sizeHalfBlock = 1LL << targetQubit;  
746         sizeBlock     = 2LL * sizeHalfBlock; 
747 
748 
749         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
750         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
751         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
752 
753 \textcolor{preprocessor}{# ifdef \_OPENMP}
754 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
755 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
756 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,rotateAll) \(\backslash\)}
757 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,controlBit) }
758 \textcolor{preprocessor}{# endif}
759         \{
760 \textcolor{preprocessor}{# ifdef \_OPENMP}
761 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
762 \textcolor{preprocessor}{# endif}
763                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
764                         thisBlock   = thisTask / sizeHalfBlock;
765                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
766                         indexLo     = indexUp + sizeHalfBlock;
767 
768                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit}(controlQubit, indexUp);
769                         \textcolor{keywordflow}{if} (rotateAll || controlBit)\{
770                                 stateRealUp = stateVecReal[indexUp];
771                                 stateImagUp = stateVecImag[indexUp];
772 
773                                 stateVecReal[indexUp] = stateVecReal[indexLo];
774                                 stateVecImag[indexUp] = stateVecImag[indexLo];
775 
776                                 stateVecReal[indexLo] = stateRealUp;
777                                 stateVecImag[indexLo] = stateImagUp;
778                         \}
779                 \} 
780         \}
781 
782 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!control\+Phase\+Gate@{control\+Phase\+Gate}}
\index{control\+Phase\+Gate@{control\+Phase\+Gate}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{control\+Phase\+Gate(\+Multi\+Qubit multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2)}{controlPhaseGate(MultiQubit multiQubit, const int idQubit1, const int idQubit2)}}]{\setlength{\rightskip}{0pt plus 5cm}void control\+Phase\+Gate (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{id\+Qubit1, }
\item[{const int}]{id\+Qubit2}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a0ad4584e44f567c140b653ed36d26ccf}{}\label{qubits_8c_a0ad4584e44f567c140b653ed36d26ccf}


The control phase (the two qubit phase gate). 

For each state, if both input qubits are equal to one, multiply the amplitude of that state by -\/1. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2} & specified qubits \\
\hline
\end{DoxyParams}


Definition at line 1391 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by main(), and test\+\_\+control\+Phase\+Gate().


\begin{DoxyCode}
1392 \{
1393         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
1394         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
1395         \textcolor{keywordtype}{int} bit1, bit2;
1396 
1397         \textcolor{comment}{// ---------------------------------------------------------------- //}
1398         \textcolor{comment}{//            tests                                                 //}
1399         \textcolor{comment}{// ---------------------------------------------------------------- //}
1400 
1401         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} && idQubit2 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1402 
1403 
1404         \textcolor{comment}{// ---------------------------------------------------------------- //}
1405         \textcolor{comment}{//            initialise the state to |0000..0>                     //}
1406         \textcolor{comment}{// ---------------------------------------------------------------- //}
1407 
1408         \textcolor{comment}{// dimension of the state vector}
1409         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1410         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1411         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1412 
1413 \textcolor{preprocessor}{# ifdef \_OPENMP}
1414 \textcolor{preprocessor}{# pragma omp parallel for \(\backslash\)}
1415 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
1416 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag ) \(\backslash\)}
1417 \textcolor{preprocessor}{        private  (index,bit1,bit2)                     \(\backslash\)}
1418 \textcolor{preprocessor}{        schedule (static)}
1419 \textcolor{preprocessor}{# endif}
1420         \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
1421                 bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
1422                 bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
1423                 \textcolor{keywordflow}{if} (bit1 && bit2) \{
1424                         stateVecReal [index] = - stateVecReal [index];
1425                         stateVecImag [index] = - stateVecImag [index];
1426                 \}
1427         \}
1428 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!control\+Rotate\+Qubit\+Distributed@{control\+Rotate\+Qubit\+Distributed}}
\index{control\+Rotate\+Qubit\+Distributed@{control\+Rotate\+Qubit\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{control\+Rotate\+Qubit\+Distributed(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, const int control\+Qubit, Complex rot1, Complex rot2, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out)}{controlRotateQubitDistributed(MultiQubit multiQubit, const int rotQubit, const int controlQubit, Complex rot1, Complex rot2, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void control\+Rotate\+Qubit\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{{\bf Complex}}]{rot1, }
\item[{{\bf Complex}}]{rot2, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_ab22d031e2507f1d859292103a99e2378}{}\label{qubits_8c_ab22d031e2507f1d859292103a99e2378}


Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. 

Only perform the rotation where the control qubit is one.

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & qubit to determine whether or not to perform a rotation \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 555 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Complex\+::real.



Referenced by control\+Rotate\+Qubit().


\begin{DoxyCode}
560 \{
561 
562         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
563         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
564         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
565 
566         \textcolor{keywordtype}{int} controlBit;
567 
568         \textcolor{comment}{// As rotations are symmetric, we can apply rotations for all elements where}
569         \textcolor{comment}{// targetQubit==0 and controlQubit==1.  }
570         \textcolor{comment}{// However, this means we will skip the case where targetQubit==controlQubit. }
571         \textcolor{comment}{// We check for that here. }
572         \textcolor{comment}{// We could also choose to rotate on targetQubit==1, but are doing it this way }
573         \textcolor{comment}{// to match the regular rotate implementation. }
574         \textcolor{keywordtype}{int} rotateAll=(rotQubit==controlQubit);
575 
576         \textcolor{comment}{// test qubit valid}
577         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
578 
579         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
580         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
581         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
582         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
583         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
584 
585 \textcolor{preprocessor}{# ifdef \_OPENMP}
586 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
587 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
588 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
589 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag,rotateAll) \(\backslash\)}
590 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit)}
591 \textcolor{preprocessor}{# endif}
592         \{
593 \textcolor{preprocessor}{# ifdef \_OPENMP}
594 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
595 \textcolor{preprocessor}{# endif}
596                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
597                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, thisTask);
598                         \textcolor{keywordflow}{if} (rotateAll || controlBit)\{
599                                 \textcolor{comment}{// store current state vector values in temp variables}
600                                 stateRealUp = stateVecRealUp[thisTask];
601                                 stateImagUp = stateVecImagUp[thisTask];
602 
603                                 stateRealLo = stateVecRealLo[thisTask];
604                                 stateImagLo = stateVecImagLo[thisTask];
605 
606                                 \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
607                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp + 
      rot2Real*stateRealLo + rot2Imag*stateImagLo;
608                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp + 
      rot2Real*stateImagLo - rot2Imag*stateRealLo;
609                         \}
610                 \}
611         \}
612 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!control\+Rotate\+Qubit\+Local@{control\+Rotate\+Qubit\+Local}}
\index{control\+Rotate\+Qubit\+Local@{control\+Rotate\+Qubit\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{control\+Rotate\+Qubit\+Local(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, const int control\+Qubit, Complex alpha, Complex beta)}{controlRotateQubitLocal(MultiQubit multiQubit, const int rotQubit, const int controlQubit, Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}void control\+Rotate\+Qubit\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a824d71bae93236d8a3cd43589044eaee}{}\label{qubits_8c_a824d71bae93236d8a3cd43589044eaee}


Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments and a control qubit. 

Only perform the rotation for elements where the control qubit is one. alpha\+Re = cos(angle1) $\ast$ cos(angle2) ~\newline
alpha\+Im = cos(angle1) $\ast$ sin(angle2) ~\newline
 beta\+Re = sin(angle1) $\ast$ cos(angle3) ~\newline
 beta\+Im = sin(angle1) $\ast$ sin(angle3) ~\newline


\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em alpha} & rotation angle \\
\hline
\mbox{\tt in}  & {\em beta} & rotation angle \\
\hline
\end{DoxyParams}


Definition at line 461 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, Complex\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by control\+Rotate\+Qubit().


\begin{DoxyCode}
463 \{
464         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
465         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
466              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
467 
468         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
469         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
470         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
471 
472         \textcolor{keywordtype}{int} controlBit;
473 
474         \textcolor{comment}{// As rotations are symmetric, we can apply rotations for all elements where}
475         \textcolor{comment}{// targetQubit==0 and controlQubit==1.  }
476         \textcolor{comment}{// However, this means we will skip the case where targetQubit==controlQubit. }
477         \textcolor{comment}{// We check for that here. }
478         \textcolor{comment}{// We could also choose to rotate on targetQubit==1, but are doing it this way }
479         \textcolor{comment}{// to match the regular rotate implementation. }
480         \textcolor{keywordtype}{int} rotateAll=(rotQubit==controlQubit);
481 
482         \textcolor{comment}{// test qubit valid}
483         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
484 
485         \textcolor{comment}{// set dimensions}
486         sizeHalfBlock = 1LL << rotQubit;  
487         sizeBlock     = 2LL * sizeHalfBlock; 
488 
489         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
490         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
491         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
492         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} alphaImag=alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, alphaReal=alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
493         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} betaImag=beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, betaReal=beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
494 
495 \textcolor{preprocessor}{# ifdef \_OPENMP}
496 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
497 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
498 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,alphaImag,
       betaReal,betaImag,\(\backslash\)}
499 \textcolor{preprocessor}{                        rotateAll) \(\backslash\)}
500 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo,
       stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit) }
501 \textcolor{preprocessor}{# endif}
502         \{
503 \textcolor{preprocessor}{# ifdef \_OPENMP}
504 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
505 \textcolor{preprocessor}{# endif}
506                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
507 
508                         thisBlock   = thisTask / sizeHalfBlock;
509                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
510                         indexLo     = indexUp + sizeHalfBlock;
511 
512                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, indexUp);
513                         \textcolor{keywordflow}{if} (rotateAll || controlBit)\{
514                                 \textcolor{comment}{// store current state vector values in temp variables}
515                                 stateRealUp = stateVecReal[indexUp];
516                                 stateImagUp = stateVecImag[indexUp];
517 
518                                 stateRealLo = stateVecReal[indexLo];
519                                 stateImagLo = stateVecImag[indexLo];
520 
521                                 \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
522                                 stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag*stateImagUp 
523                                         - betaReal*stateRealLo - betaImag*stateImagLo;
524                                 stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag*stateRealUp 
525                                         - betaReal*stateImagLo + betaImag*stateRealLo;
526 
527                                 \textcolor{comment}{// state[indexLo] = beta  * state[indexUp] + conj(alpha) * state[indexLo]}
528                                 stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*stateImagUp 
529                                         + alphaReal*stateRealLo + alphaImag*stateImagLo;
530                                 stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*stateRealUp 
531                                         + alphaReal*stateImagLo - alphaImag*stateRealLo;
532                         \}
533                 \} 
534         \}
535 
536 \} 
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!create\+Multi\+Qubit@{create\+Multi\+Qubit}}
\index{create\+Multi\+Qubit@{create\+Multi\+Qubit}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{create\+Multi\+Qubit(\+Multi\+Qubit $\ast$multi\+Qubit, int num\+Qubits, Qu\+E\+S\+T\+Env env)}{createMultiQubit(MultiQubit *multiQubit, int numQubits, QuESTEnv env)}}]{\setlength{\rightskip}{0pt plus 5cm}void create\+Multi\+Qubit (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit} $\ast$}]{multi\+Qubit, }
\item[{int}]{num\+Qubits, }
\item[{{\bf Qu\+E\+S\+T\+Env}}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a9c02591bc64c2918503afa231d90d83f}{}\label{qubits_8c_a9c02591bc64c2918503afa231d90d83f}


Create a \hyperlink{structMultiQubit}{Multi\+Qubit} object representing a set of qubits. 

Allocate space for state vector of probability amplitudes, including space for temporary values to be copied from one other chunk if running the distributed version. Define properties related to the size of the set of qubits. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em num\+Qubits} & number of qubits in the system \\
\hline
\mbox{\tt in}  & {\em env} & object representing the execution environment (local, multinode etc) \\
\hline
\end{DoxyParams}


Definition at line 27 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Chunks, Multi\+Qubit\+::num\+Qubits, Qu\+E\+S\+T\+Env\+::num\+Ranks, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Env\+::rank, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by main(), test\+\_\+control\+Not(), test\+\_\+control\+Phase\+Gate(), test\+\_\+hadamard(), test\+\_\+init\+State\+Plus(), test\+\_\+init\+State\+Zero(), test\+\_\+s\+Gate(), test\+\_\+sigma\+X(), test\+\_\+sigma\+Y(), test\+\_\+sigma\+Z(), and test\+\_\+t\+Gate().


\begin{DoxyCode}
28 \{
29         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numAmps = 1L << numQubits;
30         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numAmpsPerRank = numAmps/env.\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks};
31 
32         multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real} = malloc(numAmpsPerRank * \textcolor{keyword}{sizeof}(*(multiQubit->
      \hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real})));
33         multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag} = malloc(numAmpsPerRank * \textcolor{keyword}{sizeof}(*(multiQubit->
      \hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag})));
34         \textcolor{keywordflow}{if} (env.\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks}>1)\{
35                 multiQubit->\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real} = malloc(numAmpsPerRank * \textcolor{keyword}{sizeof}(*(multiQubit
      ->\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real})));
36                 multiQubit->\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag} = malloc(numAmpsPerRank * \textcolor{keyword}{sizeof}(*(multiQubit
      ->\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag})));
37         \}
38 
39         \textcolor{keywordflow}{if} ( (!(multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}) || !(multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}))
40                  && numAmpsPerRank ) \{
41                 printf(\textcolor{stringliteral}{"Could not allocate memory!"});
42                 exit (EXIT\_FAILURE);
43         \}
44 
45         \textcolor{keywordflow}{if} ( env.\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks}>1 && (!(multiQubit->\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.
      \hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}) || !(multiQubit->\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}))
46                  && numAmpsPerRank ) \{
47                 printf(\textcolor{stringliteral}{"Could not allocate memory!"});
48                 exit (EXIT\_FAILURE);
49         \}
50 
51         multiQubit->\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} = numQubits;
52         multiQubit->\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps} = numAmpsPerRank;
53         multiQubit->\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId} = env.\hyperlink{structQuESTEnv_aa648bb336cf8598467cb62db00b9cee8}{rank};
54         multiQubit->\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks} = env.\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks};
55 
56 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!destroy\+Multi\+Qubit@{destroy\+Multi\+Qubit}}
\index{destroy\+Multi\+Qubit@{destroy\+Multi\+Qubit}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{destroy\+Multi\+Qubit(\+Multi\+Qubit multi\+Qubit, Qu\+E\+S\+T\+Env env)}{destroyMultiQubit(MultiQubit multiQubit, QuESTEnv env)}}]{\setlength{\rightskip}{0pt plus 5cm}void destroy\+Multi\+Qubit (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{{\bf Qu\+E\+S\+T\+Env}}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}{}\label{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}


Deallocate a \hyperlink{structMultiQubit}{Multi\+Qubit} object representing a set of qubits Free memory allocated to state vector of probability amplitudes, including temporary vector for values copied from another chunk if running the distributed version. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object to be deallocated \\
\hline
\mbox{\tt in}  & {\em env} & object representing the execution environment (local, multinode etc) \\
\hline
\end{DoxyParams}


Definition at line 63 of file qubits.\+c.



References Complex\+Array\+::imag, Qu\+E\+S\+T\+Env\+::num\+Ranks, Multi\+Qubit\+::pair\+State\+Vec, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by main(), test\+\_\+control\+Not(), test\+\_\+control\+Phase\+Gate(), test\+\_\+hadamard(), test\+\_\+init\+State\+Plus(), test\+\_\+init\+State\+Zero(), test\+\_\+s\+Gate(), test\+\_\+sigma\+X(), test\+\_\+sigma\+Y(), test\+\_\+sigma\+Z(), and test\+\_\+t\+Gate().


\begin{DoxyCode}
63                                                            \{
64         free(multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real});
65         free(multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag});
66         \textcolor{keywordflow}{if} (env.\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks}>1)\{
67                 free(multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real});
68                 free(multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag});
69         \}
70 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!extract\+Bit@{extract\+Bit}}
\index{extract\+Bit@{extract\+Bit}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{extract\+Bit(const int location\+Of\+Bit\+From\+Right, const long long int the\+Encoded\+Number)}{extractBit(const int locationOfBitFromRight, const long long int theEncodedNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}static int extract\+Bit (
\begin{DoxyParamCaption}
\item[{const int}]{location\+Of\+Bit\+From\+Right, }
\item[{const long long int}]{the\+Encoded\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits_8c_a100463f6ec212c76a5fad99579000505}{}\label{qubits_8c_a100463f6ec212c76a5fad99579000505}


Get the value of the bit at a particular index in a number. 

S\+CB edit\+: new definition of extract\+Bit is much faster $\ast$$\ast$$\ast$ 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em location\+Of\+Bit\+From\+Right} & location of bit in the\+Encoded\+Number \\
\hline
\mbox{\tt in}  & {\em the\+Encoded\+Number} & number to search \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the value of the bit in the\+Encoded\+Number 
\end{DoxyReturn}


Definition at line 1380 of file qubits.\+c.



Referenced by control\+Not\+Distributed(), control\+Not\+Local(), control\+Phase\+Gate(), control\+Rotate\+Qubit\+Distributed(), control\+Rotate\+Qubit\+Local(), filter\+Out111\+Local(), prob\+Of\+Filter\+Out111\+Local(), and quad\+C\+Phase\+Gate().


\begin{DoxyCode}
1381 \{
1382         \textcolor{keywordflow}{return} (theEncodedNumber & ( 1LL << locationOfBitFromRight )) >> locationOfBitFromRight;
1383 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!filter\+Out111\+Local@{filter\+Out111\+Local}}
\index{filter\+Out111\+Local@{filter\+Out111\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{filter\+Out111\+Local(\+Multi\+Qubit multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3, const R\+E\+A\+L prob\+Of\+Filter)}{filterOut111Local(MultiQubit multiQubit, const int idQubit1, const int idQubit2, const int idQubit3, const REAL probOfFilter)}}]{\setlength{\rightskip}{0pt plus 5cm}void filter\+Out111\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{id\+Qubit1, }
\item[{const int}]{id\+Qubit2, }
\item[{const int}]{id\+Qubit3, }
\item[{const {\bf R\+E\+AL}}]{prob\+Of\+Filter}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a2d73fd11c1d154640dbf114da8f34c64}{}\label{qubits_8c_a2d73fd11c1d154640dbf114da8f34c64}


Updates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3} & specified qubits \\
\hline
\mbox{\tt in}  & {\em prob\+Of\+Filter} & Total probability that the 3 qubits are not all in the 1 state. \\
\hline
\end{DoxyParams}


Definition at line 1709 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, R\+E\+A\+L\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+F\+O\+R\+M\+AT, and Multi\+Qubit\+::state\+Vec.



Referenced by filter\+Out111().


\begin{DoxyCode}
1711 \{
1712         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
1713         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
1714         \textcolor{keywordtype}{int} bit1, bit2, bit3;
1715 
1716         \textcolor{comment}{// ---------------------------------------------------------------- //}
1717         \textcolor{comment}{//            tests                                                 //}
1718         \textcolor{comment}{// ---------------------------------------------------------------- //}
1719         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} && idQubit2 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1720 
1721         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1722 
1723         \textcolor{keywordflow}{if} ( probOfFilter<1e-16 )\{ printf(\textcolor{stringliteral}{"Extremely small or negative profOfFilter="}
      \hyperlink{precision_8h_ad751ac7ddc8ec19f23fb33083c0da8da}{REAL\_STRING\_FORMAT}\textcolor{stringliteral}{"; aborting! \(\backslash\)n"},probOfFilter); exit(1);\}
1724         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} myNorm=1/sqrt(probOfFilter);
1725         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1726         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1727 
1728 \textcolor{preprocessor}{# ifdef \_OPENMP}
1729 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1730 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
1731 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag, myNorm) \(\backslash\)}
1732 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3)                }
1733 \textcolor{preprocessor}{# endif }
1734         \{
1735 \textcolor{preprocessor}{# ifdef \_OPENMP}
1736 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1737 \textcolor{preprocessor}{# endif}
1738                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
1739                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
1740                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
1741                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index);
1742                         \textcolor{keywordflow}{if} ((bit1 && bit2 && bit3)) \{
1743                                 stateVecReal[index]=0;
1744                                 stateVecImag [index]=0;
1745                         \}\textcolor{keywordflow}{else}\{
1746                                 stateVecReal[index] *= myNorm;
1747                                 stateVecImag[index] *= myNorm;
1748                         \}
1749                 \}
1750         \}
1751 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}}
\index{find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{find\+Probability\+Of\+Zero\+Distributed(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit)}{findProbabilityOfZeroDistributed(MultiQubit multiQubit, const int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} find\+Probability\+Of\+Zero\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}{}\label{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}


Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. 

Size of regions to skip is a multiple of chunk\+Size.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 1319 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Outcome().


\begin{DoxyCode}
1321 \{
1322         \textcolor{comment}{// ----- measured probability}
1323         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
1324         \textcolor{comment}{// ----- temp variables}
1325         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1326         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1327         \textcolor{comment}{// (good for shared memory parallelism)}
1328 
1329         \textcolor{comment}{// ---------------------------------------------------------------- //}
1330         \textcolor{comment}{//            tests                                                 //}
1331         \textcolor{comment}{// ---------------------------------------------------------------- //}
1332         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1333 
1334         \textcolor{comment}{// ---------------------------------------------------------------- //}
1335         \textcolor{comment}{//            find probability                                      //}
1336         \textcolor{comment}{// ---------------------------------------------------------------- //}
1337 
1338         \textcolor{comment}{// initialise returned value}
1339         totalProbability = 0.0;
1340 
1341         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1342         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1343 
1344 \textcolor{preprocessor}{# ifdef \_OPENMP}
1345 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1346 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1347 \textcolor{preprocessor}{        private   (thisTask) \(\backslash\)}
1348 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
1349 \textcolor{preprocessor}{# endif}
1350         \{
1351 \textcolor{preprocessor}{# ifdef \_OPENMP}
1352 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1353 \textcolor{preprocessor}{# endif}
1354                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1355                         \textcolor{comment}{// summation -- simple implementation}
1356                         totalProbability += stateVecReal[thisTask]*stateVecReal[thisTask]
1357                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
1358 
1359                         \textcolor{comment}{/*}
1360 \textcolor{comment}{                        // summation -- kahan correction}
1361 \textcolor{comment}{                        y = stateVecReal[thisTask]*stateVecReal[thisTask]}
1362 \textcolor{comment}{                        + stateVecImag[thisTask]*stateVecImag[thisTask] - c;}
1363 \textcolor{comment}{                        t = totalProbability + y;}
1364 \textcolor{comment}{                        c = (t - totalProbability) - y;}
1365 \textcolor{comment}{                        totalProbability = t;}
1366 \textcolor{comment}{                        */}
1367 
1368                 \}
1369         \}
1370 
1371         \textcolor{keywordflow}{return} totalProbability;
1372 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}}
\index{find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{find\+Probability\+Of\+Zero\+Local(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit)}{findProbabilityOfZeroLocal(MultiQubit multiQubit, const int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} find\+Probability\+Of\+Zero\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}{}\label{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}


Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. 

Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 1240 of file qubits.\+c.



References D\+E\+B\+UG, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Outcome().


\begin{DoxyCode}
1242 \{
1243         \textcolor{comment}{// ----- sizes}
1244         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
1245         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
1246         \textcolor{comment}{// ----- indices}
1247         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
1248              index;                                               \textcolor{comment}{// current index for first half block}
1249         \textcolor{comment}{// ----- measured probability}
1250         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
1251         \textcolor{comment}{// ----- temp variables}
1252         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1253         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1254 
1255         \textcolor{comment}{// ---------------------------------------------------------------- //}
1256         \textcolor{comment}{//            tests                                                 //}
1257         \textcolor{comment}{// ---------------------------------------------------------------- //}
1258         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1259 
1260 
1261         \textcolor{comment}{// ---------------------------------------------------------------- //}
1262         \textcolor{comment}{//            dimensions                                            //}
1263         \textcolor{comment}{// ---------------------------------------------------------------- //}
1264         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
1265         \textcolor{comment}{// and then the number to skip}
1266         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
1267 
1268         \textcolor{comment}{// initialise returned value}
1269         totalProbability = 0.0;
1270 
1271         \textcolor{comment}{// initialise correction for kahan summation}
1272         \textcolor{keywordflow}{if} (\hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\(\backslash\)n"},sizeHalfBlock,sizeBlock,
      numTasks);
1273 
1274         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1275         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1276 
1277 \textcolor{preprocessor}{# ifdef \_OPENMP}
1278 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1279 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
1280 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index) \(\backslash\)}
1281 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
1282 \textcolor{preprocessor}{# endif }
1283         \{
1284 \textcolor{preprocessor}{# ifdef \_OPENMP}
1285 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1286 \textcolor{preprocessor}{# endif}
1287                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1288                         thisBlock = thisTask / sizeHalfBlock;
1289                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1290 
1291                         \textcolor{keywordflow}{if} (index<0)\{ printf(\textcolor{stringliteral}{"ABORTING as index=%Ld with thisBlock = %Ld  thisTask=%Ld \(\backslash\)n"},
       index,thisBlock,thisTask); exit(1);\}
1292 
1293                         \textcolor{comment}{// summation -- simple implementation}
1294                         totalProbability += stateVecReal[index]*stateVecReal[index]
1295                                 + stateVecImag[index]*stateVecImag[index];
1296 
1297                         \textcolor{comment}{/*}
1298 \textcolor{comment}{                        // summation -- kahan correction}
1299 \textcolor{comment}{                        y = stateVecReal[index]*stateVecReal[index]}
1300 \textcolor{comment}{                        + stateVecImag[index]*stateVecImag[index] - c;}
1301 \textcolor{comment}{                        t = totalProbability + y;}
1302 \textcolor{comment}{                        c = (t - totalProbability) - y;}
1303 \textcolor{comment}{                        totalProbability = t;}
1304 \textcolor{comment}{                        */}
1305 
1306                 \}
1307         \}
1308         \textcolor{keywordflow}{return} totalProbability;
1309 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!get\+Prob\+El@{get\+Prob\+El}}
\index{get\+Prob\+El@{get\+Prob\+El}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{get\+Prob\+El(\+Multi\+Qubit multi\+Qubit, long long int index)}{getProbEl(MultiQubit multiQubit, long long int index)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} get\+Prob\+El (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{long long int}]{index}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}{}\label{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}


Get probability of the state at an index in the state vector. 

Get the probability of the state at an index in the state vector.

For debugging purposes. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing a set of qubits \\
\hline
\mbox{\tt in}  & {\em index} & index in state vector of probability amplitudes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
real component $\ast$ real component + imag component $\ast$ imag component 
\end{DoxyReturn}


Definition at line 1805 of file qubits.\+c.



References get\+Imag\+Amp\+El(), get\+Real\+Amp\+El(), and R\+E\+AL.


\begin{DoxyCode}
1805                                                           \{
1806         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} real;
1807         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} imag;
1808         real = \hyperlink{qubits_8h_a317b786f577fa6bc136ea7f0ee7330a7}{getRealAmpEl}(multiQubit, index);
1809         imag = \hyperlink{qubits_8h_a3615f76fd5f57008d9b74bbd10533dd0}{getImagAmpEl}(multiQubit, index);
1810         \textcolor{keywordflow}{return} real*real + imag*imag;
1811 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!hadamard\+Distributed@{hadamard\+Distributed}}
\index{hadamard\+Distributed@{hadamard\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{hadamard\+Distributed(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out, int update\+Upper)}{hadamardDistributed(MultiQubit multiQubit, const int rotQubit, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut, int updateUpper)}}]{\setlength{\rightskip}{0pt plus 5cm}void hadamard\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out, }
\item[{int}]{update\+Upper}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_ac835c194bd547240a35f0b028db1d658}{}\label{qubits_8c_ac835c194bd547240a35f0b028db1d658}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt in}  & {\em update\+Upper} & flag, 1\+: updating upper values, 0\+: updating lower values in block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 1018 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and R\+E\+AL.



Referenced by hadamard().


\begin{DoxyCode}
1023 \{
1024 
1025         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1026         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
1027         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1028 
1029         \textcolor{comment}{// test qubit valid}
1030         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1031 
1032         \textcolor{keywordtype}{int} sign;
1033         \textcolor{keywordflow}{if} (updateUpper) sign=1;
1034         \textcolor{keywordflow}{else} sign=-1;
1035 
1036         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1037 
1038         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1039         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1040         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1041 
1042 \textcolor{preprocessor}{# ifdef \_OPENMP}
1043 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1044 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1045 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
1046 \textcolor{preprocessor}{                        recRoot2, sign) \(\backslash\)}
1047 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
1048 \textcolor{preprocessor}{# endif}
1049         \{
1050 \textcolor{preprocessor}{# ifdef \_OPENMP}
1051 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1052 \textcolor{preprocessor}{# endif}
1053                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1054                         \textcolor{comment}{// store current state vector values in temp variables}
1055                         stateRealUp = stateVecRealUp[thisTask];
1056                         stateImagUp = stateVecImagUp[thisTask];
1057 
1058                         stateRealLo = stateVecRealLo[thisTask];
1059                         stateImagLo = stateVecImagLo[thisTask];
1060 
1061                         stateVecRealOut[thisTask] = recRoot2*(stateRealUp + sign*stateRealLo);
1062                         stateVecImagOut[thisTask] = recRoot2*(stateImagUp + sign*stateImagLo);
1063                 \}
1064         \}
1065 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!hadamard\+Local@{hadamard\+Local}}
\index{hadamard\+Local@{hadamard\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{hadamard\+Local(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit)}{hadamardLocal(MultiQubit multiQubit, const int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void hadamard\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a0711416fceaf63c67b496e123e845c69}{}\label{qubits_8c_a0711416fceaf63c67b496e123e845c69}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}


Definition at line 950 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by hadamard().


\begin{DoxyCode}
951 \{
952         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
953         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
954              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
955 
956         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
957         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
958         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
959 
960         \textcolor{comment}{// test qubit valid}
961         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
962 
963         \textcolor{comment}{// set dimensions}
964         sizeHalfBlock = 1LL << rotQubit;  
965         sizeBlock     = 2LL * sizeHalfBlock; 
966 
967         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
968         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
969         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
970 
971         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
972 
973 \textcolor{preprocessor}{# ifdef \_OPENMP}
974 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
975 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
976 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \(\backslash\)}
977 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
978 \textcolor{preprocessor}{# endif}
979         \{
980 \textcolor{preprocessor}{# ifdef \_OPENMP}
981 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
982 \textcolor{preprocessor}{# endif}
983                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
984                         thisBlock   = thisTask / sizeHalfBlock;
985                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
986                         indexLo     = indexUp + sizeHalfBlock;
987 
988                         stateRealUp = stateVecReal[indexUp];
989                         stateImagUp = stateVecImag[indexUp];
990 
991                         stateRealLo = stateVecReal[indexLo];
992                         stateImagLo = stateVecImag[indexLo];
993 
994                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateRealLo);
995                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImagLo);
996 
997                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateRealLo);
998                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImagLo);
999                 \} 
1000         \}
1001 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!initialize\+State\+From\+Single\+File@{initialize\+State\+From\+Single\+File}}
\index{initialize\+State\+From\+Single\+File@{initialize\+State\+From\+Single\+File}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{initialize\+State\+From\+Single\+File(\+Multi\+Qubit $\ast$multi\+Qubit, char filename[200])}{initializeStateFromSingleFile(MultiQubit *multiQubit, char filename[200])}}]{\setlength{\rightskip}{0pt plus 5cm}void initialize\+State\+From\+Single\+File (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit} $\ast$}]{multi\+Qubit, }
\item[{char}]{filename\mbox{[}200\mbox{]}}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a9c8dad2ac76ac04b74caa059b399d576}{}\label{qubits_8c_a9c8dad2ac76ac04b74caa059b399d576}
fix -- need to add M\+PI version

fix -- format needs to work for single precision values 

Definition at line 267 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Chunks, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by test\+\_\+control\+Not(), test\+\_\+control\+Phase\+Gate(), test\+\_\+hadamard(), test\+\_\+init\+State\+Plus(), test\+\_\+init\+State\+Zero(), test\+\_\+s\+Gate(), test\+\_\+sigma\+X(), test\+\_\+sigma\+Y(), test\+\_\+sigma\+Z(), and test\+\_\+t\+Gate().


\begin{DoxyCode}
267                                                                               \{
268         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize, stateVecSize;
269         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
270 
271         chunkSize = multiQubit->\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
272         stateVecSize = chunkSize*multiQubit->\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks};
273 
274         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
275         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
277         
278         FILE *fp;
279 
280         \textcolor{keywordtype}{char} line[200];
281         fp = fopen(filename, \textcolor{stringliteral}{"r"});
282         index = 0;
283         \textcolor{keywordflow}{while} (fgets(line, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})*200, fp) != NULL && index<stateVecSize)\{
284                 \textcolor{keywordflow}{if} (line[0]!=\textcolor{charliteral}{'#'})\{
286                         sscanf(line, \textcolor{stringliteral}{"%lf, %lf"}, &(stateVecReal[index]), &(stateVecImag[index]));
287                         index += 1;
288                 \}
289         \}       
290         fclose(fp);
291 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!init\+State\+Debug@{init\+State\+Debug}}
\index{init\+State\+Debug@{init\+State\+Debug}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{init\+State\+Debug(\+Multi\+Qubit $\ast$multi\+Qubit)}{initStateDebug(MultiQubit *multiQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void init\+State\+Debug (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit} $\ast$}]{multi\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}{}\label{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}


Initialise the state vector of probability amplitudes to an (unphysical) state with each component of each probability amplitude a unique floating point value. 

For debugging processes 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits to be initialised \\
\hline
\end{DoxyParams}


Definition at line 233 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, D\+E\+B\+UG, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Chunks, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by main(), test\+\_\+control\+Not(), test\+\_\+control\+Phase\+Gate(), test\+\_\+hadamard(), test\+\_\+s\+Gate(), test\+\_\+sigma\+X(), test\+\_\+sigma\+Y(), test\+\_\+sigma\+Z(), and test\+\_\+t\+Gate().


\begin{DoxyCode}
234 \{
235         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize, stateVecSize;
236         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
237 
238         \textcolor{comment}{// dimension of the state vector}
239         chunkSize = multiQubit->\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
240         stateVecSize = chunkSize*multiQubit->\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks};
241 
242         \textcolor{comment}{// Can't use multiQubit->stateVec as a private OMP var}
243         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
244         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
245 
246         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} chunkOffset = (2.0*chunkSize*multiQubit->\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId})/10.0;
247 
248         \textcolor{comment}{// initialise the state to |0000..0000>}
249 \textcolor{preprocessor}{# ifdef \_OPENMP}
250 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
251 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
252 \textcolor{preprocessor}{        shared   (chunkSize, stateVecReal, stateVecImag, chunkOffset) \(\backslash\)}
253 \textcolor{preprocessor}{        private  (index) }
254 \textcolor{preprocessor}{# endif}
255         \{
256 \textcolor{preprocessor}{# ifdef \_OPENMP}
257 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
258 \textcolor{preprocessor}{# endif}
259                 \textcolor{keywordflow}{for} (index=0; index<chunkSize; index++) \{
260                         stateVecReal[index] = chunkOffset + (index*2.0)/10.0;
261                         stateVecImag[index] = chunkOffset + (index*2.0+1.0)/10.0;
262                 \}
263         \}
264         \textcolor{keywordflow}{if} (\hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"COMPLETED INIT\(\backslash\)n"});
265 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!init\+State\+Plus@{init\+State\+Plus}}
\index{init\+State\+Plus@{init\+State\+Plus}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{init\+State\+Plus(\+Multi\+Qubit $\ast$multi\+Qubit)}{initStatePlus(MultiQubit *multiQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void init\+State\+Plus (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit} $\ast$}]{multi\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}{}\label{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}


Initialise the state vector of probability amplitudes for a set of qubits to an equal real superposition of all amplitudes\+: $\vert$+++...++$>$ 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits to be initialised \\
\hline
\end{DoxyParams}


Definition at line 195 of file qubits.\+c.



References D\+E\+B\+UG, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Chunks, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by main(), and test\+\_\+init\+State\+Plus().


\begin{DoxyCode}
196 \{
197         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize, stateVecSize;
198         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
199 
200         \textcolor{comment}{// dimension of the state vector}
201         chunkSize = multiQubit->\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
202         stateVecSize = chunkSize*multiQubit->\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks};
203         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} normFactor = 1.0/sqrt(stateVecSize);
204 
205         \textcolor{comment}{// Can't use multiQubit->stateVec as a private OMP var}
206         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
207         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
208 
209         \textcolor{comment}{// initialise the state to |0000..0000>}
210 \textcolor{preprocessor}{# ifdef \_OPENMP}
211 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
212 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
213 \textcolor{preprocessor}{        shared   (chunkSize, stateVecReal, stateVecImag, normFactor) \(\backslash\)}
214 \textcolor{preprocessor}{        private  (index) }
215 \textcolor{preprocessor}{# endif}
216         \{
217 \textcolor{preprocessor}{# ifdef \_OPENMP}
218 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
219 \textcolor{preprocessor}{# endif}
220                 \textcolor{keywordflow}{for} (index=0; index<chunkSize; index++) \{
221                         stateVecReal[index] = normFactor;
222                         stateVecImag[index] = 0.0;
223                 \}
224         \}
225         \textcolor{keywordflow}{if} (\hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"COMPLETED INIT\(\backslash\)n"});
226 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!init\+State\+Zero@{init\+State\+Zero}}
\index{init\+State\+Zero@{init\+State\+Zero}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{init\+State\+Zero(\+Multi\+Qubit $\ast$multi\+Qubit)}{initStateZero(MultiQubit *multiQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void init\+State\+Zero (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit} $\ast$}]{multi\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_acb5b2eff794339090004d29f02a70d9a}{}\label{qubits_8c_acb5b2eff794339090004d29f02a70d9a}


Initialise the state vector of probability amplitudes for a set of qubits to the zero state\+: $\vert$000...00$>$ 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits to be initialised \\
\hline
\end{DoxyParams}


Definition at line 153 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, D\+E\+B\+UG, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by main(), and test\+\_\+init\+State\+Zero().


\begin{DoxyCode}
154 \{
155         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
156         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
157 
158         \textcolor{comment}{// dimension of the state vector}
159         stateVecSize = multiQubit->\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
160 
161         \textcolor{comment}{// Can't use multiQubit->stateVec as a private OMP var}
162         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
163         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
164 
165         \textcolor{comment}{// initialise the state to |0000..0000>}
166 \textcolor{preprocessor}{# ifdef \_OPENMP}
167 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
168 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
169 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal, stateVecImag) \(\backslash\)}
170 \textcolor{preprocessor}{        private  (index) }
171 \textcolor{preprocessor}{# endif}
172         \{
173 \textcolor{preprocessor}{# ifdef \_OPENMP}
174 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
175 \textcolor{preprocessor}{# endif}
176                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
177                         stateVecReal[index] = 0.0;
178                         stateVecImag[index] = 0.0;
179                 \}
180         \}
181 
182         \textcolor{keywordflow}{if} (multiQubit->\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}==0)\{
183                 \textcolor{comment}{// zero state |0000..0000> has probability 1}
184                 stateVecReal[0] = 1.0;
185                 stateVecImag[0] = 0.0;
186         \}
187 
188         \textcolor{keywordflow}{if} (\hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"COMPLETED INIT\(\backslash\)n"});
189 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!measure\+In\+State\+Distributed\+Renorm@{measure\+In\+State\+Distributed\+Renorm}}
\index{measure\+In\+State\+Distributed\+Renorm@{measure\+In\+State\+Distributed\+Renorm}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{measure\+In\+State\+Distributed\+Renorm(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit, const R\+E\+A\+L total\+Probability)}{measureInStateDistributedRenorm(MultiQubit multiQubit, const int measureQubit, const REAL totalProbability)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} measure\+In\+State\+Distributed\+Renorm (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit, }
\item[{const {\bf R\+E\+AL}}]{total\+Probability}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a35e5ac30c8427c482a97b33a4e295535}{}\label{qubits_8c_a35e5ac30c8427c482a97b33a4e295535}


Renormalise parts of the state vector where measure\+Qubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that the value \textquotesingle{}outcome\textquotesingle{} has been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. In the distributed version, one block (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em total\+Probability} & probability of qubit measure\+Qubit being zero \\
\hline
\end{DoxyParams}


Definition at line 1620 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+State().


\begin{DoxyCode}
1621 \{
1622         \textcolor{comment}{// ----- temp variables}
1623         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1624         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1625         \textcolor{comment}{// (good for shared memory parallelism)}
1626 
1627         \textcolor{comment}{// ---------------------------------------------------------------- //}
1628         \textcolor{comment}{//            tests                                                 //}
1629         \textcolor{comment}{// ---------------------------------------------------------------- //}
1630         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1631 
1632         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} renorm=1/sqrt(totalProbability);
1633         
1634         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1635         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1636 
1637 \textcolor{preprocessor}{# ifdef \_OPENMP}
1638 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1639 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1640 \textcolor{preprocessor}{        private   (thisTask)}
1641 \textcolor{preprocessor}{# endif}
1642         \{
1643 \textcolor{preprocessor}{# ifdef \_OPENMP}
1644 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1645 \textcolor{preprocessor}{# endif}
1646                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1647                         \textcolor{comment}{// summation -- simple implementation}
1648                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
1649                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
1650                 \}
1651         \}
1652         \textcolor{keywordflow}{return} totalProbability;
1653 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!measure\+In\+State\+Distributed\+Set\+Zero@{measure\+In\+State\+Distributed\+Set\+Zero}}
\index{measure\+In\+State\+Distributed\+Set\+Zero@{measure\+In\+State\+Distributed\+Set\+Zero}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{measure\+In\+State\+Distributed\+Set\+Zero(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit)}{measureInStateDistributedSetZero(MultiQubit multiQubit, const int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void measure\+In\+State\+Distributed\+Set\+Zero (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_ac39efc9ed939382276ebd0c15dd6a0fa}{}\label{qubits_8c_ac39efc9ed939382276ebd0c15dd6a0fa}


Set all amplitudes in one chunk to 0. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that a zero have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 or 1. In the distributed version, one block (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}


Definition at line 1668 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+State().


\begin{DoxyCode}
1669 \{
1670         \textcolor{comment}{// ----- temp variables}
1671         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1672         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1673         \textcolor{comment}{// (good for shared memory parallelism)}
1674 
1675         \textcolor{comment}{// ---------------------------------------------------------------- //}
1676         \textcolor{comment}{//            tests                                                 //}
1677         \textcolor{comment}{// ---------------------------------------------------------------- //}
1678         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1679 
1680         \textcolor{comment}{// ---------------------------------------------------------------- //}
1681         \textcolor{comment}{//            find probability                                      //}
1682         \textcolor{comment}{// ---------------------------------------------------------------- //}
1683 
1684         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1685         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1686 
1687 \textcolor{preprocessor}{# ifdef \_OPENMP}
1688 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1689 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1690 \textcolor{preprocessor}{        private   (thisTask)}
1691 \textcolor{preprocessor}{# endif}
1692         \{
1693 \textcolor{preprocessor}{# ifdef \_OPENMP}
1694 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1695 \textcolor{preprocessor}{# endif}
1696                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1697                         \textcolor{comment}{// summation -- simple implementation}
1698                         stateVecReal[thisTask] = 0;
1699                         stateVecImag[thisTask] = 0;
1700                 \}
1701         \}
1702 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!measure\+In\+State\+Local@{measure\+In\+State\+Local}}
\index{measure\+In\+State\+Local@{measure\+In\+State\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{measure\+In\+State\+Local(\+Multi\+Qubit multi\+Qubit, int measure\+Qubit, R\+E\+A\+L total\+Probability, int outcome)}{measureInStateLocal(MultiQubit multiQubit, int measureQubit, REAL totalProbability, int outcome)}}]{\setlength{\rightskip}{0pt plus 5cm}void measure\+In\+State\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{int}]{measure\+Qubit, }
\item[{{\bf R\+E\+AL}}]{total\+Probability, }
\item[{int}]{outcome}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a53614ce19e0a4f2c41b400cf05dc5bd1}{}\label{qubits_8c_a53614ce19e0a4f2c41b400cf05dc5bd1}


Update the state vector to be consistent with measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. 

Performs an irreversible change to the state vector\+: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em total\+Probability} & probability of qubit measure\+Qubit being either zero or one \\
\hline
\mbox{\tt in}  & {\em outcome} & to measure the probability of and set the state to -- either zero or one \\
\hline
\end{DoxyParams}


Definition at line 1532 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+State().


\begin{DoxyCode}
1533 \{
1534         \textcolor{comment}{// ----- sizes}
1535         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
1536         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
1537         \textcolor{comment}{// ----- indices}
1538         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
1539              index;                                               \textcolor{comment}{// current index for first half block}
1540         \textcolor{comment}{// ----- measured probability}
1541         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   renorm;                                    \textcolor{comment}{// probability (returned) value}
1542         \textcolor{comment}{// ----- temp variables}
1543         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1544         \textcolor{comment}{// (good for shared memory parallelism)}
1545         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1546 
1547         \textcolor{comment}{// ---------------------------------------------------------------- //}
1548         \textcolor{comment}{//            tests                                                 //}
1549         \textcolor{comment}{// ---------------------------------------------------------------- //}
1550         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1551 
1552         \textcolor{comment}{// ---------------------------------------------------------------- //}
1553         \textcolor{comment}{//            dimensions                                            //}
1554         \textcolor{comment}{// ---------------------------------------------------------------- //}
1555         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
1556         \textcolor{comment}{// and then the number to skip}
1557         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
1558         
1559         renorm=1/sqrt(totalProbability);
1560         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1561         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1562 
1563 
1564 \textcolor{preprocessor}{# ifdef \_OPENMP}
1565 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1566 \textcolor{preprocessor}{        default (none) \(\backslash\)}
1567 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,renorm,outcome) \(\backslash\)}
1568 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index)}
1569 \textcolor{preprocessor}{# endif}
1570         \{
1571                 \textcolor{keywordflow}{if} (outcome==0)\{
1572                         \textcolor{comment}{// measure qubit is 0}
1573 \textcolor{preprocessor}{# ifdef \_OPENMP}
1574 \textcolor{preprocessor}{                        # pragma omp for schedule  (static)}
1575 \textcolor{preprocessor}{# endif}
1576                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1577                                 thisBlock = thisTask / sizeHalfBlock;
1578                                 index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1579                                 stateVecReal[index]=stateVecReal[index]*renorm;
1580                                 stateVecImag[index]=stateVecImag[index]*renorm;
1581 
1582                                 stateVecReal[index+sizeHalfBlock]=0;
1583                                 stateVecImag[index+sizeHalfBlock]=0;
1584                         \}
1585                 \} \textcolor{keywordflow}{else} \{
1586                         \textcolor{comment}{// measure qubit is 1}
1587 \textcolor{preprocessor}{# ifdef \_OPENMP}
1588 \textcolor{preprocessor}{                        # pragma omp for schedule  (static)}
1589 \textcolor{preprocessor}{# endif}
1590                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1591                                 thisBlock = thisTask / sizeHalfBlock;
1592                                 index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1593                                 stateVecReal[index]=0;
1594                                 stateVecImag[index]=0;
1595 
1596                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[index+sizeHalfBlock]*renorm;
1597                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[index+sizeHalfBlock]*renorm;
1598                         \}
1599                 \}
1600         \}
1601 
1602 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!phase\+Gate\+Distributed@{phase\+Gate\+Distributed}}
\index{phase\+Gate\+Distributed@{phase\+Gate\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{phase\+Gate\+Distributed(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, enum phase\+Gate\+Type type)}{phaseGateDistributed(MultiQubit multiQubit, const int rotQubit, enum phaseGateType type)}}]{\setlength{\rightskip}{0pt plus 5cm}void phase\+Gate\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{enum {\bf phase\+Gate\+Type}}]{type}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a38a05c7e749e806b182ef3b89878bfc4}{}\label{qubits_8c_a38a05c7e749e806b182ef3b89878bfc4}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em type} & the type of phase gate to apply -- one of \{S\+I\+G\+M\+A\+\_\+Z, S\+\_\+\+G\+A\+TE, T\+\_\+\+G\+A\+TE\} \\
\hline
\end{DoxyParams}


Definition at line 1160 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, S\+\_\+\+G\+A\+TE, S\+I\+G\+M\+A\+\_\+Z, Multi\+Qubit\+::state\+Vec, and T\+\_\+\+G\+A\+TE.



Referenced by phase\+Gate().


\begin{DoxyCode}
1161 \{
1162         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealLo,stateImagLo;
1163         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1164         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1165 
1166         \textcolor{comment}{// test qubit valid}
1167         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1168 
1169         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1170         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1171         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1172 
1173         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1174 
1175 \textcolor{preprocessor}{# ifdef \_OPENMP}
1176 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1177 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1178 \textcolor{preprocessor}{        shared   (stateVecReal,stateVecImag, recRoot2, type) \(\backslash\)}
1179 \textcolor{preprocessor}{        private  (thisTask,stateRealLo,stateImagLo) }
1180 \textcolor{preprocessor}{# endif}
1181         \{
1182                 \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{SIGMA\_Z})\{
1183 \textcolor{preprocessor}{# ifdef \_OPENMP}
1184 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1185 \textcolor{preprocessor}{# endif}
1186                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1187                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
1188                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
1189                         \} 
1190                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{S\_GATE})\{
1191 \textcolor{preprocessor}{# ifdef \_OPENMP}
1192 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1193 \textcolor{preprocessor}{# endif}
1194                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1195                                 stateRealLo = stateVecReal[thisTask];
1196                                 stateImagLo = stateVecImag[thisTask];
1197 
1198                                 stateVecReal[thisTask] = -stateImagLo;
1199                                 stateVecImag[thisTask] = stateRealLo;
1200                         \} 
1201                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{T\_GATE})\{
1202 \textcolor{preprocessor}{# ifdef \_OPENMP}
1203 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1204 \textcolor{preprocessor}{# endif}
1205                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1206                                 stateRealLo = stateVecReal[thisTask];
1207                                 stateImagLo = stateVecImag[thisTask];
1208 
1209                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo - stateImagLo);
1210                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo + stateImagLo);
1211                         \} 
1212                 \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"Type %d is an invalid phase gate\(\backslash\)n"}, type);
1213         \}
1214 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!phase\+Gate\+Local@{phase\+Gate\+Local}}
\index{phase\+Gate\+Local@{phase\+Gate\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{phase\+Gate\+Local(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, enum phase\+Gate\+Type type)}{phaseGateLocal(MultiQubit multiQubit, const int rotQubit, enum phaseGateType type)}}]{\setlength{\rightskip}{0pt plus 5cm}void phase\+Gate\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{enum {\bf phase\+Gate\+Type}}]{type}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a6a736aeb3532898019fe7c27010edc6a}{}\label{qubits_8c_a6a736aeb3532898019fe7c27010edc6a}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em type} & the type of phase gate to apply -- one of \{S\+I\+G\+M\+A\+\_\+Z, S\+\_\+\+G\+A\+TE, T\+\_\+\+G\+A\+TE\} \\
\hline
\end{DoxyParams}
fix -- can i rewrite this to not use mod?

fix -- can i rewrite this to not use mod?

fix -- can i rewrite this to not use mod? 

Definition at line 1074 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, S\+\_\+\+G\+A\+TE, S\+I\+G\+M\+A\+\_\+Z, Multi\+Qubit\+::state\+Vec, and T\+\_\+\+G\+A\+TE.



Referenced by phase\+Gate().


\begin{DoxyCode}
1075 \{
1076         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
1077         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
1078              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
1079 
1080         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealLo,stateImagLo;
1081         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1082         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1083 
1084         \textcolor{comment}{// test qubit valid}
1085         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1086 
1087         \textcolor{comment}{// set dimensions}
1088         sizeHalfBlock = 1LL << rotQubit;  
1089         sizeBlock     = 2LL * sizeHalfBlock; 
1090 
1091         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1092         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1093         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1094 
1095         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1096 
1097 \textcolor{preprocessor}{# ifdef \_OPENMP}
1098 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1099 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1100 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type) \(\backslash\)}
1101 \textcolor{preprocessor}{        private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) }
1102 \textcolor{preprocessor}{# endif}
1103         \{
1104                 \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{SIGMA\_Z})\{
1105 \textcolor{preprocessor}{# ifdef \_OPENMP}
1106 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1107 \textcolor{preprocessor}{# endif}
1108                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1110                                 thisBlock   = thisTask / sizeHalfBlock;
1111                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1112                                 indexLo     = indexUp + sizeHalfBlock;
1113 
1114                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
1115                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
1116                         \} 
1117                 \} 
1118                 
1119                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{S\_GATE})\{
1120 \textcolor{preprocessor}{# ifdef \_OPENMP}
1121 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1122 \textcolor{preprocessor}{# endif}
1123                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1125                                 thisBlock   = thisTask / sizeHalfBlock;
1126                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1127                                 indexLo     = indexUp + sizeHalfBlock;
1128                                 stateRealLo = stateVecReal[indexLo];
1129                                 stateImagLo = stateVecImag[indexLo];
1130 
1131                                 stateVecReal[indexLo] = -stateImagLo;
1132                                 stateVecImag[indexLo] = stateRealLo;
1133                         \} 
1134                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{T\_GATE})\{
1135 \textcolor{preprocessor}{# ifdef \_OPENMP}
1136 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1137 \textcolor{preprocessor}{# endif}
1138                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1140                                 thisBlock   = thisTask / sizeHalfBlock;
1141                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1142                                 indexLo     = indexUp + sizeHalfBlock;
1143                                 stateRealLo = stateVecReal[indexLo];
1144                                 stateImagLo = stateVecImag[indexLo];
1145 
1146                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo - stateImagLo);
1147                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo + stateImagLo);
1148                         \} 
1149                 \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"Type %d is an invalid phase gate\(\backslash\)n"}, type);
1150         \}
1151 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!prob\+Of\+Filter\+Out111\+Local@{prob\+Of\+Filter\+Out111\+Local}}
\index{prob\+Of\+Filter\+Out111\+Local@{prob\+Of\+Filter\+Out111\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{prob\+Of\+Filter\+Out111\+Local(\+Multi\+Qubit multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3)}{probOfFilterOut111Local(MultiQubit multiQubit, const int idQubit1, const int idQubit2, const int idQubit3)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} prob\+Of\+Filter\+Out111\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{id\+Qubit1, }
\item[{const int}]{id\+Qubit2, }
\item[{const int}]{id\+Qubit3}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a096cddbac961f0651a084d2ceb905d1b}{}\label{qubits_8c_a096cddbac961f0651a084d2ceb905d1b}


Evaluates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. 

The function returns the probability of this outcome across all amplitudes in this chunk (if zero, it will exit with error) 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3} & specified qubits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Total probability that the 3 qubits are not all in the 1 state. 
\end{DoxyReturn}


Definition at line 1759 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by prob\+Of\+Filter\+Out111().


\begin{DoxyCode}
1760 \{
1761         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
1762         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
1763         \textcolor{keywordtype}{int} bit1, bit2, bit3;
1764 
1765         \textcolor{comment}{// ---------------------------------------------------------------- //}
1766         \textcolor{comment}{//            tests                                                 //}
1767         \textcolor{comment}{// ---------------------------------------------------------------- //}
1768         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} && idQubit2 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1769 
1770         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1771         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} probOfFilter=0;
1772         
1773         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1774         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1775 
1776 \textcolor{preprocessor}{# ifdef \_OPENMP}
1777 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1778 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
1779 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag) \(\backslash\)}
1780 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3)                \(\backslash\)}
1781 \textcolor{preprocessor}{        reduction ( +:probOfFilter )}
1782 \textcolor{preprocessor}{# endif}
1783         \{
1784 \textcolor{preprocessor}{# ifdef \_OPENMP}
1785 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1786 \textcolor{preprocessor}{# endif}
1787                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
1788                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
1789                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
1790                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index);
1791                         \textcolor{keywordflow}{if} (!(bit1 && bit2 && bit3)) \{
1792                                 probOfFilter+= stateVecReal[index]*stateVecReal[index] + stateVecImag[index
      ]* stateVecImag [index];
1793                         \}
1794                 \}
1795         \}
1796         \textcolor{keywordflow}{return} probOfFilter;
1797 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!quad\+C\+Phase\+Gate@{quad\+C\+Phase\+Gate}}
\index{quad\+C\+Phase\+Gate@{quad\+C\+Phase\+Gate}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{quad\+C\+Phase\+Gate(\+Multi\+Qubit multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3, const int id\+Qubit4)}{quadCPhaseGate(MultiQubit multiQubit, const int idQubit1, const int idQubit2, const int idQubit3, const int idQubit4)}}]{\setlength{\rightskip}{0pt plus 5cm}void quad\+C\+Phase\+Gate (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{id\+Qubit1, }
\item[{const int}]{id\+Qubit2, }
\item[{const int}]{id\+Qubit3, }
\item[{const int}]{id\+Qubit4}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_aca7765bd500718f98700a172351748cc}{}\label{qubits_8c_aca7765bd500718f98700a172351748cc}


The control not gate. 

The control phase (the four qubit phase gate). For each state, if all four input qubits are equal to one, multiply the amplitude of that state by -\/1. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3,id\+Qubit4} & specified qubits \\
\hline
\end{DoxyParams}


Definition at line 1478 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by main().


\begin{DoxyCode}
1480 \{
1481         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
1482         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
1483         \textcolor{keywordtype}{int} bit1, bit2, bit3, bit4;
1484 
1485         \textcolor{comment}{// ---------------------------------------------------------------- //}
1486         \textcolor{comment}{//            tests                                                 //}
1487         \textcolor{comment}{// ---------------------------------------------------------------- //}
1488         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} && idQubit2 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1489 
1490         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1491         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1492         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1493 
1494 \textcolor{preprocessor}{# ifdef \_OPENMP}
1495 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1496 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
1497 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag ) \(\backslash\)}
1498 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3,bit4)}
1499 \textcolor{preprocessor}{# endif}
1500         \{
1501 \textcolor{preprocessor}{# ifdef \_OPENMP}
1502 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1503 \textcolor{preprocessor}{# endif}
1504                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
1505                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
1506                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
1507                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index);
1508                         bit4 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit4, index);
1509                         \textcolor{keywordflow}{if} (bit1 && bit2 && bit3 && bit4) \{
1510                                 stateVecReal [index] = - stateVecReal [index];
1511                                 stateVecImag [index] = - stateVecImag [index];
1512                         \}
1513                 \}
1514         \}
1515 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!report\+Multi\+Qubit\+Params@{report\+Multi\+Qubit\+Params}}
\index{report\+Multi\+Qubit\+Params@{report\+Multi\+Qubit\+Params}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{report\+Multi\+Qubit\+Params(\+Multi\+Qubit multi\+Qubit)}{reportMultiQubitParams(MultiQubit multiQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+Multi\+Qubit\+Params (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}{}\label{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}


Report metainformation about a set of qubits\+: number of qubits, number of probability amplitudes. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em env} & object representing the execution environment (local, multinode etc) \\
\hline
\end{DoxyParams}


Definition at line 138 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Multi\+Qubit\+::num\+Chunks, and Multi\+Qubit\+::num\+Qubits.



Referenced by main().


\begin{DoxyCode}
138                                                   \{
139         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numAmps = 1L << multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits};
140         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numAmpsPerRank = numAmps/multiQubit.\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks};
141         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}==0)\{
142                 printf(\textcolor{stringliteral}{"QUBITS:\(\backslash\)n"});
143                 printf(\textcolor{stringliteral}{"Number of qubits is %d.\(\backslash\)n"}, multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
144                 printf(\textcolor{stringliteral}{"Number of amps is %lld.\(\backslash\)n"}, numAmps);
145                 printf(\textcolor{stringliteral}{"Number of amps per rank is %lld.\(\backslash\)n"}, numAmpsPerRank);
146         \}
147 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!report\+State@{report\+State}}
\index{report\+State@{report\+State}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{report\+State(\+Multi\+Qubit multi\+Qubit)}{reportState(MultiQubit multiQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+State (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}{}\label{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}


Print the current state vector of probability amplitudes for a set of qubits to file. 

File format\+: \begin{DoxyVerb}real, imag
realComponent1, imagComponent1
realComponent2, imagComponent2
...
realComponentN, imagComponentN
\end{DoxyVerb}


File naming convention\+:

For each node that the program runs on, a file \textquotesingle{}state\+\_\+rank\+\_\+\mbox{[}node\+\_\+rank\mbox{]}.csv\textquotesingle{} is generated. If there is more than one node, ranks after the first do not include the header \begin{DoxyVerb}real, imag
\end{DoxyVerb}
 so that files are easier to combine. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\end{DoxyParams}


Definition at line 92 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+A\+L\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+F\+O\+R\+M\+AT, and Multi\+Qubit\+::state\+Vec.



Referenced by main().


\begin{DoxyCode}
92                                        \{
93         FILE *state;
94         \textcolor{keywordtype}{char} filename[100];
95         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
96         sprintf(filename, \textcolor{stringliteral}{"state\_rank\_%d.csv"}, multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId});
97         state = fopen(filename, \textcolor{stringliteral}{"w"});
98         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}==0) fprintf(state, \textcolor{stringliteral}{"real, imag\(\backslash\)n"});
99 
100         \textcolor{keywordflow}{for}(index=0; index<multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}; index++)\{
101                 fprintf(state, \hyperlink{precision_8h_ad751ac7ddc8ec19f23fb33083c0da8da}{REAL\_STRING\_FORMAT} \textcolor{stringliteral}{","} 
      \hyperlink{precision_8h_ad751ac7ddc8ec19f23fb33083c0da8da}{REAL\_STRING\_FORMAT} \textcolor{stringliteral}{"\(\backslash\)n"}, multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[index], multiQubit.
      \hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[index]);
102         \}
103         fclose(state);
104 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!report\+State\+To\+Screen@{report\+State\+To\+Screen}}
\index{report\+State\+To\+Screen@{report\+State\+To\+Screen}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{report\+State\+To\+Screen(\+Multi\+Qubit multi\+Qubit, Qu\+E\+S\+T\+Env env, int report\+Rank)}{reportStateToScreen(MultiQubit multiQubit, QuESTEnv env, int reportRank)}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+State\+To\+Screen (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{{\bf Qu\+E\+S\+T\+Env}}]{env, }
\item[{int}]{report\+Rank}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a842d6884e063a5865a2232cba56b65ac}{}\label{qubits_8c_a842d6884e063a5865a2232cba56b65ac}


Print the current state vector of probability amplitudes for a set of qubits to standard out. 

For debugging purposes. Each rank should print output serially. Only print output for systems $<$= 5 qubits 

Definition at line 109 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Chunks, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+A\+L\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+F\+O\+R\+M\+AT, Multi\+Qubit\+::state\+Vec, and sync\+Qu\+E\+S\+T\+Env().



Referenced by main(), and report\+Test().


\begin{DoxyCode}
109                                                                              \{
110         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
111         \textcolor{keywordtype}{int} rank;
112         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}<=5)\{
113                 \textcolor{keywordflow}{for} (rank=0; rank<multiQubit.\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks}; rank++)\{
114                         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}==rank)\{
115                                 \textcolor{keywordflow}{if} (reportRank) \{
116                                         printf(\textcolor{stringliteral}{"Reporting state from rank %d [\(\backslash\)n"}, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId});
117                                         \textcolor{comment}{//printf("\(\backslash\)trank, index, real, imag\(\backslash\)n");}
118                                         printf(\textcolor{stringliteral}{"real, imag\(\backslash\)n"});
119                                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rank==0) \{
120                                         printf(\textcolor{stringliteral}{"Reporting state [\(\backslash\)n"});
121                                         printf(\textcolor{stringliteral}{"real, imag\(\backslash\)n"});
122                                 \}
123 
124                                 \textcolor{keywordflow}{for}(index=0; index<multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}; index++)\{
125                                         printf(\hyperlink{precision_8h_ad751ac7ddc8ec19f23fb33083c0da8da}{REAL\_STRING\_FORMAT} \textcolor{stringliteral}{", "} 
      \hyperlink{precision_8h_ad751ac7ddc8ec19f23fb33083c0da8da}{REAL\_STRING\_FORMAT} \textcolor{stringliteral}{"\(\backslash\)n"}, multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[index], multiQubit.
      \hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[index]);
126                                 \}
127                                 \textcolor{keywordflow}{if} (reportRank || rank==multiQubit.\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks}-1) printf(\textcolor{stringliteral}{"]\(\backslash\)n"});
128                         \}
129                         \hyperlink{qubits_8h_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{syncQuESTEnv}(env);
130                 \}
131         \}
132 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!rotate\+Qubit\+Distributed@{rotate\+Qubit\+Distributed}}
\index{rotate\+Qubit\+Distributed@{rotate\+Qubit\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{rotate\+Qubit\+Distributed(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, Complex rot1, Complex rot2, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out)}{rotateQubitDistributed(MultiQubit multiQubit, const int rotQubit, Complex rot1, Complex rot2, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void rotate\+Qubit\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf Complex}}]{rot1, }
\item[{{\bf Complex}}]{rot2, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a6ff67d25363f39fd57a4e76621a4bfd5}{}\label{qubits_8c_a6ff67d25363f39fd57a4e76621a4bfd5}


Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 400 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Complex\+::real.



Referenced by rotate\+Qubit().


\begin{DoxyCode}
405 \{
406 
407         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
408         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
409         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
410 
411         \textcolor{comment}{// test qubit valid}
412         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
413 
414         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
415         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
416         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
417         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
418         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
419 
420 \textcolor{preprocessor}{# ifdef \_OPENMP}
421 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
422 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
423 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
424 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag) \(\backslash\)}
425 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
426 \textcolor{preprocessor}{# endif}
427         \{
428 \textcolor{preprocessor}{# ifdef \_OPENMP}
429 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
430 \textcolor{preprocessor}{# endif}
431                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
432                         \textcolor{comment}{// store current state vector values in temp variables}
433                         stateRealUp = stateVecRealUp[thisTask];
434                         stateImagUp = stateVecImagUp[thisTask];
435 
436                         stateRealLo = stateVecRealLo[thisTask];
437                         stateImagLo = stateVecImagLo[thisTask];
438 
439                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
440                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp + rot2Real*
      stateRealLo + rot2Imag*stateImagLo;
441                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp + rot2Real*
      stateImagLo - rot2Imag*stateRealLo;
442                 \}
443         \}
444 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!rotate\+Qubit\+Local@{rotate\+Qubit\+Local}}
\index{rotate\+Qubit\+Local@{rotate\+Qubit\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{rotate\+Qubit\+Local(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, Complex alpha, Complex beta)}{rotateQubitLocal(MultiQubit multiQubit, const int rotQubit, Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}void rotate\+Qubit\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_acb059cbcb8c7910a5fc43d21da4f5dea}{}\label{qubits_8c_acb059cbcb8c7910a5fc43d21da4f5dea}


Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. 

alpha\+Re = cos(angle1) $\ast$ cos(angle2) ~\newline
alpha\+Im = cos(angle1) $\ast$ sin(angle2) ~\newline
 beta\+Re = sin(angle1) $\ast$ cos(angle3) ~\newline
 beta\+Im = sin(angle1) $\ast$ sin(angle3) ~\newline


\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em alpha} & rotation angle \\
\hline
\mbox{\tt in}  & {\em beta} & rotation angle \\
\hline
\end{DoxyParams}


Definition at line 321 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, Complex\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by rotate\+Qubit().


\begin{DoxyCode}
322 \{
323         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
324         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
325              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
326 
327         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
328         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
329         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
330 
331         \textcolor{comment}{// test qubit valid}
332         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
333 
334         \textcolor{comment}{// set dimensions}
335         sizeHalfBlock = 1LL << rotQubit;  
336         sizeBlock     = 2LL * sizeHalfBlock; 
337 
338         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
339         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
340         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
341         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} alphaImag=alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, alphaReal=alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
342         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} betaImag=beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, betaReal=beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
343 
344 \textcolor{preprocessor}{# ifdef \_OPENMP}
345 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
346 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
347 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,alphaImag,
       betaReal,betaImag) \(\backslash\)}
348 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
349 \textcolor{preprocessor}{# endif}
350         \{
351 \textcolor{preprocessor}{# ifdef \_OPENMP}
352 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
353 \textcolor{preprocessor}{# endif}
354                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
355 
356                         thisBlock   = thisTask / sizeHalfBlock;
357                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
358                         indexLo     = indexUp + sizeHalfBlock;
359 
360                         \textcolor{comment}{// store current state vector values in temp variables}
361                         stateRealUp = stateVecReal[indexUp];
362                         stateImagUp = stateVecImag[indexUp];
363 
364                         stateRealLo = stateVecReal[indexLo];
365                         stateImagLo = stateVecImag[indexLo];
366 
367                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
368                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag*stateImagUp 
369                                 - betaReal*stateRealLo - betaImag*stateImagLo;
370                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag*stateRealUp 
371                                 - betaReal*stateImagLo + betaImag*stateRealLo;
372 
373                         \textcolor{comment}{// state[indexLo] = beta  * state[indexUp] + conj(alpha) * state[indexLo]}
374                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*stateImagUp 
375                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
376                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*stateRealUp 
377                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
378                 \} 
379         \}
380 
381 \} 
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!s\+Gate@{s\+Gate}}
\index{s\+Gate@{s\+Gate}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{s\+Gate(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit)}{sGate(MultiQubit multiQubit, const int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void s\+Gate (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a1086d84d6a3d5b79137e2f27f18e67e0}{}\label{qubits_8c_a1086d84d6a3d5b79137e2f27f18e67e0}


Definition at line 1221 of file qubits.\+c.



References phase\+Gate(), and S\+\_\+\+G\+A\+TE.



Referenced by main(), and test\+\_\+s\+Gate().


\begin{DoxyCode}
1222 \{
1223                 \hyperlink{qubits_8h_ae275b94c1a483dda43bf4ec947635605}{phaseGate}(multiQubit, rotQubit, \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{S\_GATE});
1224 \} 
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!sigma\+X\+Distributed@{sigma\+X\+Distributed}}
\index{sigma\+X\+Distributed@{sigma\+X\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{sigma\+X\+Distributed(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, Complex\+Array state\+Vec\+In, Complex\+Array state\+Vec\+Out)}{sigmaXDistributed(MultiQubit multiQubit, const int rotQubit, ComplexArray stateVecIn, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigma\+X\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+In, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a5958808b2f2f05937921ba7dabe5a171}{}\label{qubits_8c_a5958808b2f2f05937921ba7dabe5a171}


Rotate a single qubit by \{\{0,1\},\{1,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 684 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and R\+E\+AL.



Referenced by sigma\+X().


\begin{DoxyCode}
687 \{
688 
689         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
690         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
691 
692         \textcolor{comment}{// test qubit valid}
693         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
694 
695         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
696         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
697 
698 \textcolor{preprocessor}{# ifdef \_OPENMP}
699 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
700 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
701 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) \(\backslash\)}
702 \textcolor{preprocessor}{        private  (thisTask)}
703 \textcolor{preprocessor}{# endif}
704         \{
705 \textcolor{preprocessor}{# ifdef \_OPENMP}
706 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
707 \textcolor{preprocessor}{# endif}
708                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
709                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
710                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
711                 \}
712         \}
713 \} 
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!sigma\+X\+Local@{sigma\+X\+Local}}
\index{sigma\+X\+Local@{sigma\+X\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{sigma\+X\+Local(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit)}{sigmaXLocal(MultiQubit multiQubit, const int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigma\+X\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_aa9e640bb2d0458c937c6a87dfeca0f23}{}\label{qubits_8c_aa9e640bb2d0458c937c6a87dfeca0f23}


Rotate a single qubit by \{\{0,1\},\{1,0\}. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}


Definition at line 621 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by sigma\+X().


\begin{DoxyCode}
622 \{
623         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
624         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
625              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
626 
627         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
628         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
629         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
630 
631         \textcolor{comment}{// test qubit valid}
632         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
633 
634         \textcolor{comment}{// set dimensions}
635         sizeHalfBlock = 1LL << rotQubit;  
636         sizeBlock     = 2LL * sizeHalfBlock; 
637 
638         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
639         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
640         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
641 
642 \textcolor{preprocessor}{# ifdef \_OPENMP}
643 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
644 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
645 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
646 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) }
647 \textcolor{preprocessor}{# endif}
648         \{
649 \textcolor{preprocessor}{# ifdef \_OPENMP}
650 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
651 \textcolor{preprocessor}{# endif}
652                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
653                         thisBlock   = thisTask / sizeHalfBlock;
654                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
655                         indexLo     = indexUp + sizeHalfBlock;
656 
657                         stateRealUp = stateVecReal[indexUp];
658                         stateImagUp = stateVecImag[indexUp];
659 
660                         stateVecReal[indexUp] = stateVecReal[indexLo];
661                         stateVecImag[indexUp] = stateVecImag[indexLo];
662 
663                         stateVecReal[indexLo] = stateRealUp;
664                         stateVecImag[indexLo] = stateImagUp;
665                 \} 
666         \}
667 
668 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!sigma\+Y\+Distributed@{sigma\+Y\+Distributed}}
\index{sigma\+Y\+Distributed@{sigma\+Y\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{sigma\+Y\+Distributed(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, Complex\+Array state\+Vec\+In, Complex\+Array state\+Vec\+Out, int update\+Upper)}{sigmaYDistributed(MultiQubit multiQubit, const int rotQubit, ComplexArray stateVecIn, ComplexArray stateVecOut, int updateUpper)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigma\+Y\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+In, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out, }
\item[{int}]{update\+Upper}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a0471f6b547ce8270ef85170b7f4f0214}{}\label{qubits_8c_a0471f6b547ce8270ef85170b7f4f0214}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt in}  & {\em update\+Upper} & flag, 1\+: updating upper values, 0\+: updating lower values in block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 907 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and R\+E\+AL.



Referenced by sigma\+Y().


\begin{DoxyCode}
911 \{
912 
913         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
914         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
915 
916         \textcolor{comment}{// test qubit valid}
917         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
918 
919         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
920         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
921 
922         \textcolor{keywordtype}{int} realSign=1, imagSign=1;
923         \textcolor{keywordflow}{if} (updateUpper) imagSign=-1;
924         \textcolor{keywordflow}{else} realSign = -1;
925 
926 \textcolor{preprocessor}{# ifdef \_OPENMP}
927 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
928 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
929 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,realSign,imagSign) \(\backslash\)}
930 \textcolor{preprocessor}{        private  (thisTask)}
931 \textcolor{preprocessor}{# endif}
932         \{
933 \textcolor{preprocessor}{# ifdef \_OPENMP}
934 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
935 \textcolor{preprocessor}{# endif}
936                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
937                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisTask];
938                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisTask];
939                 \}
940         \}
941 \} 
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!sigma\+Y\+Local@{sigma\+Y\+Local}}
\index{sigma\+Y\+Local@{sigma\+Y\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{sigma\+Y\+Local(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit)}{sigmaYLocal(MultiQubit multiQubit, const int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigma\+Y\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_afcbb1dcbe070ad0ed1a72a23251b6a83}{}\label{qubits_8c_afcbb1dcbe070ad0ed1a72a23251b6a83}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}


Definition at line 844 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by sigma\+Y().


\begin{DoxyCode}
845 \{
846         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
847         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
848              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
849 
850         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
851         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
852         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
853 
854         \textcolor{comment}{// test qubit valid}
855         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
856 
857         \textcolor{comment}{// set dimensions}
858         sizeHalfBlock = 1LL << rotQubit;  
859         sizeBlock     = 2LL * sizeHalfBlock; 
860 
861         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
862         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
863         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
864 
865 \textcolor{preprocessor}{# ifdef \_OPENMP}
866 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
867 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
868 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
869 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) }
870 \textcolor{preprocessor}{# endif}
871         \{
872 \textcolor{preprocessor}{# ifdef \_OPENMP}
873 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
874 \textcolor{preprocessor}{# endif}
875                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
876                         thisBlock   = thisTask / sizeHalfBlock;
877                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
878                         indexLo     = indexUp + sizeHalfBlock;
879 
880                         stateRealUp = stateVecReal[indexUp];
881                         stateImagUp = stateVecImag[indexUp];
882 
883                         stateVecReal[indexUp] = stateVecImag[indexLo];
884                         stateVecImag[indexUp] = -stateVecReal[indexLo];
885 
886                         stateVecReal[indexLo] = -stateImagUp;
887                         stateVecImag[indexLo] = stateRealUp;
888                 \} 
889         \}
890 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!sigmaZ@{sigmaZ}}
\index{sigmaZ@{sigmaZ}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{sigma\+Z(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit)}{sigmaZ(MultiQubit multiQubit, const int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaZ (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a9c90f8302e4f1d8fda23def8753e50fe}{}\label{qubits_8c_a9c90f8302e4f1d8fda23def8753e50fe}


Rotate a single qubit by \{\{1,0\},\{\{0,-\/1\}\} -- apply a phase of -\/1 to $\vert$1$>$. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}


Definition at line 1216 of file qubits.\+c.



References phase\+Gate(), and S\+I\+G\+M\+A\+\_\+Z.



Referenced by main(), and test\+\_\+sigma\+Z().


\begin{DoxyCode}
1217 \{
1218                 \hyperlink{qubits_8h_ae275b94c1a483dda43bf4ec947635605}{phaseGate}(multiQubit, rotQubit, \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{SIGMA\_Z});
1219 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!t\+Gate@{t\+Gate}}
\index{t\+Gate@{t\+Gate}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{t\+Gate(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit)}{tGate(MultiQubit multiQubit, const int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void t\+Gate (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a5f33ddd690383fd09cc79bf143e383fb}{}\label{qubits_8c_a5f33ddd690383fd09cc79bf143e383fb}


Definition at line 1226 of file qubits.\+c.



References phase\+Gate(), and T\+\_\+\+G\+A\+TE.



Referenced by main(), and test\+\_\+t\+Gate().


\begin{DoxyCode}
1227 \{
1228                 \hyperlink{qubits_8h_ae275b94c1a483dda43bf4ec947635605}{phaseGate}(multiQubit, rotQubit, \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{T\_GATE});
1229 \}
\end{DoxyCode}
