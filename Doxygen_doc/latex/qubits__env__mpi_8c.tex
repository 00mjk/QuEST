\hypertarget{qubits__env__mpi_8c}{}\subsection{qubits\+\_\+env\+\_\+mpi.\+c File Reference}
\label{qubits__env__mpi_8c}\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}


An implementation of the A\+PI in \hyperlink{qubits_8h}{qubits.\+h} for an M\+PI environment.  


{\ttfamily \#include $<$unistd.\+h$>$}\newline
{\ttfamily \#include $<$mpi.\+h$>$}\newline
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include $<$omp.\+h$>$}\newline
{\ttfamily \#include \char`\"{}precision.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}qubits.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}qubits\+\_\+internal.\+h\char`\"{}}\newline
\subsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}
\item 
\#define \hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{D\+E\+B\+UG}~0
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero} (int chunk\+Id, long long int chunk\+Size, int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Find chunks to skip when calculating probability of qubit being zero. \end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunk\+Is\+Upper} (int chunk\+Id, long long int chunk\+Size, int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Returns whether a given chunk in position chunk\+Id is in the upper or lower half of a block. \end{DoxyCompactList}\item 
static void \hyperlink{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{get\+Rot\+Angle} (int \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunk\+Is\+Upper}, \hyperlink{structComplex}{Complex} $\ast$rot1, \hyperlink{structComplex}{Complex} $\ast$rot2, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Get rotation values for a given chunk. \end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{get\+Chunk\+Pair\+Id} (int \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunk\+Is\+Upper}, int chunk\+Id, long long int chunk\+Size, int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em get position of corresponding chunk, holding values required to update values in my chunk (with chunk\+Id) when rotating rot\+Qubit. \end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{half\+Matrix\+Block\+Fits\+In\+Chunk} (long long int chunk\+Size, int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em return whether the current qubit rotation will use blocks that fit within a single chunk. \end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{get\+Chunk\+Id\+From\+Index} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, long long int index)
\item 
void \hyperlink{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}{init\+Qu\+E\+S\+T\+Env} (\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} $\ast$env)
\begin{DoxyCompactList}\small\item\em Initialize Qu\+E\+ST environment. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{sync\+Qu\+E\+S\+T\+Env} (\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} env)
\begin{DoxyCompactList}\small\item\em Guarantees that all code up to the given point has been executed on all nodes. \end{DoxyCompactList}\item 
int \hyperlink{qubits__env__mpi_8c_a877396e10f0e9aeead078664c51bb0e3}{sync\+Qu\+E\+S\+T\+Success} (\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} env, int success\+Code)
\begin{DoxyCompactList}\small\item\em Performs a logical A\+ND on all success\+Codes held by all processes. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}{close\+Qu\+E\+S\+T\+Env} (\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} env)
\begin{DoxyCompactList}\small\item\em Close Qu\+E\+ST environment. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}{report\+Qu\+E\+S\+T\+Env} (\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} env)
\begin{DoxyCompactList}\small\item\em Report information about the Qu\+E\+ST environment. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}{report\+Node\+List} (\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} env)
\begin{DoxyCompactList}\small\item\em Report a list of C\+PU hostnames and the rank that is running on each if running with M\+PI enabled and an error message otherwise. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}{get\+Real\+Amp\+El} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the real component of the probability amplitude at an index in the state vector. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}{get\+Imag\+Amp\+El} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the imaginary component of the probability amplitude at an index in the state vector. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}{calc\+Total\+Probability} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Calculate the probability of being in any state by taking the norm of the entire state vector. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchange\+State\+Vectors} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, int pair\+Rank)
\item 
void \hyperlink{qubits__env__mpi_8c_a4ba468aa69f812efd1f964e10a45ca2f}{rotate\+Qubit} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_abac5189a14bc12e79580ba0d75de796e}{control\+Rotate\+Qubit} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, const int control\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_acda82bebb0a62f419eec9c1e0575daad}{sigmaX} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}\} -- swap $\vert$0$>$ and $\vert$1$>$. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a41f33b4f5f2bf697821591eb224cabb9}{control\+Not} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, const int control\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -- swap $\vert$0$>$ and $\vert$1$>$ and apply a phase of -\/i or i, only for elements when control qubit is 1. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a7b022c75cef77be046bd5d61e38a581e}{sigmaY} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -- swap $\vert$0$>$ and $\vert$1$>$ and apply a phase of -\/i or i. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ae275b94c1a483dda43bf4ec947635605}{phase\+Gate} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ad247d084dc7150893e9051a438a5807e}{hadamard} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2 -- turn a $\vert$0$>$ into a $\vert$+$>$ and a $\vert$1$>$ into a $\vert$-\/$>$. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{find\+Probability\+Of\+Outcome} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit, int outcome)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero or one state. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_a88605f373c2401760aab0e08719e08dd}{measure\+In\+State} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measure\+Qubit=0 or measure\+Qubit=1 according to the value of outcome. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_ae8fcabd3f22c6c9a9104e1807fb78f80}{filter\+Out111} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3)
\begin{DoxyCompactList}\small\item\em Updates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_a909ba48b5a82c9f5c3a94d17a72b1aa3}{prob\+Of\+Filter\+Out111} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3)
\begin{DoxyCompactList}\small\item\em Evaluates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
An implementation of the A\+PI in \hyperlink{qubits_8h}{qubits.\+h} for an M\+PI environment. 



\subsubsection{Macro Definition Documentation}
\mbox{\Hypertarget{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}\label{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE@{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}}
\index{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE@{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}{\_BSD\_SOURCE}}
{\footnotesize\ttfamily \#define \+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}



Definition at line 5 of file qubits\+\_\+env\+\_\+mpi.\+c.

\mbox{\Hypertarget{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}\label{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!D\+E\+B\+UG@{D\+E\+B\+UG}}
\index{D\+E\+B\+UG@{D\+E\+B\+UG}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{D\+E\+B\+UG}{DEBUG}}
{\footnotesize\ttfamily \#define D\+E\+B\+UG~0}



Definition at line 17 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by calc\+Total\+Probability(), exchange\+State\+Vectors(), and init\+Qu\+E\+S\+T\+Env().



\subsubsection{Function Documentation}
\mbox{\Hypertarget{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}\label{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!calc\+Total\+Probability@{calc\+Total\+Probability}}
\index{calc\+Total\+Probability@{calc\+Total\+Probability}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{calc\+Total\+Probability()}{calcTotalProbability()}}
{\footnotesize\ttfamily \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} calc\+Total\+Probability (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit }\end{DoxyParamCaption})}



Calculate the probability of being in any state by taking the norm of the entire state vector. 

Should be equal to 1. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing a set of qubits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
total probability 
\end{DoxyReturn}


Definition at line 107 of file qubits\+\_\+env\+\_\+mpi.\+c.



References chunk\+Is\+Upper(), D\+E\+B\+UG, Complex\+Array\+::imag, M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Chunks, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
107                                                 \{
108   \textcolor{comment}{/* IJB - implemented using Kahan summation for greater accuracy at a slight floating}
109 \textcolor{comment}{     point operation overhead. For more details see https://en.wikipedia.org/wiki/Kahan\_summation\_algorithm
       */}
110   \textcolor{comment}{/* Don't change the bracketing in this routine! */}
111   \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} pTotal=0; 
112   \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} y, t, c;
113   \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} allRankTotals=0;
114   \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
115   \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numAmpsPerRank = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
116   c = 0.0;
117   \textcolor{keywordflow}{for} (index=0; index<numAmpsPerRank; index++)\{ 
118     \textcolor{comment}{/* Perform pTotal+=multiQubit.stateVec.real[index]*multiQubit.stateVec.real[index]; by Kahan */}
119     y = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[index]*multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.
      \hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[index] - c;
120     t = pTotal + y;
121     c = ( t - pTotal ) - y;
122     pTotal = t;
123     \textcolor{comment}{/* Perform pTotal+=multiQubit.stateVec.imag[index]*multiQubit.stateVec.imag[index]; by Kahan */}
124     y = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[index]*multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[index] - c;
125     t = pTotal + y;
126     c = ( t - pTotal ) - y;
127     pTotal = t;
128   \} 
129   \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"before calc prob. %d\(\backslash\)n"}, multiQubit.\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks});
130   \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks}>1) MPI\_Allreduce(&pTotal, &allRankTotals, 1, 
      \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, MPI\_SUM, MPI\_COMM\_WORLD);
131   \textcolor{keywordflow}{else} allRankTotals=pTotal;
132   
133   \textcolor{keywordflow}{return} allRankTotals;
134 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}\label{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!chunk\+Is\+Upper@{chunk\+Is\+Upper}}
\index{chunk\+Is\+Upper@{chunk\+Is\+Upper}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{chunk\+Is\+Upper()}{chunkIsUpper()}}
{\footnotesize\ttfamily static int chunk\+Is\+Upper (\begin{DoxyParamCaption}\item[{int}]{chunk\+Id,  }\item[{long long int}]{chunk\+Size,  }\item[{int}]{rot\+Qubit }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Returns whether a given chunk in position chunk\+Id is in the upper or lower half of a block. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Id} & id of chunk in state vector \\
\hline
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit being rotated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1\+: chunk is in upper half of block, 0\+: chunk is in lower half of block fix -- is this the same as is\+Chunk\+To\+Skip? 
\end{DoxyReturn}


Definition at line 145 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by calc\+Total\+Probability(), control\+Not(), control\+Rotate\+Qubit(), hadamard(), phase\+Gate(), rotate\+Qubit(), sigma\+X(), and sigma\+Y().


\begin{DoxyCode}
146 \{       
147         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (rotQubit);
148         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock = sizeHalfBlock*2;
149         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} posInBlock = (chunkId*chunkSize) % sizeBlock;
150         \textcolor{keywordflow}{return} posInBlock<sizeHalfBlock;
151 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}\label{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!close\+Qu\+E\+S\+T\+Env@{close\+Qu\+E\+S\+T\+Env}}
\index{close\+Qu\+E\+S\+T\+Env@{close\+Qu\+E\+S\+T\+Env}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{close\+Qu\+E\+S\+T\+Env()}{closeQuESTEnv()}}
{\footnotesize\ttfamily void close\+Qu\+E\+S\+T\+Env (\begin{DoxyParamCaption}\item[{\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env}}]{env }\end{DoxyParamCaption})}



Close Qu\+E\+ST environment. 

If something needs to be done to clean up the execution environment, such as finalizing M\+PI when running in distributed mode, it is handled here 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 55 of file qubits\+\_\+env\+\_\+mpi.\+c.


\begin{DoxyCode}
55                                 \{
56         \textcolor{keywordtype}{int} finalized;
57         MPI\_Finalized(&finalized);
58         \textcolor{keywordflow}{if} (!finalized) MPI\_Finalize();
59         \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"ERROR: Trying to close QuESTEnv multiple times. Ignoring\(\backslash\)n"});
60 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_a41f33b4f5f2bf697821591eb224cabb9}\label{qubits__env__mpi_8c_a41f33b4f5f2bf697821591eb224cabb9}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!control\+Not@{control\+Not}}
\index{control\+Not@{control\+Not}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{control\+Not()}{controlNot()}}
{\footnotesize\ttfamily void control\+Not (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{target\+Qubit,  }\item[{const int}]{control\+Qubit }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -- swap $\vert$0$>$ and $\vert$1$>$ and apply a phase of -\/i or i, only for elements when control qubit is 1. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & perform sigmaX rotation if this qubit is 1 \\
\hline
\end{DoxyParams}


Definition at line 347 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), control\+Not\+Distributed(), control\+Not\+Local(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::pair\+State\+Vec, and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
348 \{
349         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
350         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
351 
352         \textcolor{comment}{// rank's chunk is in upper half of block }
353         \textcolor{keywordtype}{int} rankIsUpper;
354         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
355 
356         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
357                 \textcolor{comment}{// all values required to update state vector lie in this rank}
358                 \hyperlink{qubits_8c_a2901e2e5531cb77f87ea54b3fc28f51a}{controlNotLocal}(multiQubit, rotQubit, controlQubit);
359         \} \textcolor{keywordflow}{else} \{
360                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
361                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
362                 pairRank = \hyperlink{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
363                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
364                 \textcolor{comment}{// get corresponding values from my pair}
365                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
366                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. send values to
       rotateQubitDistributed}
367                 \textcolor{comment}{// in the correct order}
368                 \textcolor{keywordflow}{if} (rankIsUpper)\{
369                         \hyperlink{qubits_8c_a774dd1217fcc3591a74a74d5667afa29}{controlNotDistributed}(multiQubit,rotQubit,controlQubit,
370                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//in}
371                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//out}
372                 \} \textcolor{keywordflow}{else} \{
373                         \hyperlink{qubits_8c_a774dd1217fcc3591a74a74d5667afa29}{controlNotDistributed}(multiQubit,rotQubit,controlQubit,
374                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//in}
375                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//out}
376                 \}
377         \}
378 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_abac5189a14bc12e79580ba0d75de796e}\label{qubits__env__mpi_8c_abac5189a14bc12e79580ba0d75de796e}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!control\+Rotate\+Qubit@{control\+Rotate\+Qubit}}
\index{control\+Rotate\+Qubit@{control\+Rotate\+Qubit}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{control\+Rotate\+Qubit()}{controlRotateQubit()}}
{\footnotesize\ttfamily void control\+Rotate\+Qubit (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{const int}]{control\+Qubit,  }\item[{\hyperlink{structComplex}{Complex}}]{alpha,  }\item[{\hyperlink{structComplex}{Complex}}]{beta }\end{DoxyParamCaption})}



Rotate a single qubit in the state vector of probability amplitudes. 

Given two complex numbers alpha and beta and a control qubit, applies the operation\+: ~\newline
\mbox{[}alpha, -\/beta$\ast$ ~\newline
 beta, alpha$\ast$\mbox{]} ~\newline
Only when the control qubit is one.

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}
alpha, beta must obey $\vert$alpha$\vert$$^\wedge$2 + $\vert$beta$\vert$$^\wedge$2 = 1


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & perform rotation if this qubit is 1 \\
\hline
\mbox{\tt in}  & {\em alpha} & rotation angle \\
\hline
\mbox{\tt in}  & {\em beta} & rotation angle \\
\hline
\end{DoxyParams}


Definition at line 282 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), control\+Rotate\+Qubit\+Distributed(), control\+Rotate\+Qubit\+Local(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), get\+Rot\+Angle(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::pair\+State\+Vec, and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
283 \{
284         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
285         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
286         \hyperlink{structComplex}{Complex} rot1, rot2;
287 
288         \textcolor{comment}{// rank's chunk is in upper half of block }
289         \textcolor{keywordtype}{int} rankIsUpper;
290         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
291 
292         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
293                 \textcolor{comment}{// all values required to update state vector lie in this rank}
294                 \hyperlink{qubits_8c_a824d71bae93236d8a3cd43589044eaee}{controlRotateQubitLocal}(multiQubit, rotQubit, controlQubit, alpha, 
      beta);
295         \} \textcolor{keywordflow}{else} \{
296                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
297                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
298                 \hyperlink{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{getRotAngle}(rankIsUpper, &rot1, &rot2, alpha, beta);
299                 pairRank = \hyperlink{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
300                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
301                 \textcolor{comment}{// get corresponding values from my pair}
302                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
303                 
304                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. send values to
       rotateQubitDistributed}
305                 \textcolor{comment}{// in the correct order}
306                 \textcolor{keywordflow}{if} (rankIsUpper)\{
307                         \hyperlink{qubits_8c_ab22d031e2507f1d859292103a99e2378}{controlRotateQubitDistributed}(multiQubit,rotQubit,
      controlQubit,rot1,rot2,
308                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//upper}
309                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//lower}
310                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
311                 \} \textcolor{keywordflow}{else} \{
312                         \hyperlink{qubits_8c_ab22d031e2507f1d859292103a99e2378}{controlRotateQubitDistributed}(multiQubit,rotQubit,
      controlQubit,rot1,rot2,
313                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//upper}
314                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//lower}
315                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
316                 \}
317         \}
318 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}\label{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!exchange\+State\+Vectors@{exchange\+State\+Vectors}}
\index{exchange\+State\+Vectors@{exchange\+State\+Vectors}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{exchange\+State\+Vectors()}{exchangeStateVectors()}}
{\footnotesize\ttfamily void exchange\+State\+Vectors (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{int}]{pair\+Rank }\end{DoxyParamCaption})}



Definition at line 213 of file qubits\+\_\+env\+\_\+mpi.\+c.



References D\+E\+B\+UG, Complex\+Array\+::imag, M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::pair\+State\+Vec, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by control\+Not(), control\+Rotate\+Qubit(), hadamard(), rotate\+Qubit(), sigma\+X(), and sigma\+Y().


\begin{DoxyCode}
213                                                               \{
214         \textcolor{comment}{// MPI send/receive vars}
215         \textcolor{keywordtype}{int} TAG=100;
216         MPI\_Status status;
217 
218         \textcolor{comment}{// Multiple messages are required as MPI uses int rather than long long int for count}
219         \textcolor{comment}{// For openmpi, messages are further restricted to 2GB in size -- do this for all cases}
220         \textcolor{comment}{// to be safe}
221         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} maxMessageCount = 1LL<<29;
222         \textcolor{keywordflow}{if} (\textcolor{keyword}{sizeof}(\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL})==8) maxMessageCount = (1LL<<28);
223         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\textcolor{keyword}{sizeof}(\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL})==16) maxMessageCount = (1LL<<27);
224 
225         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}<maxMessageCount) maxMessageCount = multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
226         \textcolor{keywordtype}{int} numMessages = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}/maxMessageCount;
227         \textcolor{keywordtype}{int} i;
228         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} offset;
229         \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"numMessages %d maxMessageCount %lld\(\backslash\)n"}, numMessages, maxMessageCount);
230 
231         \textcolor{comment}{// send my state vector to pairRank's multiQubit.pairStateVec}
232         \textcolor{comment}{// receive pairRank's state vector into multiQubit.pairStateVec}
233         \textcolor{keywordflow}{for} (i=0; i<numMessages; i++)\{
234                 offset = i*maxMessageCount;
235                 MPI\_Sendrecv(&multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[offset], maxMessageCount, 
      \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, pairRank, TAG,
236                                  &multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[offset], maxMessageCount, 
      \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL},
237                                  pairRank, TAG, MPI\_COMM\_WORLD, &status);
238                 \textcolor{comment}{//printf("rank: %d err: %d\(\backslash\)n", multiQubit.rank, err);}
239                 MPI\_Sendrecv(&multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[offset], maxMessageCount, 
      \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, pairRank, TAG,
240                                 &multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[offset], maxMessageCount, 
      \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL},
241                                 pairRank, TAG, MPI\_COMM\_WORLD, &status);
242         \}
243 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_ae8fcabd3f22c6c9a9104e1807fb78f80}\label{qubits__env__mpi_8c_ae8fcabd3f22c6c9a9104e1807fb78f80}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!filter\+Out111@{filter\+Out111}}
\index{filter\+Out111@{filter\+Out111}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{filter\+Out111()}{filterOut111()}}
{\footnotesize\ttfamily \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} filter\+Out111 (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{id\+Qubit1,  }\item[{const int}]{id\+Qubit2,  }\item[{const int}]{id\+Qubit3 }\end{DoxyParamCaption})}



Updates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. 

The function returns the probability of this outcome (if zero, it will exit with error) 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3} & specified qubits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Total probability that the 3 qubits are not all in the 1 state. 
\end{DoxyReturn}


Definition at line 522 of file qubits\+\_\+env\+\_\+mpi.\+c.



References filter\+Out111\+Local(), prob\+Of\+Filter\+Out111(), and R\+E\+AL.


\begin{DoxyCode}
523 \{
524         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateProb=0;
525         stateProb = \hyperlink{qubits__env__mpi_8c_a909ba48b5a82c9f5c3a94d17a72b1aa3}{probOfFilterOut111}(multiQubit, idQubit1, idQubit2, idQubit3);
526         \textcolor{keywordflow}{if} (stateProb != 0) \hyperlink{qubits_8c_a2d73fd11c1d154640dbf114da8f34c64}{filterOut111Local}(multiQubit, idQubit1, idQubit2, idQubit3, 
      stateProb);
527         \textcolor{keywordflow}{return} stateProb;
528 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}\label{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!find\+Probability\+Of\+Outcome@{find\+Probability\+Of\+Outcome}}
\index{find\+Probability\+Of\+Outcome@{find\+Probability\+Of\+Outcome}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{find\+Probability\+Of\+Outcome()}{findProbabilityOfOutcome()}}
{\footnotesize\ttfamily \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} find\+Probability\+Of\+Outcome (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit,  }\item[{int}]{outcome }\end{DoxyParamCaption})}



Measure the probability of a specified qubit being in the zero or one state. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em outcome} & to measure the probability of -- either zero or one \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being either zero or one 
\end{DoxyReturn}


Definition at line 481 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, find\+Probability\+Of\+Zero\+Distributed(), find\+Probability\+Of\+Zero\+Local(), half\+Matrix\+Block\+Fits\+In\+Chunk(), is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero(), M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps, and R\+E\+AL.



Referenced by measure\+In\+State().


\begin{DoxyCode}
482 \{
483         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateProb=0, totalStateProb=0;
484         \textcolor{keywordtype}{int} skipValuesWithinRank = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, measureQubit);
485         \textcolor{keywordflow}{if} (skipValuesWithinRank) \{
486                 stateProb = \hyperlink{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}{findProbabilityOfZeroLocal}(multiQubit, measureQubit);
487         \} \textcolor{keywordflow}{else} \{
488                 \textcolor{keywordflow}{if} (!\hyperlink{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{isChunkToSkipInFindPZero}(multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, measureQubit))\{
489                         stateProb = \hyperlink{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}{findProbabilityOfZeroDistributed}(
      multiQubit, measureQubit);
490                 \} \textcolor{keywordflow}{else} stateProb = 0;
491         \}
492         MPI\_Allreduce(&stateProb, &totalStateProb, 1, \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, MPI\_SUM, MPI\_COMM\_WORLD
      );
493         \textcolor{keywordflow}{if} (outcome==1) totalStateProb = 1.0 - totalStateProb;
494         \textcolor{keywordflow}{return} totalStateProb;
495 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}\label{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Chunk\+Id\+From\+Index@{get\+Chunk\+Id\+From\+Index}}
\index{get\+Chunk\+Id\+From\+Index@{get\+Chunk\+Id\+From\+Index}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{get\+Chunk\+Id\+From\+Index()}{getChunkIdFromIndex()}}
{\footnotesize\ttfamily int get\+Chunk\+Id\+From\+Index (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{long long int}]{index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 83 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::num\+Amps.



Referenced by get\+Imag\+Amp\+El(), and get\+Real\+Amp\+El().


\begin{DoxyCode}
83                                                                    \{
84         \textcolor{keywordflow}{return} index/multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}; \textcolor{comment}{// this is numAmpsPerChunk}
85 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}\label{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Chunk\+Pair\+Id@{get\+Chunk\+Pair\+Id}}
\index{get\+Chunk\+Pair\+Id@{get\+Chunk\+Pair\+Id}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{get\+Chunk\+Pair\+Id()}{getChunkPairId()}}
{\footnotesize\ttfamily static int get\+Chunk\+Pair\+Id (\begin{DoxyParamCaption}\item[{int}]{chunk\+Is\+Upper,  }\item[{int}]{chunk\+Id,  }\item[{long long int}]{chunk\+Size,  }\item[{int}]{rot\+Qubit }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



get position of corresponding chunk, holding values required to update values in my chunk (with chunk\+Id) when rotating rot\+Qubit. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Is\+Upper} & 1\+: chunk is in upper half of block, 0\+: chunk is in lower half \\
\hline
\mbox{\tt in}  & {\em chunk\+Id} & id of chunk in state vector \\
\hline
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit being rotated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
chunk\+Id of chunk required to rotate rot\+Qubit 
\end{DoxyReturn}


Definition at line 187 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by control\+Not(), control\+Rotate\+Qubit(), hadamard(), rotate\+Qubit(), sigma\+X(), and sigma\+Y().


\begin{DoxyCode}
188 \{
189         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (rotQubit);
190         \textcolor{keywordtype}{int} chunksPerHalfBlock = sizeHalfBlock/chunkSize;
191         \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper})\{
192                 \textcolor{keywordflow}{return} chunkId + chunksPerHalfBlock;
193         \} \textcolor{keywordflow}{else} \{
194                 \textcolor{keywordflow}{return} chunkId - chunksPerHalfBlock;
195         \}
196 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}\label{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Imag\+Amp\+El@{get\+Imag\+Amp\+El}}
\index{get\+Imag\+Amp\+El@{get\+Imag\+Amp\+El}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{get\+Imag\+Amp\+El()}{getImagAmpEl()}}
{\footnotesize\ttfamily \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} get\+Imag\+Amp\+El (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{long long int}]{index }\end{DoxyParamCaption})}



Get the imaginary component of the probability amplitude at an index in the state vector. 

For debugging purposes. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing a set of qubits \\
\hline
\mbox{\tt in}  & {\em index} & index in state vector of probability amplitudes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
imaginary component at that index 
\end{DoxyReturn}


Definition at line 97 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, get\+Chunk\+Id\+From\+Index(), Complex\+Array\+::imag, M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by get\+Prob\+El().


\begin{DoxyCode}
97                                                              \{
98         \textcolor{keywordtype}{int} chunkId = \hyperlink{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{getChunkIdFromIndex}(multiQubit, index);
99         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} el; 
100         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}==chunkId)\{
101                 el = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[index-chunkId*multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}];
102         \}
103         MPI\_Bcast(&el, 1, \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, chunkId, MPI\_COMM\_WORLD);
104         \textcolor{keywordflow}{return} el; 
105 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}\label{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Real\+Amp\+El@{get\+Real\+Amp\+El}}
\index{get\+Real\+Amp\+El@{get\+Real\+Amp\+El}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{get\+Real\+Amp\+El()}{getRealAmpEl()}}
{\footnotesize\ttfamily \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} get\+Real\+Amp\+El (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{long long int}]{index }\end{DoxyParamCaption})}



Get the real component of the probability amplitude at an index in the state vector. 

For debugging purposes. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing a set of qubits \\
\hline
\mbox{\tt in}  & {\em index} & index in state vector of probability amplitudes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
real component at that index 
\end{DoxyReturn}


Definition at line 87 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, get\+Chunk\+Id\+From\+Index(), M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by get\+Prob\+El().


\begin{DoxyCode}
87                                                              \{
88         \textcolor{keywordtype}{int} chunkId = \hyperlink{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{getChunkIdFromIndex}(multiQubit, index);
89         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} el; 
90         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}==chunkId)\{
91                 el = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[index-chunkId*multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}];
92         \}
93         MPI\_Bcast(&el, 1, \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, chunkId, MPI\_COMM\_WORLD);
94         \textcolor{keywordflow}{return} el; 
95 \} 
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}\label{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Rot\+Angle@{get\+Rot\+Angle}}
\index{get\+Rot\+Angle@{get\+Rot\+Angle}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{get\+Rot\+Angle()}{getRotAngle()}}
{\footnotesize\ttfamily static void get\+Rot\+Angle (\begin{DoxyParamCaption}\item[{int}]{chunk\+Is\+Upper,  }\item[{\hyperlink{structComplex}{Complex} $\ast$}]{rot1,  }\item[{\hyperlink{structComplex}{Complex} $\ast$}]{rot2,  }\item[{\hyperlink{structComplex}{Complex}}]{alpha,  }\item[{\hyperlink{structComplex}{Complex}}]{beta }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Get rotation values for a given chunk. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Is\+Upper} & 1\+: chunk is in upper half of block, 0\+: chunk is in lower half\\
\hline
\mbox{\tt out}  & {\em rot1,rot2} & rotation values to use, allocated for upper/lower such that \begin{DoxyVerb}stateUpper = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 or \begin{DoxyVerb}stateLower = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 \\
\hline
\mbox{\tt in}  & {\em alpha,beta} & initial rotation values \\
\hline
\end{DoxyParams}


Definition at line 166 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Complex\+::imag, and Complex\+::real.



Referenced by control\+Rotate\+Qubit(), and rotate\+Qubit().


\begin{DoxyCode}
167 \{
168         \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper})\{
169                 *rot1=alpha;
170                 rot2->\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}=-beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
171                 rot2->\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}=-beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
172         \} \textcolor{keywordflow}{else} \{
173                 *rot1=beta;
174                 *rot2=alpha;
175         \}
176 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_ad247d084dc7150893e9051a438a5807e}\label{qubits__env__mpi_8c_ad247d084dc7150893e9051a438a5807e}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!hadamard@{hadamard}}
\index{hadamard@{hadamard}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{hadamard()}{hadamard()}}
{\footnotesize\ttfamily void hadamard (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2 -- turn a $\vert$0$>$ into a $\vert$+$>$ and a $\vert$1$>$ into a $\vert$-\/$>$. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}


Definition at line 425 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), hadamard\+Distributed(), hadamard\+Local(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::pair\+State\+Vec, and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
426 \{
427         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
428         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
429 
430         \textcolor{comment}{// rank's chunk is in upper half of block }
431         \textcolor{keywordtype}{int} rankIsUpper;
432         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
433 
434         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
435                 \textcolor{comment}{// all values required to update state vector lie in this rank}
436                 \hyperlink{qubits_8c_a0711416fceaf63c67b496e123e845c69}{hadamardLocal}(multiQubit, rotQubit);
437         \} \textcolor{keywordflow}{else} \{
438                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
439                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
440                 pairRank = \hyperlink{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
441                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
442                 \textcolor{comment}{// get corresponding values from my pair}
443                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
444                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. send values to
       rotateQubitDistributed}
445                 \textcolor{comment}{// in the correct order}
446                 \textcolor{keywordflow}{if} (rankIsUpper)\{
447                         \hyperlink{qubits_8c_ac835c194bd547240a35f0b028db1d658}{hadamardDistributed}(multiQubit,rotQubit,
448                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//upper}
449                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//lower}
450                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, rankIsUpper); \textcolor{comment}{//output}
451                 \} \textcolor{keywordflow}{else} \{
452                         \hyperlink{qubits_8c_ac835c194bd547240a35f0b028db1d658}{hadamardDistributed}(multiQubit,rotQubit,
453                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//upper}
454                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//lower}
455                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, rankIsUpper); \textcolor{comment}{//output}
456                 \}
457         \}
458 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}\label{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!half\+Matrix\+Block\+Fits\+In\+Chunk@{half\+Matrix\+Block\+Fits\+In\+Chunk}}
\index{half\+Matrix\+Block\+Fits\+In\+Chunk@{half\+Matrix\+Block\+Fits\+In\+Chunk}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{half\+Matrix\+Block\+Fits\+In\+Chunk()}{halfMatrixBlockFitsInChunk()}}
{\footnotesize\ttfamily static int half\+Matrix\+Block\+Fits\+In\+Chunk (\begin{DoxyParamCaption}\item[{long long int}]{chunk\+Size,  }\item[{int}]{rot\+Qubit }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



return whether the current qubit rotation will use blocks that fit within a single chunk. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit being rotated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1\+: one chunk fits in one block 0\+: chunk is larger than block 
\end{DoxyReturn}


Definition at line 206 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by control\+Not(), control\+Rotate\+Qubit(), find\+Probability\+Of\+Outcome(), hadamard(), measure\+In\+State(), phase\+Gate(), rotate\+Qubit(), sigma\+X(), and sigma\+Y().


\begin{DoxyCode}
207 \{
208         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (rotQubit);
209         \textcolor{keywordflow}{if} (chunkSize > sizeHalfBlock) \textcolor{keywordflow}{return} 1;
210         \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} 0;
211 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}\label{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!init\+Qu\+E\+S\+T\+Env@{init\+Qu\+E\+S\+T\+Env}}
\index{init\+Qu\+E\+S\+T\+Env@{init\+Qu\+E\+S\+T\+Env}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{init\+Qu\+E\+S\+T\+Env()}{initQuESTEnv()}}
{\footnotesize\ttfamily void init\+Qu\+E\+S\+T\+Env (\begin{DoxyParamCaption}\item[{\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} $\ast$}]{env }\end{DoxyParamCaption})}



Initialize Qu\+E\+ST environment. 

If something needs to be done to set up the execution environment, such as initializing M\+PI when running in distributed mode, it is handled here 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 25 of file qubits\+\_\+env\+\_\+mpi.\+c.



References D\+E\+B\+UG, Qu\+E\+S\+T\+Env\+::num\+Ranks, and Qu\+E\+S\+T\+Env\+::rank.


\begin{DoxyCode}
25                                 \{
26         \textcolor{comment}{// init MPI environment}
27         \textcolor{keywordtype}{int} rank, numRanks, initialized;
28         MPI\_Initialized(&initialized);
29         \textcolor{keywordflow}{if} (!initialized)\{
30                 MPI\_Init(NULL, NULL);
31                 MPI\_Comm\_size(MPI\_COMM\_WORLD, &numRanks);
32                 MPI\_Comm\_rank(MPI\_COMM\_WORLD, &rank);
33 
34                 \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) \{
35                         \textcolor{keywordtype}{char} hostName[256];
36                         \textcolor{keywordtype}{int} hostNameLen;
37                         MPI\_Get\_processor\_name(hostName, &hostNameLen);
38                         printf(\textcolor{stringliteral}{"rank %d on host %s\(\backslash\)n"}, rank, hostName);
39                 \}
40                 env->\hyperlink{structQuESTEnv_aa648bb336cf8598467cb62db00b9cee8}{rank}=rank;
41                 env->\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks}=numRanks;
42         \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"ERROR: Trying to initialize QuESTEnv multiple times. Ignoring\(\backslash\)n"});
43 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}\label{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero@{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero}}
\index{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero@{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero()}{isChunkToSkipInFindPZero()}}
{\footnotesize\ttfamily static int is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero (\begin{DoxyParamCaption}\item[{int}]{chunk\+Id,  }\item[{long long int}]{chunk\+Size,  }\item[{int}]{measure\+Qubit }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Find chunks to skip when calculating probability of qubit being zero. 

When calculating probability of a bit q being zero, sum up 2$^\wedge$q values, then skip 2$^\wedge$q values, etc. This function finds if an entire chunk is in the range of values to be skipped


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Id} & id of chunk in state vector \\
\hline
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em measure\+Qubi} & qubit being measured \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int -- 1\+: skip, 0\+: don\textquotesingle{}t skip 
\end{DoxyReturn}


Definition at line 472 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by find\+Probability\+Of\+Outcome(), and measure\+In\+State().


\begin{DoxyCode}
473 \{
474         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (measureQubit);
475         \textcolor{keywordtype}{int} numChunksToSkip = sizeHalfBlock/chunkSize;
476         \textcolor{comment}{// calculate probability by summing over numChunksToSkip, then skipping numChunksToSkip, etc}
477         \textcolor{keywordtype}{int} bitToCheck = chunkId & numChunksToSkip;
478         \textcolor{keywordflow}{return} bitToCheck;
479 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_a88605f373c2401760aab0e08719e08dd}\label{qubits__env__mpi_8c_a88605f373c2401760aab0e08719e08dd}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!measure\+In\+State@{measure\+In\+State}}
\index{measure\+In\+State@{measure\+In\+State}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{measure\+In\+State()}{measureInState()}}
{\footnotesize\ttfamily \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} measure\+In\+State (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit,  }\item[{int}]{outcome }\end{DoxyParamCaption})}



Update the state vector to be consistent with measuring measure\+Qubit=0 or measure\+Qubit=1 according to the value of outcome. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that an outcome has been measured on the qubit indicated by measure\+Qubit (where his label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 if outcome=0 or measure\+Qubit=1 if outcome=1. It then returns the probability of making this measurement.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em outcome} & to measure the probability of and set the state to -- either zero or one \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being either zero or one 
\end{DoxyReturn}


Definition at line 498 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, find\+Probability\+Of\+Outcome(), half\+Matrix\+Block\+Fits\+In\+Chunk(), is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero(), measure\+In\+State\+Distributed\+Renorm(), measure\+In\+State\+Distributed\+Set\+Zero(), measure\+In\+State\+Local(), Multi\+Qubit\+::num\+Amps, and R\+E\+AL.


\begin{DoxyCode}
499 \{
500         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} totalStateProb=\hyperlink{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{findProbabilityOfOutcome}(multiQubit, measureQubit, 
      outcome);
501         \textcolor{keywordtype}{int} skipValuesWithinRank = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, measureQubit);
502         \textcolor{keywordflow}{if} (totalStateProb != 0)\{
503                 \textcolor{keywordflow}{if} (skipValuesWithinRank) \{
504                         \hyperlink{qubits_8c_a53614ce19e0a4f2c41b400cf05dc5bd1}{measureInStateLocal}(multiQubit, measureQubit, totalStateProb, 
      outcome);
505                 \} \textcolor{keywordflow}{else} \{
506                         \textcolor{keywordflow}{if} (!\hyperlink{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{isChunkToSkipInFindPZero}(multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, measureQubit))\{
507                                 \textcolor{comment}{// chunk has amps for q=0}
508                                 \textcolor{keywordflow}{if} (outcome==0) \hyperlink{qubits_8c_a35e5ac30c8427c482a97b33a4e295535}{measureInStateDistributedRenorm}
      (multiQubit, measureQubit, 
509                                                 totalStateProb);
510                                 \textcolor{keywordflow}{else} \hyperlink{qubits_8c_ac39efc9ed939382276ebd0c15dd6a0fa}{measureInStateDistributedSetZero}(
      multiQubit, measureQubit);
511                         \} \textcolor{keywordflow}{else} \{
512                                 \textcolor{comment}{// chunk has amps for q=1}
513                                 \textcolor{keywordflow}{if} (outcome==1) \hyperlink{qubits_8c_a35e5ac30c8427c482a97b33a4e295535}{measureInStateDistributedRenorm}
      (multiQubit, measureQubit, 
514                                                 totalStateProb);
515                                 \textcolor{keywordflow}{else} \hyperlink{qubits_8c_ac39efc9ed939382276ebd0c15dd6a0fa}{measureInStateDistributedSetZero}(
      multiQubit, measureQubit);
516                         \}
517                 \}
518         \}
519         \textcolor{keywordflow}{return} totalStateProb;
520 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_ae275b94c1a483dda43bf4ec947635605}\label{qubits__env__mpi_8c_ae275b94c1a483dda43bf4ec947635605}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!phase\+Gate@{phase\+Gate}}
\index{phase\+Gate@{phase\+Gate}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{phase\+Gate()}{phaseGate()}}
{\footnotesize\ttfamily void phase\+Gate (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type}}]{type }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em type} & the type of phase gate to apply -- one of \{S\+I\+G\+M\+A\+\_\+Z, S\+\_\+\+G\+A\+TE, T\+\_\+\+G\+A\+TE\} \\
\hline
\end{DoxyParams}


Definition at line 409 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, phase\+Gate\+Distributed(), and phase\+Gate\+Local().


\begin{DoxyCode}
410 \{
411         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
412         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
413 
414         \textcolor{comment}{// rank's chunk is in upper half of block }
415         \textcolor{keywordtype}{int} rankIsUpper;
416 
417         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
418                 \hyperlink{qubits_8c_a6a736aeb3532898019fe7c27010edc6a}{phaseGateLocal}(multiQubit, rotQubit, type);
419         \} \textcolor{keywordflow}{else} \{
420                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
421                 \textcolor{keywordflow}{if} (!rankIsUpper) \hyperlink{qubits_8c_a38a05c7e749e806b182ef3b89878bfc4}{phaseGateDistributed}(multiQubit, rotQubit, type);
422         \}
423 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_a909ba48b5a82c9f5c3a94d17a72b1aa3}\label{qubits__env__mpi_8c_a909ba48b5a82c9f5c3a94d17a72b1aa3}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!prob\+Of\+Filter\+Out111@{prob\+Of\+Filter\+Out111}}
\index{prob\+Of\+Filter\+Out111@{prob\+Of\+Filter\+Out111}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{prob\+Of\+Filter\+Out111()}{probOfFilterOut111()}}
{\footnotesize\ttfamily \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} prob\+Of\+Filter\+Out111 (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{id\+Qubit1,  }\item[{const int}]{id\+Qubit2,  }\item[{const int}]{id\+Qubit3 }\end{DoxyParamCaption})}



Evaluates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. 

The function returns the probability of this outcome (if zero, it will exit with error) 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3} & specified qubits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Total probability that the 3 qubits are not all in the 1 state. 
\end{DoxyReturn}


Definition at line 530 of file qubits\+\_\+env\+\_\+mpi.\+c.



References M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, prob\+Of\+Filter\+Out111\+Local(), and R\+E\+AL.



Referenced by filter\+Out111().


\begin{DoxyCode}
531 \{
532         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateProb=0, totalStateProb=0;
533         stateProb = \hyperlink{qubits_8c_a096cddbac961f0651a084d2ceb905d1b}{probOfFilterOut111Local}(multiQubit, idQubit1, idQubit2, idQubit3
      );
534         MPI\_Allreduce(&stateProb, &totalStateProb, 1, \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, MPI\_SUM, MPI\_COMM\_WORLD
      );
535         \textcolor{keywordflow}{return} totalStateProb;
536 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}\label{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!report\+Node\+List@{report\+Node\+List}}
\index{report\+Node\+List@{report\+Node\+List}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{report\+Node\+List()}{reportNodeList()}}
{\footnotesize\ttfamily void report\+Node\+List (\begin{DoxyParamCaption}\item[{\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env}}]{env }\end{DoxyParamCaption})}



Report a list of C\+PU hostnames and the rank that is running on each if running with M\+PI enabled and an error message otherwise. 

For debugging purposes. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 77 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Qu\+E\+S\+T\+Env\+::rank.


\begin{DoxyCode}
77                                  \{
78         \textcolor{keywordtype}{char} hostName[256];
79         gethostname(hostName, 255);
80         printf(\textcolor{stringliteral}{"hostname on rank %d: %s\(\backslash\)n"}, env.\hyperlink{structQuESTEnv_aa648bb336cf8598467cb62db00b9cee8}{rank}, hostName);
81 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}\label{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!report\+Qu\+E\+S\+T\+Env@{report\+Qu\+E\+S\+T\+Env}}
\index{report\+Qu\+E\+S\+T\+Env@{report\+Qu\+E\+S\+T\+Env}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{report\+Qu\+E\+S\+T\+Env()}{reportQuESTEnv()}}
{\footnotesize\ttfamily void report\+Qu\+E\+S\+T\+Env (\begin{DoxyParamCaption}\item[{\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env}}]{env }\end{DoxyParamCaption})}



Report information about the Qu\+E\+ST environment. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 62 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Qu\+E\+S\+T\+Env\+::num\+Ranks, Qu\+E\+S\+T\+Env\+::rank, and R\+E\+AL.


\begin{DoxyCode}
62                                  \{
63         \textcolor{keywordflow}{if} (env.\hyperlink{structQuESTEnv_aa648bb336cf8598467cb62db00b9cee8}{rank}==0)\{
64                 printf(\textcolor{stringliteral}{"EXECUTION ENVIRONMENT:\(\backslash\)n"}); 
65                 printf(\textcolor{stringliteral}{"Running distributed (MPI) version\(\backslash\)n"});
66                 printf(\textcolor{stringliteral}{"Number of ranks is %d\(\backslash\)n"}, env.\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks});
67 \textcolor{preprocessor}{# ifdef \_OPENMP}
68                 printf(\textcolor{stringliteral}{"OpenMP enabled\(\backslash\)n"});
69                 printf(\textcolor{stringliteral}{"Number of threads available is %d\(\backslash\)n"}, omp\_get\_max\_threads());
70 \textcolor{preprocessor}{# else}
71                 printf(\textcolor{stringliteral}{"OpenMP disabled\(\backslash\)n"});
72 \textcolor{preprocessor}{# endif }
73                 printf(\textcolor{stringliteral}{"Precision: size of REAL is %ld bytes\(\backslash\)n"}, \textcolor{keyword}{sizeof}(\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}));
74         \}
75 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_a4ba468aa69f812efd1f964e10a45ca2f}\label{qubits__env__mpi_8c_a4ba468aa69f812efd1f964e10a45ca2f}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!rotate\+Qubit@{rotate\+Qubit}}
\index{rotate\+Qubit@{rotate\+Qubit}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{rotate\+Qubit()}{rotateQubit()}}
{\footnotesize\ttfamily void rotate\+Qubit (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{\hyperlink{structComplex}{Complex}}]{alpha,  }\item[{\hyperlink{structComplex}{Complex}}]{beta }\end{DoxyParamCaption})}



Rotate a single qubit in the state vector of probability amplitudes. 

Given two complex numbers alpha and beta, applies the operation ~\newline
\mbox{[}alpha, -\/beta$\ast$ ~\newline
 beta, alpha$\ast$\mbox{]} ~\newline
 \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}
alpha, beta must obey $\vert$alpha$\vert$$^\wedge$2 + $\vert$beta$\vert$$^\wedge$2 = 1


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em alpha} & rotation angle \\
\hline
\mbox{\tt in}  & {\em beta} & rotation angle \\
\hline
\end{DoxyParams}


Definition at line 245 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), get\+Rot\+Angle(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::pair\+State\+Vec, rotate\+Qubit\+Distributed(), rotate\+Qubit\+Local(), and Multi\+Qubit\+::state\+Vec.



Referenced by rotate\+Qubit\+By\+Angle().


\begin{DoxyCode}
246 \{
247         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
248         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
249         \hyperlink{structComplex}{Complex} rot1, rot2;
250 
251         \textcolor{comment}{// rank's chunk is in upper half of block }
252         \textcolor{keywordtype}{int} rankIsUpper;
253         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
254 
255         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
256                 \textcolor{comment}{// all values required to update state vector lie in this rank}
257                 \hyperlink{qubits_8c_acb059cbcb8c7910a5fc43d21da4f5dea}{rotateQubitLocal}(multiQubit, rotQubit, alpha, beta);
258         \} \textcolor{keywordflow}{else} \{
259                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
260                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
261                 \hyperlink{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{getRotAngle}(rankIsUpper, &rot1, &rot2, alpha, beta);
262                 pairRank = \hyperlink{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
263                 \textcolor{comment}{// get corresponding values from my pair}
264                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
265 
266                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. }
267                 \textcolor{comment}{// send values to rotateQubitDistributed in the correct order}
268                 \textcolor{keywordflow}{if} (rankIsUpper)\{
269                         \hyperlink{qubits_8c_a6ff67d25363f39fd57a4e76621a4bfd5}{rotateQubitDistributed}(multiQubit,rotQubit,rot1,rot2,
270                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//upper}
271                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//lower}
272                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
273                 \} \textcolor{keywordflow}{else} \{
274                         \hyperlink{qubits_8c_a6ff67d25363f39fd57a4e76621a4bfd5}{rotateQubitDistributed}(multiQubit,rotQubit,rot1,rot2,
275                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//upper}
276                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//lower}
277                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
278                 \}
279         \}
280 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_acda82bebb0a62f419eec9c1e0575daad}\label{qubits__env__mpi_8c_acda82bebb0a62f419eec9c1e0575daad}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!sigmaX@{sigmaX}}
\index{sigmaX@{sigmaX}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{sigma\+X()}{sigmaX()}}
{\footnotesize\ttfamily void sigmaX (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{0,1\},\{1,0\}\} -- swap $\vert$0$>$ and $\vert$1$>$. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}


Definition at line 320 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::pair\+State\+Vec, sigma\+X\+Distributed(), sigma\+X\+Local(), and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
321 \{
322         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
323         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
324 
325         \textcolor{comment}{// rank's chunk is in upper half of block }
326         \textcolor{keywordtype}{int} rankIsUpper;
327         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
328 
329         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
330                 \textcolor{comment}{// all values required to update state vector lie in this rank}
331                 \hyperlink{qubits_8c_aa9e640bb2d0458c937c6a87dfeca0f23}{sigmaXLocal}(multiQubit, rotQubit);
332         \} \textcolor{keywordflow}{else} \{
333                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
334                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
335                 pairRank = \hyperlink{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
336                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
337                 \textcolor{comment}{// get corresponding values from my pair}
338                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
339                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. sigmaX just
       replaces}
340                 \textcolor{comment}{// this rank's values with pair values}
341                 \hyperlink{qubits_8c_a5958808b2f2f05937921ba7dabe5a171}{sigmaXDistributed}(multiQubit, rotQubit,
342                         multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{// in}
343                         multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{// out}
344         \}
345 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_a7b022c75cef77be046bd5d61e38a581e}\label{qubits__env__mpi_8c_a7b022c75cef77be046bd5d61e38a581e}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!sigmaY@{sigmaY}}
\index{sigmaY@{sigmaY}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{sigma\+Y()}{sigmaY()}}
{\footnotesize\ttfamily void sigmaY (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -- swap $\vert$0$>$ and $\vert$1$>$ and apply a phase of -\/i or i. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}
fix -- put duplicate code (sigmaX, sigmaY) in seperate function 

Definition at line 380 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::pair\+State\+Vec, sigma\+Y\+Distributed(), sigma\+Y\+Local(), and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
381 \{
382         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
383         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
384 
385         \textcolor{comment}{// rank's chunk is in upper half of block }
386         \textcolor{keywordtype}{int} rankIsUpper;
387         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
388 
389         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
390                 \textcolor{comment}{// all values required to update state vector lie in this rank}
391                 \hyperlink{qubits_8c_afcbb1dcbe070ad0ed1a72a23251b6a83}{sigmaYLocal}(multiQubit, rotQubit);
392         \} \textcolor{keywordflow}{else} \{
394                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
395                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
396                 pairRank = \hyperlink{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
397                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
398                 \textcolor{comment}{// get corresponding values from my pair}
399                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
400                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. sigmaX just
       replaces}
401                 \textcolor{comment}{// this rank's values with pair values}
402                 \hyperlink{qubits_8c_a0471f6b547ce8270ef85170b7f4f0214}{sigmaYDistributed}(multiQubit,rotQubit,
403                         multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{// in}
404                         multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{// out}
405                         rankIsUpper);
406         \}
407 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}\label{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!sync\+Qu\+E\+S\+T\+Env@{sync\+Qu\+E\+S\+T\+Env}}
\index{sync\+Qu\+E\+S\+T\+Env@{sync\+Qu\+E\+S\+T\+Env}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{sync\+Qu\+E\+S\+T\+Env()}{syncQuESTEnv()}}
{\footnotesize\ttfamily void sync\+Qu\+E\+S\+T\+Env (\begin{DoxyParamCaption}\item[{\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env}}]{env }\end{DoxyParamCaption})}



Guarantees that all code up to the given point has been executed on all nodes. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 45 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by initialize\+State\+From\+Single\+File(), and report\+State\+To\+Screen().


\begin{DoxyCode}
45                                \{
46         MPI\_Barrier(MPI\_COMM\_WORLD);
47 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__env__mpi_8c_a877396e10f0e9aeead078664c51bb0e3}\label{qubits__env__mpi_8c_a877396e10f0e9aeead078664c51bb0e3}} 
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!sync\+Qu\+E\+S\+T\+Success@{sync\+Qu\+E\+S\+T\+Success}}
\index{sync\+Qu\+E\+S\+T\+Success@{sync\+Qu\+E\+S\+T\+Success}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{sync\+Qu\+E\+S\+T\+Success()}{syncQuESTSuccess()}}
{\footnotesize\ttfamily int sync\+Qu\+E\+S\+T\+Success (\begin{DoxyParamCaption}\item[{\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env}}]{env,  }\item[{int}]{success\+Code }\end{DoxyParamCaption})}



Performs a logical A\+ND on all success\+Codes held by all processes. 

If any one process has a zero success\+Code all processes will return a zero success code. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\mbox{\tt in}  & {\em success\+Code} & 1 if process task succeeded, 0 if process task failed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if all processes succeeded, 0 if any one process failed 
\end{DoxyReturn}


Definition at line 49 of file qubits\+\_\+env\+\_\+mpi.\+c.


\begin{DoxyCode}
49                                                    \{
50         \textcolor{keywordtype}{int} totalSuccess;
51         MPI\_Allreduce(&successCode, &totalSuccess, 1, MPI\_INT, MPI\_LAND, MPI\_COMM\_WORLD);
52         \textcolor{keywordflow}{return} totalSuccess;
53 \}
\end{DoxyCode}
