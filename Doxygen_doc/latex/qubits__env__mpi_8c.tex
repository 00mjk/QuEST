\hypertarget{qubits__env__mpi_8c}{}\subsection{qubits\+\_\+env\+\_\+mpi.\+c File Reference}
\label{qubits__env__mpi_8c}\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}


An implementation of the A\+PI in \hyperlink{qubits_8h}{qubits.\+h} for an M\+PI environment.  


{\ttfamily \#include $<$unistd.\+h$>$}\\*
{\ttfamily \#include $<$mpi.\+h$>$}\\*
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$math.\+h$>$}\\*
{\ttfamily \#include $<$omp.\+h$>$}\\*
{\ttfamily \#include \char`\"{}precision.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}qubits.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}qubits\+\_\+internal.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}mt19937ar.\+h\char`\"{}}\\*
{\ttfamily \#include $<$time.\+h$>$}\\*
{\ttfamily \#include $<$sys/types.\+h$>$}\\*
\subsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}
\item 
\#define \hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{D\+E\+B\+UG}~0
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero} (int chunk\+Id, long long int chunk\+Size, int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Find chunks to skip when calculating probability of qubit being zero. \end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunk\+Is\+Upper} (int chunk\+Id, long long int chunk\+Size, int target\+Qubit)
\begin{DoxyCompactList}\small\item\em Returns whether a given chunk in position chunk\+Id is in the upper or lower half of a block. \end{DoxyCompactList}\item 
static void \hyperlink{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{get\+Rot\+Angle} (int \hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunk\+Is\+Upper}, \hyperlink{structComplex}{Complex} $\ast$rot1, \hyperlink{structComplex}{Complex} $\ast$rot2, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Get rotation values for a given chunk. \end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{get\+Chunk\+Pair\+Id} (int \hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunk\+Is\+Upper}, int chunk\+Id, long long int chunk\+Size, int target\+Qubit)
\begin{DoxyCompactList}\small\item\em get position of corresponding chunk, holding values required to update values in my chunk (with chunk\+Id) when rotating target\+Qubit. \end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{half\+Matrix\+Block\+Fits\+In\+Chunk} (long long int chunk\+Size, int target\+Qubit)
\begin{DoxyCompactList}\small\item\em return whether the current qubit rotation will use blocks that fit within a single chunk. \end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{get\+Chunk\+Id\+From\+Index} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, long long int index)
\item 
void \hyperlink{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}{init\+Qu\+E\+S\+T\+Env} (\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} $\ast$env)
\begin{DoxyCompactList}\small\item\em Initialize the Qu\+E\+ST environment. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{sync\+Qu\+E\+S\+T\+Env} (\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} env)
\begin{DoxyCompactList}\small\item\em Guarantees that all code up to the given point has been executed on all nodes (if running in distributed mode) \end{DoxyCompactList}\item 
int \hyperlink{qubits__env__mpi_8c_ac7e38d768a1bd79019f88cc1e6295092}{sync\+Qu\+E\+S\+T\+Success} (int success\+Code)
\begin{DoxyCompactList}\small\item\em Performs a logical A\+ND on all success\+Codes held by all processes. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}{close\+Qu\+E\+S\+T\+Env} (\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} env)
\begin{DoxyCompactList}\small\item\em Close Qu\+E\+ST environment. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}{report\+Qu\+E\+S\+T\+Env} (\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} env)
\begin{DoxyCompactList}\small\item\em Report information about the Qu\+E\+ST environment. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}{report\+Node\+List} (\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} env)
\begin{DoxyCompactList}\small\item\em Report a list of C\+PU hostnames and the rank that is running on each if running with M\+PI enabled and an error message otherwise. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}{get\+Real\+Amp\+El} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the real component of the complex probability amplitude at an index in the state vector. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}{get\+Imag\+Amp\+El} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the imaginary component of the complex probability amplitude at an index in the state vector. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}{calc\+Total\+Probability} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Calculate the probability of being in any state by taking the norm of the entire state vector. \end{DoxyCompactList}\item 
static void \hyperlink{qubits__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}{get\+Rot\+Angle\+From\+Unitary\+Matrix} (int \hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunk\+Is\+Upper}, \hyperlink{structComplex}{Complex} $\ast$rot1, \hyperlink{structComplex}{Complex} $\ast$rot2, \hyperlink{structComplexMatrix2}{Complex\+Matrix2} u)
\begin{DoxyCompactList}\small\item\em Get rotation values for a given chunk given a unitary matrix. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchange\+State\+Vectors} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, int pair\+Rank)
\item 
void \hyperlink{qubits__env__mpi_8c_a03b13dfcabd8c59b50dbdd3af44ba8b2}{compact\+Unitary} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Apply a single-\/qubit unitary parameterised by two given complex scalars. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a7a0877e33700f6bad48adb51b7b3fb67}{unitary} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, \hyperlink{structComplexMatrix2}{Complex\+Matrix2} u)
\begin{DoxyCompactList}\small\item\em Apply a general single-\/qubit unitary (including a global phase factor). \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ab4812953bc457405b3aa05a4c2f64f4a}{controlled\+Compact\+Unitary} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int control\+Qubit, const int target\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Apply a controlled unitary (single control, single target) parameterised by two given complex scalars. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a8a701526263392599aa21d0d0f05d9d8}{controlled\+Unitary} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int control\+Qubit, const int target\+Qubit, \hyperlink{structComplexMatrix2}{Complex\+Matrix2} u)
\begin{DoxyCompactList}\small\item\em Apply a general controlled unitary (single control, single target), which can include a global phase factor. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ae395a79690283ed81106afadd7a8cd8a}{multi\+Controlled\+Unitary} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, int $\ast$control\+Qubits, const int num\+Control\+Qubits, const int target\+Qubit, \hyperlink{structComplexMatrix2}{Complex\+Matrix2} u)
\begin{DoxyCompactList}\small\item\em Apply a general multiple-\/control single-\/target unitary, which can include a global phase factor. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a86e396e06b7d527cac20ba0108872423}{sigmaX} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit sigma-\/X (also known as the X, Pauli-\/X, N\+OT or bit-\/flip) gate. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a67576895bbc65463481a8ea24d9b1e22}{controlled\+Not} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int control\+Qubit, const int target\+Qubit)
\begin{DoxyCompactList}\small\item\em Apply the controlled not (single control, single target) gate, also known as the c-\/X, c-\/sigma-\/X, c-\/\+Pauli-\/X and c-\/bit-\/flip gate. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a1f54d70a42403f7e1c2e2c2007332f61}{sigmaY} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit sigma-\/Y (also known as the Y or Pauli-\/Y) gate. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_aae7a8a7f1ccbddb7f76b6c52b746bb43}{phase\+Gate} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type} type)
\item 
void \hyperlink{qubits__env__mpi_8c_aa09b5dd93de6df1384b8f2c0041749ab}{hadamard} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit Hadamard gate. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{find\+Probability\+Of\+Outcome} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit, int outcome)
\begin{DoxyCompactList}\small\item\em Gives the probability of a specified qubit being measured in the given outcome (0 or 1). \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_a07418ebac70fd9ae5d051d089961631d}{collapse\+To\+Outcome} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit, int outcome)
\begin{DoxyCompactList}\small\item\em Updates the state vector to be consistent with measuring the measure qubit in the given outcome (0 or 1), and returns the probability of such a measurement outcome. \end{DoxyCompactList}\item 
int \hyperlink{qubits__env__mpi_8c_ad5774247d836267175c664cd0e451bcb}{measure} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measures a single qubit, collapsing it randomly to 0 or 1. \end{DoxyCompactList}\item 
int \hyperlink{qubits__env__mpi_8c_a2ac46e470c750bf93c754e06c64b0a7a}{measure\+With\+Stats} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, int measure\+Qubit, \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} $\ast$state\+Prob)
\begin{DoxyCompactList}\small\item\em Measures a single qubit, collapsing it randomly to 0 or 1, and additionally gives the probability of that outcome. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ae5f9019826f35e8b51b1716cfe397b45}{exit\+With\+Error} (int error\+Code, const char $\ast$func)
\item 
void \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{Qu\+E\+S\+T\+Assert} (int is\+Valid, int error\+Code, const char $\ast$func)
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
An implementation of the A\+PI in \hyperlink{qubits_8h}{qubits.\+h} for an M\+PI environment. 



\subsubsection{Macro Definition Documentation}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE@{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}}
\index{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE@{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}{_BSD_SOURCE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define \+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}\hypertarget{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}{}\label{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}


Definition at line 5 of file qubits\+\_\+env\+\_\+mpi.\+c.

\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!D\+E\+B\+UG@{D\+E\+B\+UG}}
\index{D\+E\+B\+UG@{D\+E\+B\+UG}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{D\+E\+B\+UG}{DEBUG}}]{\setlength{\rightskip}{0pt plus 5cm}\#define D\+E\+B\+UG~0}\hypertarget{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{}\label{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}


Definition at line 24 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by calc\+Total\+Probability(), exchange\+State\+Vectors(), and init\+Qu\+E\+S\+T\+Env().



\subsubsection{Function Documentation}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!calc\+Total\+Probability@{calc\+Total\+Probability}}
\index{calc\+Total\+Probability@{calc\+Total\+Probability}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{calc\+Total\+Probability(\+Multi\+Qubit multi\+Qubit)}{calcTotalProbability(MultiQubit multiQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} calc\+Total\+Probability (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}{}\label{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}


Calculate the probability of being in any state by taking the norm of the entire state vector. 

Should be equal to 1.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing a set of qubits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
total probability 
\end{DoxyReturn}


Definition at line 123 of file qubits\+\_\+env\+\_\+mpi.\+c.



References chunk\+Is\+Upper(), D\+E\+B\+UG, Complex\+Array\+::imag, M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Chunks, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
123                                                 \{
124   \textcolor{comment}{/* IJB - implemented using Kahan summation for greater accuracy at a slight floating}
125 \textcolor{comment}{     point operation overhead. For more details see https://en.wikipedia.org/wiki/Kahan\_summation\_algorithm
       */}
126   \textcolor{comment}{/* Don't change the bracketing in this routine! */}
127   \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} pTotal=0; 
128   \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} y, t, c;
129   \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} allRankTotals=0;
130   \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
131   \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numAmpsPerRank = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
132   c = 0.0;
133   \textcolor{keywordflow}{for} (index=0; index<numAmpsPerRank; index++)\{ 
134     \textcolor{comment}{/* Perform pTotal+=multiQubit.stateVec.real[index]*multiQubit.stateVec.real[index]; by Kahan */}
135     y = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[index]*multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.
      \hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[index] - c;
136     t = pTotal + y;
137     c = ( t - pTotal ) - y;
138     pTotal = t;
139     \textcolor{comment}{/* Perform pTotal+=multiQubit.stateVec.imag[index]*multiQubit.stateVec.imag[index]; by Kahan */}
140     y = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[index]*multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[index] - c;
141     t = pTotal + y;
142     c = ( t - pTotal ) - y;
143     pTotal = t;
144   \} 
145   \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"before calc prob. %d\(\backslash\)n"}, multiQubit.\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks});
146   \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks}>1) MPI\_Allreduce(&pTotal, &allRankTotals, 1, 
      \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, MPI\_SUM, MPI\_COMM\_WORLD);
147   \textcolor{keywordflow}{else} allRankTotals=pTotal;
148   
149   \textcolor{keywordflow}{return} allRankTotals;
150 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!chunk\+Is\+Upper@{chunk\+Is\+Upper}}
\index{chunk\+Is\+Upper@{chunk\+Is\+Upper}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{chunk\+Is\+Upper(int chunk\+Id, long long int chunk\+Size, int target\+Qubit)}{chunkIsUpper(int chunkId, long long int chunkSize, int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}static int chunk\+Is\+Upper (
\begin{DoxyParamCaption}
\item[{int}]{chunk\+Id, }
\item[{long long int}]{chunk\+Size, }
\item[{int}]{target\+Qubit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{}\label{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}


Returns whether a given chunk in position chunk\+Id is in the upper or lower half of a block. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Id} & id of chunk in state vector \\
\hline
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit being rotated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1\+: chunk is in upper half of block, 0\+: chunk is in lower half of block fix -- is this the same as is\+Chunk\+To\+Skip? 
\end{DoxyReturn}


Definition at line 161 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by calc\+Total\+Probability(), compact\+Unitary(), controlled\+Compact\+Unitary(), controlled\+Not(), controlled\+Unitary(), hadamard(), multi\+Controlled\+Unitary(), phase\+Gate(), sigma\+X(), sigma\+Y(), and unitary().


\begin{DoxyCode}
162 \{       
163         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (targetQubit);
164         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock = sizeHalfBlock*2;
165         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} posInBlock = (chunkId*chunkSize) % sizeBlock;
166         \textcolor{keywordflow}{return} posInBlock<sizeHalfBlock;
167 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!close\+Qu\+E\+S\+T\+Env@{close\+Qu\+E\+S\+T\+Env}}
\index{close\+Qu\+E\+S\+T\+Env@{close\+Qu\+E\+S\+T\+Env}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{close\+Qu\+E\+S\+T\+Env(\+Qu\+E\+S\+T\+Env env)}{closeQuESTEnv(QuESTEnv env)}}]{\setlength{\rightskip}{0pt plus 5cm}void close\+Qu\+E\+S\+T\+Env (
\begin{DoxyParamCaption}
\item[{{\bf Qu\+E\+S\+T\+Env}}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}{}\label{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}


Close Qu\+E\+ST environment. 

If something needs to be done to clean up the execution environment, such as finalizing M\+PI when running in distributed mode, it is handled here


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 71 of file qubits\+\_\+env\+\_\+mpi.\+c.


\begin{DoxyCode}
71                                 \{
72         \textcolor{keywordtype}{int} finalized;
73         MPI\_Finalized(&finalized);
74         \textcolor{keywordflow}{if} (!finalized) MPI\_Finalize();
75         \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"ERROR: Trying to close QuESTEnv multiple times. Ignoring\(\backslash\)n"});
76 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!collapse\+To\+Outcome@{collapse\+To\+Outcome}}
\index{collapse\+To\+Outcome@{collapse\+To\+Outcome}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{collapse\+To\+Outcome(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit, int outcome)}{collapseToOutcome(MultiQubit multiQubit, const int measureQubit, int outcome)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} collapse\+To\+Outcome (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit, }
\item[{int}]{outcome}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a07418ebac70fd9ae5d051d089961631d}{}\label{qubits__env__mpi_8c_a07418ebac70fd9ae5d051d089961631d}


Updates the state vector to be consistent with measuring the measure qubit in the given outcome (0 or 1), and returns the probability of such a measurement outcome. 

This is effectively performing a measurement and forcing the outcome. This is an irreversible change to the state vector, whereby incompatible states in the state vector are given zero amplitude and the remaining states are renormalised. Exits with error if the given outcome has $\sim$zero probability, and so cannot be collapsed into.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em outcome} & to force the measure qubit to enter \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of the (forced) measurement outcome 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily measure\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}), or if {\ttfamily outcome} is not in \{0, 1\}, or if the probability of {\ttfamily outcome} is zero (within machine epsilon) \\
\hline
\end{DoxyExceptions}


Definition at line 691 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, collapse\+To\+Outcome\+Distributed\+Renorm(), collapse\+To\+Outcome\+Distributed\+Set\+Zero(), collapse\+To\+Outcome\+Local(), find\+Probability\+Of\+Outcome(), half\+Matrix\+Block\+Fits\+In\+Chunk(), is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Qu\+E\+S\+T\+Assert(), R\+E\+AL, and R\+E\+A\+L\+\_\+\+E\+PS.


\begin{DoxyCode}
692 \{
693     \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(measureQubit >= 0 && measureQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 2, \_\_func\_\_);
694 
695         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} totalStateProb=\hyperlink{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{findProbabilityOfOutcome}(multiQubit, measureQubit, 
      outcome);
696     \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(fabs(totalStateProb>\hyperlink{precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS}), 8, \_\_func\_\_);
697 
698         \textcolor{keywordtype}{int} skipValuesWithinRank = \hyperlink{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, measureQubit);
699     \textcolor{keywordflow}{if} (skipValuesWithinRank) \{
700         \hyperlink{qubits_8c_a01d9a8b7ff0e09ec399e158389783aa9}{collapseToOutcomeLocal}(multiQubit, measureQubit, totalStateProb, outcome);
701     \} \textcolor{keywordflow}{else} \{
702         \textcolor{keywordflow}{if} (!\hyperlink{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{isChunkToSkipInFindPZero}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, measureQubit))\{
703             \textcolor{comment}{// chunk has amps for q=0}
704             \textcolor{keywordflow}{if} (outcome==0) \hyperlink{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm}(multiQubit
      , measureQubit, 
705                     totalStateProb);
706             \textcolor{keywordflow}{else} \hyperlink{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero}(multiQubit, 
      measureQubit);
707         \} \textcolor{keywordflow}{else} \{
708             \textcolor{comment}{// chunk has amps for q=1}
709             \textcolor{keywordflow}{if} (outcome==1) \hyperlink{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm}(multiQubit
      , measureQubit, 
710                     totalStateProb);
711             \textcolor{keywordflow}{else} \hyperlink{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero}(multiQubit, 
      measureQubit);
712         \}
713     \}
714         \textcolor{keywordflow}{return} totalStateProb;
715 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!compact\+Unitary@{compact\+Unitary}}
\index{compact\+Unitary@{compact\+Unitary}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{compact\+Unitary(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, Complex alpha, Complex beta)}{compactUnitary(MultiQubit multiQubit, const int targetQubit, Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}void compact\+Unitary (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a03b13dfcabd8c59b50dbdd3af44ba8b2}{}\label{qubits__env__mpi_8c_a03b13dfcabd8c59b50dbdd3af44ba8b2}


Apply a single-\/qubit unitary parameterised by two given complex scalars. 

Given valid complex numbers $\alpha$ and $\beta$, applies the unitary \[ U = \begin{pmatrix} \alpha & -\beta^* \\ \beta & \alpha^* \end{pmatrix} \] which is general up to a global phase factor. Valid $\alpha$, $\beta$ satisfy $|\alpha|^2 + |\beta|^2 = 1$.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {U}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to operate on \\
\hline
\mbox{\tt in}  & {\em alpha} & complex unitary parameter (row 1, column 1) \\
\hline
\mbox{\tt in}  & {\em beta} & complex unitary parameter (row 2, column 1) \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily target\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}), or if {\ttfamily alpha}, {\ttfamily beta} don\textquotesingle{}t satisfy $\vert${\ttfamily alpha$\vert$$^\wedge$2} + $\vert${\ttfamily beta$\vert$$^\wedge$2} = 1. \\
\hline
\end{DoxyExceptions}


Definition at line 285 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), compact\+Unitary\+Distributed(), compact\+Unitary\+Local(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), get\+Rot\+Angle(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), Multi\+Qubit\+::state\+Vec, and validate\+Alpha\+Beta().



Referenced by rotate\+Around\+Axis(), rotate\+X(), rotate\+Y(), and rotate\+Z().


\begin{DoxyCode}
286 \{
287         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(targetQubit >= 0 && targetQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 1, \_\_func\_\_);
288         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(\hyperlink{qubits_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}{validateAlphaBeta}(alpha, beta), 6, \_\_func\_\_);
289 
290         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
291         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
292         \hyperlink{structComplex}{Complex} rot1, rot2;
293 
294         \textcolor{comment}{// rank's chunk is in upper half of block }
295         \textcolor{keywordtype}{int} rankIsUpper;
296         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
297 
298         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
299                 \textcolor{comment}{// all values required to update state vector lie in this rank}
300                 \hyperlink{qubits_8c_a9cee2d8716667a3318420a3b672f5b92}{compactUnitaryLocal}(multiQubit, targetQubit, alpha, beta);
301         \} \textcolor{keywordflow}{else} \{
302                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
303                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
304                 \hyperlink{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{getRotAngle}(rankIsUpper, &rot1, &rot2, alpha, beta);
305                 pairRank = \hyperlink{qubits__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
306                 \textcolor{comment}{// get corresponding values from my pair}
307                         \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
308 
309                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. }
310                         \textcolor{comment}{// send values to compactUnitaryDistributed in the correct order}
311                 \textcolor{keywordflow}{if} (rankIsUpper)\{
312                         \hyperlink{qubits_8c_a20ee1878a63ae6112e8845f4a8787592}{compactUnitaryDistributed}(multiQubit,targetQubit,rot1,rot2
      ,
313                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//upper}
314                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//lower}
315                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
316                 \} \textcolor{keywordflow}{else} \{
317                         \hyperlink{qubits_8c_a20ee1878a63ae6112e8845f4a8787592}{compactUnitaryDistributed}(multiQubit,targetQubit,rot1,rot2
      ,
318                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//upper}
319                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//lower}
320                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
321                 \}
322         \}
323 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!controlled\+Compact\+Unitary@{controlled\+Compact\+Unitary}}
\index{controlled\+Compact\+Unitary@{controlled\+Compact\+Unitary}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{controlled\+Compact\+Unitary(\+Multi\+Qubit multi\+Qubit, const int control\+Qubit, const int target\+Qubit, Complex alpha, Complex beta)}{controlledCompactUnitary(MultiQubit multiQubit, const int controlQubit, const int targetQubit, Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}void controlled\+Compact\+Unitary (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_ab4812953bc457405b3aa05a4c2f64f4a}{}\label{qubits__env__mpi_8c_ab4812953bc457405b3aa05a4c2f64f4a}


Apply a controlled unitary (single control, single target) parameterised by two given complex scalars. 

Given valid complex numbers $\alpha$ and $\beta$, applies the two-\/qubit unitary \[ \begin{pmatrix} 1 \\ & 1 \\ & & \alpha & -\beta^* \\ & & \beta & \alpha^* \end{pmatrix} \] to the control and target qubits. Valid $\alpha$, $\beta$ satisfy $|\alpha|^2 + |\beta|^2 = 1$. The target unitary is general up to a global phase factor.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {control}; \node[draw=none] at (-3.5, 0) {target}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 1); \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$U_{\alpha, \beta}$}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & apply the target unitary if this qubit has value 1 \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit on which to apply the target unitary \\
\hline
\mbox{\tt in}  & {\em alpha} & complex unitary parameter (row 1, column 1) \\
\hline
\mbox{\tt in}  & {\em beta} & complex unitary parameter (row 2, column 1) \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if either {\ttfamily control\+Qubit} or {\ttfamily target\+Qubit} are outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}) or are equal, or if {\ttfamily alpha}, {\ttfamily beta} don\textquotesingle{}t satisfy $\vert${\ttfamily alpha$\vert$$^\wedge$2} + $\vert${\ttfamily beta$\vert$$^\wedge$2} = 1. \\
\hline
\end{DoxyExceptions}


Definition at line 367 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), controlled\+Compact\+Unitary\+Distributed(), controlled\+Compact\+Unitary\+Local(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), get\+Rot\+Angle(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), Multi\+Qubit\+::state\+Vec, and validate\+Alpha\+Beta().


\begin{DoxyCode}
368 \{
369         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(targetQubit >= 0 && targetQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 1, \_\_func\_\_);
370         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(controlQubit >= 0 && controlQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 2, \_\_func\_\_);
371         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(controlQubit != targetQubit, 3, \_\_func\_\_);
372         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(\hyperlink{qubits_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}{validateAlphaBeta}(alpha, beta), 6, \_\_func\_\_);
373 
374         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
375         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
376         \hyperlink{structComplex}{Complex} rot1, rot2;
377 
378         \textcolor{comment}{// rank's chunk is in upper half of block }
379         \textcolor{keywordtype}{int} rankIsUpper;
380         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
381 
382         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
383                 \textcolor{comment}{// all values required to update state vector lie in this rank}
384                 \hyperlink{qubits_8c_afc77657651d52c47403b44b923a098a8}{controlledCompactUnitaryLocal}(multiQubit, controlQubit, 
      targetQubit, alpha, beta);
385         \} \textcolor{keywordflow}{else} \{
386                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
387                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
388                 \hyperlink{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{getRotAngle}(rankIsUpper, &rot1, &rot2, alpha, beta);
389                 pairRank = \hyperlink{qubits__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
390                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
391                 \textcolor{comment}{// get corresponding values from my pair}
392                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
393                 
394                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. send values to
       controlledCompactUnitaryDistributed}
395                 \textcolor{comment}{// in the correct order}
396                 \textcolor{keywordflow}{if} (rankIsUpper)\{
397                         \hyperlink{qubits_8c_a717855e835e3161e08c18cdc15325d27}{controlledCompactUnitaryDistributed}(multiQubit,
      controlQubit,targetQubit,rot1,rot2,
398                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//upper}
399                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//lower}
400                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
401                 \} \textcolor{keywordflow}{else} \{
402                         \hyperlink{qubits_8c_a717855e835e3161e08c18cdc15325d27}{controlledCompactUnitaryDistributed}(multiQubit,
      controlQubit,targetQubit,rot1,rot2,
403                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//upper}
404                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//lower}
405                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
406                 \}
407         \}
408 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!controlled\+Not@{controlled\+Not}}
\index{controlled\+Not@{controlled\+Not}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{controlled\+Not(\+Multi\+Qubit multi\+Qubit, const int control\+Qubit, const int target\+Qubit)}{controlledNot(MultiQubit multiQubit, const int controlQubit, const int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void controlled\+Not (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{const int}]{target\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a67576895bbc65463481a8ea24d9b1e22}{}\label{qubits__env__mpi_8c_a67576895bbc65463481a8ea24d9b1e22}


Apply the controlled not (single control, single target) gate, also known as the c-\/X, c-\/sigma-\/X, c-\/\+Pauli-\/X and c-\/bit-\/flip gate. 

This applies sigmaX to the target qubit if the control qubit has value 1. This effects the two-\/qubit unitary \[ \begin{pmatrix} 1 \\ & 1 \\\ & & & 1 \\ & & 1 \end{pmatrix} \] on the control and target qubits.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {control}; \node[draw=none] at (-3.5, 0) {target}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, -.5); \draw (-2,0) -- (2, 0); \draw (0, 0) circle (.5); \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & nots the target if this qubit is 1 \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to not \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if either {\ttfamily control\+Qubit} or {\ttfamily target\+Qubit} are outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}), or are equal. \\
\hline
\end{DoxyExceptions}


Definition at line 529 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), controlled\+Not\+Distributed(), controlled\+Not\+Local(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
530 \{
531         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(targetQubit >= 0 && targetQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 1, \_\_func\_\_);
532         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(controlQubit >= 0 && controlQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 2, \_\_func\_\_);
533         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(controlQubit != targetQubit, 3, \_\_func\_\_);
534 
535         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
536         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
537 
538         \textcolor{comment}{// rank's chunk is in upper half of block }
539         \textcolor{keywordtype}{int} rankIsUpper;
540         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
541 
542         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
543                 \textcolor{comment}{// all values required to update state vector lie in this rank}
544                 \hyperlink{qubits_8c_ad357a43e80e3baf013975b1b70942f4c}{controlledNotLocal}(multiQubit, controlQubit, targetQubit);
545         \} \textcolor{keywordflow}{else} \{
546                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
547                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
548                 pairRank = \hyperlink{qubits__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
549                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
550                 \textcolor{comment}{// get corresponding values from my pair}
551                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
552                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. send values to
       controlledNot}
553                 \textcolor{comment}{// in the correct order}
554                 \textcolor{keywordflow}{if} (rankIsUpper)\{
555                         \hyperlink{qubits_8c_a05875a70b539a3efb28d027823403f34}{controlledNotDistributed}(multiQubit,controlQubit,
      targetQubit,
556                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//in}
557                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//out}
558                 \} \textcolor{keywordflow}{else} \{
559                         \hyperlink{qubits_8c_a05875a70b539a3efb28d027823403f34}{controlledNotDistributed}(multiQubit,controlQubit,
      targetQubit,
560                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//in}
561                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//out}
562                 \}
563         \}
564 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!controlled\+Unitary@{controlled\+Unitary}}
\index{controlled\+Unitary@{controlled\+Unitary}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{controlled\+Unitary(\+Multi\+Qubit multi\+Qubit, const int control\+Qubit, const int target\+Qubit, Complex\+Matrix2 u)}{controlledUnitary(MultiQubit multiQubit, const int controlQubit, const int targetQubit, ComplexMatrix2 u)}}]{\setlength{\rightskip}{0pt plus 5cm}void controlled\+Unitary (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex\+Matrix2}}]{u}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a8a701526263392599aa21d0d0f05d9d8}{}\label{qubits__env__mpi_8c_a8a701526263392599aa21d0d0f05d9d8}


Apply a general controlled unitary (single control, single target), which can include a global phase factor. 

The given unitary is applied to the target qubit if the control qubit has value 1, effecting the two-\/qubit unitary \[ \begin{pmatrix} 1 \\ & 1 \\ & & u_{00} & u_{01}\\ & & u_{10} & u_{11} \end{pmatrix} \] on the control and target qubits.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {control}; \node[draw=none] at (-3.5, 0) {target}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 1); \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {U}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & apply unitary if this qubit is 1 \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to operate on \\
\hline
\mbox{\tt in}  & {\em u} & single-\/qubit unitary matrix to apply \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if either {\ttfamily control\+Qubit} or {\ttfamily target\+Qubit} are outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}) or are equal, or if {\ttfamily u} is not unitary. \\
\hline
\end{DoxyExceptions}


Definition at line 410 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), controlled\+Unitary\+Distributed(), controlled\+Unitary\+Local(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), get\+Rot\+Angle\+From\+Unitary\+Matrix(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), Multi\+Qubit\+::state\+Vec, and validate\+Matrix\+Is\+Unitary().


\begin{DoxyCode}
412 \{
413         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(targetQubit >= 0 && targetQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 1, \_\_func\_\_);
414         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(controlQubit >= 0 && controlQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 2, \_\_func\_\_);
415         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(controlQubit != targetQubit, 3, \_\_func\_\_);
416         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(\hyperlink{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}{validateMatrixIsUnitary}(u), 5, \_\_func\_\_);
417 
418         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
419         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
420         \hyperlink{structComplex}{Complex} rot1, rot2;
421 
422         \textcolor{comment}{// rank's chunk is in upper half of block }
423         \textcolor{keywordtype}{int} rankIsUpper;
424         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
425 
426         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
427                 \textcolor{comment}{// all values required to update state vector lie in this rank}
428                 \hyperlink{qubits_8c_a8a4afcff70195a306c082b8ed8d4e09a}{controlledUnitaryLocal}(multiQubit, controlQubit, targetQubit, u);
429         \} \textcolor{keywordflow}{else} \{
430                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
431                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
432                 \hyperlink{qubits__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}{getRotAngleFromUnitaryMatrix}(rankIsUpper, &rot1, &rot2, u);
433                 pairRank = \hyperlink{qubits__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
434                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
435                 \textcolor{comment}{// get corresponding values from my pair}
436                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
437                 
438                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. send values to
       controlledUnitaryDistributed}
439                 \textcolor{comment}{// in the correct order}
440                 \textcolor{keywordflow}{if} (rankIsUpper)\{
441                         \hyperlink{qubits_8c_a642093063a1f889f61a1311f6d6f2d3f}{controlledUnitaryDistributed}(multiQubit,controlQubit,
      targetQubit,rot1,rot2,
442                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//upper}
443                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//lower}
444                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
445                 \} \textcolor{keywordflow}{else} \{
446                         \hyperlink{qubits_8c_a642093063a1f889f61a1311f6d6f2d3f}{controlledUnitaryDistributed}(multiQubit,controlQubit,
      targetQubit,rot1,rot2,
447                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//upper}
448                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//lower}
449                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
450                 \}
451         \}
452 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!exchange\+State\+Vectors@{exchange\+State\+Vectors}}
\index{exchange\+State\+Vectors@{exchange\+State\+Vectors}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{exchange\+State\+Vectors(\+Multi\+Qubit multi\+Qubit, int pair\+Rank)}{exchangeStateVectors(MultiQubit multiQubit, int pairRank)}}]{\setlength{\rightskip}{0pt plus 5cm}void exchange\+State\+Vectors (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{int}]{pair\+Rank}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{}\label{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}


Definition at line 253 of file qubits\+\_\+env\+\_\+mpi.\+c.



References D\+E\+B\+UG, Complex\+Array\+::imag, M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::pair\+State\+Vec, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by compact\+Unitary(), controlled\+Compact\+Unitary(), controlled\+Not(), controlled\+Unitary(), hadamard(), multi\+Controlled\+Unitary(), sigma\+X(), sigma\+Y(), and unitary().


\begin{DoxyCode}
253                                                               \{
254         \textcolor{comment}{// MPI send/receive vars}
255         \textcolor{keywordtype}{int} TAG=100;
256         MPI\_Status status;
257 
258         \textcolor{comment}{// Multiple messages are required as MPI uses int rather than long long int for count}
259         \textcolor{comment}{// For openmpi, messages are further restricted to 2GB in size -- do this for all cases}
260         \textcolor{comment}{// to be safe}
261         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} maxMessageCount = 1LL<<29;
262         \textcolor{keywordflow}{if} (\textcolor{keyword}{sizeof}(\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL})==8) maxMessageCount = (1LL<<28);
263         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\textcolor{keyword}{sizeof}(\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL})==16) maxMessageCount = (1LL<<27);
264 
265         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}<maxMessageCount) maxMessageCount = multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
266         \textcolor{keywordtype}{int} numMessages = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}/maxMessageCount;
267         \textcolor{keywordtype}{int} i;
268         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} offset;
269         \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"numMessages %d maxMessageCount %lld\(\backslash\)n"}, numMessages, maxMessageCount);
270 
271         \textcolor{comment}{// send my state vector to pairRank's multiQubit.pairStateVec}
272         \textcolor{comment}{// receive pairRank's state vector into multiQubit.pairStateVec}
273         \textcolor{keywordflow}{for} (i=0; i<numMessages; i++)\{
274                 offset = i*maxMessageCount;
275                 MPI\_Sendrecv(&multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[offset], maxMessageCount, 
      \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, pairRank, TAG,
276                                  &multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[offset], maxMessageCount, 
      \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL},
277                                  pairRank, TAG, MPI\_COMM\_WORLD, &status);
278                 \textcolor{comment}{//printf("rank: %d err: %d\(\backslash\)n", multiQubit.rank, err);}
279                 MPI\_Sendrecv(&multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[offset], maxMessageCount, 
      \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, pairRank, TAG,
280                                 &multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[offset], maxMessageCount, 
      \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL},
281                                 pairRank, TAG, MPI\_COMM\_WORLD, &status);
282         \}
283 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!exit\+With\+Error@{exit\+With\+Error}}
\index{exit\+With\+Error@{exit\+With\+Error}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{exit\+With\+Error(int error\+Code, const char $\ast$func)}{exitWithError(int errorCode, const char *func)}}]{\setlength{\rightskip}{0pt plus 5cm}void exit\+With\+Error (
\begin{DoxyParamCaption}
\item[{int}]{error\+Code, }
\item[{const char $\ast$}]{func}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_ae5f9019826f35e8b51b1716cfe397b45}{}\label{qubits__env__mpi_8c_ae5f9019826f35e8b51b1716cfe397b45}


Definition at line 764 of file qubits\+\_\+env\+\_\+mpi.\+c.



References error\+Codes.



Referenced by Qu\+E\+S\+T\+Assert().


\begin{DoxyCode}
764                                                    \{
765     printf(\textcolor{stringliteral}{"!!!\(\backslash\)n"});
766     printf(\textcolor{stringliteral}{"QuEST Error in function %s: %s\(\backslash\)n"}, func, \hyperlink{qubits_8c_aac1637696885c75b73a1ecf381cea713}{errorCodes}[errorCode]);
767     printf(\textcolor{stringliteral}{"!!!\(\backslash\)n"});
768     printf(\textcolor{stringliteral}{"exiting..\(\backslash\)n"});
769     MPI\_Abort(MPI\_COMM\_WORLD, errorCode);
770 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!find\+Probability\+Of\+Outcome@{find\+Probability\+Of\+Outcome}}
\index{find\+Probability\+Of\+Outcome@{find\+Probability\+Of\+Outcome}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{find\+Probability\+Of\+Outcome(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit, int outcome)}{findProbabilityOfOutcome(MultiQubit multiQubit, const int measureQubit, int outcome)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} find\+Probability\+Of\+Outcome (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit, }
\item[{int}]{outcome}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{}\label{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}


Gives the probability of a specified qubit being measured in the given outcome (0 or 1). 

This performs no actual measurement and does not change the state of the qubits.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to study \\
\hline
\mbox{\tt in}  & {\em outcome} & for which to find the probability of the qubit being measured in \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being measured in the given outcome 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily measure\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}), or if {\ttfamily outcome} is not in \{0, 1\}. \\
\hline
\end{DoxyExceptions}


Definition at line 672 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, find\+Probability\+Of\+Zero\+Distributed(), find\+Probability\+Of\+Zero\+Local(), half\+Matrix\+Block\+Fits\+In\+Chunk(), is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero(), M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Qu\+E\+S\+T\+Assert(), and R\+E\+AL.



Referenced by collapse\+To\+Outcome(), and measure\+With\+Stats().


\begin{DoxyCode}
673 \{
674     \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(measureQubit >= 0 && measureQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 2, \_\_func\_\_);
675 
676         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateProb=0, totalStateProb=0;
677         \textcolor{keywordtype}{int} skipValuesWithinRank = \hyperlink{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, measureQubit);
678         \textcolor{keywordflow}{if} (skipValuesWithinRank) \{
679                 stateProb = \hyperlink{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}{findProbabilityOfZeroLocal}(multiQubit, measureQubit);
680         \} \textcolor{keywordflow}{else} \{
681                 \textcolor{keywordflow}{if} (!\hyperlink{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{isChunkToSkipInFindPZero}(multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, measureQubit))\{
682                         stateProb = \hyperlink{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}{findProbabilityOfZeroDistributed}(
      multiQubit, measureQubit);
683                 \} \textcolor{keywordflow}{else} stateProb = 0;
684         \}
685         MPI\_Allreduce(&stateProb, &totalStateProb, 1, \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, MPI\_SUM, MPI\_COMM\_WORLD
      );
686         \textcolor{keywordflow}{if} (outcome==1) totalStateProb = 1.0 - totalStateProb;
687         \textcolor{keywordflow}{return} totalStateProb;
688 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Chunk\+Id\+From\+Index@{get\+Chunk\+Id\+From\+Index}}
\index{get\+Chunk\+Id\+From\+Index@{get\+Chunk\+Id\+From\+Index}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{get\+Chunk\+Id\+From\+Index(\+Multi\+Qubit multi\+Qubit, long long int index)}{getChunkIdFromIndex(MultiQubit multiQubit, long long int index)}}]{\setlength{\rightskip}{0pt plus 5cm}int get\+Chunk\+Id\+From\+Index (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{long long int}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{}\label{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}


Definition at line 99 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::num\+Amps.



Referenced by get\+Imag\+Amp\+El(), and get\+Real\+Amp\+El().


\begin{DoxyCode}
99                                                                    \{
100         \textcolor{keywordflow}{return} index/multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}; \textcolor{comment}{// this is numAmpsPerChunk}
101 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Chunk\+Pair\+Id@{get\+Chunk\+Pair\+Id}}
\index{get\+Chunk\+Pair\+Id@{get\+Chunk\+Pair\+Id}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{get\+Chunk\+Pair\+Id(int chunk\+Is\+Upper, int chunk\+Id, long long int chunk\+Size, int target\+Qubit)}{getChunkPairId(int chunkIsUpper, int chunkId, long long int chunkSize, int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}static int get\+Chunk\+Pair\+Id (
\begin{DoxyParamCaption}
\item[{int}]{chunk\+Is\+Upper, }
\item[{int}]{chunk\+Id, }
\item[{long long int}]{chunk\+Size, }
\item[{int}]{target\+Qubit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{}\label{qubits__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}


get position of corresponding chunk, holding values required to update values in my chunk (with chunk\+Id) when rotating target\+Qubit. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Is\+Upper} & 1\+: chunk is in upper half of block, 0\+: chunk is in lower half \\
\hline
\mbox{\tt in}  & {\em chunk\+Id} & id of chunk in state vector \\
\hline
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit being rotated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
chunk\+Id of chunk required to rotate target\+Qubit 
\end{DoxyReturn}


Definition at line 228 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by compact\+Unitary(), controlled\+Compact\+Unitary(), controlled\+Not(), controlled\+Unitary(), hadamard(), multi\+Controlled\+Unitary(), sigma\+X(), sigma\+Y(), and unitary().


\begin{DoxyCode}
229 \{
230         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (targetQubit);
231         \textcolor{keywordtype}{int} chunksPerHalfBlock = sizeHalfBlock/chunkSize;
232         \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper})\{
233                 \textcolor{keywordflow}{return} chunkId + chunksPerHalfBlock;
234         \} \textcolor{keywordflow}{else} \{
235                 \textcolor{keywordflow}{return} chunkId - chunksPerHalfBlock;
236         \}
237 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Imag\+Amp\+El@{get\+Imag\+Amp\+El}}
\index{get\+Imag\+Amp\+El@{get\+Imag\+Amp\+El}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{get\+Imag\+Amp\+El(\+Multi\+Qubit multi\+Qubit, long long int index)}{getImagAmpEl(MultiQubit multiQubit, long long int index)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} get\+Imag\+Amp\+El (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{long long int}]{index}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}{}\label{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}


Get the imaginary component of the complex probability amplitude at an index in the state vector. 

For debugging purposes.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing a set of qubits \\
\hline
\mbox{\tt in}  & {\em index} & index in state vector of probability amplitudes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
imaginary component at that index 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily index} is outside \mbox{[}0, $2^{N}$) where $N = $ {\ttfamily multi\+Qubit.\+num\+Qubits} \\
\hline
\end{DoxyExceptions}


Definition at line 113 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, get\+Chunk\+Id\+From\+Index(), Complex\+Array\+::imag, M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by get\+Prob\+El().


\begin{DoxyCode}
113                                                              \{
114         \textcolor{keywordtype}{int} chunkId = \hyperlink{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{getChunkIdFromIndex}(multiQubit, index);
115         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} el; 
116         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}==chunkId)\{
117                 el = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[index-chunkId*multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}];
118         \}
119         MPI\_Bcast(&el, 1, \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, chunkId, MPI\_COMM\_WORLD);
120         \textcolor{keywordflow}{return} el; 
121 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Real\+Amp\+El@{get\+Real\+Amp\+El}}
\index{get\+Real\+Amp\+El@{get\+Real\+Amp\+El}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{get\+Real\+Amp\+El(\+Multi\+Qubit multi\+Qubit, long long int index)}{getRealAmpEl(MultiQubit multiQubit, long long int index)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} get\+Real\+Amp\+El (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{long long int}]{index}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}{}\label{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}


Get the real component of the complex probability amplitude at an index in the state vector. 

For debugging purposes.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing a set of qubits \\
\hline
\mbox{\tt in}  & {\em index} & index in state vector of probability amplitudes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
real component at that index 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily index} is outside \mbox{[}0, $2^{N}$) where $N = $ {\ttfamily multi\+Qubit.\+num\+Qubits} \\
\hline
\end{DoxyExceptions}


Definition at line 103 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, get\+Chunk\+Id\+From\+Index(), M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by get\+Prob\+El().


\begin{DoxyCode}
103                                                              \{
104         \textcolor{keywordtype}{int} chunkId = \hyperlink{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{getChunkIdFromIndex}(multiQubit, index);
105         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} el; 
106         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}==chunkId)\{
107                 el = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[index-chunkId*multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}];
108         \}
109         MPI\_Bcast(&el, 1, \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, chunkId, MPI\_COMM\_WORLD);
110         \textcolor{keywordflow}{return} el; 
111 \} 
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Rot\+Angle@{get\+Rot\+Angle}}
\index{get\+Rot\+Angle@{get\+Rot\+Angle}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{get\+Rot\+Angle(int chunk\+Is\+Upper, Complex $\ast$rot1, Complex $\ast$rot2, Complex alpha, Complex beta)}{getRotAngle(int chunkIsUpper, Complex *rot1, Complex *rot2, Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}static void get\+Rot\+Angle (
\begin{DoxyParamCaption}
\item[{int}]{chunk\+Is\+Upper, }
\item[{{\bf Complex} $\ast$}]{rot1, }
\item[{{\bf Complex} $\ast$}]{rot2, }
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{}\label{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}


Get rotation values for a given chunk. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Is\+Upper} & 1\+: chunk is in upper half of block, 0\+: chunk is in lower half\\
\hline
\mbox{\tt out}  & {\em rot1,rot2} & rotation values to use, allocated for upper/lower such that \begin{DoxyVerb}stateUpper = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 or \begin{DoxyVerb}stateLower = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em alpha,beta} & initial rotation values \\
\hline
\end{DoxyParams}


Definition at line 183 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Complex\+::imag, and Complex\+::real.



Referenced by compact\+Unitary(), and controlled\+Compact\+Unitary().


\begin{DoxyCode}
184 \{
185         \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper})\{
186                 *rot1=alpha;
187                 rot2->\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}=-beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
188                 rot2->\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}=-beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
189         \} \textcolor{keywordflow}{else} \{
190                 *rot1=beta;
191                 *rot2=alpha;
192         \}
193 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Rot\+Angle\+From\+Unitary\+Matrix@{get\+Rot\+Angle\+From\+Unitary\+Matrix}}
\index{get\+Rot\+Angle\+From\+Unitary\+Matrix@{get\+Rot\+Angle\+From\+Unitary\+Matrix}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{get\+Rot\+Angle\+From\+Unitary\+Matrix(int chunk\+Is\+Upper, Complex $\ast$rot1, Complex $\ast$rot2, Complex\+Matrix2 u)}{getRotAngleFromUnitaryMatrix(int chunkIsUpper, Complex *rot1, Complex *rot2, ComplexMatrix2 u)}}]{\setlength{\rightskip}{0pt plus 5cm}static void get\+Rot\+Angle\+From\+Unitary\+Matrix (
\begin{DoxyParamCaption}
\item[{int}]{chunk\+Is\+Upper, }
\item[{{\bf Complex} $\ast$}]{rot1, }
\item[{{\bf Complex} $\ast$}]{rot2, }
\item[{{\bf Complex\+Matrix2}}]{u}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}{}\label{qubits__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}


Get rotation values for a given chunk given a unitary matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Is\+Upper} & 1\+: chunk is in upper half of block, 0\+: chunk is in lower half\\
\hline
\mbox{\tt out}  & {\em rot1,rot2} & rotation values to use, allocated for upper/lower such that \begin{DoxyVerb}stateUpper = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 or \begin{DoxyVerb}stateLower = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 \\
\hline
\mbox{\tt in}  & {\em u} & unitary matrix operation \\
\hline
\end{DoxyParams}


Definition at line 208 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Complex\+Matrix2\+::r0c0, Complex\+Matrix2\+::r0c1, Complex\+Matrix2\+::r1c0, and Complex\+Matrix2\+::r1c1.



Referenced by controlled\+Unitary(), multi\+Controlled\+Unitary(), and unitary().


\begin{DoxyCode}
209 \{
210         \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper})\{
211                 *rot1=u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0};
212                 *rot2=u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1};
213         \} \textcolor{keywordflow}{else} \{
214                 *rot1=u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0};
215                 *rot2=u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1};
216         \}
217 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!hadamard@{hadamard}}
\index{hadamard@{hadamard}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{hadamard(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit)}{hadamard(MultiQubit multiQubit, const int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void hadamard (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_aa09b5dd93de6df1384b8f2c0041749ab}{}\label{qubits__env__mpi_8c_aa09b5dd93de6df1384b8f2c0041749ab}


Apply the single-\/qubit Hadamard gate. 

This takes $|0\rangle$ to $|+\rangle$ and $|1\rangle$ to $|-\rangle$, and is equivalent to a rotation of $\pi$ around the x-\/axis then $\pi/2$ about the y-\/axis on the Bloch-\/sphere. I.\+e. \[ \frac{1}{\sqrt{2}} \begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {H}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to operate on \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily target\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}). \\
\hline
\end{DoxyExceptions}


Definition at line 615 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), hadamard\+Distributed(), hadamard\+Local(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
616 \{
617         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(targetQubit >= 0 && targetQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 1, \_\_func\_\_);
618 
619         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
620         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
621 
622         \textcolor{comment}{// rank's chunk is in upper half of block }
623         \textcolor{keywordtype}{int} rankIsUpper;
624         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
625 
626         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
627                 \textcolor{comment}{// all values required to update state vector lie in this rank}
628                 \hyperlink{qubits_8c_aa9f0718b4dd794a3e1b143e3b153bfc5}{hadamardLocal}(multiQubit, targetQubit);
629         \} \textcolor{keywordflow}{else} \{
630                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
631                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
632                 pairRank = \hyperlink{qubits__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
633                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
634                 \textcolor{comment}{// get corresponding values from my pair}
635                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
636                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. send values to
       hadamardDistributed}
637                 \textcolor{comment}{// in the correct order}
638                 \textcolor{keywordflow}{if} (rankIsUpper)\{
639                         \hyperlink{qubits_8c_ae6a897066979fc52d977007d959ca09d}{hadamardDistributed}(multiQubit,targetQubit,
640                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//upper}
641                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//lower}
642                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, rankIsUpper); \textcolor{comment}{//output}
643                 \} \textcolor{keywordflow}{else} \{
644                         \hyperlink{qubits_8c_ae6a897066979fc52d977007d959ca09d}{hadamardDistributed}(multiQubit,targetQubit,
645                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//upper}
646                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//lower}
647                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, rankIsUpper); \textcolor{comment}{//output}
648                 \}
649         \}
650 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!half\+Matrix\+Block\+Fits\+In\+Chunk@{half\+Matrix\+Block\+Fits\+In\+Chunk}}
\index{half\+Matrix\+Block\+Fits\+In\+Chunk@{half\+Matrix\+Block\+Fits\+In\+Chunk}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{half\+Matrix\+Block\+Fits\+In\+Chunk(long long int chunk\+Size, int target\+Qubit)}{halfMatrixBlockFitsInChunk(long long int chunkSize, int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}static int half\+Matrix\+Block\+Fits\+In\+Chunk (
\begin{DoxyParamCaption}
\item[{long long int}]{chunk\+Size, }
\item[{int}]{target\+Qubit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{}\label{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}


return whether the current qubit rotation will use blocks that fit within a single chunk. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit being rotated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1\+: one chunk fits in one block 0\+: chunk is larger than block 
\end{DoxyReturn}


Definition at line 246 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by collapse\+To\+Outcome(), compact\+Unitary(), controlled\+Compact\+Unitary(), controlled\+Not(), controlled\+Unitary(), find\+Probability\+Of\+Outcome(), hadamard(), measure\+With\+Stats(), multi\+Controlled\+Unitary(), phase\+Gate(), sigma\+X(), sigma\+Y(), and unitary().


\begin{DoxyCode}
247 \{
248         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (targetQubit);
249         \textcolor{keywordflow}{if} (chunkSize > sizeHalfBlock) \textcolor{keywordflow}{return} 1;
250         \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} 0;
251 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!init\+Qu\+E\+S\+T\+Env@{init\+Qu\+E\+S\+T\+Env}}
\index{init\+Qu\+E\+S\+T\+Env@{init\+Qu\+E\+S\+T\+Env}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{init\+Qu\+E\+S\+T\+Env(\+Qu\+E\+S\+T\+Env $\ast$env)}{initQuESTEnv(QuESTEnv *env)}}]{\setlength{\rightskip}{0pt plus 5cm}void init\+Qu\+E\+S\+T\+Env (
\begin{DoxyParamCaption}
\item[{{\bf Qu\+E\+S\+T\+Env} $\ast$}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}{}\label{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}


Initialize the Qu\+E\+ST environment. 

If something needs to be done to set up the execution environment, such as initializing M\+PI when running in distributed mode, it is handled here


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 32 of file qubits\+\_\+env\+\_\+mpi.\+c.



References D\+E\+B\+UG, init\+\_\+by\+\_\+array(), Qu\+E\+S\+T\+Env\+::num\+Ranks, and Qu\+E\+S\+T\+Env\+::rank.


\begin{DoxyCode}
32                                 \{
33         \textcolor{comment}{// init MPI environment}
34         \textcolor{keywordtype}{int} rank, numRanks, initialized;
35         MPI\_Initialized(&initialized);
36         \textcolor{keywordflow}{if} (!initialized)\{
37                 MPI\_Init(NULL, NULL);
38                 MPI\_Comm\_size(MPI\_COMM\_WORLD, &numRanks);
39                 MPI\_Comm\_rank(MPI\_COMM\_WORLD, &rank);
40 
41                 \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) \{
42                         \textcolor{keywordtype}{char} hostName[256];
43                         \textcolor{keywordtype}{int} hostNameLen;
44                         MPI\_Get\_processor\_name(hostName, &hostNameLen);
45                         printf(\textcolor{stringliteral}{"rank %d on host %s\(\backslash\)n"}, rank, hostName);
46                 \}
47                 env->\hyperlink{structQuESTEnv_aa648bb336cf8598467cb62db00b9cee8}{rank}=rank;
48                 env->\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks}=numRanks;
49 
50         \textcolor{comment}{// init MT random number generator with two keys -- time and pid }
51         \textcolor{comment}{// it is ok that all procs will get the same seed as random numbers will only be }
52         \textcolor{comment}{// used by the master process}
53         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} secs = time(NULL);
54         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} pid = getpid();
55         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} key[2];
56         key[0] = secs; key[1] = pid;
57         \hyperlink{mt19937ar_8c_ac1283f9b1ed571332f5ffe53545ffc16}{init\_by\_array}(key, 2);
58         \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"ERROR: Trying to initialize QuESTEnv multiple times. Ignoring\(\backslash\)n"});
59 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero@{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero}}
\index{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero@{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero(int chunk\+Id, long long int chunk\+Size, int measure\+Qubit)}{isChunkToSkipInFindPZero(int chunkId, long long int chunkSize, int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}static int is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero (
\begin{DoxyParamCaption}
\item[{int}]{chunk\+Id, }
\item[{long long int}]{chunk\+Size, }
\item[{int}]{measure\+Qubit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{}\label{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}


Find chunks to skip when calculating probability of qubit being zero. 

When calculating probability of a bit q being zero, sum up 2$^\wedge$q values, then skip 2$^\wedge$q values, etc. This function finds if an entire chunk is in the range of values to be skipped


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Id} & id of chunk in state vector \\
\hline
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em measure\+Qubi} & qubit being measured \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int -- 1\+: skip, 0\+: don\textquotesingle{}t skip 
\end{DoxyReturn}


Definition at line 663 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by collapse\+To\+Outcome(), find\+Probability\+Of\+Outcome(), and measure\+With\+Stats().


\begin{DoxyCode}
664 \{
665         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (measureQubit);
666         \textcolor{keywordtype}{int} numChunksToSkip = sizeHalfBlock/chunkSize;
667         \textcolor{comment}{// calculate probability by summing over numChunksToSkip, then skipping numChunksToSkip, etc}
668         \textcolor{keywordtype}{int} bitToCheck = chunkId & numChunksToSkip;
669         \textcolor{keywordflow}{return} bitToCheck;
670 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!measure@{measure}}
\index{measure@{measure}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{measure(\+Multi\+Qubit multi\+Qubit, int measure\+Qubit)}{measure(MultiQubit multiQubit, int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}int measure (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{int}]{measure\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_ad5774247d836267175c664cd0e451bcb}{}\label{qubits__env__mpi_8c_ad5774247d836267175c664cd0e451bcb}


Measures a single qubit, collapsing it randomly to 0 or 1. 

Outcome probabilities are weighted by the state vector, which is irreversibly changed after collapse to be consistent with the outcome.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the measurement outcome, 0 or 1 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily measure\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}) \\
\hline
\end{DoxyExceptions}


Definition at line 718 of file qubits\+\_\+env\+\_\+mpi.\+c.



References measure\+With\+Stats(), Multi\+Qubit\+::num\+Qubits, Qu\+E\+S\+T\+Assert(), and R\+E\+AL.


\begin{DoxyCode}
718                                                     \{
719     \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(measureQubit >= 0 && measureQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 2, \_\_func\_\_);
720     \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateProb; 
721     \textcolor{keywordflow}{return} \hyperlink{qubits__env__mpi_8c_a2ac46e470c750bf93c754e06c64b0a7a}{measureWithStats}(multiQubit, measureQubit, &stateProb); 
722 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!measure\+With\+Stats@{measure\+With\+Stats}}
\index{measure\+With\+Stats@{measure\+With\+Stats}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{measure\+With\+Stats(\+Multi\+Qubit multi\+Qubit, int measure\+Qubit, R\+E\+A\+L $\ast$state\+Prob)}{measureWithStats(MultiQubit multiQubit, int measureQubit, REAL *stateProb)}}]{\setlength{\rightskip}{0pt plus 5cm}int measure\+With\+Stats (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{int}]{measure\+Qubit, }
\item[{{\bf R\+E\+AL} $\ast$}]{state\+Prob}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a2ac46e470c750bf93c754e06c64b0a7a}{}\label{qubits__env__mpi_8c_a2ac46e470c750bf93c754e06c64b0a7a}


Measures a single qubit, collapsing it randomly to 0 or 1, and additionally gives the probability of that outcome. 

Outcome probabilities are weighted by the state vector, which is irreversibly changed after collapse to be consistent with the outcome.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt out}  & {\em state\+Prob} & a pointer to a R\+E\+AL which is set to the probability of the occurred outcome \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the measurement outcome, 0 or 1 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily measure\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}) \\
\hline
\end{DoxyExceptions}


Definition at line 724 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, collapse\+To\+Outcome\+Distributed\+Renorm(), collapse\+To\+Outcome\+Distributed\+Set\+Zero(), collapse\+To\+Outcome\+Local(), find\+Probability\+Of\+Outcome(), genrand\+\_\+real1(), half\+Matrix\+Block\+Fits\+In\+Chunk(), is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Qu\+E\+S\+T\+Assert(), R\+E\+AL, and R\+E\+A\+L\+\_\+\+E\+PS.



Referenced by measure().


\begin{DoxyCode}
724                                                                               \{
725     \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(measureQubit >= 0 && measureQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 2, \_\_func\_\_);
726 
727     \textcolor{keywordtype}{int} outcome;
728     \textcolor{comment}{// find probability of qubit being in state 1}
729     \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateProbInternal = \hyperlink{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{findProbabilityOfOutcome}(multiQubit, measureQubit,
       1);
730 
731     \textcolor{comment}{// we can't collapse to a state that has a probability too close to zero}
732     \textcolor{keywordflow}{if} (stateProbInternal<\hyperlink{precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS}) outcome=0;
733     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (1-stateProbInternal<\hyperlink{precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS}) outcome=1;
734     \textcolor{keywordflow}{else} \{
735         \textcolor{comment}{// ok. both P(0) and P(1) are large enough to resolve}
736         \textcolor{comment}{// generate random float on [0,1]}
737         \textcolor{keywordtype}{float} randNum = \hyperlink{mt19937ar_8c_ac94ab75771800274ed1a2bedeca86f04}{genrand\_real1}();
738         \textcolor{keywordflow}{if} (randNum<=stateProbInternal) outcome = 1;
739         \textcolor{keywordflow}{else} outcome = 0;
740     \} 
741     \textcolor{keywordflow}{if} (outcome==0) stateProbInternal = 1-stateProbInternal;
742 
743         \textcolor{keywordtype}{int} skipValuesWithinRank = \hyperlink{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, measureQubit);
744     \textcolor{keywordflow}{if} (skipValuesWithinRank) \{
745         \hyperlink{qubits_8c_a01d9a8b7ff0e09ec399e158389783aa9}{collapseToOutcomeLocal}(multiQubit, measureQubit, stateProbInternal, outcome);
746     \} \textcolor{keywordflow}{else} \{
747         \textcolor{keywordflow}{if} (!\hyperlink{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{isChunkToSkipInFindPZero}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, measureQubit))\{
748             \textcolor{comment}{// chunk has amps for q=0}
749             \textcolor{keywordflow}{if} (outcome==0) \hyperlink{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm}(multiQubit
      , measureQubit, 
750                     stateProbInternal);
751             \textcolor{keywordflow}{else} \hyperlink{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero}(multiQubit, 
      measureQubit);
752         \} \textcolor{keywordflow}{else} \{
753             \textcolor{comment}{// chunk has amps for q=1}
754             \textcolor{keywordflow}{if} (outcome==1) \hyperlink{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm}(multiQubit
      , measureQubit, 
755                     stateProbInternal);
756             \textcolor{keywordflow}{else} \hyperlink{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero}(multiQubit, 
      measureQubit);
757         \}
758     \}
759 
760     *stateProb = stateProbInternal;
761     \textcolor{keywordflow}{return} outcome;
762 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!multi\+Controlled\+Unitary@{multi\+Controlled\+Unitary}}
\index{multi\+Controlled\+Unitary@{multi\+Controlled\+Unitary}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{multi\+Controlled\+Unitary(\+Multi\+Qubit multi\+Qubit, int $\ast$control\+Qubits, const int num\+Control\+Qubits, const int target\+Qubit, Complex\+Matrix2 u)}{multiControlledUnitary(MultiQubit multiQubit, int *controlQubits, const int numControlQubits, const int targetQubit, ComplexMatrix2 u)}}]{\setlength{\rightskip}{0pt plus 5cm}void multi\+Controlled\+Unitary (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{int $\ast$}]{control\+Qubits, }
\item[{const int}]{num\+Control\+Qubits, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex\+Matrix2}}]{u}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_ae395a79690283ed81106afadd7a8cd8a}{}\label{qubits__env__mpi_8c_ae395a79690283ed81106afadd7a8cd8a}


Apply a general multiple-\/control single-\/target unitary, which can include a global phase factor. 

Any number of control qubits can be specified, and if all have value 1, the given unitary is applied to the target qubit. This effects the many-\/qubit unitary \[ \begin{pmatrix} 1 \\ & 1 \\\ & & \ddots \\ & & & u_{00} & u_{01}\\ & & & u_{10} & u_{11} \end{pmatrix} \] on the control and target qubits. The given 2x2 Complex\+Matrix must be unitary, otherwise an error is thrown.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 3) {controls}; \node[draw=none] at (-3.5, 0) {target}; \node[draw=none] at (0, 6) {$\vdots$}; \draw (0, 5) -- (0, 4); \draw (-2, 4) -- (2, 4); \draw[fill=black] (0, 4) circle (.2); \draw (0, 4) -- (0, 2); \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 1); \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {U}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em control\+Qubits} & applies unitary if all qubits in this array equal 1 \\
\hline
\mbox{\tt in}  & {\em num\+Control\+Qubits} & number of control qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to operate on \\
\hline
\mbox{\tt in}  & {\em u} & single-\/qubit unitary matrix to apply \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily num\+Control\+Qubits} is outside \mbox{[}1, {\ttfamily multi\+Qubit.\+num\+Qubits}\mbox{]}), or if any qubit index ({\ttfamily target\+Qubit} or one in {\ttfamily control\+Qubits}) is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}\mbox{]}), or if {\ttfamily control\+Qubits} contains {\ttfamily target\+Qubit}, or if {\ttfamily u} is not unitary. \\
\hline
\end{DoxyExceptions}


Definition at line 454 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), get\+Rot\+Angle\+From\+Unitary\+Matrix(), half\+Matrix\+Block\+Fits\+In\+Chunk(), multi\+Controlled\+Unitary\+Distributed(), multi\+Controlled\+Unitary\+Local(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), Multi\+Qubit\+::state\+Vec, and validate\+Matrix\+Is\+Unitary().


\begin{DoxyCode}
455 \{
456         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(targetQubit >= 0 && targetQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 1, \_\_func\_\_);
457         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(numControlQubits > 0 && numControlQubits <= multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 4, \_\_func\_\_);
458         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(\hyperlink{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}{validateMatrixIsUnitary}(u), 5, \_\_func\_\_);
459          
460         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} mask=0;
461         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<numControlQubits; i++) mask = mask | (1LL<<controlQubits[i]);
462         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(mask >=0 && mask <= (1LL<<multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits})-1, 2, \_\_func\_\_);
463         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}((mask & (1LL<<targetQubit)) != (1LL<<targetQubit), 3, \_\_func\_\_);
464         
465         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
466         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
467         \hyperlink{structComplex}{Complex} rot1, rot2;
468 
469         \textcolor{comment}{// rank's chunk is in upper half of block }
470         \textcolor{keywordtype}{int} rankIsUpper;
471         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
472 
473         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
474                 \textcolor{comment}{// all values required to update state vector lie in this rank}
475                 \hyperlink{qubits_8c_a1309eabcba3cb97fbc3cd2e606d17766}{multiControlledUnitaryLocal}(multiQubit, targetQubit, mask, u);
476         \} \textcolor{keywordflow}{else} \{
477                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
478                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
479                 \hyperlink{qubits__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}{getRotAngleFromUnitaryMatrix}(rankIsUpper, &rot1, &rot2, u);
480                 pairRank = \hyperlink{qubits__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
481                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
482                 \textcolor{comment}{// get corresponding values from my pair}
483                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
484                 
485                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. send values to
       multiControlledUnitaryDistributed}
486                 \textcolor{comment}{// in the correct order}
487                 \textcolor{keywordflow}{if} (rankIsUpper)\{
488                         \hyperlink{qubits_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{multiControlledUnitaryDistributed}(multiQubit,
      targetQubit,mask,rot1,rot2,
489                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//upper}
490                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//lower}
491                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
492                 \} \textcolor{keywordflow}{else} \{
493                         \hyperlink{qubits_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{multiControlledUnitaryDistributed}(multiQubit,
      targetQubit,mask,rot1,rot2,
494                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//upper}
495                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//lower}
496                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
497                 \}
498         \}
499 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!phase\+Gate@{phase\+Gate}}
\index{phase\+Gate@{phase\+Gate}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{phase\+Gate(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, enum phase\+Gate\+Type type)}{phaseGate(MultiQubit multiQubit, const int targetQubit, enum phaseGateType type)}}]{\setlength{\rightskip}{0pt plus 5cm}void phase\+Gate (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{enum {\bf phase\+Gate\+Type}}]{type}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_aae7a8a7f1ccbddb7f76b6c52b746bb43}{}\label{qubits__env__mpi_8c_aae7a8a7f1ccbddb7f76b6c52b746bb43}


Definition at line 597 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, phase\+Gate\+Distributed(), phase\+Gate\+Local(), and Qu\+E\+S\+T\+Assert().


\begin{DoxyCode}
598 \{
599         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(targetQubit >= 0 && targetQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 1, \_\_func\_\_);
600 
601         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
602         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
603 
604         \textcolor{comment}{// rank's chunk is in upper half of block }
605         \textcolor{keywordtype}{int} rankIsUpper;
606 
607         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
608                 \hyperlink{qubits_8c_a3a54566b73ac84c312d7da4f56ffbc3b}{phaseGateLocal}(multiQubit, targetQubit, type);
609         \} \textcolor{keywordflow}{else} \{
610                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
611                 \textcolor{keywordflow}{if} (!rankIsUpper) \hyperlink{qubits_8c_af832ed00b02a0597b7fe0b714032c54a}{phaseGateDistributed}(multiQubit, targetQubit, type);
612         \}
613 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!Qu\+E\+S\+T\+Assert@{Qu\+E\+S\+T\+Assert}}
\index{Qu\+E\+S\+T\+Assert@{Qu\+E\+S\+T\+Assert}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{Qu\+E\+S\+T\+Assert(int is\+Valid, int error\+Code, const char $\ast$func)}{QuESTAssert(int isValid, int errorCode, const char *func)}}]{\setlength{\rightskip}{0pt plus 5cm}void Qu\+E\+S\+T\+Assert (
\begin{DoxyParamCaption}
\item[{int}]{is\+Valid, }
\item[{int}]{error\+Code, }
\item[{const char $\ast$}]{func}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{}\label{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}


Definition at line 772 of file qubits\+\_\+env\+\_\+mpi.\+c.



References exit\+With\+Error().



Referenced by collapse\+To\+Outcome(), compact\+Unitary(), controlled\+Compact\+Unitary(), controlled\+Not(), controlled\+Unitary(), find\+Probability\+Of\+Outcome(), hadamard(), measure(), measure\+With\+Stats(), multi\+Controlled\+Unitary(), phase\+Gate(), sigma\+X(), sigma\+Y(), and unitary().


\begin{DoxyCode}
772                                                               \{
773     \textcolor{keywordflow}{if} (!isValid) \hyperlink{qubits__env__mpi_8c_ae5f9019826f35e8b51b1716cfe397b45}{exitWithError}(errorCode, func);
774 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!report\+Node\+List@{report\+Node\+List}}
\index{report\+Node\+List@{report\+Node\+List}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{report\+Node\+List(\+Qu\+E\+S\+T\+Env env)}{reportNodeList(QuESTEnv env)}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+Node\+List (
\begin{DoxyParamCaption}
\item[{{\bf Qu\+E\+S\+T\+Env}}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}{}\label{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}


Report a list of C\+PU hostnames and the rank that is running on each if running with M\+PI enabled and an error message otherwise. 

For debugging purposes. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 93 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Qu\+E\+S\+T\+Env\+::rank.


\begin{DoxyCode}
93                                  \{
94         \textcolor{keywordtype}{char} hostName[256];
95         gethostname(hostName, 255);
96         printf(\textcolor{stringliteral}{"hostname on rank %d: %s\(\backslash\)n"}, env.\hyperlink{structQuESTEnv_aa648bb336cf8598467cb62db00b9cee8}{rank}, hostName);
97 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!report\+Qu\+E\+S\+T\+Env@{report\+Qu\+E\+S\+T\+Env}}
\index{report\+Qu\+E\+S\+T\+Env@{report\+Qu\+E\+S\+T\+Env}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{report\+Qu\+E\+S\+T\+Env(\+Qu\+E\+S\+T\+Env env)}{reportQuESTEnv(QuESTEnv env)}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+Qu\+E\+S\+T\+Env (
\begin{DoxyParamCaption}
\item[{{\bf Qu\+E\+S\+T\+Env}}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}{}\label{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}


Report information about the Qu\+E\+ST environment. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 78 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Qu\+E\+S\+T\+Env\+::num\+Ranks, Qu\+E\+S\+T\+Env\+::rank, and R\+E\+AL.


\begin{DoxyCode}
78                                  \{
79         \textcolor{keywordflow}{if} (env.\hyperlink{structQuESTEnv_aa648bb336cf8598467cb62db00b9cee8}{rank}==0)\{
80                 printf(\textcolor{stringliteral}{"EXECUTION ENVIRONMENT:\(\backslash\)n"}); 
81                 printf(\textcolor{stringliteral}{"Running distributed (MPI) version\(\backslash\)n"});
82                 printf(\textcolor{stringliteral}{"Number of ranks is %d\(\backslash\)n"}, env.\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks});
83 \textcolor{preprocessor}{# ifdef \_OPENMP}
84                 printf(\textcolor{stringliteral}{"OpenMP enabled\(\backslash\)n"});
85                 printf(\textcolor{stringliteral}{"Number of threads available is %d\(\backslash\)n"}, omp\_get\_max\_threads());
86 \textcolor{preprocessor}{# else}
87                 printf(\textcolor{stringliteral}{"OpenMP disabled\(\backslash\)n"});
88 \textcolor{preprocessor}{# endif }
89                 printf(\textcolor{stringliteral}{"Precision: size of REAL is %ld bytes\(\backslash\)n"}, \textcolor{keyword}{sizeof}(\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}));
90         \}
91 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!sigmaX@{sigmaX}}
\index{sigmaX@{sigmaX}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{sigma\+X(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit)}{sigmaX(MultiQubit multiQubit, const int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaX (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a86e396e06b7d527cac20ba0108872423}{}\label{qubits__env__mpi_8c_a86e396e06b7d527cac20ba0108872423}


Apply the single-\/qubit sigma-\/X (also known as the X, Pauli-\/X, N\+OT or bit-\/flip) gate. 

This is a rotation of $\pi$ around the x-\/axis on the Bloch sphere. I.\+e. \[ \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (2, 0); \draw (0, 0) circle (.5); \draw (0, .5) -- (0, -.5); \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to operate on \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily target\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}). \\
\hline
\end{DoxyExceptions}


Definition at line 500 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), sigma\+X\+Distributed(), sigma\+X\+Local(), and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
501 \{
502         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(targetQubit >= 0 && targetQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 1, \_\_func\_\_);
503 
504         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
505         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
506 
507         \textcolor{comment}{// rank's chunk is in upper half of block }
508         \textcolor{keywordtype}{int} rankIsUpper;
509         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
510 
511         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
512                 \textcolor{comment}{// all values required to update state vector lie in this rank}
513                 \hyperlink{qubits_8c_a74822fd86bb5d81766e6e8dbdcd62df1}{sigmaXLocal}(multiQubit, targetQubit);
514         \} \textcolor{keywordflow}{else} \{
515                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
516                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
517                 pairRank = \hyperlink{qubits__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
518                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
519                 \textcolor{comment}{// get corresponding values from my pair}
520                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
521                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. sigmaX just
       replaces}
522                 \textcolor{comment}{// this rank's values with pair values}
523                 \hyperlink{qubits_8c_a2275fff50824fe47485890ff5a857785}{sigmaXDistributed}(multiQubit, targetQubit,
524                         multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{// in}
525                         multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{// out}
526         \}
527 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!sigmaY@{sigmaY}}
\index{sigmaY@{sigmaY}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{sigma\+Y(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit)}{sigmaY(MultiQubit multiQubit, const int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaY (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a1f54d70a42403f7e1c2e2c2007332f61}{}\label{qubits__env__mpi_8c_a1f54d70a42403f7e1c2e2c2007332f61}


Apply the single-\/qubit sigma-\/Y (also known as the Y or Pauli-\/Y) gate. 

This is a rotation of $\pi$ around the Y-\/axis on the Bloch sphere. I.\+e. \[ \begin{pmatrix} 0 & -i \\ i & 0 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$\sigma_y$}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to operate on \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily target\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}). \\
\hline
\end{DoxyExceptions}
fix -- put duplicate code (sigmaX, sigmaY) in seperate function 

Definition at line 566 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), sigma\+Y\+Distributed(), sigma\+Y\+Local(), and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
567 \{
568         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(targetQubit >= 0 && targetQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 1, \_\_func\_\_);
569 
570         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
571         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
572 
573         \textcolor{comment}{// rank's chunk is in upper half of block }
574         \textcolor{keywordtype}{int} rankIsUpper;
575         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
576 
577         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
578                 \textcolor{comment}{// all values required to update state vector lie in this rank}
579                 \hyperlink{qubits_8c_a81fbfaed65a742a7dfd622e17652245e}{sigmaYLocal}(multiQubit, targetQubit);
580         \} \textcolor{keywordflow}{else} \{
582                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
583                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
584                 pairRank = \hyperlink{qubits__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
585                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
586                 \textcolor{comment}{// get corresponding values from my pair}
587                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
588                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. sigmaX just
       replaces}
589                 \textcolor{comment}{// this rank's values with pair values}
590                 \hyperlink{qubits_8c_af5ef5166f00c0572354b4ac53dcf40cf}{sigmaYDistributed}(multiQubit,targetQubit,
591                         multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{// in}
592                         multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{// out}
593                         rankIsUpper);
594         \}
595 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!sync\+Qu\+E\+S\+T\+Env@{sync\+Qu\+E\+S\+T\+Env}}
\index{sync\+Qu\+E\+S\+T\+Env@{sync\+Qu\+E\+S\+T\+Env}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{sync\+Qu\+E\+S\+T\+Env(\+Qu\+E\+S\+T\+Env env)}{syncQuESTEnv(QuESTEnv env)}}]{\setlength{\rightskip}{0pt plus 5cm}void sync\+Qu\+E\+S\+T\+Env (
\begin{DoxyParamCaption}
\item[{{\bf Qu\+E\+S\+T\+Env}}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{}\label{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}


Guarantees that all code up to the given point has been executed on all nodes (if running in distributed mode) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 61 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by initialize\+State\+From\+Single\+File(), and report\+State\+To\+Screen().


\begin{DoxyCode}
61                                \{
62         MPI\_Barrier(MPI\_COMM\_WORLD);
63 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!sync\+Qu\+E\+S\+T\+Success@{sync\+Qu\+E\+S\+T\+Success}}
\index{sync\+Qu\+E\+S\+T\+Success@{sync\+Qu\+E\+S\+T\+Success}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{sync\+Qu\+E\+S\+T\+Success(int success\+Code)}{syncQuESTSuccess(int successCode)}}]{\setlength{\rightskip}{0pt plus 5cm}int sync\+Qu\+E\+S\+T\+Success (
\begin{DoxyParamCaption}
\item[{int}]{success\+Code}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_ac7e38d768a1bd79019f88cc1e6295092}{}\label{qubits__env__mpi_8c_ac7e38d768a1bd79019f88cc1e6295092}


Performs a logical A\+ND on all success\+Codes held by all processes. 

If any one process has a zero success\+Code all processes will return a zero success code.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\mbox{\tt in}  & {\em success\+Code} & 1 if process task succeeded, 0 if process task failed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if all processes succeeded, 0 if any one process failed 
\end{DoxyReturn}


Definition at line 65 of file qubits\+\_\+env\+\_\+mpi.\+c.


\begin{DoxyCode}
65                                      \{
66         \textcolor{keywordtype}{int} totalSuccess;
67         MPI\_Allreduce(&successCode, &totalSuccess, 1, MPI\_INT, MPI\_LAND, MPI\_COMM\_WORLD);
68         \textcolor{keywordflow}{return} totalSuccess;
69 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!unitary@{unitary}}
\index{unitary@{unitary}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{unitary(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, Complex\+Matrix2 u)}{unitary(MultiQubit multiQubit, const int targetQubit, ComplexMatrix2 u)}}]{\setlength{\rightskip}{0pt plus 5cm}void unitary (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex\+Matrix2}}]{u}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a7a0877e33700f6bad48adb51b7b3fb67}{}\label{qubits__env__mpi_8c_a7a0877e33700f6bad48adb51b7b3fb67}


Apply a general single-\/qubit unitary (including a global phase factor). 

The passed 2x2 Complex\+Matrix must be unitary, otherwise an error is thrown.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {U}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to operate on \\
\hline
\mbox{\tt in}  & {\em u} & unitary matrix to apply \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily target\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}), or matrix {\ttfamily u} is not unitary. \\
\hline
\end{DoxyExceptions}


Definition at line 325 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), get\+Rot\+Angle\+From\+Unitary\+Matrix(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), Multi\+Qubit\+::state\+Vec, unitary\+Distributed(), unitary\+Local(), and validate\+Matrix\+Is\+Unitary().


\begin{DoxyCode}
326 \{
327         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(targetQubit >= 0 && targetQubit < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 1, \_\_func\_\_);
328         \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(\hyperlink{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}{validateMatrixIsUnitary}(u), 5, \_\_func\_\_);
329 
330         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
331         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
332         \hyperlink{structComplex}{Complex} rot1, rot2;
333 
334         \textcolor{comment}{// rank's chunk is in upper half of block }
335         \textcolor{keywordtype}{int} rankIsUpper;
336         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
337 
338         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
339                 \textcolor{comment}{// all values required to update state vector lie in this rank}
340                 \hyperlink{qubits_8c_ac134fb45b0a7248c5d15e16eb7139a35}{unitaryLocal}(multiQubit, targetQubit, u);
341         \} \textcolor{keywordflow}{else} \{
342                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
343                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
344                 \hyperlink{qubits__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}{getRotAngleFromUnitaryMatrix}(rankIsUpper, &rot1, &rot2, u);
345                 pairRank = \hyperlink{qubits__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, targetQubit);
346                 \textcolor{comment}{// get corresponding values from my pair}
347                         \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
348 
349                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. }
350                 \textcolor{comment}{// send values to compactUnitaryDistributed in the correct order}
351                 \textcolor{keywordflow}{if} (rankIsUpper)\{
352                         \hyperlink{qubits_8c_a2343b7240118e89aa615e2c9140b770b}{unitaryDistributed}(multiQubit,targetQubit,rot1,rot2,
353                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//upper}
354                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//lower}
355                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
356                 \} \textcolor{keywordflow}{else} \{
357                         \hyperlink{qubits_8c_a2343b7240118e89aa615e2c9140b770b}{unitaryDistributed}(multiQubit,targetQubit,rot1,rot2,
358                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//upper}
359                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//lower}
360                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
361                 \}
362         \}
363 
364 
365 \}
\end{DoxyCode}
