\hypertarget{qubits__internal_8h}{
\subsection{qubits\_\-internal.h File Reference}
\label{qubits__internal_8h}\index{qubits\_\-internal.h@{qubits\_\-internal.h}}
}


Internal functions used to implement the public facing API in \hyperlink{qubits_8h}{qubits.h}.  
{\ttfamily \#include \char`\"{}precision.h\char`\"{}}\par
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}{rotateQubitLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}{rotateQubitDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a824d71bae93236d8a3cd43589044eaee}{controlRotateQubitLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, const int controlQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ab22d031e2507f1d859292103a99e2378}{controlRotateQubitDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, const int controlQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_aa9e640bb2d0458c937c6a87dfeca0f23}{sigmaXLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a5958808b2f2f05937921ba7dabe5a171}{sigmaXDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_afcbb1dcbe070ad0ed1a72a23251b6a83}{sigmaYLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a0471f6b547ce8270ef85170b7f4f0214}{sigmaYDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a0711416fceaf63c67b496e123e845c69}{hadamardLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ac835c194bd547240a35f0b028db1d658}{hadamardDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a6a736aeb3532898019fe7c27010edc6a}{phaseGateLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a38a05c7e749e806b182ef3b89878bfc4}{phaseGateDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a2901e2e5531cb77f87ea54b3fc28f51a}{controlNotLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, const int controlQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\} for elements where controlQubit is one. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a774dd1217fcc3591a74a74d5667afa29}{controlNotDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, const int controlQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{findProbabilityOfZeroLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{findProbabilityOfZeroDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a53614ce19e0a4f2c41b400cf05dc5bd1}{measureInStateLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int measureQubit, REAL totalProbability, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a35e5ac30c8427c482a97b33a4e295535}{measureInStateDistributedRenorm} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, const REAL totalProbability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ac39efc9ed939382276ebd0c15dd6a0fa}{measureInStateDistributedSetZero} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Set all amplitudes in one chunk to 0. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a2d73fd11c1d154640dbf114da8f34c64}{filterOut111Local} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int idQubit1, const int idQubit2, const int idQubit3, const REAL probOfFilter)
\begin{DoxyCompactList}\small\item\em Updates the state according to this scenario: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a096cddbac961f0651a084d2ceb905d1b}{probOfFilterOut111Local} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int idQubit1, const int idQubit2, const int idQubit3)
\begin{DoxyCompactList}\small\item\em Evaluates the state according to this scenario: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ae275b94c1a483dda43bf4ec947635605}{phaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \item\end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
Internal functions used to implement the public facing API in \hyperlink{qubits_8h}{qubits.h}. Do not call these functions directly. In general, \hyperlink{qubits__env__local_8c}{qubits\_\-env\_\-local.c} and \hyperlink{qubits__env__mpi_8c}{qubits\_\-env\_\-mpi.c} will implement the public API by choosing the correct function or combination of functions to use from those included here. 

Definition in file \hyperlink{qubits__internal_8h_source}{qubits\_\-internal.h}.

\subsubsection{Function Documentation}
\hypertarget{qubits__internal_8h_a774dd1217fcc3591a74a74d5667afa29}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlNotDistributed@{controlNotDistributed}}
\index{controlNotDistributed@{controlNotDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlNotDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlNotDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  const int {\em controlQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a774dd1217fcc3591a74a74d5667afa29}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk. Only perform the rotation for elements where controlQubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 865 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, and REAL.

Referenced by controlNot().


\begin{DoxyCode}
868 {
869 
870         long long int thisTask;  
871         const long long int numTasks=multiQubit.numAmps;
872         const long long int chunkSize=multiQubit.numAmps;
873         const long long int chunkId=multiQubit.chunkId;
874         
875         // if targetQubit==controlQubit, it is guaranteed that controlQubit==1 wh
      en
876         // targetQubit==1. As rotations are symmetric, we can instead apply the r
      otation
877         // on all amplitudes where targetQubit==0 as we do here.
878         int rotateAll=(targetQubit==controlQubit);
879 
880         int controlBit;
881 
882         // test qubit valid
883         assert (targetQubit >= 0 && targetQubit < multiQubit.numQubits);
884 
885         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
886         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
887 
888 # ifdef _OPENMP
889 # pragma omp parallel \
890         default  (none) \
891         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,r
      otateAll) \
892         private  (thisTask,controlBit)
893 # endif
894         {
895 # ifdef _OPENMP
896                 # pragma omp for schedule (static)
897 # endif
898                 for (thisTask=0; thisTask<numTasks; thisTask++) {
899                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
900                         if (rotateAll || controlBit){
901                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTa
      sk];
902                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTa
      sk];
903                         }
904                 }
905         }
906 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a2901e2e5531cb77f87ea54b3fc28f51a}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlNotLocal@{controlNotLocal}}
\index{controlNotLocal@{controlNotLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlNotLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlNotLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  const int {\em controlQubit})}\hfill}
\label{qubits__internal_8h_a2901e2e5531cb77f87ea54b3fc28f51a}


Rotate a single qubit by \{\{0,1\},\{1,0\} for elements where controlQubit is one. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \end{DoxyParams}


Definition at line 791 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlNot().


\begin{DoxyCode}
792 {
793         long long int sizeBlock, sizeHalfBlock;
794         long long int thisBlock, // current block
795              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
796 
797         REAL stateRealUp,stateImagUp;
798         long long int thisTask;         
799         const long long int numTasks=multiQubit.numAmps>>1;
800         const long long int chunkSize=multiQubit.numAmps;
801         const long long int chunkId=multiQubit.chunkId;
802 
803         int controlBit;
804 
805         // if targetQubit==controlQubit, it is guaranteed that controlQubit==1 wh
      en
806         // targetQubit==1. As rotations are symmetric, we can instead apply the r
      otation
807         // on all amplitudes where targetQubit==0 as we do here.
808         int rotateAll=(targetQubit==controlQubit);
809 
810         // test qubit valid
811         assert (targetQubit >= 0 && targetQubit < multiQubit.numQubits);
812 
813         // set dimensions
814         sizeHalfBlock = 1LL << targetQubit;  
815         sizeBlock     = 2LL * sizeHalfBlock; 
816 
817 
818         // Can't use multiQubit.stateVec as a private OMP var
819         REAL *stateVecReal = multiQubit.stateVec.real;
820         REAL *stateVecImag = multiQubit.stateVec.imag;
821 
822 # ifdef _OPENMP
823 # pragma omp parallel \
824         default  (none) \
825         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,rotateAll) \
      
826         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,co
      ntrolBit) 
827 # endif
828         {
829 # ifdef _OPENMP
830                 # pragma omp for schedule (static)
831 # endif
832                 for (thisTask=0; thisTask<numTasks; thisTask++) {
833                         thisBlock   = thisTask / sizeHalfBlock;
834                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
835                         indexLo     = indexUp + sizeHalfBlock;
836 
837                         controlBit = extractBit(controlQubit, indexUp+chunkId*chu
      nkSize);
838                         if (rotateAll || controlBit){
839                                 stateRealUp = stateVecReal[indexUp];
840                                 stateImagUp = stateVecImag[indexUp];
841 
842                                 stateVecReal[indexUp] = stateVecReal[indexLo];
843                                 stateVecImag[indexUp] = stateVecImag[indexLo];
844 
845                                 stateVecReal[indexLo] = stateRealUp;
846                                 stateVecImag[indexLo] = stateImagUp;
847                         }
848                 } 
849         }
850 
851 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ab22d031e2507f1d859292103a99e2378}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlRotateQubitDistributed@{controlRotateQubitDistributed}}
\index{controlRotateQubitDistributed@{controlRotateQubitDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlRotateQubitDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlRotateQubitDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  const int {\em controlQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_ab22d031e2507f1d859292103a99e2378}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 620 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, Complex::real, and REAL.

Referenced by controlRotateQubit().


\begin{DoxyCode}
625 {
626 
627         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
628         long long int thisTask;  
629         const long long int numTasks=multiQubit.numAmps;
630         const long long int chunkSize=multiQubit.numAmps;
631         const long long int chunkId=multiQubit.chunkId;
632 
633         int controlBit;
634 
635         // As rotations are symmetric, we can apply rotations for all elements wh
      ere
636         // targetQubit==0 and controlQubit==1.  
637         // However, this means we will skip the case where targetQubit==controlQu
      bit. 
638         // We check for that here. 
639         // We could also choose to rotate on targetQubit==1, but are doing it thi
      s way 
640         // to match the regular rotate implementation. 
641         int rotateAll=(rotQubit==controlQubit);
642 
643         // test qubit valid
644         assert (rotQubit >= 0 && rotQubit < multiQubit.numQubits);
645 
646         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
647         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
648         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
649         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
650         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
651 
652 # ifdef _OPENMP
653 # pragma omp parallel \
654         default  (none) \
655         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
656                         rot1Real,rot1Imag, rot2Real,rot2Imag,rotateAll) \
657         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
658 # endif
659         {
660 # ifdef _OPENMP
661                 # pragma omp for schedule (static)
662 # endif
663                 for (thisTask=0; thisTask<numTasks; thisTask++) {
664                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
665                         if (rotateAll || controlBit){
666                                 // store current state vector values in temp vari
      ables
667                                 stateRealUp = stateVecRealUp[thisTask];
668                                 stateImagUp = stateVecImagUp[thisTask];
669 
670                                 stateRealLo = stateVecRealLo[thisTask];
671                                 stateImagLo = stateVecImagLo[thisTask];
672 
673                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
674                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp 
      - rot1Imag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
675                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp 
      + rot1Imag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
676                         }
677                 }
678         }
679 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a824d71bae93236d8a3cd43589044eaee}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlRotateQubitLocal@{controlRotateQubitLocal}}
\index{controlRotateQubitLocal@{controlRotateQubitLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlRotateQubitLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlRotateQubitLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  const int {\em controlQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_a824d71bae93236d8a3cd43589044eaee}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. Only perform the rotation for elements where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform rotation if this qubit is 1 \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 528 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlRotateQubit().


\begin{DoxyCode}
530 {
531         long long int sizeBlock, sizeHalfBlock;
532         long long int thisBlock, // current block
533              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
534 
535         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
536         long long int thisTask;         
537         const long long int numTasks=multiQubit.numAmps>>1;
538         const long long int chunkSize=multiQubit.numAmps;
539         const long long int chunkId=multiQubit.chunkId;
540 
541         int controlBit;
542 
543         // As rotations are symmetric, we can apply rotations for all elements wh
      ere
544         // targetQubit==0 and controlQubit==1.  
545         // However, this means we will skip the case where targetQubit==controlQu
      bit. 
546         // We check for that here. 
547         // We could also choose to rotate on targetQubit==1, but are doing it thi
      s way 
548         // to match the regular rotate implementation. 
549         int rotateAll=(rotQubit==controlQubit);
550 
551         // test qubit valid
552         assert (rotQubit >= 0 && rotQubit < multiQubit.numQubits);
553 
554         // set dimensions
555         sizeHalfBlock = 1LL << rotQubit;  
556         sizeBlock     = 2LL * sizeHalfBlock; 
557 
558         // Can't use multiQubit.stateVec as a private OMP var
559         REAL *stateVecReal = multiQubit.stateVec.real;
560         REAL *stateVecImag = multiQubit.stateVec.imag;
561         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
562         REAL betaImag=beta.imag, betaReal=beta.real;
563 
564 # ifdef _OPENMP
565 # pragma omp parallel \
566         default  (none) \
567         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag,\
568                         rotateAll) \
569         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
570 # endif
571         {
572 # ifdef _OPENMP
573                 # pragma omp for schedule (static)
574 # endif
575                 for (thisTask=0; thisTask<numTasks; thisTask++) {
576 
577                         thisBlock   = thisTask / sizeHalfBlock;
578                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
579                         indexLo     = indexUp + sizeHalfBlock;
580 
581                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
582                         if (rotateAll || controlBit){
583                                 // store current state vector values in temp vari
      ables
584                                 stateRealUp = stateVecReal[indexUp];
585                                 stateImagUp = stateVecImag[indexUp];
586 
587                                 stateRealLo = stateVecReal[indexLo];
588                                 stateImagLo = stateVecImag[indexLo];
589 
590                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
591                                 stateVecReal[indexUp] = alphaReal*stateRealUp - a
      lphaImag*stateImagUp 
592                                         - betaReal*stateRealLo - betaImag*stateIm
      agLo;
593                                 stateVecImag[indexUp] = alphaReal*stateImagUp + a
      lphaImag*stateRealUp 
594                                         - betaReal*stateImagLo + betaImag*stateRe
      alLo;
595 
596                                 // state[indexLo] = beta  * state[indexUp] + conj
      (alpha) * state[indexLo]
597                                 stateVecReal[indexLo] = betaReal*stateRealUp - be
      taImag*stateImagUp 
598                                         + alphaReal*stateRealLo + alphaImag*state
      ImagLo;
599                                 stateVecImag[indexLo] = betaReal*stateImagUp + be
      taImag*stateRealUp 
600                                         + alphaReal*stateImagLo - alphaImag*state
      RealLo;
601                         }
602                 } 
603         }
604 
605 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a2d73fd11c1d154640dbf114da8f34c64}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!filterOut111Local@{filterOut111Local}}
\index{filterOut111Local@{filterOut111Local}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{filterOut111Local}]{\setlength{\rightskip}{0pt plus 5cm}void filterOut111Local ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em idQubit1}, \/  const int {\em idQubit2}, \/  const int {\em idQubit3}, \/  const REAL {\em probOfFilter})}\hfill}
\label{qubits__internal_8h_a2d73fd11c1d154640dbf114da8f34c64}


Updates the state according to this scenario: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em idQubit1,idQubit2,idQubit3}]specified qubits \item[\mbox{$\leftarrow$} {\em probOfFilter}]Total probability that the 3 qubits are not all in the 1 state. \end{DoxyParams}


Definition at line 1786 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, REAL, REAL\_\-STRING\_\-FORMAT, and MultiQubit::stateVec.

Referenced by filterOut111().


\begin{DoxyCode}
1788 {
1789         long long int index;
1790         long long int stateVecSize;
1791         int bit1, bit2, bit3;
1792         const long long int chunkSize=multiQubit.numAmps;
1793         const long long int chunkId=multiQubit.chunkId;
1794 
1795         // ---------------------------------------------------------------- //
1796         //            tests                                                 //
1797         // ---------------------------------------------------------------- //
1798         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      numQubits && idQubit2 < multiQubit.numQubits);
1799 
1800         assert (probOfFilter != 0);
1801         stateVecSize = multiQubit.numAmps;
1802 
1803         if ( probOfFilter<1e-16 ){ printf("Extremely small or negative profOfFilt
      er="REAL_STRING_FORMAT"; aborting! \n",probOfFilter); exit(1);}
1804         REAL myNorm=1/sqrt(probOfFilter);
1805         REAL *stateVecReal = multiQubit.stateVec.real;
1806         REAL *stateVecImag = multiQubit.stateVec.imag;
1807 
1808 # ifdef _OPENMP
1809 # pragma omp parallel \
1810         default  (none)                      \
1811         shared   (stateVecSize, stateVecReal,stateVecImag, myNorm) \
1812         private  (index,bit1,bit2,bit3)                
1813 # endif 
1814         {
1815 # ifdef _OPENMP
1816                 # pragma omp for schedule (static)
1817 # endif
1818                 for (index=0; index<stateVecSize; index++) {
1819                         bit1 = extractBit (idQubit1, index+chunkId*chunkSize);
1820                         bit2 = extractBit (idQubit2, index+chunkId*chunkSize);
1821                         bit3 = extractBit (idQubit3, index+chunkId*chunkSize);
1822                         if ((bit1 && bit2 && bit3)) {
1823                                 stateVecReal[index]=0;
1824                                 stateVecImag [index]=0;
1825                         }else{
1826                                 stateVecReal[index] *= myNorm;
1827                                 stateVecImag[index] *= myNorm;
1828                         }
1829                 }
1830         }
1831 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}}
\index{findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{findProbabilityOfZeroDistributed}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}


Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. Size of regions to skip is a multiple of chunkSize.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1389 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1391 {
1392         // ----- measured probability
1393         REAL   totalProbability;                                    // probabilit
      y (returned) value
1394         // ----- temp variables
1395         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1396         long long int numTasks=multiQubit.numAmps;
1397         // (good for shared memory parallelism)
1398 
1399         // ---------------------------------------------------------------- //
1400         //            tests                                                 //
1401         // ---------------------------------------------------------------- //
1402         assert (measureQubit >= 0 && measureQubit < multiQubit.numQubits);
1403 
1404         // ---------------------------------------------------------------- //
1405         //            find probability                                      //
1406         // ---------------------------------------------------------------- //
1407 
1408         // initialise returned value
1409         totalProbability = 0.0;
1410 
1411         REAL *stateVecReal = multiQubit.stateVec.real;
1412         REAL *stateVecImag = multiQubit.stateVec.imag;
1413 
1414 # ifdef _OPENMP
1415 # pragma omp parallel \
1416         shared    (numTasks,stateVecReal,stateVecImag) \
1417         private   (thisTask) \
1418         reduction ( +:totalProbability )
1419 # endif
1420         {
1421 # ifdef _OPENMP
1422                 # pragma omp for schedule  (static)
1423 # endif
1424                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1425                         // summation -- simple implementation
1426                         totalProbability += stateVecReal[thisTask]*stateVecReal[t
      hisTask]
1427                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
1428 
1429                         /*
1430                         // summation -- kahan correction
1431                         y = stateVecReal[thisTask]*stateVecReal[thisTask]
1432                         + stateVecImag[thisTask]*stateVecImag[thisTask] - c;
1433                         t = totalProbability + y;
1434                         c = (t - totalProbability) - y;
1435                         totalProbability = t;
1436                         */
1437 
1438                 }
1439         }
1440 
1441         return totalProbability;
1442 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}}
\index{findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{findProbabilityOfZeroLocal}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}


Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1310 of file qubits.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1312 {
1313         // ----- sizes
1314         long long int sizeBlock,                                           // siz
      e of blocks
1315         sizeHalfBlock;                                       // size of blocks ha
      lved
1316         // ----- indices
1317         long long int thisBlock,                                           // cur
      rent block
1318              index;                                               // current inde
      x for first half block
1319         // ----- measured probability
1320         REAL   totalProbability;                                    // probabilit
      y (returned) value
1321         // ----- temp variables
1322         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1323         long long int numTasks=multiQubit.numAmps>>1;
1324 
1325         // ---------------------------------------------------------------- //
1326         //            tests                                                 //
1327         // ---------------------------------------------------------------- //
1328         assert (measureQubit >= 0 && measureQubit < multiQubit.numQubits);
1329 
1330 
1331         // ---------------------------------------------------------------- //
1332         //            dimensions                                            //
1333         // ---------------------------------------------------------------- //
1334         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1335         // and then the number to skip
1336         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1337 
1338         // initialise returned value
1339         totalProbability = 0.0;
1340 
1341         // initialise correction for kahan summation
1342         if (DEBUG) printf("sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\n",sizeHa
      lfBlock,sizeBlock,numTasks);
1343 
1344         REAL *stateVecReal = multiQubit.stateVec.real;
1345         REAL *stateVecImag = multiQubit.stateVec.imag;
1346 
1347 # ifdef _OPENMP
1348 # pragma omp parallel \
1349         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
      
1350         private   (thisTask,thisBlock,index) \
1351         reduction ( +:totalProbability )
1352 # endif 
1353         {
1354 # ifdef _OPENMP
1355                 # pragma omp for schedule  (static)
1356 # endif
1357                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1358                         thisBlock = thisTask / sizeHalfBlock;
1359                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
      
1360 
1361                         if (index<0){ printf("ABORTING as index=%Ld with thisBloc
      k = %Ld  thisTask=%Ld \n", index,thisBlock,thisTask); exit(1);}
1362 
1363                         // summation -- simple implementation
1364                         totalProbability += stateVecReal[index]*stateVecReal[inde
      x]
1365                                 + stateVecImag[index]*stateVecImag[index];
1366 
1367                         /*
1368                         // summation -- kahan correction
1369                         y = stateVecReal[index]*stateVecReal[index]
1370                         + stateVecImag[index]*stateVecImag[index] - c;
1371                         t = totalProbability + y;
1372                         c = (t - totalProbability) - y;
1373                         totalProbability = t;
1374                         */
1375 
1376                 }
1377         }
1378         return totalProbability;
1379 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ac835c194bd547240a35f0b028db1d658}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!hadamardDistributed@{hadamardDistributed}}
\index{hadamardDistributed@{hadamardDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{hadamardDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits__internal_8h_ac835c194bd547240a35f0b028db1d658}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1088 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, and REAL.

Referenced by hadamard().


\begin{DoxyCode}
1093 {
1094 
1095         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1096         long long int thisTask;  
1097         const long long int numTasks=multiQubit.numAmps;
1098 
1099         // test qubit valid
1100         assert (rotQubit >= 0 && rotQubit < multiQubit.numQubits);
1101 
1102         int sign;
1103         if (updateUpper) sign=1;
1104         else sign=-1;
1105 
1106         REAL recRoot2 = 1.0/sqrt(2);
1107 
1108         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1109         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1110         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1111 
1112 # ifdef _OPENMP
1113 # pragma omp parallel \
1114         default  (none) \
1115         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1116                         recRoot2, sign) \
1117         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1118 # endif
1119         {
1120 # ifdef _OPENMP
1121                 # pragma omp for schedule (static)
1122 # endif
1123                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1124                         // store current state vector values in temp variables
1125                         stateRealUp = stateVecRealUp[thisTask];
1126                         stateImagUp = stateVecImagUp[thisTask];
1127 
1128                         stateRealLo = stateVecRealLo[thisTask];
1129                         stateImagLo = stateVecImagLo[thisTask];
1130 
1131                         stateVecRealOut[thisTask] = recRoot2*(stateRealUp + sign*
      stateRealLo);
1132                         stateVecImagOut[thisTask] = recRoot2*(stateImagUp + sign*
      stateImagLo);
1133                 }
1134         }
1135 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a0711416fceaf63c67b496e123e845c69}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!hadamardLocal@{hadamardLocal}}
\index{hadamardLocal@{hadamardLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{hadamardLocal}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit})}\hfill}
\label{qubits__internal_8h_a0711416fceaf63c67b496e123e845c69}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \end{DoxyParams}


Definition at line 1023 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by hadamard().


\begin{DoxyCode}
1024 {
1025         long long int sizeBlock, sizeHalfBlock;
1026         long long int thisBlock, // current block
1027              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1028 
1029         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1030         long long int thisTask;         
1031         const long long int numTasks=multiQubit.numAmps>>1;
1032 
1033         // test qubit valid
1034         assert (rotQubit >= 0 && rotQubit < multiQubit.numQubits);
1035 
1036         // set dimensions
1037         sizeHalfBlock = 1LL << rotQubit;  
1038         sizeBlock     = 2LL * sizeHalfBlock; 
1039 
1040         // Can't use multiQubit.stateVec as a private OMP var
1041         REAL *stateVecReal = multiQubit.stateVec.real;
1042         REAL *stateVecImag = multiQubit.stateVec.imag;
1043 
1044         REAL recRoot2 = 1.0/sqrt(2);
1045 
1046 # ifdef _OPENMP
1047 # pragma omp parallel \
1048         default  (none) \
1049         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \
      
1050         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
1051 # endif
1052         {
1053 # ifdef _OPENMP
1054                 # pragma omp for schedule (static)
1055 # endif
1056                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1057                         thisBlock   = thisTask / sizeHalfBlock;
1058                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1059                         indexLo     = indexUp + sizeHalfBlock;
1060 
1061                         stateRealUp = stateVecReal[indexUp];
1062                         stateImagUp = stateVecImag[indexUp];
1063 
1064                         stateRealLo = stateVecReal[indexLo];
1065                         stateImagLo = stateVecImag[indexLo];
1066 
1067                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateReal
      Lo);
1068                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImag
      Lo);
1069 
1070                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateReal
      Lo);
1071                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImag
      Lo);
1072                 } 
1073         }
1074 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a35e5ac30c8427c482a97b33a4e295535}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!measureInStateDistributedRenorm@{measureInStateDistributedRenorm}}
\index{measureInStateDistributedRenorm@{measureInStateDistributedRenorm}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{measureInStateDistributedRenorm}]{\setlength{\rightskip}{0pt plus 5cm}REAL measureInStateDistributedRenorm ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  const REAL {\em totalProbability})}\hfill}
\label{qubits__internal_8h_a35e5ac30c8427c482a97b33a4e295535}


Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that the value 'outcome' has been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being zero \end{DoxyParams}


Definition at line 1696 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by measureInState().


\begin{DoxyCode}
1697 {
1698         // ----- temp variables
1699         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1700         long long int numTasks=multiQubit.numAmps;
1701         // (good for shared memory parallelism)
1702 
1703         // ---------------------------------------------------------------- //
1704         //            tests                                                 //
1705         // ---------------------------------------------------------------- //
1706         assert (measureQubit >= 0 && measureQubit < multiQubit.numQubits);
1707         assert (totalProbability != 0);
1708 
1709         REAL renorm=1/sqrt(totalProbability);
1710         
1711         REAL *stateVecReal = multiQubit.stateVec.real;
1712         REAL *stateVecImag = multiQubit.stateVec.imag;
1713 
1714 # ifdef _OPENMP
1715 # pragma omp parallel \
1716         shared    (numTasks,stateVecReal,stateVecImag) \
1717         private   (thisTask)
1718 # endif
1719         {
1720 # ifdef _OPENMP
1721                 # pragma omp for schedule  (static)
1722 # endif
1723                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1724                         // summation -- simple implementation
1725                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
1726                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
1727                 }
1728         }
1729         return totalProbability;
1730 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ac39efc9ed939382276ebd0c15dd6a0fa}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!measureInStateDistributedSetZero@{measureInStateDistributedSetZero}}
\index{measureInStateDistributedSetZero@{measureInStateDistributedSetZero}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{measureInStateDistributedSetZero}]{\setlength{\rightskip}{0pt plus 5cm}void measureInStateDistributedSetZero ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_ac39efc9ed939382276ebd0c15dd6a0fa}


Set all amplitudes in one chunk to 0. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that a zero have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}


Definition at line 1745 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by measureInState().


\begin{DoxyCode}
1746 {
1747         // ----- temp variables
1748         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1749         long long int numTasks=multiQubit.numAmps;
1750         // (good for shared memory parallelism)
1751 
1752         // ---------------------------------------------------------------- //
1753         //            tests                                                 //
1754         // ---------------------------------------------------------------- //
1755         assert (measureQubit >= 0 && measureQubit < multiQubit.numQubits);
1756 
1757         // ---------------------------------------------------------------- //
1758         //            find probability                                      //
1759         // ---------------------------------------------------------------- //
1760 
1761         REAL *stateVecReal = multiQubit.stateVec.real;
1762         REAL *stateVecImag = multiQubit.stateVec.imag;
1763 
1764 # ifdef _OPENMP
1765 # pragma omp parallel \
1766         shared    (numTasks,stateVecReal,stateVecImag) \
1767         private   (thisTask)
1768 # endif
1769         {
1770 # ifdef _OPENMP
1771                 # pragma omp for schedule  (static)
1772 # endif
1773                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1774                         // summation -- simple implementation
1775                         stateVecReal[thisTask] = 0;
1776                         stateVecImag[thisTask] = 0;
1777                 }
1778         }
1779 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a53614ce19e0a4f2c41b400cf05dc5bd1}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!measureInStateLocal@{measureInStateLocal}}
\index{measureInStateLocal@{measureInStateLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{measureInStateLocal}]{\setlength{\rightskip}{0pt plus 5cm}void measureInStateLocal ({\bf MultiQubit} {\em multiQubit}, \/  int {\em measureQubit}, \/  REAL {\em totalProbability}, \/  int {\em outcome})}\hfill}
\label{qubits__internal_8h_a53614ce19e0a4f2c41b400cf05dc5bd1}


Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. Performs an irreversible change to the state vector: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being either zero or one \item[\mbox{$\leftarrow$} {\em outcome}]to measure the probability of and set the state to -\/-\/ either zero or one \end{DoxyParams}


Definition at line 1607 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by measureInState().


\begin{DoxyCode}
1608 {
1609         // ----- sizes
1610         long long int sizeBlock,                                           // siz
      e of blocks
1611         sizeHalfBlock;                                       // size of blocks ha
      lved
1612         // ----- indices
1613         long long int thisBlock,                                           // cur
      rent block
1614              index;                                               // current inde
      x for first half block
1615         // ----- measured probability
1616         REAL   renorm;                                    // probability (returne
      d) value
1617         // ----- temp variables
1618         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1619         // (good for shared memory parallelism)
1620         long long int numTasks=multiQubit.numAmps>>1;
1621 
1622         // ---------------------------------------------------------------- //
1623         //            tests                                                 //
1624         // ---------------------------------------------------------------- //
1625         assert (measureQubit >= 0 && measureQubit < multiQubit.numQubits);
1626         assert (totalProbability != 0);
1627 
1628         // ---------------------------------------------------------------- //
1629         //            dimensions                                            //
1630         // ---------------------------------------------------------------- //
1631         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1632         // and then the number to skip
1633         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1634         
1635         renorm=1/sqrt(totalProbability);
1636         REAL *stateVecReal = multiQubit.stateVec.real;
1637         REAL *stateVecImag = multiQubit.stateVec.imag;
1638 
1639 
1640 # ifdef _OPENMP
1641 # pragma omp parallel \
1642         default (none) \
1643         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,re
      norm,outcome) \
1644         private   (thisTask,thisBlock,index)
1645 # endif
1646         {
1647                 if (outcome==0){
1648                         // measure qubit is 0
1649 # ifdef _OPENMP
1650                         # pragma omp for schedule  (static)
1651 # endif
1652                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1653                                 thisBlock = thisTask / sizeHalfBlock;
1654                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
1655                                 stateVecReal[index]=stateVecReal[index]*renorm;
1656                                 stateVecImag[index]=stateVecImag[index]*renorm;
1657 
1658                                 stateVecReal[index+sizeHalfBlock]=0;
1659                                 stateVecImag[index+sizeHalfBlock]=0;
1660                         }
1661                 } else {
1662                         // measure qubit is 1
1663 # ifdef _OPENMP
1664                         # pragma omp for schedule  (static)
1665 # endif
1666                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1667                                 thisBlock = thisTask / sizeHalfBlock;
1668                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
1669                                 stateVecReal[index]=0;
1670                                 stateVecImag[index]=0;
1671 
1672                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[in
      dex+sizeHalfBlock]*renorm;
1673                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[in
      dex+sizeHalfBlock]*renorm;
1674                         }
1675                 }
1676         }
1677 
1678 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae275b94c1a483dda43bf4ec947635605}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGate@{phaseGate}}
\index{phaseGate@{phaseGate}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_ae275b94c1a483dda43bf4ec947635605}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em type}]the type of phase gate to apply -\/-\/ one of \{SIGMA\_\-Z, S\_\-GATE, T\_\-GATE\} \end{DoxyParams}


Definition at line 108 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, phaseGateDistributed(), and phaseGateLocal().

Referenced by sGate(), sigmaZ(), and tGate().


\begin{DoxyCode}
109 {
110         phaseGateLocal(multiQubit, rotQubit, type);
111 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a38a05c7e749e806b182ef3b89878bfc4}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGateDistributed@{phaseGateDistributed}}
\index{phaseGateDistributed@{phaseGateDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGateDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_a38a05c7e749e806b182ef3b89878bfc4}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em type}]the type of phase gate to apply -\/-\/ one of \{SIGMA\_\-Z, S\_\-GATE, T\_\-GATE\} \end{DoxyParams}


Definition at line 1230 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1231 {
1232         REAL stateRealLo,stateImagLo;
1233         long long int thisTask;         
1234         const long long int numTasks=multiQubit.numAmps;
1235 
1236         // test qubit valid
1237         assert (rotQubit >= 0 && rotQubit < multiQubit.numQubits);
1238 
1239         // Can't use multiQubit.stateVec as a private OMP var
1240         REAL *stateVecReal = multiQubit.stateVec.real;
1241         REAL *stateVecImag = multiQubit.stateVec.imag;
1242 
1243         REAL recRoot2 = 1.0/sqrt(2);
1244 
1245 # ifdef _OPENMP
1246 # pragma omp parallel \
1247         default  (none) \
1248         shared   (stateVecReal,stateVecImag, recRoot2, type) \
1249         private  (thisTask,stateRealLo,stateImagLo) 
1250 # endif
1251         {
1252                 if (type==SIGMA_Z){
1253 # ifdef _OPENMP
1254                         # pragma omp for schedule (static)
1255 # endif
1256                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1257                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
      
1258                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
      
1259                         } 
1260                 } else if (type==S_GATE){
1261 # ifdef _OPENMP
1262                         # pragma omp for schedule (static)
1263 # endif
1264                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1265                                 stateRealLo = stateVecReal[thisTask];
1266                                 stateImagLo = stateVecImag[thisTask];
1267 
1268                                 stateVecReal[thisTask] = -stateImagLo;
1269                                 stateVecImag[thisTask] = stateRealLo;
1270                         } 
1271                 } else if (type==T_GATE){
1272 # ifdef _OPENMP
1273                         # pragma omp for schedule (static)
1274 # endif
1275                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1276                                 stateRealLo = stateVecReal[thisTask];
1277                                 stateImagLo = stateVecImag[thisTask];
1278 
1279                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo 
      - stateImagLo);
1280                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo 
      + stateImagLo);
1281                         } 
1282                 } else printf("Type %d is an invalid phase gate\n", type);
1283         }
1284 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a6a736aeb3532898019fe7c27010edc6a}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGateLocal@{phaseGateLocal}}
\index{phaseGateLocal@{phaseGateLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGateLocal}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_a6a736aeb3532898019fe7c27010edc6a}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em type}]the type of phase gate to apply -\/-\/ one of \{SIGMA\_\-Z, S\_\-GATE, T\_\-GATE\} \end{DoxyParams}


fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod? 

Definition at line 1144 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1145 {
1146         long long int sizeBlock, sizeHalfBlock;
1147         long long int thisBlock, // current block
1148              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1149 
1150         REAL stateRealLo,stateImagLo;
1151         long long int thisTask;         
1152         const long long int numTasks=multiQubit.numAmps>>1;
1153 
1154         // test qubit valid
1155         assert (rotQubit >= 0 && rotQubit < multiQubit.numQubits);
1156 
1157         // set dimensions
1158         sizeHalfBlock = 1LL << rotQubit;  
1159         sizeBlock     = 2LL * sizeHalfBlock; 
1160 
1161         // Can't use multiQubit.stateVec as a private OMP var
1162         REAL *stateVecReal = multiQubit.stateVec.real;
1163         REAL *stateVecImag = multiQubit.stateVec.imag;
1164 
1165         REAL recRoot2 = 1.0/sqrt(2);
1166 
1167 # ifdef _OPENMP
1168 # pragma omp parallel \
1169         default  (none) \
1170         shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type
      ) \
1171         private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) 
1172 # endif
1173         {
1174                 if (type==SIGMA_Z){
1175 # ifdef _OPENMP
1176                         # pragma omp for schedule (static)
1177 # endif
1178                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1180                                 thisBlock   = thisTask / sizeHalfBlock;
1181                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1182                                 indexLo     = indexUp + sizeHalfBlock;
1183 
1184                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
1185                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
1186                         } 
1187                 } 
1188                 
1189                 else if (type==S_GATE){
1190 # ifdef _OPENMP
1191                         # pragma omp for schedule (static)
1192 # endif
1193                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1195                                 thisBlock   = thisTask / sizeHalfBlock;
1196                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1197                                 indexLo     = indexUp + sizeHalfBlock;
1198                                 stateRealLo = stateVecReal[indexLo];
1199                                 stateImagLo = stateVecImag[indexLo];
1200 
1201                                 stateVecReal[indexLo] = -stateImagLo;
1202                                 stateVecImag[indexLo] = stateRealLo;
1203                         } 
1204                 } else if (type==T_GATE){
1205 # ifdef _OPENMP
1206                         # pragma omp for schedule (static)
1207 # endif
1208                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1210                                 thisBlock   = thisTask / sizeHalfBlock;
1211                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1212                                 indexLo     = indexUp + sizeHalfBlock;
1213                                 stateRealLo = stateVecReal[indexLo];
1214                                 stateImagLo = stateVecImag[indexLo];
1215 
1216                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo -
       stateImagLo);
1217                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo +
       stateImagLo);
1218                         } 
1219                 } else printf("Type %d is an invalid phase gate\n", type);
1220         }
1221 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a096cddbac961f0651a084d2ceb905d1b}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!probOfFilterOut111Local@{probOfFilterOut111Local}}
\index{probOfFilterOut111Local@{probOfFilterOut111Local}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{probOfFilterOut111Local}]{\setlength{\rightskip}{0pt plus 5cm}REAL probOfFilterOut111Local ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em idQubit1}, \/  const int {\em idQubit2}, \/  const int {\em idQubit3})}\hfill}
\label{qubits__internal_8h_a096cddbac961f0651a084d2ceb905d1b}


Evaluates the state according to this scenario: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. The function returns the probability of this outcome across all amplitudes in this chunk (if zero, it will exit with error) 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em idQubit1,idQubit2,idQubit3}]specified qubits \end{DoxyParams}
\begin{DoxyReturn}{Returns}
Total probability that the 3 qubits are not all in the 1 state. 
\end{DoxyReturn}


Definition at line 1839 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by probOfFilterOut111().


\begin{DoxyCode}
1840 {
1841         long long int index;
1842         long long int stateVecSize;
1843         int bit1, bit2, bit3;
1844         const long long int chunkSize=multiQubit.numAmps;
1845         const long long int chunkId=multiQubit.chunkId;
1846 
1847         // ---------------------------------------------------------------- //
1848         //            tests                                                 //
1849         // ---------------------------------------------------------------- //
1850         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      numQubits && idQubit2 < multiQubit.numQubits);
1851 
1852         stateVecSize = multiQubit.numAmps;
1853         REAL probOfFilter=0;
1854         
1855         REAL *stateVecReal = multiQubit.stateVec.real;
1856         REAL *stateVecImag = multiQubit.stateVec.imag;
1857 
1858 # ifdef _OPENMP
1859 # pragma omp parallel \
1860         default  (none)                      \
1861         shared   (stateVecSize, stateVecReal,stateVecImag) \
1862         private  (index,bit1,bit2,bit3)                \
1863         reduction ( +:probOfFilter )
1864 # endif
1865         {
1866 # ifdef _OPENMP
1867                 # pragma omp for schedule (static)
1868 # endif
1869                 for (index=0; index<stateVecSize; index++) {
1870                         bit1 = extractBit (idQubit1, index+chunkId*chunkSize);
1871                         bit2 = extractBit (idQubit2, index+chunkId*chunkSize);
1872                         bit3 = extractBit (idQubit3, index+chunkId*chunkSize);
1873                         if (!(bit1 && bit2 && bit3)) {
1874                                 probOfFilter+= stateVecReal[index]*stateVecReal[i
      ndex] + stateVecImag[index]* stateVecImag [index];
1875                         }
1876                 }
1877         }
1878         return probOfFilter;
1879 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!rotateQubitDistributed@{rotateQubitDistributed}}
\index{rotateQubitDistributed@{rotateQubitDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{rotateQubitDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void rotateQubitDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 472 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, Complex::real, and REAL.

Referenced by rotateQubit().


\begin{DoxyCode}
477 {
478 
479         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
480         long long int thisTask;  
481         const long long int numTasks=multiQubit.numAmps;
482 
483         // test qubit valid
484         assert (rotQubit >= 0 && rotQubit < multiQubit.numQubits);
485 
486         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
487         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
488         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
489         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
490         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
491 
492 # ifdef _OPENMP
493 # pragma omp parallel \
494         default  (none) \
495         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
496                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
497         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
498 # endif
499         {
500 # ifdef _OPENMP
501                 # pragma omp for schedule (static)
502 # endif
503                 for (thisTask=0; thisTask<numTasks; thisTask++) {
504                         // store current state vector values in temp variables
505                         stateRealUp = stateVecRealUp[thisTask];
506                         stateImagUp = stateVecImagUp[thisTask];
507 
508                         stateRealLo = stateVecRealLo[thisTask];
509                         stateImagLo = stateVecImagLo[thisTask];
510 
511                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
512                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
513                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
514                 }
515         }
516 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!rotateQubitLocal@{rotateQubitLocal}}
\index{rotateQubitLocal@{rotateQubitLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{rotateQubitLocal}]{\setlength{\rightskip}{0pt plus 5cm}void rotateQubitLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}


Rotate a single qubit in the state vector of probability amplitudes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 397 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by rotateQubit().


\begin{DoxyCode}
398 {
399         long long int sizeBlock, sizeHalfBlock;
400         long long int thisBlock, // current block
401              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
402 
403         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
404         long long int thisTask;         
405         const long long int numTasks=multiQubit.numAmps>>1;
406 
407         // test qubit valid
408         assert (rotQubit >= 0 && rotQubit < multiQubit.numQubits);
409 
410         // set dimensions
411         sizeHalfBlock = 1LL << rotQubit;  
412         sizeBlock     = 2LL * sizeHalfBlock; 
413 
414         // Can't use multiQubit.stateVec as a private OMP var
415         REAL *stateVecReal = multiQubit.stateVec.real;
416         REAL *stateVecImag = multiQubit.stateVec.imag;
417         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
418         REAL betaImag=beta.imag, betaReal=beta.real;
419 
420 # ifdef _OPENMP
421 # pragma omp parallel \
422         default  (none) \
423         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
424         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
425 # endif
426         {
427 # ifdef _OPENMP
428                 # pragma omp for schedule (static)
429 # endif
430                 for (thisTask=0; thisTask<numTasks; thisTask++) {
431 
432                         thisBlock   = thisTask / sizeHalfBlock;
433                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
434                         indexLo     = indexUp + sizeHalfBlock;
435 
436                         // store current state vector values in temp variables
437                         stateRealUp = stateVecReal[indexUp];
438                         stateImagUp = stateVecImag[indexUp];
439 
440                         stateRealLo = stateVecReal[indexLo];
441                         stateImagLo = stateVecImag[indexLo];
442 
443                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
444                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag
      *stateImagUp 
445                                 - betaReal*stateRealLo - betaImag*stateImagLo;
446                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag
      *stateRealUp 
447                                 - betaReal*stateImagLo + betaImag*stateRealLo;
448 
449                         // state[indexLo] = beta  * state[indexUp] + conj(alpha) 
      * state[indexLo]
450                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*s
      tateImagUp 
451                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
452                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*s
      tateRealUp 
453                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
454                 } 
455         }
456 
457 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a5958808b2f2f05937921ba7dabe5a171}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaXDistributed@{sigmaXDistributed}}
\index{sigmaXDistributed@{sigmaXDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaXDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a5958808b2f2f05937921ba7dabe5a171}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 751 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, and REAL.

Referenced by sigmaX().


\begin{DoxyCode}
754 {
755 
756         long long int thisTask;  
757         const long long int numTasks=multiQubit.numAmps;
758 
759         // test qubit valid
760         assert (rotQubit >= 0 && rotQubit < multiQubit.numQubits);
761 
762         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
763         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
764 
765 # ifdef _OPENMP
766 # pragma omp parallel \
767         default  (none) \
768         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
769         private  (thisTask)
770 # endif
771         {
772 # ifdef _OPENMP
773                 # pragma omp for schedule (static)
774 # endif
775                 for (thisTask=0; thisTask<numTasks; thisTask++) {
776                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
777                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
778                 }
779         }
780 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_aa9e640bb2d0458c937c6a87dfeca0f23}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaXLocal@{sigmaXLocal}}
\index{sigmaXLocal@{sigmaXLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaXLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit})}\hfill}
\label{qubits__internal_8h_aa9e640bb2d0458c937c6a87dfeca0f23}


Rotate a single qubit by \{\{0,1\},\{1,0\}. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \end{DoxyParams}


Definition at line 688 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaX().


\begin{DoxyCode}
689 {
690         long long int sizeBlock, sizeHalfBlock;
691         long long int thisBlock, // current block
692              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
693 
694         REAL stateRealUp,stateImagUp;
695         long long int thisTask;         
696         const long long int numTasks=multiQubit.numAmps>>1;
697 
698         // test qubit valid
699         assert (rotQubit >= 0 && rotQubit < multiQubit.numQubits);
700 
701         // set dimensions
702         sizeHalfBlock = 1LL << rotQubit;  
703         sizeBlock     = 2LL * sizeHalfBlock; 
704 
705         // Can't use multiQubit.stateVec as a private OMP var
706         REAL *stateVecReal = multiQubit.stateVec.real;
707         REAL *stateVecImag = multiQubit.stateVec.imag;
708 
709 # ifdef _OPENMP
710 # pragma omp parallel \
711         default  (none) \
712         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
713         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
714 # endif
715         {
716 # ifdef _OPENMP
717                 # pragma omp for schedule (static)
718 # endif
719                 for (thisTask=0; thisTask<numTasks; thisTask++) {
720                         thisBlock   = thisTask / sizeHalfBlock;
721                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
722                         indexLo     = indexUp + sizeHalfBlock;
723 
724                         stateRealUp = stateVecReal[indexUp];
725                         stateImagUp = stateVecImag[indexUp];
726 
727                         stateVecReal[indexUp] = stateVecReal[indexLo];
728                         stateVecImag[indexUp] = stateVecImag[indexLo];
729 
730                         stateVecReal[indexLo] = stateRealUp;
731                         stateVecImag[indexLo] = stateImagUp;
732                 } 
733         }
734 
735 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a0471f6b547ce8270ef85170b7f4f0214}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaYDistributed@{sigmaYDistributed}}
\index{sigmaYDistributed@{sigmaYDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaYDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits__internal_8h_a0471f6b547ce8270ef85170b7f4f0214}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 980 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, and REAL.

Referenced by sigmaY().


\begin{DoxyCode}
984 {
985 
986         long long int thisTask;  
987         const long long int numTasks=multiQubit.numAmps;
988 
989         // test qubit valid
990         assert (rotQubit >= 0 && rotQubit < multiQubit.numQubits);
991 
992         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
993         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
994 
995         int realSign=1, imagSign=1;
996         if (updateUpper) imagSign=-1;
997         else realSign = -1;
998 
999 # ifdef _OPENMP
1000 # pragma omp parallel \
1001         default  (none) \
1002         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,r
      ealSign,imagSign) \
1003         private  (thisTask)
1004 # endif
1005         {
1006 # ifdef _OPENMP
1007                 # pragma omp for schedule (static)
1008 # endif
1009                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1010                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisT
      ask];
1011                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisT
      ask];
1012                 }
1013         }
1014 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_afcbb1dcbe070ad0ed1a72a23251b6a83}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaYLocal@{sigmaYLocal}}
\index{sigmaYLocal@{sigmaYLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaYLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit})}\hfill}
\label{qubits__internal_8h_afcbb1dcbe070ad0ed1a72a23251b6a83}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \end{DoxyParams}


Definition at line 917 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaY().


\begin{DoxyCode}
918 {
919         long long int sizeBlock, sizeHalfBlock;
920         long long int thisBlock, // current block
921              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
922 
923         REAL stateRealUp,stateImagUp;
924         long long int thisTask;         
925         const long long int numTasks=multiQubit.numAmps>>1;
926 
927         // test qubit valid
928         assert (rotQubit >= 0 && rotQubit < multiQubit.numQubits);
929 
930         // set dimensions
931         sizeHalfBlock = 1LL << rotQubit;  
932         sizeBlock     = 2LL * sizeHalfBlock; 
933 
934         // Can't use multiQubit.stateVec as a private OMP var
935         REAL *stateVecReal = multiQubit.stateVec.real;
936         REAL *stateVecImag = multiQubit.stateVec.imag;
937 
938 # ifdef _OPENMP
939 # pragma omp parallel \
940         default  (none) \
941         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
942         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
943 # endif
944         {
945 # ifdef _OPENMP
946                 # pragma omp for schedule (static)
947 # endif
948                 for (thisTask=0; thisTask<numTasks; thisTask++) {
949                         thisBlock   = thisTask / sizeHalfBlock;
950                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
951                         indexLo     = indexUp + sizeHalfBlock;
952 
953                         stateRealUp = stateVecReal[indexUp];
954                         stateImagUp = stateVecImag[indexUp];
955 
956                         stateVecReal[indexUp] = stateVecImag[indexLo];
957                         stateVecImag[indexUp] = -stateVecReal[indexLo];
958 
959                         stateVecReal[indexLo] = -stateImagUp;
960                         stateVecImag[indexLo] = stateRealUp;
961                 } 
962         }
963 }
\end{DoxyCode}
