{\bfseries Table of Contents}
\begin{DoxyItemize}
\item \href{#coding}{\tt Coding}
\item \href{#compiling}{\tt Compiling}
\item \href{#running}{\tt Running}
\end{DoxyItemize}

\subsection*{Coding}

Qu\+E\+ST can be used in your C or C++ code, simply by including 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <\mbox{\hyperlink{QuEST_8h}{QuEST.h}}>}
\end{DoxyCode}


Independent of which platform you\textquotesingle{}ll run your simulation on (multicore C\+P\+US, a G\+PU, or over a network), your Qu\+E\+ST code will look the same, compile with the same \href{https://github.com/TysonRayJones/QuEST/blob/master/makefile}{\tt makefile}, and use the same \href{https://tysonrayjones.github.io/QuEST/QuEST_8h.html}{\tt A\+PI}.

Here\textquotesingle{}s a simulation of a very simple circuit which measures . 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <\mbox{\hyperlink{QuEST_8h}{QuEST.h}}>}

\textcolor{keywordtype}{int} \mbox{\hyperlink{bernstein__vazirani__circuit_8c_a0b1907e3d123f469a739aa425bd05574}{main}}(\textcolor{keywordtype}{int} narg, \textcolor{keywordtype}{char} *varg[]) \{

  \textcolor{comment}{// load QuEST}
  \mbox{\hyperlink{structQuESTEnv}{QuESTEnv}} \mbox{\hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env}};
  \mbox{\hyperlink{QuEST__env__local_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}{initQuESTEnv}}(&\mbox{\hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env}});

  \textcolor{comment}{// create 2 qubits in the zero state}
  \mbox{\hyperlink{structMultiQubit}{MultiQubit}} qubits; 
  \mbox{\hyperlink{QuEST_8c_a9c02591bc64c2918503afa231d90d83f}{createMultiQubit}}(&qubits, 2, \mbox{\hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env}});
  \mbox{\hyperlink{QuEST_8c_a9ba8171c9ec5c42202b144026527e9ec}{initStateZero}}(qubits);

  \textcolor{comment}{// apply circuit}
  \mbox{\hyperlink{QuEST__env__local_8c_aa09b5dd93de6df1384b8f2c0041749ab}{hadamard}}(qubits, 0);
  \mbox{\hyperlink{QuEST__env__local_8c_a67576895bbc65463481a8ea24d9b1e22}{controlledNot}}(qubits, 0, 1);
  \mbox{\hyperlink{QuEST__env__local_8c_ad5774247d836267175c664cd0e451bcb}{measure}}(qubits, 1);

  \textcolor{comment}{// unload QuEST}
  \mbox{\hyperlink{QuEST_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}{destroyMultiQubit}}(qubits, \mbox{\hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env}}); 
  \mbox{\hyperlink{QuEST__env__local_8c_abd4bc926cd3f9b65610bb228d0c59fe0}{closeQuESTEnv}}(\mbox{\hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env}});
  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 Of course, this code doesn\textquotesingle{}t output anything!





Let\textquotesingle{}s walk through a more sophisticated circuit.

We first construct a quest environment, which abstracts away any preparation of multithreading, distribution or G\+P\+U-\/acceleration strategies. 
\begin{DoxyCode}
\mbox{\hyperlink{structQuESTEnv}{QuESTEnv}} \mbox{\hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env}};
\mbox{\hyperlink{QuEST__env__local_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}{initQuESTEnv}}(&\mbox{\hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env}});
\end{DoxyCode}


We then create a quantum register, in this case of 3 qubits. 
\begin{DoxyCode}
\mbox{\hyperlink{structMultiQubit}{MultiQubit}} qubits; 
\mbox{\hyperlink{QuEST_8c_a9c02591bc64c2918503afa231d90d83f}{createMultiQubit}}(&qubits, 3, \mbox{\hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env}});
\end{DoxyCode}
 and set it to be in the zero state. 
\begin{DoxyCode}
\mbox{\hyperlink{QuEST_8c_a9ba8171c9ec5c42202b144026527e9ec}{initStateZero}}(qubits);
\end{DoxyCode}
 We can create multiple {\ttfamily \mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}} instances, and Qu\+E\+ST will sort out allocating memory for the state-\/vectors, even over networks!

We\textquotesingle{}re now ready to apply some gates to our qubits, which in this case have indices 0, 1 and 2. When applying a gate, we pass along which quantum register to operate upon. 
\begin{DoxyCode}
\mbox{\hyperlink{QuEST__env__local_8c_aa09b5dd93de6df1384b8f2c0041749ab}{hadamard}}(qubits, 0);
\mbox{\hyperlink{QuEST__env__local_8c_a67576895bbc65463481a8ea24d9b1e22}{controlledNot}}(qubits, 0, 1);
\mbox{\hyperlink{QuEST_8c_ace0d3592d38a990e81a434c4e9681500}{rotateY}}(qubits, 2, .1);
\end{DoxyCode}


Some gates allow us to specify a general number of control qubits 
\begin{DoxyCode}
\mbox{\hyperlink{QuEST_8c_afc1835c6b43b6e59ce7df7b13f274fc7}{multiControlledPhaseGate}}(qubits, (\textcolor{keywordtype}{int} [])\{0, 1, 2\}, 3);
\end{DoxyCode}


We can specify general single-\/qubit unitary operations as 2x2 matrices 
\begin{DoxyCode}
\textcolor{comment}{// sqrt(X) with a pi/4 global phase}
\mbox{\hyperlink{structComplexMatrix2}{ComplexMatrix2}} u;
u.\mbox{\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}} = (\mbox{\hyperlink{QuEST_8h_ad59c9e471673c07782e6c403277ffd8d}{Complex}}) \{.\mbox{\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}}=.5, .imag= .5\};
u.\mbox{\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}} = (\mbox{\hyperlink{QuEST_8h_ad59c9e471673c07782e6c403277ffd8d}{Complex}}) \{.\mbox{\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}}=.5, .imag=-.5\}; 
u.\mbox{\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}} = (\mbox{\hyperlink{QuEST_8h_ad59c9e471673c07782e6c403277ffd8d}{Complex}}) \{.\mbox{\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}}=.5, .imag=-.5\};
u.\mbox{\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}} = (\mbox{\hyperlink{QuEST_8h_ad59c9e471673c07782e6c403277ffd8d}{Complex}}) \{.\mbox{\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}}=.5, .imag= .5\};
\mbox{\hyperlink{QuEST__env__local_8c_a7a0877e33700f6bad48adb51b7b3fb67}{unitary}}(qubits, 0, u);
\end{DoxyCode}
 or more compactly, foregoing the global phase factor, 
\begin{DoxyCode}
\mbox{\hyperlink{structComplex}{Complex}} a, b;
a.\mbox{\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}} = .5; a.\mbox{\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}} =  .5;
b.\mbox{\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}} = .5; b.\mbox{\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}} = -.5;
\mbox{\hyperlink{QuEST__env__local_8c_a03b13dfcabd8c59b50dbdd3af44ba8b2}{compactUnitary}}(qubits, 1, a, b);
\end{DoxyCode}
 or even more compactly, as a rotation around an arbitrary axis on the Bloch-\/sphere 
\begin{DoxyCode}
\mbox{\hyperlink{structVector}{Vector}} v;
v.\mbox{\hyperlink{structVector_aac7abe171ba4bada50ed72acba6259fc}{x}} = 1; v.\mbox{\hyperlink{structVector_a375ca805d4c808a53d7c4e0c737ae3de}{y}} = 0; v.\mbox{\hyperlink{structVector_ad4e863651be7d6b7e2b28cd7445a0ccf}{z}} = 0;
\mbox{\hyperlink{QuEST_8c_a8810423457803005fecd415f4299f40d}{rotateAroundAxis}}(qubits, 2, 3.14/2, v);
\end{DoxyCode}


We can controlled-\/apply general unitaries 
\begin{DoxyCode}
\mbox{\hyperlink{QuEST__env__local_8c_ab4812953bc457405b3aa05a4c2f64f4a}{controlledCompactUnitary}}(qubits, 0, 1, a, b);
\end{DoxyCode}
 even with multiple control qubits! 
\begin{DoxyCode}
\mbox{\hyperlink{QuEST__env__local_8c_ae395a79690283ed81106afadd7a8cd8a}{multiControlledUnitary}}(qubits, (\textcolor{keywordtype}{int} [])\{0, 1\}, 2, 2, u);
\end{DoxyCode}


What has this done to the probability of the basis state $\vert$111$>$ = $\vert$7$>$? 
\begin{DoxyCode}
\mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}} prob = \mbox{\hyperlink{QuEST_8c_a799b10447d6dbdaf960a4d3eedd22014}{getProbEl}}(qubits, 7);
printf(\textcolor{stringliteral}{"Probability amplitude of |111>: %lf\(\backslash\)n"}, prob);
\end{DoxyCode}
 Here, {\ttfamily R\+E\+AL} is a floating point number (e.\+g. {\ttfamily double}). The state-\/vector is stored as {\ttfamily R\+E\+AL}s so that we can change its precision without any recoding, by configuring \href{../QuEST/QuEST_precision.h}{\tt Qu\+E\+S\+T\+\_\+precision.\+h}

How probable is measuring our final qubit (2) in outcome {\ttfamily 1}? 
\begin{DoxyCode}
prob = \mbox{\hyperlink{QuEST__env__local_8c_ad315c941a51bc053d39ebfa2040fd32e}{findProbabilityOfOutcome}}(qubits, 2, 1);
printf(\textcolor{stringliteral}{"Probability of qubit 2 being in state 1: %f\(\backslash\)n"}, prob);
\end{DoxyCode}


Let\textquotesingle{}s measure the first qubit, randomly collapsing it to 0 or 1 
\begin{DoxyCode}
\textcolor{keywordtype}{int} outcome = \mbox{\hyperlink{QuEST__env__local_8c_ad5774247d836267175c664cd0e451bcb}{measure}}(qubits, 0);
printf(\textcolor{stringliteral}{"Qubit 0 was measured in state %d\(\backslash\)n"}, outcome);
\end{DoxyCode}
 and now measure our final qubit, while also learning of the probability of its outcome. 
\begin{DoxyCode}
outcome = measureWithStats(qubits, 2, &prob);
printf("Qubit 2 collapsed to %d with probability %f\(\backslash\)n", outcome, prob);
\end{DoxyCode}


At the conclusion of our circuit, we should free up the memory used by our state-\/vector. 
\begin{DoxyCode}
\mbox{\hyperlink{QuEST_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}{destroyMultiQubit}}(qubits, \mbox{\hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env}}); 
\mbox{\hyperlink{QuEST__env__local_8c_abd4bc926cd3f9b65610bb228d0c59fe0}{closeQuESTEnv}}(\mbox{\hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env}});
\textcolor{keywordflow}{return} 0;
\end{DoxyCode}


The effect of the \href{tutorial_example.c}{\tt code above} is to simulate the below circuit



and after compiling (see section below), gives psuedo-\/random output

\begin{quote}

\begin{DoxyCode}
Probability amplitude of |111>: 0.498751
Probability of qubit 2 being in state 1: 0.749178
Qubit 0 was measured in state 1
Qubit 2 collapsed to 1 with probability 0.998752
\end{DoxyCode}
 \end{quote}


\begin{quote}

\begin{DoxyCode}
Probability amplitude of |111>: 0.498751
Probability of qubit 2 being in state 1: 0.749178
Qubit 0 was measured in state 0
Qubit 2 collapsed to 1 with probability 0.499604
\end{DoxyCode}
 \end{quote}


Qu\+E\+ST uses the \href{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html}{\tt Mersenne Twister} algorithm to generate random numbers used for randomly collapsing the state-\/vector. The user can seed this R\+NG using {\ttfamily seed\+Qu\+E\+S\+T(array\+Of\+Seeds, array\+Length)}, otherwise Qu\+E\+ST will by default (through {\ttfamily \mbox{\hyperlink{QuEST_8c_ab0ab3ec70938712c26988a6aa51263a0}{seed\+Qu\+E\+S\+T\+Default()}}}) create a seed from the current time, the process id, and the hostname. 



\subsection*{Compiling}

To compile, copy the \href{../makefile}{\tt makefile} into the same folder as your circuit code. Adjust the {\itshape User Settings} section to configure compilation. You\textquotesingle{}ll need to set 
\begin{DoxyCode}
# name of the executable to create
EXE = myExecutable

# space-separated names (no file type) of all user source files (.c or .cpp) in the root directory
SOURCES = myCode1 myCode2

# path to QuEST library from root directory
QUEST\_DIR = path/to/QuEST
\end{DoxyCode}


Next, indicate which compiler you wish to use. For example, to use the default compiler on O\+SX\+: 
\begin{DoxyCode}
# compiler to use, which should support both C and C++, to be wrapped by GPU/MPI compilers
COMPILER = clang

# type of above compiler, one of \{GNU, INTEL, CLANG\}, used for setting compiler flags
COMPILER\_TYPE = CLANG
\end{DoxyCode}


To compile your code to run on multicore/multi-\/\+C\+PU systems, and/or for distributed systems, or on G\+P\+Us, simply set the appropriate variables 
\begin{DoxyCode}
# hardwares to target: 1 means use, 0 means don't use
MULTITHREADED = 0
DISTRIBUTED = 0
GPUACCELERATED = 0
\end{DoxyCode}
 Note that using multithreading requires an Open\+MP compatible compiler (e.\+g. \href{https://gcc.gnu.org/gcc-4.9/changes.html}{\tt G\+CC 4.\+9}), using distribution requires an M\+PI compiler ({\ttfamily mpicc})is installed on your system, and G\+PU acceleration requires a C\+U\+DA compiler ({\ttfamily nvcc}). We\textquotesingle{}ve made a comprehensive list of compatible compilers which you can view ../tests/compilers/compatibility.md \char`\"{}here\char`\"{}. This does not change your {\ttfamily C\+O\+M\+P\+I\+L\+ER} setting -\/ the makefile will choose the appropriate M\+PI and C\+U\+DA wrappers automatically.

\begin{quote}
Note also that G\+PU users must additionally specify the the {\itshape Compute Capability} of their G\+PU, which can be looked up at the \href{https://developer.nvidia.com/cuda-gpus}{\tt N\+V\+I\+D\+IA website} 
\begin{DoxyCode}
GPU\_COMPUTE\_CAPABILITY = 30
\end{DoxyCode}
 An incorrect {\itshape Compute Capability} will lead to drastically incorrect computations. You can check if you\textquotesingle{}ve set the right {\itshape Compute Capability} by running the unit tests via {\ttfamily \mbox{\hyperlink{runTests_8c}{tests/run\+Tests.\+c}}}. \end{quote}


You\textquotesingle{}re now ready to compile your code by entering 
\begin{DoxyCode}
make
\end{DoxyCode}
 at the terminal, in the directory of your code. For the above example, this performs 
\begin{DoxyCode}
gcc -O2 -std=c99 -mavx -Wall -fopenmp -c path/to/QuEST/CPU/QuEST.c
gcc -O2 -std=c99 -mavx -Wall -fopenmp -c path/to/QuEST/mt19937ar.c
gcc -O2 -std=c99 -mavx -Wall -fopenmp -c myCode1.c
gcc -O2 -std=c99 -mavx -Wall -fopenmp -c myCode2.c
gcc -O2 -std=c99 -mavx -Wall -fopenmp -c path/to/QuEST/CPU/QuEST\_env\_local.c
gcc -O2 -std=c99 -mavx -Wall -fopenmp -o myExecutable QuEST.o mt19937ar.o myCode1.o myCode2.o
       QuEST\_env\_local.o -lm
\end{DoxyCode}
 



\subsection*{Running}

\subsubsection*{locally}

You can then call your code 
\begin{DoxyCode}
./myExecutable
\end{DoxyCode}
 If you enabled multithreading when compiling, you can control how many threads your code uses by setting {\ttfamily O\+M\+P\+\_\+\+N\+U\+M\+\_\+\+T\+H\+R\+E\+A\+DS}, ideally to the number of available cores on your machine 
\begin{DoxyCode}
export OMP\_NUM\_THREADS=8
./myExecutable
\end{DoxyCode}
 Qu\+E\+ST will automatically allocate work between the given number of threads to speedup your simulation.

If you compiled in distributed mode, your code can be run over a network (here, over 8 machines) using 
\begin{DoxyCode}
mpirun -np 8 ./myExecutable
\end{DoxyCode}
 This will, if enabled, also utilise multithreading on each node with as many threads set in {\ttfamily O\+M\+P\+\_\+\+N\+U\+M\+\_\+\+T\+H\+R\+E\+A\+DS}.

If you compiled for a G\+PU connected to your system, simply run 
\begin{DoxyCode}
./myExecutable
\end{DoxyCode}
 as normal!

\subsubsection*{through a job submission system}

There are no special requirements for running Qu\+E\+ST through job submission systems. Just call {\ttfamily ./my\+Executable} as you would any other binary.

For example, the \href{tutorial_example.c}{\tt above code} can be split over 4 M\+PI nodes (each with 8 cores) by setting {\ttfamily D\+I\+S\+T\+R\+I\+B\+U\+T\+ED = 1} (and {\ttfamily M\+U\+L\+T\+I\+T\+H\+R\+E\+A\+D\+ED = 1}) in the makefile, and writing a S\+L\+U\+RM submission script 
\begin{DoxyCode}
#SBATCH --nodes=4
#SBATCH --ntasks-per-node=1

module purge
module load mvapich2

make clean
make

export OMP\_NUM\_THREADS=8
mpirun ./myExecutable
\end{DoxyCode}
 or a P\+BS submission script like 
\begin{DoxyCode}
#PBS -l select=4:ncpus=8

make clean
make

export OMP\_NUM\_THREADS=8
aprun -n 4 -d 8 -cc numa\_node ./myExecutable
\end{DoxyCode}


Running Qu\+E\+ST on a G\+PU partition is similarly easy in S\+L\+U\+RM 
\begin{DoxyCode}
#SBATCH --nodes=1
#SBATCH --ntasks-per-node=1
#SBATCH --gres=gpu:1 

#SBATCH --partition=gpu    ## name may vary

module purge
module load cuda  ## name may vary

make clean
make

./myExecutable
\end{DoxyCode}


On each platform, there is no change to our source code or our Qu\+E\+ST interface. We simply recompile, and Qu\+E\+ST will utilise the available hardware (a G\+PU, shared-\/memory or distributed C\+P\+Us) to speedup our code.

Note that parallelising with M\+PI ({\ttfamily D\+I\+S\+T\+R\+I\+B\+U\+T\+ED = 1}) will mean all code in your source file will be repeated on every node. To execute some code (e.\+g. printing) only on one node, do 
\begin{DoxyCode}
\textcolor{keywordflow}{if} (\mbox{\hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env}}.\mbox{\hyperlink{structQuESTEnv_aa648bb336cf8598467cb62db00b9cee8}{rank}} == 0)
    printf(\textcolor{stringliteral}{"Only one node executes this print!"});
\end{DoxyCode}
 Such conditions are valid and always satisfied in code run on a single node. 