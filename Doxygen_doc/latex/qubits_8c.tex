\hypertarget{qubits_8c}{}\subsection{qubits.\+c File Reference}
\label{qubits_8c}\index{qubits.\+c@{qubits.\+c}}


The core of the Qu\+E\+ST Library.  


{\ttfamily \#include $<$math.\+h$>$}\\*
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$assert.\+h$>$}\\*
{\ttfamily \#include \char`\"{}precision.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}qubits.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}qubits\+\_\+internal.\+h\char`\"{}}\\*
{\ttfamily \#include $<$omp.\+h$>$}\\*
\subsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{D\+E\+B\+UG}~0
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extract\+Bit} (const int location\+Of\+Bit\+From\+Right, const long long int the\+Encoded\+Number)
\begin{DoxyCompactList}\small\item\em Get the value of the bit at a particular index in a number. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a9c02591bc64c2918503afa231d90d83f}{create\+Multi\+Qubit} (\hyperlink{structMultiQubit}{Multi\+Qubit} $\ast$multi\+Qubit, int num\+Qubits, \hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} env)
\begin{DoxyCompactList}\small\item\em Create a \hyperlink{structMultiQubit}{Multi\+Qubit} object representing a set of qubits. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}{destroy\+Multi\+Qubit} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, \hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} env)
\begin{DoxyCompactList}\small\item\em Deallocate a \hyperlink{structMultiQubit}{Multi\+Qubit} object representing a set of qubits. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}{report\+State} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Print the current state vector of probability amplitudes for a set of qubits to file. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a842d6884e063a5865a2232cba56b65ac}{report\+State\+To\+Screen} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, \hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} env, int report\+Rank)
\begin{DoxyCompactList}\small\item\em Print the current state vector of probability amplitudes for a set of qubits to standard out. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}{report\+Multi\+Qubit\+Params} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Report metainformation about a set of qubits\+: number of qubits, number of probability amplitudes. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a8f10aabf9f607f19093aee54630caa21}{get\+Environment\+String} (\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} env, \hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, char str\mbox{[}200\mbox{]})
\item 
void \hyperlink{qubits_8c_acb5b2eff794339090004d29f02a70d9a}{init\+State\+Zero} (\hyperlink{structMultiQubit}{Multi\+Qubit} $\ast$multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Initialise a set of $ N $ qubits to the classical zero state $ {| 0 \rangle}^{\otimes N} $. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}{init\+State\+Plus} (\hyperlink{structMultiQubit}{Multi\+Qubit} $\ast$multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Initialise a set of $ N $ qubits to the plus state $ {| + \rangle}^{\otimes N} = \frac{1}{\sqrt{2^N}} (| 0 \rangle + | 1 \rangle)^{\otimes N} $. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a7169fd0442cbc3418f3fac4d13363ca2}{init\+State\+Of\+Single\+Qubit} (\hyperlink{structMultiQubit}{Multi\+Qubit} $\ast$multi\+Qubit, int qubit\+Id, int outcome)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes such that one qubit is set to \textquotesingle{}outcome\textquotesingle{} and all other qubits are in an equal superposition of zero and one. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}{init\+State\+Debug} (\hyperlink{structMultiQubit}{Multi\+Qubit} $\ast$multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes to an (unphysical) state with each component of each probability amplitude a unique floating point value. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a433876ee9f3bcc54af346300f571fc3c}{initialize\+State\+From\+Single\+File} (\hyperlink{structMultiQubit}{Multi\+Qubit} $\ast$multi\+Qubit, char filename\mbox{[}200\mbox{]}, \hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} env)
\item 
int \hyperlink{qubits_8c_a793584932ae384c82e7e42db7d35d18d}{compare\+States} (\hyperlink{structMultiQubit}{Multi\+Qubit} mq1, \hyperlink{structMultiQubit}{Multi\+Qubit} mq2, \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} precision)
\item 
int \hyperlink{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}{validate\+Matrix\+Is\+Unitary} (\hyperlink{structComplexMatrix2}{Complex\+Matrix2} u)
\item 
int \hyperlink{qubits_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}{validate\+Alpha\+Beta} (\hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
int \hyperlink{qubits_8c_a71c14976f63cfcda70026fa20ee531fe}{validate\+Unit\+Vector} (\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} ux, \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} uy, \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} uz)
\item 
void \hyperlink{qubits_8c_a7fadb225fc385db789e844c87fcba9e1}{rotate\+Around\+Axis} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} angle, \hyperlink{structVector}{Vector} unit\+Axis)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around a given vector on the Bloch-\/sphere. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a6cc7fa705a2f2e6b486b49c5589d5df5}{rotateX} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around the X-\/axis of the Bloch-\/sphere. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ace0d3592d38a990e81a434c4e9681500}{rotateY} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around the Y-\/axis of the Bloch-\/sphere. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_abd621412ad30c1b034f4ce153c4afe10}{rotateZ} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around the Z-\/axis of the Bloch-\/sphere (also known as a phase shift gate). \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a9cee2d8716667a3318420a3b672f5b92}{compact\+Unitary\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits_8c_ac134fb45b0a7248c5d15e16eb7139a35}{unitary\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, \hyperlink{structComplexMatrix2}{Complex\+Matrix2} u)
\item 
void \hyperlink{qubits_8c_a20ee1878a63ae6112e8845f4a8787592}{compact\+Unitary\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a2343b7240118e89aa615e2c9140b770b}{unitary\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_afc77657651d52c47403b44b923a098a8}{controlled\+Compact\+Unitary\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int control\+Qubit, const int target\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits_8c_a1309eabcba3cb97fbc3cd2e606d17766}{multi\+Controlled\+Unitary\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, long long int mask, \hyperlink{structComplexMatrix2}{Complex\+Matrix2} u)
\item 
void \hyperlink{qubits_8c_a8a4afcff70195a306c082b8ed8d4e09a}{controlled\+Unitary\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int control\+Qubit, const int target\+Qubit, \hyperlink{structComplexMatrix2}{Complex\+Matrix2} u)
\item 
void \hyperlink{qubits_8c_a717855e835e3161e08c18cdc15325d27}{controlled\+Compact\+Unitary\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int control\+Qubit, const int target\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a642093063a1f889f61a1311f6d6f2d3f}{controlled\+Unitary\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int control\+Qubit, const int target\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{multi\+Controlled\+Unitary\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, long long int mask, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a74822fd86bb5d81766e6e8dbdcd62df1}{sigma\+X\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit)
\item 
void \hyperlink{qubits_8c_a2275fff50824fe47485890ff5a857785}{sigma\+X\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ad357a43e80e3baf013975b1b70942f4c}{controlled\+Not\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int control\+Qubit, const int target\+Qubit)
\item 
void \hyperlink{qubits_8c_a05875a70b539a3efb28d027823403f34}{controlled\+Not\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int control\+Qubit, const int target\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a81fbfaed65a742a7dfd622e17652245e}{sigma\+Y\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit)
\item 
void \hyperlink{qubits_8c_af5ef5166f00c0572354b4ac53dcf40cf}{sigma\+Y\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out, int update\+Upper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_aa9f0718b4dd794a3e1b143e3b153bfc5}{hadamard\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit)
\item 
void \hyperlink{qubits_8c_ae6a897066979fc52d977007d959ca09d}{hadamard\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out, int update\+Upper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a3a54566b73ac84c312d7da4f56ffbc3b}{phase\+Gate\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type} type)
\item 
void \hyperlink{qubits_8c_af832ed00b02a0597b7fe0b714032c54a}{phase\+Gate\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type} type)
\item 
void \hyperlink{qubits_8c_aebaab86326779de55d335cfea3efde8f}{sigmaZ} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit sigma-\/Z (also known as the Z, Pauli-\/Z or phase-\/flip) gate. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_adda6c47876a7676488ed0565a19eaa65}{s\+Gate} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit S gate. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_af764ea63a2e870098f4e1ce08562942e}{t\+Gate} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit T gate. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}{find\+Probability\+Of\+Zero\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}{find\+Probability\+Of\+Zero\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a11a96159191cbf1b01a1080e7f045aac}{controlled\+Phase\+Gate} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2)
\begin{DoxyCompactList}\small\item\em Apply the (two-\/qubit) controlled phase gate, also known as the controlled sigmaZ gate. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_afc1835c6b43b6e59ce7df7b13f274fc7}{multi\+Controlled\+Phase\+Gate} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, int $\ast$control\+Qubits, int num\+Control\+Qubits)
\begin{DoxyCompactList}\small\item\em Apply the multiple-\/qubit controlled phase gate, also known as the multiple-\/qubit controlled sigmaZ gate. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a01d9a8b7ff0e09ec399e158389783aa9}{collapse\+To\+Outcome\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, int measure\+Qubit, \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} total\+Probability, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapse\+To\+Outcome\+Distributed\+Renorm} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit, const \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} total\+Probability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measure\+Qubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapse\+To\+Outcome\+Distributed\+Set\+Zero} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Set all amplitudes in one chunk to 0. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}{get\+Prob\+El} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the probability of the state at an index in the full state vector. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \hyperlink{qubits_8c_aac1637696885c75b73a1ecf381cea713}{error\+Codes} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
The core of the Qu\+E\+ST Library. 



\subsubsection{Macro Definition Documentation}
\index{qubits.\+c@{qubits.\+c}!D\+E\+B\+UG@{D\+E\+B\+UG}}
\index{D\+E\+B\+UG@{D\+E\+B\+UG}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{D\+E\+B\+UG}{DEBUG}}]{\setlength{\rightskip}{0pt plus 5cm}\#define D\+E\+B\+UG~0}\hypertarget{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{}\label{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}


Definition at line 15 of file qubits.\+c.



Referenced by find\+Probability\+Of\+Zero\+Local(), init\+State\+Of\+Single\+Qubit(), init\+State\+Plus(), and init\+State\+Zero().



\subsubsection{Function Documentation}
\index{qubits.\+c@{qubits.\+c}!collapse\+To\+Outcome\+Distributed\+Renorm@{collapse\+To\+Outcome\+Distributed\+Renorm}}
\index{collapse\+To\+Outcome\+Distributed\+Renorm@{collapse\+To\+Outcome\+Distributed\+Renorm}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{collapse\+To\+Outcome\+Distributed\+Renorm(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit, const R\+E\+A\+L total\+Probability)}{collapseToOutcomeDistributedRenorm(MultiQubit multiQubit, const int measureQubit, const REAL totalProbability)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} collapse\+To\+Outcome\+Distributed\+Renorm (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit, }
\item[{const {\bf R\+E\+AL}}]{total\+Probability}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{}\label{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}


Renormalise parts of the state vector where measure\+Qubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that the value \textquotesingle{}outcome\textquotesingle{} has been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. In the distributed version, one block (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em total\+Probability} & probability of qubit measure\+Qubit being zero \\
\hline
\end{DoxyParams}


Definition at line 1871 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by collapse\+To\+Outcome(), and measure\+With\+Stats().


\begin{DoxyCode}
1872 \{
1873         \textcolor{comment}{// ----- temp variables}
1874         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1875         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1876         \textcolor{comment}{// (good for shared memory parallelism)}
1877 
1878         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} renorm=1/sqrt(totalProbability);
1879         
1880         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1881         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1882 
1883 \textcolor{preprocessor}{# ifdef \_OPENMP}
1884 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1885 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1886 \textcolor{preprocessor}{        private   (thisTask)}
1887 \textcolor{preprocessor}{# endif}
1888         \{
1889 \textcolor{preprocessor}{# ifdef \_OPENMP}
1890 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1891 \textcolor{preprocessor}{# endif}
1892                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1893                         \textcolor{comment}{// summation -- simple implementation}
1894                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
1895                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
1896                 \}
1897         \}
1898         \textcolor{keywordflow}{return} totalProbability;
1899 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!collapse\+To\+Outcome\+Distributed\+Set\+Zero@{collapse\+To\+Outcome\+Distributed\+Set\+Zero}}
\index{collapse\+To\+Outcome\+Distributed\+Set\+Zero@{collapse\+To\+Outcome\+Distributed\+Set\+Zero}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{collapse\+To\+Outcome\+Distributed\+Set\+Zero(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit)}{collapseToOutcomeDistributedSetZero(MultiQubit multiQubit, const int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void collapse\+To\+Outcome\+Distributed\+Set\+Zero (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{}\label{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}


Set all amplitudes in one chunk to 0. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that a zero have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 or 1. In the distributed version, one block (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}


Definition at line 1913 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by collapse\+To\+Outcome(), and measure\+With\+Stats().


\begin{DoxyCode}
1914 \{
1915         \textcolor{comment}{// ----- temp variables}
1916         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1917         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1918         \textcolor{comment}{// (good for shared memory parallelism)}
1919 
1920         \textcolor{comment}{// ---------------------------------------------------------------- //}
1921         \textcolor{comment}{//            find probability                                      //}
1922         \textcolor{comment}{// ---------------------------------------------------------------- //}
1923 
1924         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1925         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1926 
1927 \textcolor{preprocessor}{# ifdef \_OPENMP}
1928 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1929 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1930 \textcolor{preprocessor}{        private   (thisTask)}
1931 \textcolor{preprocessor}{# endif}
1932         \{
1933 \textcolor{preprocessor}{# ifdef \_OPENMP}
1934 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1935 \textcolor{preprocessor}{# endif}
1936                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1937                         \textcolor{comment}{// summation -- simple implementation}
1938                         stateVecReal[thisTask] = 0;
1939                         stateVecImag[thisTask] = 0;
1940                 \}
1941         \}
1942 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!collapse\+To\+Outcome\+Local@{collapse\+To\+Outcome\+Local}}
\index{collapse\+To\+Outcome\+Local@{collapse\+To\+Outcome\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{collapse\+To\+Outcome\+Local(\+Multi\+Qubit multi\+Qubit, int measure\+Qubit, R\+E\+A\+L total\+Probability, int outcome)}{collapseToOutcomeLocal(MultiQubit multiQubit, int measureQubit, REAL totalProbability, int outcome)}}]{\setlength{\rightskip}{0pt plus 5cm}void collapse\+To\+Outcome\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{int}]{measure\+Qubit, }
\item[{{\bf R\+E\+AL}}]{total\+Probability, }
\item[{int}]{outcome}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a01d9a8b7ff0e09ec399e158389783aa9}{}\label{qubits_8c_a01d9a8b7ff0e09ec399e158389783aa9}


Update the state vector to be consistent with measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. 

Performs an irreversible change to the state vector\+: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em total\+Probability} & probability of qubit measure\+Qubit being either zero or one \\
\hline
\mbox{\tt in}  & {\em outcome} & to measure the probability of and set the state to -- either zero or one \\
\hline
\end{DoxyParams}


Definition at line 1789 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by collapse\+To\+Outcome(), and measure\+With\+Stats().


\begin{DoxyCode}
1790 \{
1791         \textcolor{comment}{// ----- sizes}
1792         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
1793         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
1794         \textcolor{comment}{// ----- indices}
1795         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
1796              index;                                               \textcolor{comment}{// current index for first half block}
1797         \textcolor{comment}{// ----- measured probability}
1798         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   renorm;                                    \textcolor{comment}{// probability (returned) value}
1799         \textcolor{comment}{// ----- temp variables}
1800         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1801         \textcolor{comment}{// (good for shared memory parallelism)}
1802         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1803 
1804         \textcolor{comment}{// ---------------------------------------------------------------- //}
1805         \textcolor{comment}{//            dimensions                                            //}
1806         \textcolor{comment}{// ---------------------------------------------------------------- //}
1807         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
1808         \textcolor{comment}{// and then the number to skip}
1809         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
1810         
1811         renorm=1/sqrt(totalProbability);
1812         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1813         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1814 
1815 
1816 \textcolor{preprocessor}{# ifdef \_OPENMP}
1817 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1818 \textcolor{preprocessor}{        default (none) \(\backslash\)}
1819 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,renorm,outcome) \(\backslash\)}
1820 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index)}
1821 \textcolor{preprocessor}{# endif}
1822         \{
1823                 \textcolor{keywordflow}{if} (outcome==0)\{
1824                         \textcolor{comment}{// measure qubit is 0}
1825 \textcolor{preprocessor}{# ifdef \_OPENMP}
1826 \textcolor{preprocessor}{                        # pragma omp for schedule  (static)}
1827 \textcolor{preprocessor}{# endif}
1828                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1829                                 thisBlock = thisTask / sizeHalfBlock;
1830                                 index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1831                                 stateVecReal[index]=stateVecReal[index]*renorm;
1832                                 stateVecImag[index]=stateVecImag[index]*renorm;
1833 
1834                                 stateVecReal[index+sizeHalfBlock]=0;
1835                                 stateVecImag[index+sizeHalfBlock]=0;
1836                         \}
1837                 \} \textcolor{keywordflow}{else} \{
1838                         \textcolor{comment}{// measure qubit is 1}
1839 \textcolor{preprocessor}{# ifdef \_OPENMP}
1840 \textcolor{preprocessor}{                        # pragma omp for schedule  (static)}
1841 \textcolor{preprocessor}{# endif}
1842                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1843                                 thisBlock = thisTask / sizeHalfBlock;
1844                                 index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1845                                 stateVecReal[index]=0;
1846                                 stateVecImag[index]=0;
1847 
1848                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[index+sizeHalfBlock]*renorm;
1849                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[index+sizeHalfBlock]*renorm;
1850                         \}
1851                 \}
1852         \}
1853 
1854 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!compact\+Unitary\+Distributed@{compact\+Unitary\+Distributed}}
\index{compact\+Unitary\+Distributed@{compact\+Unitary\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{compact\+Unitary\+Distributed(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, Complex rot1, Complex rot2, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out)}{compactUnitaryDistributed(MultiQubit multiQubit, const int targetQubit, Complex rot1, Complex rot2, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void compact\+Unitary\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex}}]{rot1, }
\item[{{\bf Complex}}]{rot2, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a20ee1878a63ae6112e8845f4a8787592}{}\label{qubits_8c_a20ee1878a63ae6112e8845f4a8787592}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 546 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, Complex\+::real, and R\+E\+AL.



Referenced by compact\+Unitary().


\begin{DoxyCode}
551 \{
552 
553         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
554         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
555         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
556 
557         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
558         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
559         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
560         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
561         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
562 
563 \textcolor{preprocessor}{# ifdef \_OPENMP}
564 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
565 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
566 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
567 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag) \(\backslash\)}
568 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
569 \textcolor{preprocessor}{# endif}
570         \{
571 \textcolor{preprocessor}{# ifdef \_OPENMP}
572 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
573 \textcolor{preprocessor}{# endif}
574                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
575                         \textcolor{comment}{// store current state vector values in temp variables}
576                         stateRealUp = stateVecRealUp[thisTask];
577                         stateImagUp = stateVecImagUp[thisTask];
578 
579                         stateRealLo = stateVecRealLo[thisTask];
580                         stateImagLo = stateVecImagLo[thisTask];
581 
582                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
583                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp + rot2Real*
      stateRealLo + rot2Imag*stateImagLo;
584                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp + rot2Real*
      stateImagLo - rot2Imag*stateRealLo;
585                 \}
586         \}
587 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!compact\+Unitary\+Local@{compact\+Unitary\+Local}}
\index{compact\+Unitary\+Local@{compact\+Unitary\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{compact\+Unitary\+Local(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, Complex alpha, Complex beta)}{compactUnitaryLocal(MultiQubit multiQubit, const int targetQubit, Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}void compact\+Unitary\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a9cee2d8716667a3318420a3b672f5b92}{}\label{qubits_8c_a9cee2d8716667a3318420a3b672f5b92}


Definition at line 417 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, Complex\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by compact\+Unitary().


\begin{DoxyCode}
418 \{
419         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
420         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
421              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
422 
423         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
424         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
425         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
426 
427         \textcolor{comment}{// set dimensions}
428         sizeHalfBlock = 1LL << targetQubit;  
429         sizeBlock     = 2LL * sizeHalfBlock; 
430 
431         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
432         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
433         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
434         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} alphaImag=alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, alphaReal=alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
435         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} betaImag=beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, betaReal=beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
436 
437 \textcolor{preprocessor}{# ifdef \_OPENMP}
438 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
439 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
440 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,alphaImag,
       betaReal,betaImag) \(\backslash\)}
441 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
442 \textcolor{preprocessor}{# endif}
443         \{
444 \textcolor{preprocessor}{# ifdef \_OPENMP}
445 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
446 \textcolor{preprocessor}{# endif}
447                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
448 
449                         thisBlock   = thisTask / sizeHalfBlock;
450                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
451                         indexLo     = indexUp + sizeHalfBlock;
452 
453                         \textcolor{comment}{// store current state vector values in temp variables}
454                         stateRealUp = stateVecReal[indexUp];
455                         stateImagUp = stateVecImag[indexUp];
456 
457                         stateRealLo = stateVecReal[indexLo];
458                         stateImagLo = stateVecImag[indexLo];
459 
460                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
461                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag*stateImagUp 
462                                 - betaReal*stateRealLo - betaImag*stateImagLo;
463                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag*stateRealUp 
464                                 - betaReal*stateImagLo + betaImag*stateRealLo;
465 
466                         \textcolor{comment}{// state[indexLo] = beta  * state[indexUp] + conj(alpha) * state[indexLo]}
467                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*stateImagUp 
468                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
469                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*stateRealUp 
470                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
471                 \} 
472         \}
473 
474 \} 
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!compare\+States@{compare\+States}}
\index{compare\+States@{compare\+States}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{compare\+States(\+Multi\+Qubit mq1, Multi\+Qubit mq2, R\+E\+A\+L precision)}{compareStates(MultiQubit mq1, MultiQubit mq2, REAL precision)}}]{\setlength{\rightskip}{0pt plus 5cm}int compare\+States (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{mq1, }
\item[{{\bf Multi\+Qubit}}]{mq2, }
\item[{{\bf R\+E\+AL}}]{precision}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a793584932ae384c82e7e42db7d35d18d}{}\label{qubits_8c_a793584932ae384c82e7e42db7d35d18d}


Definition at line 326 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
326                                                                  \{
327         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} diff;
328         \textcolor{keywordtype}{int} chunkSize = mq1.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
329         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<chunkSize; i++)\{
330                 diff = mq1.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[i] - mq2.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.
      \hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[i];
331                 \textcolor{keywordflow}{if} (diff<0) diff *= -1;
332                 \textcolor{keywordflow}{if} (diff>precision) \textcolor{keywordflow}{return} 0;
333                 diff = mq1.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[i] - mq2.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[i];
334                 \textcolor{keywordflow}{if} (diff<0) diff *= -1;
335                 \textcolor{keywordflow}{if} (diff>precision) \textcolor{keywordflow}{return} 0;
336         \}
337         \textcolor{keywordflow}{return} 1;
338 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!controlled\+Compact\+Unitary\+Distributed@{controlled\+Compact\+Unitary\+Distributed}}
\index{controlled\+Compact\+Unitary\+Distributed@{controlled\+Compact\+Unitary\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{controlled\+Compact\+Unitary\+Distributed(\+Multi\+Qubit multi\+Qubit, const int control\+Qubit, const int target\+Qubit, Complex rot1, Complex rot2, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out)}{controlledCompactUnitaryDistributed(MultiQubit multiQubit, const int controlQubit, const int targetQubit, Complex rot1, Complex rot2, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void controlled\+Compact\+Unitary\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex}}]{rot1, }
\item[{{\bf Complex}}]{rot2, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a717855e835e3161e08c18cdc15325d27}{}\label{qubits_8c_a717855e835e3161e08c18cdc15325d27}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. 

Only perform the rotation where the control qubit is one.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & qubit to determine whether or not to perform a rotation \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 856 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, Complex\+::real, and R\+E\+AL.



Referenced by controlled\+Compact\+Unitary().


\begin{DoxyCode}
861 \{
862 
863         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
864         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
865         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
866         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
867         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
868 
869         \textcolor{keywordtype}{int} controlBit;
870 
871     \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
872         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
873         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
874         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
875         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
876 
877 \textcolor{preprocessor}{# ifdef \_OPENMP}
878 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
879 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
880 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
881 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag) \(\backslash\)}
882 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit)}
883 \textcolor{preprocessor}{# endif}
884         \{
885 \textcolor{preprocessor}{# ifdef \_OPENMP}
886 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
887 \textcolor{preprocessor}{# endif}
888                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
889                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, thisTask+chunkId*chunkSize);
890                         \textcolor{keywordflow}{if} (controlBit)\{
891                                 \textcolor{comment}{// store current state vector values in temp variables}
892                                 stateRealUp = stateVecRealUp[thisTask];
893                                 stateImagUp = stateVecImagUp[thisTask];
894 
895                                 stateRealLo = stateVecRealLo[thisTask];
896                                 stateImagLo = stateVecImagLo[thisTask];
897 
898                                 \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
899                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp + 
      rot2Real*stateRealLo + rot2Imag*stateImagLo;
900                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp + 
      rot2Real*stateImagLo - rot2Imag*stateRealLo;
901                         \}
902                 \}
903         \}
904 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!controlled\+Compact\+Unitary\+Local@{controlled\+Compact\+Unitary\+Local}}
\index{controlled\+Compact\+Unitary\+Local@{controlled\+Compact\+Unitary\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{controlled\+Compact\+Unitary\+Local(\+Multi\+Qubit multi\+Qubit, const int control\+Qubit, const int target\+Qubit, Complex alpha, Complex beta)}{controlledCompactUnitaryLocal(MultiQubit multiQubit, const int controlQubit, const int targetQubit, Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}void controlled\+Compact\+Unitary\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_afc77657651d52c47403b44b923a098a8}{}\label{qubits_8c_afc77657651d52c47403b44b923a098a8}


Definition at line 647 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, Complex\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by controlled\+Compact\+Unitary().


\begin{DoxyCode}
649 \{
650         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
651         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
652              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
653 
654         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
655         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
656         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
657         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
658         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
659 
660         \textcolor{keywordtype}{int} controlBit;
661 
662     \textcolor{comment}{// set dimensions}
663         sizeHalfBlock = 1LL << targetQubit;  
664         sizeBlock     = 2LL * sizeHalfBlock; 
665 
666         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
667         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
668         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
669         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} alphaImag=alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, alphaReal=alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
670         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} betaImag=beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, betaReal=beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
671 
672 \textcolor{preprocessor}{# ifdef \_OPENMP}
673 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
674 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
675 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,alphaImag,
       betaReal,betaImag) \(\backslash\)}
676 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo,
       stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit) }
677 \textcolor{preprocessor}{# endif}
678         \{
679 \textcolor{preprocessor}{# ifdef \_OPENMP}
680 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
681 \textcolor{preprocessor}{# endif}
682                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
683 
684                         thisBlock   = thisTask / sizeHalfBlock;
685                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
686                         indexLo     = indexUp + sizeHalfBlock;
687 
688                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, indexUp+chunkId*chunkSize);
689                         \textcolor{keywordflow}{if} (controlBit)\{
690                                 \textcolor{comment}{// store current state vector values in temp variables}
691                                 stateRealUp = stateVecReal[indexUp];
692                                 stateImagUp = stateVecImag[indexUp];
693 
694                                 stateRealLo = stateVecReal[indexLo];
695                                 stateImagLo = stateVecImag[indexLo];
696 
697                                 \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
698                                 stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag*stateImagUp 
699                                         - betaReal*stateRealLo - betaImag*stateImagLo;
700                                 stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag*stateRealUp 
701                                         - betaReal*stateImagLo + betaImag*stateRealLo;
702 
703                                 \textcolor{comment}{// state[indexLo] = beta  * state[indexUp] + conj(alpha) * state[indexLo]}
704                                 stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*stateImagUp 
705                                         + alphaReal*stateRealLo + alphaImag*stateImagLo;
706                                 stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*stateRealUp 
707                                         + alphaReal*stateImagLo - alphaImag*stateRealLo;
708                         \}
709                 \} 
710         \}
711 
712 \} 
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!controlled\+Not\+Distributed@{controlled\+Not\+Distributed}}
\index{controlled\+Not\+Distributed@{controlled\+Not\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{controlled\+Not\+Distributed(\+Multi\+Qubit multi\+Qubit, const int control\+Qubit, const int target\+Qubit, Complex\+Array state\+Vec\+In, Complex\+Array state\+Vec\+Out)}{controlledNotDistributed(MultiQubit multiQubit, const int controlQubit, const int targetQubit, ComplexArray stateVecIn, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void controlled\+Not\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+In, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a05875a70b539a3efb28d027823403f34}{}\label{qubits_8c_a05875a70b539a3efb28d027823403f34}


Rotate a single qubit by \{\{0,1\},\{1,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk. Only perform the rotation for elements where control\+Qubit is one.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 1185 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, and R\+E\+AL.



Referenced by controlled\+Not().


\begin{DoxyCode}
1188 \{
1189 
1190         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
1191         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1192         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1193         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
1194 
1195         \textcolor{keywordtype}{int} controlBit;
1196 
1197         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1198         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1199 
1200 \textcolor{preprocessor}{# ifdef \_OPENMP}
1201 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1202 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1203 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) \(\backslash\)}
1204 \textcolor{preprocessor}{        private  (thisTask,controlBit)}
1205 \textcolor{preprocessor}{# endif}
1206         \{
1207 \textcolor{preprocessor}{# ifdef \_OPENMP}
1208 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1209 \textcolor{preprocessor}{# endif}
1210                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1211                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, thisTask+chunkId*chunkSize);
1212                         \textcolor{keywordflow}{if} (controlBit)\{
1213                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
1214                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
1215                         \}
1216                 \}
1217         \}
1218 \} 
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!controlled\+Not\+Local@{controlled\+Not\+Local}}
\index{controlled\+Not\+Local@{controlled\+Not\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{controlled\+Not\+Local(\+Multi\+Qubit multi\+Qubit, const int control\+Qubit, const int target\+Qubit)}{controlledNotLocal(MultiQubit multiQubit, const int controlQubit, const int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void controlled\+Not\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{const int}]{target\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_ad357a43e80e3baf013975b1b70942f4c}{}\label{qubits_8c_ad357a43e80e3baf013975b1b70942f4c}


Definition at line 1120 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by controlled\+Not().


\begin{DoxyCode}
1121 \{
1122         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
1123         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
1124              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
1125 
1126         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
1127         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1128         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1129         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1130         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
1131 
1132         \textcolor{keywordtype}{int} controlBit;
1133 
1134         \textcolor{comment}{// set dimensions}
1135         sizeHalfBlock = 1LL << targetQubit;  
1136         sizeBlock     = 2LL * sizeHalfBlock; 
1137 
1138 
1139         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1140         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1141         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1142 
1143 \textcolor{preprocessor}{# ifdef \_OPENMP}
1144 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1145 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1146 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
1147 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,controlBit) }
1148 \textcolor{preprocessor}{# endif}
1149         \{
1150 \textcolor{preprocessor}{# ifdef \_OPENMP}
1151 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1152 \textcolor{preprocessor}{# endif}
1153                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1154                         thisBlock   = thisTask / sizeHalfBlock;
1155                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1156                         indexLo     = indexUp + sizeHalfBlock;
1157 
1158                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit}(controlQubit, indexUp+chunkId*chunkSize);
1159                         \textcolor{keywordflow}{if} (controlBit)\{
1160                                 stateRealUp = stateVecReal[indexUp];
1161                                 stateImagUp = stateVecImag[indexUp];
1162 
1163                                 stateVecReal[indexUp] = stateVecReal[indexLo];
1164                                 stateVecImag[indexUp] = stateVecImag[indexLo];
1165 
1166                                 stateVecReal[indexLo] = stateRealUp;
1167                                 stateVecImag[indexLo] = stateImagUp;
1168                         \}
1169                 \} 
1170         \}
1171 
1172 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!controlled\+Phase\+Gate@{controlled\+Phase\+Gate}}
\index{controlled\+Phase\+Gate@{controlled\+Phase\+Gate}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{controlled\+Phase\+Gate(\+Multi\+Qubit multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2)}{controlledPhaseGate(MultiQubit multiQubit, const int idQubit1, const int idQubit2)}}]{\setlength{\rightskip}{0pt plus 5cm}void controlled\+Phase\+Gate (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{id\+Qubit1, }
\item[{const int}]{id\+Qubit2}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a11a96159191cbf1b01a1080e7f045aac}{}\label{qubits_8c_a11a96159191cbf1b01a1080e7f045aac}


Apply the (two-\/qubit) controlled phase gate, also known as the controlled sigmaZ gate. 

For each state, if both input qubits have value one, multiply the amplitude of that state by -\/1. This applies the two-\/qubit unitary\+: \[ \begin{pmatrix} 1 \\ & 1 \\\ & & 1 \\ & & & -1 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {idQubit1}; \node[draw=none] at (-3.5, 0) {idQubit2}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 0); \draw (-2,0) -- (2, 0); \draw[fill=black] (0, 0) circle (.2); \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2} & qubits to operate upon \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily id\+Qubit1} or {\ttfamily id\+Qubit2} are outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}), or are equal \\
\hline
\end{DoxyExceptions}


Definition at line 1702 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Qu\+E\+S\+T\+Assert(), Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
1703 \{
1704         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
1705         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
1706         \textcolor{keywordtype}{int} bit1, bit2;
1707 
1708         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1709         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
1710 
1711     \hyperlink{qubits__env__local_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(idQubit1 >= 0 && idQubit1 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 2, \_\_func\_\_);
1712     \hyperlink{qubits__env__local_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(idQubit2 >= 0 && idQubit2 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 1, \_\_func\_\_);
1713     \hyperlink{qubits__env__local_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(idQubit1 != idQubit2, 3, \_\_func\_\_);
1714 
1715         \textcolor{comment}{// dimension of the state vector}
1716         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1717         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1718         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1719 
1720 \textcolor{preprocessor}{# ifdef \_OPENMP}
1721 \textcolor{preprocessor}{# pragma omp parallel for \(\backslash\)}
1722 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
1723 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag ) \(\backslash\)}
1724 \textcolor{preprocessor}{        private  (index,bit1,bit2)                     \(\backslash\)}
1725 \textcolor{preprocessor}{        schedule (static)}
1726 \textcolor{preprocessor}{# endif}
1727         \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
1728                 bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index+chunkId*chunkSize);
1729                 bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index+chunkId*chunkSize);
1730                 \textcolor{keywordflow}{if} (bit1 && bit2) \{
1731                         stateVecReal [index] = - stateVecReal [index];
1732                         stateVecImag [index] = - stateVecImag [index];
1733                 \}
1734         \}
1735 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!controlled\+Unitary\+Distributed@{controlled\+Unitary\+Distributed}}
\index{controlled\+Unitary\+Distributed@{controlled\+Unitary\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{controlled\+Unitary\+Distributed(\+Multi\+Qubit multi\+Qubit, const int control\+Qubit, const int target\+Qubit, Complex rot1, Complex rot2, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out)}{controlledUnitaryDistributed(MultiQubit multiQubit, const int controlQubit, const int targetQubit, Complex rot1, Complex rot2, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void controlled\+Unitary\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex}}]{rot1, }
\item[{{\bf Complex}}]{rot2, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a642093063a1f889f61a1311f6d6f2d3f}{}\label{qubits_8c_a642093063a1f889f61a1311f6d6f2d3f}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. 

Only perform the rotation where the control qubit is one.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & qubit to determine whether or not to perform a rotation \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 919 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, Complex\+::real, and R\+E\+AL.



Referenced by controlled\+Unitary().


\begin{DoxyCode}
924 \{
925 
926         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
927         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
928         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
929         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
930         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
931 
932         \textcolor{keywordtype}{int} controlBit;
933 
934         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
935         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
936         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
937         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
938         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
939 
940 \textcolor{preprocessor}{# ifdef \_OPENMP}
941 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
942 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
943 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
944 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag) \(\backslash\)}
945 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit)}
946 \textcolor{preprocessor}{# endif}
947         \{
948 \textcolor{preprocessor}{# ifdef \_OPENMP}
949 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
950 \textcolor{preprocessor}{# endif}
951                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
952                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, thisTask+chunkId*chunkSize);
953                         \textcolor{keywordflow}{if} (controlBit)\{
954                                 \textcolor{comment}{// store current state vector values in temp variables}
955                                 stateRealUp = stateVecRealUp[thisTask];
956                                 stateImagUp = stateVecImagUp[thisTask];
957 
958                                 stateRealLo = stateVecRealLo[thisTask];
959                                 stateImagLo = stateVecImagLo[thisTask];
960 
961                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp 
962                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
963                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp 
964                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
965                         \}
966                 \}
967         \}
968 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!controlled\+Unitary\+Local@{controlled\+Unitary\+Local}}
\index{controlled\+Unitary\+Local@{controlled\+Unitary\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{controlled\+Unitary\+Local(\+Multi\+Qubit multi\+Qubit, const int control\+Qubit, const int target\+Qubit, Complex\+Matrix2 u)}{controlledUnitaryLocal(MultiQubit multiQubit, const int controlQubit, const int targetQubit, ComplexMatrix2 u)}}]{\setlength{\rightskip}{0pt plus 5cm}void controlled\+Unitary\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex\+Matrix2}}]{u}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a8a4afcff70195a306c082b8ed8d4e09a}{}\label{qubits_8c_a8a4afcff70195a306c082b8ed8d4e09a}


Definition at line 777 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Matrix2\+::r0c0, Complex\+Matrix2\+::r0c1, Complex\+Matrix2\+::r1c0, Complex\+Matrix2\+::r1c1, Complex\+Array\+::real, Complex\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by controlled\+Unitary().


\begin{DoxyCode}
779 \{
780         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
781         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
782              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
783 
784         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
785         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
786         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
787         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
788         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
789 
790         \textcolor{keywordtype}{int} controlBit;
791 
792     \textcolor{comment}{// set dimensions}
793         sizeHalfBlock = 1LL << targetQubit;  
794         sizeBlock     = 2LL * sizeHalfBlock; 
795 
796         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
797         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
798         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
799 
800 \textcolor{preprocessor}{# ifdef \_OPENMP}
801 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
802 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
803 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \(\backslash\)}
804 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo,
       stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit) }
805 \textcolor{preprocessor}{# endif}
806         \{
807 \textcolor{preprocessor}{# ifdef \_OPENMP}
808 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
809 \textcolor{preprocessor}{# endif}
810                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
811 
812                         thisBlock   = thisTask / sizeHalfBlock;
813                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
814                         indexLo     = indexUp + sizeHalfBlock;
815 
816                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, indexUp+chunkId*chunkSize);
817                         \textcolor{keywordflow}{if} (controlBit)\{
818                                 \textcolor{comment}{// store current state vector values in temp variables}
819                                 stateRealUp = stateVecReal[indexUp];
820                                 stateImagUp = stateVecImag[indexUp];
821 
822                                 stateRealLo = stateVecReal[indexLo];
823                                 stateImagLo = stateVecImag[indexLo];
824 
825 
826                                 \textcolor{comment}{// state[indexUp] = u00 * state[indexUp] + u01 * state[indexLo]}
827                                 stateVecReal[indexUp] = u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealUp - u.
      \hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagUp 
828                                         + u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealLo - u.
      \hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagLo;
829                                 stateVecImag[indexUp] = u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagUp + u.
      \hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealUp 
830                                         + u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagLo + u.
      \hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealLo;
831 
832                                 \textcolor{comment}{// state[indexLo] = u10  * state[indexUp] + u11 * state[indexLo]}
833                                 stateVecReal[indexLo] = u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealUp  - u.
      \hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagUp 
834                                         + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealLo  -  u.
      \hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagLo;
835                                 stateVecImag[indexLo] = u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagUp + u.
      \hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealUp 
836                                         + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagLo + u.
      \hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealLo;
837                         \}
838                 \} 
839         \}
840 
841 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!create\+Multi\+Qubit@{create\+Multi\+Qubit}}
\index{create\+Multi\+Qubit@{create\+Multi\+Qubit}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{create\+Multi\+Qubit(\+Multi\+Qubit $\ast$multi\+Qubit, int num\+Qubits, Qu\+E\+S\+T\+Env env)}{createMultiQubit(MultiQubit *multiQubit, int numQubits, QuESTEnv env)}}]{\setlength{\rightskip}{0pt plus 5cm}void create\+Multi\+Qubit (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit} $\ast$}]{multi\+Qubit, }
\item[{int}]{num\+Qubits, }
\item[{{\bf Qu\+E\+S\+T\+Env}}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a9c02591bc64c2918503afa231d90d83f}{}\label{qubits_8c_a9c02591bc64c2918503afa231d90d83f}


Create a \hyperlink{structMultiQubit}{Multi\+Qubit} object representing a set of qubits. 

Allocate space for state vector of probability amplitudes, including space for temporary values to be copied from one other chunk if running the distributed version. Define properties related to the size of the set of qubits. init\+State\+Zero should be called after this to initialise the qubits to the zero state.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & a pointer to an object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em num\+Qubits} & number of qubits in the system \\
\hline
\mbox{\tt in}  & {\em env} & object representing the execution environment (local, multinode etc) \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily num\+Qubits} $<$= 0 \\
\hline
\end{DoxyExceptions}


Definition at line 35 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Chunks, Multi\+Qubit\+::num\+Qubits, Qu\+E\+S\+T\+Env\+::num\+Ranks, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), Qu\+E\+S\+T\+Env\+::rank, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
36 \{
37     \hyperlink{qubits__env__local_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(numQubits>0, 9, \_\_func\_\_);
38         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numAmps = 1L << numQubits;
39         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numAmpsPerRank = numAmps/env.\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks};
40 
41         multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real} = malloc(numAmpsPerRank * \textcolor{keyword}{sizeof}(*(multiQubit->
      \hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real})));
42         multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag} = malloc(numAmpsPerRank * \textcolor{keyword}{sizeof}(*(multiQubit->
      \hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag})));
43         \textcolor{keywordflow}{if} (env.\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks}>1)\{
44                 multiQubit->\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real} = malloc(numAmpsPerRank * \textcolor{keyword}{sizeof}(*(multiQubit
      ->\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real})));
45                 multiQubit->\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag} = malloc(numAmpsPerRank * \textcolor{keyword}{sizeof}(*(multiQubit
      ->\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag})));
46         \}
47 
48         \textcolor{keywordflow}{if} ( (!(multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}) || !(multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}))
49                  && numAmpsPerRank ) \{
50                 printf(\textcolor{stringliteral}{"Could not allocate memory!"});
51                 exit (EXIT\_FAILURE);
52         \}
53 
54         \textcolor{keywordflow}{if} ( env.\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks}>1 && (!(multiQubit->\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.
      \hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}) || !(multiQubit->\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}))
55                  && numAmpsPerRank ) \{
56                 printf(\textcolor{stringliteral}{"Could not allocate memory!"});
57                 exit (EXIT\_FAILURE);
58         \}
59 
60         multiQubit->\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} = numQubits;
61         multiQubit->\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps} = numAmpsPerRank;
62         multiQubit->\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId} = env.\hyperlink{structQuESTEnv_aa648bb336cf8598467cb62db00b9cee8}{rank};
63         multiQubit->\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks} = env.\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks};
64 
65 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!destroy\+Multi\+Qubit@{destroy\+Multi\+Qubit}}
\index{destroy\+Multi\+Qubit@{destroy\+Multi\+Qubit}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{destroy\+Multi\+Qubit(\+Multi\+Qubit multi\+Qubit, Qu\+E\+S\+T\+Env env)}{destroyMultiQubit(MultiQubit multiQubit, QuESTEnv env)}}]{\setlength{\rightskip}{0pt plus 5cm}void destroy\+Multi\+Qubit (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{{\bf Qu\+E\+S\+T\+Env}}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}{}\label{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}


Deallocate a \hyperlink{structMultiQubit}{Multi\+Qubit} object representing a set of qubits. 

Free memory allocated to state vector of probability amplitudes, including temporary vector for values copied from another chunk if running the distributed version.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object to be deallocated \\
\hline
\mbox{\tt in}  & {\em env} & object representing the execution environment (local, multinode etc) \\
\hline
\end{DoxyParams}


Definition at line 67 of file qubits.\+c.



References Complex\+Array\+::imag, Qu\+E\+S\+T\+Env\+::num\+Ranks, Multi\+Qubit\+::pair\+State\+Vec, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
67                                                            \{
68         free(multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real});
69         free(multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag});
70         \textcolor{keywordflow}{if} (env.\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks}>1)\{
71                 free(multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real});
72                 free(multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag});
73         \}
74 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!extract\+Bit@{extract\+Bit}}
\index{extract\+Bit@{extract\+Bit}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{extract\+Bit(const int location\+Of\+Bit\+From\+Right, const long long int the\+Encoded\+Number)}{extractBit(const int locationOfBitFromRight, const long long int theEncodedNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}static int extract\+Bit (
\begin{DoxyParamCaption}
\item[{const int}]{location\+Of\+Bit\+From\+Right, }
\item[{const long long int}]{the\+Encoded\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits_8c_a100463f6ec212c76a5fad99579000505}{}\label{qubits_8c_a100463f6ec212c76a5fad99579000505}


Get the value of the bit at a particular index in a number. 

S\+CB edit\+: new definition of extract\+Bit is much faster $\ast$$\ast$$\ast$ 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em location\+Of\+Bit\+From\+Right} & location of bit in the\+Encoded\+Number \\
\hline
\mbox{\tt in}  & {\em the\+Encoded\+Number} & number to search \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the value of the bit in the\+Encoded\+Number 
\end{DoxyReturn}


Definition at line 1697 of file qubits.\+c.



Referenced by controlled\+Compact\+Unitary\+Distributed(), controlled\+Compact\+Unitary\+Local(), controlled\+Not\+Distributed(), controlled\+Not\+Local(), controlled\+Phase\+Gate(), controlled\+Unitary\+Distributed(), controlled\+Unitary\+Local(), and init\+State\+Of\+Single\+Qubit().


\begin{DoxyCode}
1698 \{
1699         \textcolor{keywordflow}{return} (theEncodedNumber & ( 1LL << locationOfBitFromRight )) >> locationOfBitFromRight;
1700 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}}
\index{find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{find\+Probability\+Of\+Zero\+Distributed(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit)}{findProbabilityOfZeroDistributed(MultiQubit multiQubit, const int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} find\+Probability\+Of\+Zero\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}{}\label{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}


Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. 

Size of regions to skip is a multiple of chunk\+Size.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 1642 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Outcome().


\begin{DoxyCode}
1644 \{
1645         \textcolor{comment}{// ----- measured probability}
1646         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
1647         \textcolor{comment}{// ----- temp variables}
1648         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1649         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1650 
1651         \textcolor{comment}{// ---------------------------------------------------------------- //}
1652         \textcolor{comment}{//            find probability                                      //}
1653         \textcolor{comment}{// ---------------------------------------------------------------- //}
1654 
1655         \textcolor{comment}{// initialise returned value}
1656         totalProbability = 0.0;
1657 
1658         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1659         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1660 
1661 \textcolor{preprocessor}{# ifdef \_OPENMP}
1662 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1663 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1664 \textcolor{preprocessor}{        private   (thisTask) \(\backslash\)}
1665 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
1666 \textcolor{preprocessor}{# endif}
1667         \{
1668 \textcolor{preprocessor}{# ifdef \_OPENMP}
1669 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1670 \textcolor{preprocessor}{# endif}
1671                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1672                         \textcolor{comment}{// summation -- simple implementation}
1673                         totalProbability += stateVecReal[thisTask]*stateVecReal[thisTask]
1674                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
1675 
1676                         \textcolor{comment}{/*}
1677 \textcolor{comment}{                        // summation -- kahan correction}
1678 \textcolor{comment}{                        y = stateVecReal[thisTask]*stateVecReal[thisTask]}
1679 \textcolor{comment}{                        + stateVecImag[thisTask]*stateVecImag[thisTask] - c;}
1680 \textcolor{comment}{                        t = totalProbability + y;}
1681 \textcolor{comment}{                        c = (t - totalProbability) - y;}
1682 \textcolor{comment}{                        totalProbability = t;}
1683 \textcolor{comment}{                        */}
1684 
1685                 \}
1686         \}
1687 
1688         \textcolor{keywordflow}{return} totalProbability;
1689 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}}
\index{find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{find\+Probability\+Of\+Zero\+Local(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit)}{findProbabilityOfZeroLocal(MultiQubit multiQubit, const int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} find\+Probability\+Of\+Zero\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}{}\label{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}


Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. 

Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 1570 of file qubits.\+c.



References D\+E\+B\+UG, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Outcome().


\begin{DoxyCode}
1572 \{
1573         \textcolor{comment}{// ----- sizes}
1574         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
1575         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
1576         \textcolor{comment}{// ----- indices}
1577         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
1578              index;                                               \textcolor{comment}{// current index for first half block}
1579         \textcolor{comment}{// ----- measured probability}
1580         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
1581         \textcolor{comment}{// ----- temp variables}
1582         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1583         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1584 
1585         \textcolor{comment}{// ---------------------------------------------------------------- //}
1586         \textcolor{comment}{//            dimensions                                            //}
1587         \textcolor{comment}{// ---------------------------------------------------------------- //}
1588         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
1589         \textcolor{comment}{// and then the number to skip}
1590         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
1591 
1592         \textcolor{comment}{// initialise returned value}
1593         totalProbability = 0.0;
1594 
1595         \textcolor{comment}{// initialise correction for kahan summation}
1596         \textcolor{keywordflow}{if} (\hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\(\backslash\)n"},sizeHalfBlock,sizeBlock,
      numTasks);
1597 
1598         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1599         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1600 
1601 \textcolor{preprocessor}{# ifdef \_OPENMP}
1602 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1603 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
1604 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index) \(\backslash\)}
1605 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
1606 \textcolor{preprocessor}{# endif }
1607         \{
1608 \textcolor{preprocessor}{# ifdef \_OPENMP}
1609 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1610 \textcolor{preprocessor}{# endif}
1611                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1612                         thisBlock = thisTask / sizeHalfBlock;
1613                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1614 
1615                         \textcolor{keywordflow}{if} (index<0)\{ printf(\textcolor{stringliteral}{"ABORTING as index=%Ld with thisBlock = %Ld  thisTask=%Ld \(\backslash\)n"},
       index,thisBlock,thisTask); exit(1);\}
1616 
1617                         \textcolor{comment}{// summation -- simple implementation}
1618                         totalProbability += stateVecReal[index]*stateVecReal[index]
1619                                 + stateVecImag[index]*stateVecImag[index];
1620 
1621                         \textcolor{comment}{/*}
1622 \textcolor{comment}{                        // summation -- kahan correction}
1623 \textcolor{comment}{                        y = stateVecReal[index]*stateVecReal[index]}
1624 \textcolor{comment}{                        + stateVecImag[index]*stateVecImag[index] - c;}
1625 \textcolor{comment}{                        t = totalProbability + y;}
1626 \textcolor{comment}{                        c = (t - totalProbability) - y;}
1627 \textcolor{comment}{                        totalProbability = t;}
1628 \textcolor{comment}{                        */}
1629 
1630                 \}
1631         \}
1632         \textcolor{keywordflow}{return} totalProbability;
1633 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!get\+Environment\+String@{get\+Environment\+String}}
\index{get\+Environment\+String@{get\+Environment\+String}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{get\+Environment\+String(\+Qu\+E\+S\+T\+Env env, Multi\+Qubit multi\+Qubit, char str[200])}{getEnvironmentString(QuESTEnv env, MultiQubit multiQubit, char str[200])}}]{\setlength{\rightskip}{0pt plus 5cm}void get\+Environment\+String (
\begin{DoxyParamCaption}
\item[{{\bf Qu\+E\+S\+T\+Env}}]{env, }
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{char}]{str\mbox{[}200\mbox{]}}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a8f10aabf9f607f19093aee54630caa21}{}\label{qubits_8c_a8f10aabf9f607f19093aee54630caa21}


Definition at line 127 of file qubits.\+c.



References Multi\+Qubit\+::num\+Qubits, and Qu\+E\+S\+T\+Env\+::num\+Ranks.


\begin{DoxyCode}
127                                                                              \{
128         \textcolor{keywordtype}{int} numThreads=1;
129 \textcolor{preprocessor}{# ifdef \_OPENMP}
130         numThreads=omp\_get\_max\_threads(); 
131 \textcolor{preprocessor}{# endif}
132         sprintf(str, \textcolor{stringliteral}{"%dqubits\_CPU\_%dranksx%dthreads"}, multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, env.
      \hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks}, numThreads);
133 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!get\+Prob\+El@{get\+Prob\+El}}
\index{get\+Prob\+El@{get\+Prob\+El}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{get\+Prob\+El(\+Multi\+Qubit multi\+Qubit, long long int index)}{getProbEl(MultiQubit multiQubit, long long int index)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} get\+Prob\+El (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{long long int}]{index}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}{}\label{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}


Get the probability of the state at an index in the full state vector. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing a set of qubits \\
\hline
\mbox{\tt in}  & {\em index} & index in state vector of probability amplitudes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
real\+El$\ast$real\+El + imag\+El$\ast$imag\+El 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily index} is outside \mbox{[}0, $2^{N}$) where $N = $ {\ttfamily multi\+Qubit.\+num\+Qubits} \\
\hline
\end{DoxyExceptions}


Definition at line 1944 of file qubits.\+c.



References get\+Imag\+Amp\+El(), get\+Real\+Amp\+El(), and R\+E\+AL.


\begin{DoxyCode}
1944                                                           \{
1945         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} real;
1946         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} imag;
1947         real = \hyperlink{qubits_8h_a317b786f577fa6bc136ea7f0ee7330a7}{getRealAmpEl}(multiQubit, index);
1948         imag = \hyperlink{qubits_8h_a3615f76fd5f57008d9b74bbd10533dd0}{getImagAmpEl}(multiQubit, index);
1949         \textcolor{keywordflow}{return} real*real + imag*imag;
1950 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!hadamard\+Distributed@{hadamard\+Distributed}}
\index{hadamard\+Distributed@{hadamard\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{hadamard\+Distributed(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out, int update\+Upper)}{hadamardDistributed(MultiQubit multiQubit, const int targetQubit, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut, int updateUpper)}}]{\setlength{\rightskip}{0pt plus 5cm}void hadamard\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out, }
\item[{int}]{update\+Upper}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_ae6a897066979fc52d977007d959ca09d}{}\label{qubits_8c_ae6a897066979fc52d977007d959ca09d}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt in}  & {\em update\+Upper} & flag, 1\+: updating upper values, 0\+: updating lower values in block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 1373 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, and R\+E\+AL.



Referenced by hadamard().


\begin{DoxyCode}
1378 \{
1379 
1380         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1381         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
1382         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1383 
1384         \textcolor{keywordtype}{int} sign;
1385         \textcolor{keywordflow}{if} (updateUpper) sign=1;
1386         \textcolor{keywordflow}{else} sign=-1;
1387 
1388         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1389 
1390         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1391         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1392         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1393 
1394 \textcolor{preprocessor}{# ifdef \_OPENMP}
1395 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1396 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1397 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
1398 \textcolor{preprocessor}{                        recRoot2, sign) \(\backslash\)}
1399 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
1400 \textcolor{preprocessor}{# endif}
1401         \{
1402 \textcolor{preprocessor}{# ifdef \_OPENMP}
1403 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1404 \textcolor{preprocessor}{# endif}
1405                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1406                         \textcolor{comment}{// store current state vector values in temp variables}
1407                         stateRealUp = stateVecRealUp[thisTask];
1408                         stateImagUp = stateVecImagUp[thisTask];
1409 
1410                         stateRealLo = stateVecRealLo[thisTask];
1411                         stateImagLo = stateVecImagLo[thisTask];
1412 
1413                         stateVecRealOut[thisTask] = recRoot2*(stateRealUp + sign*stateRealLo);
1414                         stateVecImagOut[thisTask] = recRoot2*(stateImagUp + sign*stateImagLo);
1415                 \}
1416         \}
1417 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!hadamard\+Local@{hadamard\+Local}}
\index{hadamard\+Local@{hadamard\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{hadamard\+Local(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit)}{hadamardLocal(MultiQubit multiQubit, const int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void hadamard\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_aa9f0718b4dd794a3e1b143e3b153bfc5}{}\label{qubits_8c_aa9f0718b4dd794a3e1b143e3b153bfc5}


Definition at line 1312 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by hadamard().


\begin{DoxyCode}
1313 \{
1314         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
1315         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
1316              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
1317 
1318         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1319         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1320         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1321 
1322         \textcolor{comment}{// set dimensions}
1323         sizeHalfBlock = 1LL << targetQubit;  
1324         sizeBlock     = 2LL * sizeHalfBlock; 
1325 
1326         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1327         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1328         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1329 
1330         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1331 
1332 \textcolor{preprocessor}{# ifdef \_OPENMP}
1333 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1334 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1335 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \(\backslash\)}
1336 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
1337 \textcolor{preprocessor}{# endif}
1338         \{
1339 \textcolor{preprocessor}{# ifdef \_OPENMP}
1340 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1341 \textcolor{preprocessor}{# endif}
1342                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1343                         thisBlock   = thisTask / sizeHalfBlock;
1344                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1345                         indexLo     = indexUp + sizeHalfBlock;
1346 
1347                         stateRealUp = stateVecReal[indexUp];
1348                         stateImagUp = stateVecImag[indexUp];
1349 
1350                         stateRealLo = stateVecReal[indexLo];
1351                         stateImagLo = stateVecImag[indexLo];
1352 
1353                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateRealLo);
1354                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImagLo);
1355 
1356                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateRealLo);
1357                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImagLo);
1358                 \} 
1359         \}
1360 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!initialize\+State\+From\+Single\+File@{initialize\+State\+From\+Single\+File}}
\index{initialize\+State\+From\+Single\+File@{initialize\+State\+From\+Single\+File}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{initialize\+State\+From\+Single\+File(\+Multi\+Qubit $\ast$multi\+Qubit, char filename[200], Qu\+E\+S\+T\+Env env)}{initializeStateFromSingleFile(MultiQubit *multiQubit, char filename[200], QuESTEnv env)}}]{\setlength{\rightskip}{0pt plus 5cm}void initialize\+State\+From\+Single\+File (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit} $\ast$}]{multi\+Qubit, }
\item[{char}]{filename\mbox{[}200\mbox{]}, }
\item[{{\bf Qu\+E\+S\+T\+Env}}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a433876ee9f3bcc54af346300f571fc3c}{}\label{qubits_8c_a433876ee9f3bcc54af346300f571fc3c}
fix -- format needs to work for single precision values 

Definition at line 291 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Chunks, Complex\+Array\+::real, R\+E\+AL, Multi\+Qubit\+::state\+Vec, and sync\+Qu\+E\+S\+T\+Env().


\begin{DoxyCode}
291                                                                                             \{
292         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize, stateVecSize;
293         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} indexInChunk, totalIndex;
294 
295         chunkSize = multiQubit->\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
296         stateVecSize = chunkSize*multiQubit->\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks};
297 
298         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
299         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
300         
301         FILE *fp;
302         \textcolor{keywordtype}{char} line[200];
303 
304         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} rank=0; rank<(multiQubit->\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks}); rank++)\{
305                 \textcolor{keywordflow}{if} (rank==multiQubit->\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId})\{
306                         fp = fopen(filename, \textcolor{stringliteral}{"r"});
307                         indexInChunk = 0; totalIndex = 0;
308                         \textcolor{keywordflow}{while} (fgets(line, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})*200, fp) != NULL && totalIndex<stateVecSize)\{
309                                 \textcolor{keywordflow}{if} (line[0]!=\textcolor{charliteral}{'#'})\{
310                                         \textcolor{keywordtype}{int} chunkId = totalIndex/chunkSize;
311                                         \textcolor{keywordflow}{if} (chunkId==multiQubit->\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId})\{
313                                                 sscanf(line, \textcolor{stringliteral}{"%lf, %lf"}, &(stateVecReal[indexInChunk]), 
314                                                                 &(stateVecImag[indexInChunk]));
315                                                 indexInChunk += 1;
316                                         \}
317                                         totalIndex += 1;
318                                 \}
319                         \}       
320                         fclose(fp);
321                 \}
322                 \hyperlink{qubits_8h_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{syncQuESTEnv}(env);
323         \}
324 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!init\+State\+Debug@{init\+State\+Debug}}
\index{init\+State\+Debug@{init\+State\+Debug}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{init\+State\+Debug(\+Multi\+Qubit $\ast$multi\+Qubit)}{initStateDebug(MultiQubit *multiQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void init\+State\+Debug (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit} $\ast$}]{multi\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}{}\label{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}


Initialise the state vector of probability amplitudes to an (unphysical) state with each component of each probability amplitude a unique floating point value. 

For debugging processes 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits to be initialised \\
\hline
\end{DoxyParams}


Definition at line 259 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
260 \{
261         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize;
262         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
263 
264         \textcolor{comment}{// dimension of the state vector}
265         chunkSize = multiQubit->\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
266 
267         \textcolor{comment}{// Can't use multiQubit->stateVec as a private OMP var}
268         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
269         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
270 
271         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} chunkOffset = (2.0*chunkSize*multiQubit->\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId})/10.0;
272 
273         \textcolor{comment}{// initialise the state to |0000..0000>}
274 \textcolor{preprocessor}{# ifdef \_OPENMP}
275 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
276 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
277 \textcolor{preprocessor}{        shared   (chunkSize, stateVecReal, stateVecImag, chunkOffset) \(\backslash\)}
278 \textcolor{preprocessor}{        private  (index) }
279 \textcolor{preprocessor}{# endif}
280         \{
281 \textcolor{preprocessor}{# ifdef \_OPENMP}
282 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
283 \textcolor{preprocessor}{# endif}
284                 \textcolor{keywordflow}{for} (index=0; index<chunkSize; index++) \{
285                         stateVecReal[index] = chunkOffset + (index*2.0)/10.0;
286                         stateVecImag[index] = chunkOffset + (index*2.0+1.0)/10.0;
287                 \}
288         \}
289 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!init\+State\+Of\+Single\+Qubit@{init\+State\+Of\+Single\+Qubit}}
\index{init\+State\+Of\+Single\+Qubit@{init\+State\+Of\+Single\+Qubit}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{init\+State\+Of\+Single\+Qubit(\+Multi\+Qubit $\ast$multi\+Qubit, int qubit\+Id, int outcome)}{initStateOfSingleQubit(MultiQubit *multiQubit, int qubitId, int outcome)}}]{\setlength{\rightskip}{0pt plus 5cm}void init\+State\+Of\+Single\+Qubit (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit} $\ast$}]{multi\+Qubit, }
\item[{int}]{qubit\+Id, }
\item[{int}]{outcome}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a7169fd0442cbc3418f3fac4d13363ca2}{}\label{qubits_8c_a7169fd0442cbc3418f3fac4d13363ca2}


Initialise the state vector of probability amplitudes such that one qubit is set to \textquotesingle{}outcome\textquotesingle{} and all other qubits are in an equal superposition of zero and one. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits to be initialised \\
\hline
\mbox{\tt in}  & {\em qubit\+Id} & id of qubit to set to state \textquotesingle{}outcome\textquotesingle{} \\
\hline
\mbox{\tt in}  & {\em value} & of qubit \textquotesingle{}qubit\+Id\textquotesingle{} \\
\hline
\end{DoxyParams}


Definition at line 212 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, D\+E\+B\+UG, extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Chunks, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
213 \{
214         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize, stateVecSize;
215         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
216         \textcolor{keywordtype}{int} bit;
217         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit->\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
218 
219         \textcolor{comment}{// dimension of the state vector}
220         chunkSize = multiQubit->\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
221         stateVecSize = chunkSize*multiQubit->\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks};
222         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} normFactor = 1.0/sqrt(stateVecSize/2);
223 
224         \textcolor{comment}{// Can't use multiQubit->stateVec as a private OMP var}
225         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
226         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
227 
228         \textcolor{comment}{// initialise the state to |0000..0000>}
229 \textcolor{preprocessor}{# ifdef \_OPENMP}
230 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
231 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
232 \textcolor{preprocessor}{        shared   (chunkSize, stateVecReal, stateVecImag, normFactor, qubitId, outcome) \(\backslash\)}
233 \textcolor{preprocessor}{        private  (index, bit) }
234 \textcolor{preprocessor}{# endif}
235         \{
236 \textcolor{preprocessor}{# ifdef \_OPENMP}
237 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
238 \textcolor{preprocessor}{# endif}
239                 \textcolor{keywordflow}{for} (index=0; index<chunkSize; index++) \{
240                         bit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit}(qubitId, index+chunkId*chunkSize);
241                         \textcolor{keywordflow}{if} (bit==outcome) \{
242                                 stateVecReal[index] = normFactor;
243                                 stateVecImag[index] = 0.0;
244                         \} \textcolor{keywordflow}{else} \{
245                                 stateVecReal[index] = 0.0;
246                                 stateVecImag[index] = 0.0;
247                         \}
248                 \}
249         \}
250         \textcolor{keywordflow}{if} (\hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"COMPLETED INIT\(\backslash\)n"});
251 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!init\+State\+Plus@{init\+State\+Plus}}
\index{init\+State\+Plus@{init\+State\+Plus}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{init\+State\+Plus(\+Multi\+Qubit $\ast$multi\+Qubit)}{initStatePlus(MultiQubit *multiQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void init\+State\+Plus (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit} $\ast$}]{multi\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}{}\label{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}


Initialise a set of $ N $ qubits to the plus state $ {| + \rangle}^{\otimes N} = \frac{1}{\sqrt{2^N}} (| 0 \rangle + | 1 \rangle)^{\otimes N} $. 

This is the product state of $N$ qubits where every classical state is uniformly populated with real coefficient $\frac{1}{\sqrt{2^N}}$. This is equivalent to applying a Hadamard to every qubit in the zero state\+: $ \hat{H}^{\otimes N} {|0\rangle}^{\otimes N} $


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & a pointer to the object representing the set of qubits to be initialised \\
\hline
\end{DoxyParams}


Definition at line 173 of file qubits.\+c.



References D\+E\+B\+UG, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Chunks, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
174 \{
175         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize, stateVecSize;
176         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
177 
178         \textcolor{comment}{// dimension of the state vector}
179         chunkSize = multiQubit->\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
180         stateVecSize = chunkSize*multiQubit->\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks};
181         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} normFactor = 1.0/sqrt(stateVecSize);
182 
183         \textcolor{comment}{// Can't use multiQubit->stateVec as a private OMP var}
184         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
185         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
186 
187         \textcolor{comment}{// initialise the state to |0000..0000>}
188 \textcolor{preprocessor}{# ifdef \_OPENMP}
189 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
190 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
191 \textcolor{preprocessor}{        shared   (chunkSize, stateVecReal, stateVecImag, normFactor) \(\backslash\)}
192 \textcolor{preprocessor}{        private  (index) }
193 \textcolor{preprocessor}{# endif}
194         \{
195 \textcolor{preprocessor}{# ifdef \_OPENMP}
196 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
197 \textcolor{preprocessor}{# endif}
198                 \textcolor{keywordflow}{for} (index=0; index<chunkSize; index++) \{
199                         stateVecReal[index] = normFactor;
200                         stateVecImag[index] = 0.0;
201                 \}
202         \}
203         \textcolor{keywordflow}{if} (\hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"COMPLETED INIT\(\backslash\)n"});
204 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!init\+State\+Zero@{init\+State\+Zero}}
\index{init\+State\+Zero@{init\+State\+Zero}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{init\+State\+Zero(\+Multi\+Qubit $\ast$multi\+Qubit)}{initStateZero(MultiQubit *multiQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void init\+State\+Zero (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit} $\ast$}]{multi\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_acb5b2eff794339090004d29f02a70d9a}{}\label{qubits_8c_acb5b2eff794339090004d29f02a70d9a}


Initialise a set of $ N $ qubits to the classical zero state $ {| 0 \rangle}^{\otimes N} $. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & a pointer to the object representing the set of all qubits to initialise \\
\hline
\end{DoxyParams}


Definition at line 135 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, D\+E\+B\+UG, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
136 \{
137         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
138         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
139 
140         \textcolor{comment}{// dimension of the state vector}
141         stateVecSize = multiQubit->\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
142 
143         \textcolor{comment}{// Can't use multiQubit->stateVec as a private OMP var}
144         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
145         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
146 
147         \textcolor{comment}{// initialise the state to |0000..0000>}
148 \textcolor{preprocessor}{# ifdef \_OPENMP}
149 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
150 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
151 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal, stateVecImag) \(\backslash\)}
152 \textcolor{preprocessor}{        private  (index) }
153 \textcolor{preprocessor}{# endif}
154         \{
155 \textcolor{preprocessor}{# ifdef \_OPENMP}
156 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
157 \textcolor{preprocessor}{# endif}
158                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
159                         stateVecReal[index] = 0.0;
160                         stateVecImag[index] = 0.0;
161                 \}
162         \}
163 
164         \textcolor{keywordflow}{if} (multiQubit->\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}==0)\{
165                 \textcolor{comment}{// zero state |0000..0000> has probability 1}
166                 stateVecReal[0] = 1.0;
167                 stateVecImag[0] = 0.0;
168         \}
169 
170         \textcolor{keywordflow}{if} (\hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"COMPLETED INIT\(\backslash\)n"});
171 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!multi\+Controlled\+Phase\+Gate@{multi\+Controlled\+Phase\+Gate}}
\index{multi\+Controlled\+Phase\+Gate@{multi\+Controlled\+Phase\+Gate}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{multi\+Controlled\+Phase\+Gate(\+Multi\+Qubit multi\+Qubit, int $\ast$control\+Qubits, int num\+Control\+Qubits)}{multiControlledPhaseGate(MultiQubit multiQubit, int *controlQubits, int numControlQubits)}}]{\setlength{\rightskip}{0pt plus 5cm}void multi\+Controlled\+Phase\+Gate (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{int $\ast$}]{control\+Qubits, }
\item[{int}]{num\+Control\+Qubits}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_afc1835c6b43b6e59ce7df7b13f274fc7}{}\label{qubits_8c_afc1835c6b43b6e59ce7df7b13f274fc7}


Apply the multiple-\/qubit controlled phase gate, also known as the multiple-\/qubit controlled sigmaZ gate. 

For each state, if all control qubits have value one, multiply the amplitude of that state by -\/1. This applies the many-\/qubit unitary\+: \[ \begin{pmatrix} 1 \\ & 1 \\\ & & \ddots \\ & & & 1 \\ & & & & -1 \end{pmatrix} \] on the control qubits.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {controls}; \node[draw=none] at (0, 6) {$\vdots$}; \draw (0, 5) -- (0, 4); \draw (-2, 4) -- (2, 4); \draw[fill=black] (0, 4) circle (.2); \draw (0, 4) -- (0, 2); \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 0); \draw (-2,0) -- (2, 0); \draw[fill=black] (0, 0) circle (.2); \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em control\+Qubits} & array of input qubits \\
\hline
\mbox{\tt in}  & {\em num\+Control\+Qubits} & number of input qubits \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily num\+Control\+Qubits} is outside \mbox{[}1, {\ttfamily multi\+Qubit.\+num\+Qubits}) \\
\hline
\end{DoxyExceptions}


Definition at line 1737 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Qu\+E\+S\+T\+Assert(), Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
1738 \{
1739         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
1740         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
1741         
1742         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1743         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
1744 
1745     \hyperlink{qubits__env__local_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(numControlQubits > 0 && numControlQubits <= multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}, 4, \_\_func\_\_);
1746     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} mask=0;
1747     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<numControlQubits; i++) mask = mask | (1LL<<controlQubits[i]);
1748     \hyperlink{qubits__env__local_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}(mask >=0 && mask <= (1LL<<multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits})-1, 2, \_\_func\_\_);
1749 
1750         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1751         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1752         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1753 
1754 \textcolor{preprocessor}{# ifdef \_OPENMP}
1755 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1756 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
1757 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag, mask ) \(\backslash\)}
1758 \textcolor{preprocessor}{        private  (index)}
1759 \textcolor{preprocessor}{# endif}
1760         \{
1761 \textcolor{preprocessor}{# ifdef \_OPENMP}
1762 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1763 \textcolor{preprocessor}{# endif}
1764                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
1765                         \textcolor{keywordflow}{if} (mask == (mask & (index+chunkId*chunkSize)) )\{
1766                                 stateVecReal [index] = - stateVecReal [index];
1767                                 stateVecImag [index] = - stateVecImag [index];
1768                         \}
1769                 \}
1770         \}
1771 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!multi\+Controlled\+Unitary\+Distributed@{multi\+Controlled\+Unitary\+Distributed}}
\index{multi\+Controlled\+Unitary\+Distributed@{multi\+Controlled\+Unitary\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{multi\+Controlled\+Unitary\+Distributed(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, long long int mask, Complex rot1, Complex rot2, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out)}{multiControlledUnitaryDistributed(MultiQubit multiQubit, const int targetQubit, long long int mask, Complex rot1, Complex rot2, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void multi\+Controlled\+Unitary\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{long long int}]{mask, }
\item[{{\bf Complex}}]{rot1, }
\item[{{\bf Complex}}]{rot2, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{}\label{qubits_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}


Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. 

Only perform the rotation where all the control qubits are 1.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & qubit to determine whether or not to perform a rotation \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 983 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, Complex\+::real, and R\+E\+AL.



Referenced by multi\+Controlled\+Unitary().


\begin{DoxyCode}
990 \{
991 
992         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
993         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
994         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
995         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
996         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
997 
998         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
999         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
1000         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1001         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1002         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1003 
1004 \textcolor{preprocessor}{# ifdef \_OPENMP}
1005 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1006 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1007 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
1008 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag, mask) \(\backslash\)}
1009 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
1010 \textcolor{preprocessor}{# endif}
1011         \{
1012 \textcolor{preprocessor}{# ifdef \_OPENMP}
1013 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1014 \textcolor{preprocessor}{# endif}
1015                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1016                         \textcolor{keywordflow}{if} (mask == (mask & (thisTask+chunkId*chunkSize)) )\{
1017                                 \textcolor{comment}{// store current state vector values in temp variables}
1018                                 stateRealUp = stateVecRealUp[thisTask];
1019                                 stateImagUp = stateVecImagUp[thisTask];
1020 
1021                                 stateRealLo = stateVecRealLo[thisTask];
1022                                 stateImagLo = stateVecImagLo[thisTask];
1023 
1024                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp 
1025                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
1026                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp 
1027                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
1028                         \}
1029                 \}
1030         \}
1031 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!multi\+Controlled\+Unitary\+Local@{multi\+Controlled\+Unitary\+Local}}
\index{multi\+Controlled\+Unitary\+Local@{multi\+Controlled\+Unitary\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{multi\+Controlled\+Unitary\+Local(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, long long int mask, Complex\+Matrix2 u)}{multiControlledUnitaryLocal(MultiQubit multiQubit, const int targetQubit, long long int mask, ComplexMatrix2 u)}}]{\setlength{\rightskip}{0pt plus 5cm}void multi\+Controlled\+Unitary\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{long long int}]{mask, }
\item[{{\bf Complex\+Matrix2}}]{u}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a1309eabcba3cb97fbc3cd2e606d17766}{}\label{qubits_8c_a1309eabcba3cb97fbc3cd2e606d17766}


Definition at line 714 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Matrix2\+::r0c0, Complex\+Matrix2\+::r0c1, Complex\+Matrix2\+::r1c0, Complex\+Matrix2\+::r1c1, Complex\+Array\+::real, Complex\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by multi\+Controlled\+Unitary().


\begin{DoxyCode}
716 \{
717         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
718         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
719              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
720 
721         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
722         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
723         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
724         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
725         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
726 
727         \textcolor{comment}{// set dimensions}
728         sizeHalfBlock = 1LL << targetQubit;  
729         sizeBlock     = 2LL * sizeHalfBlock; 
730 
731         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
732         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
733         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
734 
735 \textcolor{preprocessor}{# ifdef \_OPENMP}
736 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
737 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
738 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u, mask) \(\backslash\)}
739 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
740 \textcolor{preprocessor}{# endif}
741         \{
742 \textcolor{preprocessor}{# ifdef \_OPENMP}
743 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
744 \textcolor{preprocessor}{# endif}
745                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
746 
747                         thisBlock   = thisTask / sizeHalfBlock;
748                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
749                         indexLo     = indexUp + sizeHalfBlock;
750 
751                         \textcolor{keywordflow}{if} (mask == (mask & (indexUp+chunkId*chunkSize)) )\{
752                                 \textcolor{comment}{// store current state vector values in temp variables}
753                                 stateRealUp = stateVecReal[indexUp];
754                                 stateImagUp = stateVecImag[indexUp];
755 
756                                 stateRealLo = stateVecReal[indexLo];
757                                 stateImagLo = stateVecImag[indexLo];
758 
759 
760                                 \textcolor{comment}{// state[indexUp] = u00 * state[indexUp] + u01 * state[indexLo]}
761                                 stateVecReal[indexUp] = u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealUp - u.
      \hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagUp 
762                                         + u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealLo - u.
      \hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagLo;
763                                 stateVecImag[indexUp] = u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagUp + u.
      \hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealUp 
764                                         + u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagLo + u.
      \hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealLo;
765 
766                                 \textcolor{comment}{// state[indexLo] = u10  * state[indexUp] + u11 * state[indexLo]}
767                                 stateVecReal[indexLo] = u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealUp  - u.
      \hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagUp 
768                                         + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealLo  -  u.
      \hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagLo;
769                                 stateVecImag[indexLo] = u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagUp + u.
      \hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealUp 
770                                         + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagLo + u.
      \hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealLo;
771                         \}
772                 \} 
773         \}
774 
775 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!phase\+Gate\+Distributed@{phase\+Gate\+Distributed}}
\index{phase\+Gate\+Distributed@{phase\+Gate\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{phase\+Gate\+Distributed(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, enum phase\+Gate\+Type type)}{phaseGateDistributed(MultiQubit multiQubit, const int targetQubit, enum phaseGateType type)}}]{\setlength{\rightskip}{0pt plus 5cm}void phase\+Gate\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{enum {\bf phase\+Gate\+Type}}]{type}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_af832ed00b02a0597b7fe0b714032c54a}{}\label{qubits_8c_af832ed00b02a0597b7fe0b714032c54a}


Definition at line 1495 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, S\+\_\+\+G\+A\+TE, S\+I\+G\+M\+A\+\_\+Z, Multi\+Qubit\+::state\+Vec, and T\+\_\+\+G\+A\+TE.



Referenced by phase\+Gate().


\begin{DoxyCode}
1496 \{
1497         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealLo,stateImagLo;
1498         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1499         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1500 
1501         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1502         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1503         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1504 
1505         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1506 
1507 \textcolor{preprocessor}{# ifdef \_OPENMP}
1508 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1509 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1510 \textcolor{preprocessor}{        shared   (stateVecReal,stateVecImag, recRoot2, type) \(\backslash\)}
1511 \textcolor{preprocessor}{        private  (thisTask,stateRealLo,stateImagLo) }
1512 \textcolor{preprocessor}{# endif}
1513         \{
1514                 \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{SIGMA\_Z})\{
1515 \textcolor{preprocessor}{# ifdef \_OPENMP}
1516 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1517 \textcolor{preprocessor}{# endif}
1518                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1519                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
1520                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
1521                         \} 
1522                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{S\_GATE})\{
1523 \textcolor{preprocessor}{# ifdef \_OPENMP}
1524 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1525 \textcolor{preprocessor}{# endif}
1526                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1527                                 stateRealLo = stateVecReal[thisTask];
1528                                 stateImagLo = stateVecImag[thisTask];
1529 
1530                                 stateVecReal[thisTask] = -stateImagLo;
1531                                 stateVecImag[thisTask] = stateRealLo;
1532                         \} 
1533                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{T\_GATE})\{
1534 \textcolor{preprocessor}{# ifdef \_OPENMP}
1535 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1536 \textcolor{preprocessor}{# endif}
1537                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1538                                 stateRealLo = stateVecReal[thisTask];
1539                                 stateImagLo = stateVecImag[thisTask];
1540 
1541                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo - stateImagLo);
1542                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo + stateImagLo);
1543                         \} 
1544                 \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"Type %d is an invalid phase gate\(\backslash\)n"}, type);
1545         \}
1546 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!phase\+Gate\+Local@{phase\+Gate\+Local}}
\index{phase\+Gate\+Local@{phase\+Gate\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{phase\+Gate\+Local(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, enum phase\+Gate\+Type type)}{phaseGateLocal(MultiQubit multiQubit, const int targetQubit, enum phaseGateType type)}}]{\setlength{\rightskip}{0pt plus 5cm}void phase\+Gate\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{enum {\bf phase\+Gate\+Type}}]{type}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a3a54566b73ac84c312d7da4f56ffbc3b}{}\label{qubits_8c_a3a54566b73ac84c312d7da4f56ffbc3b}
fix -- can i rewrite this to not use mod?

fix -- can i rewrite this to not use mod?

fix -- can i rewrite this to not use mod? 

Definition at line 1419 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, S\+\_\+\+G\+A\+TE, S\+I\+G\+M\+A\+\_\+Z, Multi\+Qubit\+::state\+Vec, and T\+\_\+\+G\+A\+TE.



Referenced by phase\+Gate().


\begin{DoxyCode}
1420 \{
1421         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
1422         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
1423              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
1424 
1425         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealLo,stateImagLo;
1426         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1427         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1428 
1429         \textcolor{comment}{// set dimensions}
1430         sizeHalfBlock = 1LL << targetQubit;  
1431         sizeBlock     = 2LL * sizeHalfBlock; 
1432 
1433         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1434         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1435         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1436 
1437         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1438 
1439 \textcolor{preprocessor}{# ifdef \_OPENMP}
1440 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1441 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1442 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type) \(\backslash\)}
1443 \textcolor{preprocessor}{        private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) }
1444 \textcolor{preprocessor}{# endif}
1445         \{
1446                 \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{SIGMA\_Z})\{
1447 \textcolor{preprocessor}{# ifdef \_OPENMP}
1448 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1449 \textcolor{preprocessor}{# endif}
1450                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1452                                 thisBlock   = thisTask / sizeHalfBlock;
1453                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1454                                 indexLo     = indexUp + sizeHalfBlock;
1455 
1456                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
1457                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
1458                         \} 
1459                 \} 
1460                 
1461                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{S\_GATE})\{
1462 \textcolor{preprocessor}{# ifdef \_OPENMP}
1463 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1464 \textcolor{preprocessor}{# endif}
1465                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1467                                 thisBlock   = thisTask / sizeHalfBlock;
1468                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1469                                 indexLo     = indexUp + sizeHalfBlock;
1470                                 stateRealLo = stateVecReal[indexLo];
1471                                 stateImagLo = stateVecImag[indexLo];
1472 
1473                                 stateVecReal[indexLo] = -stateImagLo;
1474                                 stateVecImag[indexLo] = stateRealLo;
1475                         \} 
1476                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{T\_GATE})\{
1477 \textcolor{preprocessor}{# ifdef \_OPENMP}
1478 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1479 \textcolor{preprocessor}{# endif}
1480                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1482                                 thisBlock   = thisTask / sizeHalfBlock;
1483                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1484                                 indexLo     = indexUp + sizeHalfBlock;
1485                                 stateRealLo = stateVecReal[indexLo];
1486                                 stateImagLo = stateVecImag[indexLo];
1487 
1488                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo - stateImagLo);
1489                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo + stateImagLo);
1490                         \} 
1491                 \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"Type %d is an invalid phase gate\(\backslash\)n"}, type);
1492         \}
1493 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!report\+Multi\+Qubit\+Params@{report\+Multi\+Qubit\+Params}}
\index{report\+Multi\+Qubit\+Params@{report\+Multi\+Qubit\+Params}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{report\+Multi\+Qubit\+Params(\+Multi\+Qubit multi\+Qubit)}{reportMultiQubitParams(MultiQubit multiQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+Multi\+Qubit\+Params (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}{}\label{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}


Report metainformation about a set of qubits\+: number of qubits, number of probability amplitudes. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em env} & object representing the execution environment (local, multinode etc) \\
\hline
\end{DoxyParams}


Definition at line 116 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Multi\+Qubit\+::num\+Chunks, and Multi\+Qubit\+::num\+Qubits.


\begin{DoxyCode}
116                                                   \{
117         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numAmps = 1L << multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits};
118         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numAmpsPerRank = numAmps/multiQubit.\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks};
119         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}==0)\{
120                 printf(\textcolor{stringliteral}{"QUBITS:\(\backslash\)n"});
121                 printf(\textcolor{stringliteral}{"Number of qubits is %d.\(\backslash\)n"}, multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
122                 printf(\textcolor{stringliteral}{"Number of amps is %lld.\(\backslash\)n"}, numAmps);
123                 printf(\textcolor{stringliteral}{"Number of amps per rank is %lld.\(\backslash\)n"}, numAmpsPerRank);
124         \}
125 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!report\+State@{report\+State}}
\index{report\+State@{report\+State}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{report\+State(\+Multi\+Qubit multi\+Qubit)}{reportState(MultiQubit multiQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+State (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}{}\label{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}


Print the current state vector of probability amplitudes for a set of qubits to file. 

File format\+: \begin{DoxyVerb}real, imag
realComponent1, imagComponent1
realComponent2, imagComponent2
...
realComponentN, imagComponentN
\end{DoxyVerb}


File naming convention\+:

For each node that the program runs on, a file \textquotesingle{}state\+\_\+rank\+\_\+\mbox{[}node\+\_\+rank\mbox{]}.csv\textquotesingle{} is generated. If there is more than one node, ranks after the first do not include the header \begin{DoxyVerb}real, imag
\end{DoxyVerb}
 so that files are easier to combine.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\end{DoxyParams}


Definition at line 77 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+A\+L\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+F\+O\+R\+M\+AT, and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
77                                        \{
78         FILE *state;
79         \textcolor{keywordtype}{char} filename[100];
80         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
81         sprintf(filename, \textcolor{stringliteral}{"state\_rank\_%d.csv"}, multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId});
82         state = fopen(filename, \textcolor{stringliteral}{"w"});
83         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}==0) fprintf(state, \textcolor{stringliteral}{"real, imag\(\backslash\)n"});
84 
85         \textcolor{keywordflow}{for}(index=0; index<multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}; index++)\{
86                 fprintf(state, \hyperlink{precision_8h_ad751ac7ddc8ec19f23fb33083c0da8da}{REAL\_STRING\_FORMAT} \textcolor{stringliteral}{","} 
      \hyperlink{precision_8h_ad751ac7ddc8ec19f23fb33083c0da8da}{REAL\_STRING\_FORMAT} \textcolor{stringliteral}{"\(\backslash\)n"}, multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[index], multiQubit.
      \hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[index]);
87         \}
88         fclose(state);
89 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!report\+State\+To\+Screen@{report\+State\+To\+Screen}}
\index{report\+State\+To\+Screen@{report\+State\+To\+Screen}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{report\+State\+To\+Screen(\+Multi\+Qubit multi\+Qubit, Qu\+E\+S\+T\+Env env, int report\+Rank)}{reportStateToScreen(MultiQubit multiQubit, QuESTEnv env, int reportRank)}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+State\+To\+Screen (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{{\bf Qu\+E\+S\+T\+Env}}]{env, }
\item[{int}]{report\+Rank}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a842d6884e063a5865a2232cba56b65ac}{}\label{qubits_8c_a842d6884e063a5865a2232cba56b65ac}


Print the current state vector of probability amplitudes for a set of qubits to standard out. 

For debugging purposes. Each rank should print output serially. Only print output for systems $<$= 5 qubits 

Definition at line 91 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Chunks, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+A\+L\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+F\+O\+R\+M\+AT, Multi\+Qubit\+::state\+Vec, and sync\+Qu\+E\+S\+T\+Env().


\begin{DoxyCode}
91                                                                              \{
92         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
93         \textcolor{keywordtype}{int} rank;
94         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}<=5)\{
95                 \textcolor{keywordflow}{for} (rank=0; rank<multiQubit.\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks}; rank++)\{
96                         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}==rank)\{
97                                 \textcolor{keywordflow}{if} (reportRank) \{
98                                         printf(\textcolor{stringliteral}{"Reporting state from rank %d [\(\backslash\)n"}, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId});
99                                         \textcolor{comment}{//printf("\(\backslash\)trank, index, real, imag\(\backslash\)n");}
100                                         printf(\textcolor{stringliteral}{"real, imag\(\backslash\)n"});
101                                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rank==0) \{
102                                         printf(\textcolor{stringliteral}{"Reporting state [\(\backslash\)n"});
103                                         printf(\textcolor{stringliteral}{"real, imag\(\backslash\)n"});
104                                 \}
105 
106                                 \textcolor{keywordflow}{for}(index=0; index<multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}; index++)\{
107                                         printf(\hyperlink{precision_8h_ad751ac7ddc8ec19f23fb33083c0da8da}{REAL\_STRING\_FORMAT} \textcolor{stringliteral}{", "} 
      \hyperlink{precision_8h_ad751ac7ddc8ec19f23fb33083c0da8da}{REAL\_STRING\_FORMAT} \textcolor{stringliteral}{"\(\backslash\)n"}, multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[index], multiQubit.
      \hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[index]);
108                                 \}
109                                 \textcolor{keywordflow}{if} (reportRank || rank==multiQubit.\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks}-1) printf(\textcolor{stringliteral}{"]\(\backslash\)n"});
110                         \}
111                         \hyperlink{qubits_8h_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{syncQuESTEnv}(env);
112                 \}
113         \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"Error: reportStateToScreen will not print output for systems of more than 5 qubits.
      \(\backslash\)n"});
114 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!rotate\+Around\+Axis@{rotate\+Around\+Axis}}
\index{rotate\+Around\+Axis@{rotate\+Around\+Axis}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{rotate\+Around\+Axis(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, R\+E\+A\+L angle, Vector unit\+Axis)}{rotateAroundAxis(MultiQubit multiQubit, const int rotQubit, REAL angle, Vector unitAxis)}}]{\setlength{\rightskip}{0pt plus 5cm}void rotate\+Around\+Axis (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf R\+E\+AL}}]{angle, }
\item[{{\bf Vector}}]{unit\+Axis}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a7fadb225fc385db789e844c87fcba9e1}{}\label{qubits_8c_a7fadb225fc385db789e844c87fcba9e1}


Rotate a single qubit by a given angle around a given vector on the Bloch-\/sphere. 


\begin{DoxyItemize}
\item The vector must not be zero (else an error is thrown), but needn\textquotesingle{}t be unit magnitude.
\end{DoxyItemize}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em angle} & angle by which to rotate in radians \\
\hline
\mbox{\tt in}  & {\em axis} & vector around which to rotate \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily rot\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}), or if {\ttfamily axis} is the zero vector \\
\hline
\end{DoxyExceptions}


Definition at line 378 of file qubits.\+c.



References compact\+Unitary(), Complex\+::imag, Complex\+::real, Vector\+::x, Vector\+::y, and Vector\+::z.


\begin{DoxyCode}
378                                                                                              \{
379         \hyperlink{structComplex}{Complex} alpha, beta;
380         alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} = cos(angle/2.0);
381         alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag} = -sin(angle/2.0)*unitAxis.\hyperlink{structVector_ad4e863651be7d6b7e2b28cd7445a0ccf}{z};   
382         beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} = 0;
383         beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag} = -sin(angle/2.0)*(unitAxis.\hyperlink{structVector_aac7abe171ba4bada50ed72acba6259fc}{x} + unitAxis.\hyperlink{structVector_a375ca805d4c808a53d7c4e0c737ae3de}{y});
384         \hyperlink{qubits_8h_a03b13dfcabd8c59b50dbdd3af44ba8b2}{compactUnitary}(multiQubit, rotQubit, alpha, beta);
385 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!rotateX@{rotateX}}
\index{rotateX@{rotateX}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{rotate\+X(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, R\+E\+A\+L angle)}{rotateX(MultiQubit multiQubit, const int rotQubit, REAL angle)}}]{\setlength{\rightskip}{0pt plus 5cm}void rotateX (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf R\+E\+AL}}]{angle}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a6cc7fa705a2f2e6b486b49c5589d5df5}{}\label{qubits_8c_a6cc7fa705a2f2e6b486b49c5589d5df5}


Rotate a single qubit by a given angle around the X-\/axis of the Bloch-\/sphere. 

For angle $\theta$, applies \[ \begin{pmatrix} \cos\theta/2 & -i \sin \theta/2\\ -i \sin \theta/2 & \cos \theta/2 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {rot}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_x(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em angle} & angle by which to rotate in radians \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily rot\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}). \\
\hline
\end{DoxyExceptions}


Definition at line 387 of file qubits.\+c.



References compact\+Unitary(), Complex\+::imag, Complex\+::real, Vector\+::x, Vector\+::y, and Vector\+::z.


\begin{DoxyCode}
387                                                                    \{
388         \hyperlink{structComplex}{Complex} alpha, beta;
389     \hyperlink{structVector}{Vector} unitAxis = \{1, 0, 0\};
390         alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} = cos(angle/2.0);
391         alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag} = -sin(angle/2.0)*unitAxis.\hyperlink{structVector_ad4e863651be7d6b7e2b28cd7445a0ccf}{z};   
392         beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} = 0;
393         beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag} = -sin(angle/2.0)*(unitAxis.\hyperlink{structVector_aac7abe171ba4bada50ed72acba6259fc}{x} + unitAxis.\hyperlink{structVector_a375ca805d4c808a53d7c4e0c737ae3de}{y});
394         \hyperlink{qubits_8h_a03b13dfcabd8c59b50dbdd3af44ba8b2}{compactUnitary}(multiQubit, rotQubit, alpha, beta);
395 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!rotateY@{rotateY}}
\index{rotateY@{rotateY}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{rotate\+Y(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, R\+E\+A\+L angle)}{rotateY(MultiQubit multiQubit, const int rotQubit, REAL angle)}}]{\setlength{\rightskip}{0pt plus 5cm}void rotateY (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf R\+E\+AL}}]{angle}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_ace0d3592d38a990e81a434c4e9681500}{}\label{qubits_8c_ace0d3592d38a990e81a434c4e9681500}


Rotate a single qubit by a given angle around the Y-\/axis of the Bloch-\/sphere. 

For angle $\theta$, applies \[ \begin{pmatrix} \cos\theta/2 & \sin \theta/2\\ \sin \theta/2 & \cos \theta/2 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {rot}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_y(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em angle} & angle by which to rotate in radians \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily rot\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}). \\
\hline
\end{DoxyExceptions}


Definition at line 397 of file qubits.\+c.



References compact\+Unitary(), Complex\+::imag, Complex\+::real, Vector\+::x, Vector\+::y, and Vector\+::z.


\begin{DoxyCode}
397                                                                    \{
398         \hyperlink{structComplex}{Complex} alpha, beta;
399     \hyperlink{structVector}{Vector} unitAxis = \{0, 1, 0\};
400         alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} = cos(angle/2.0);
401         alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag} = -sin(angle/2.0)*unitAxis.\hyperlink{structVector_ad4e863651be7d6b7e2b28cd7445a0ccf}{z};   
402         beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} = 0;
403         beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag} = -sin(angle/2.0)*(unitAxis.\hyperlink{structVector_aac7abe171ba4bada50ed72acba6259fc}{x} + unitAxis.\hyperlink{structVector_a375ca805d4c808a53d7c4e0c737ae3de}{y});
404         \hyperlink{qubits_8h_a03b13dfcabd8c59b50dbdd3af44ba8b2}{compactUnitary}(multiQubit, rotQubit, alpha, beta);
405 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!rotateZ@{rotateZ}}
\index{rotateZ@{rotateZ}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{rotate\+Z(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, R\+E\+A\+L angle)}{rotateZ(MultiQubit multiQubit, const int rotQubit, REAL angle)}}]{\setlength{\rightskip}{0pt plus 5cm}void rotateZ (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf R\+E\+AL}}]{angle}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_abd621412ad30c1b034f4ce153c4afe10}{}\label{qubits_8c_abd621412ad30c1b034f4ce153c4afe10}


Rotate a single qubit by a given angle around the Z-\/axis of the Bloch-\/sphere (also known as a phase shift gate). 

For angle $\theta$, applies \[ \begin{pmatrix} \exp(-i \theta/2) & 0 \\ 0 & \exp(i \theta/2) \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {rot}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_z(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em angle} & angle by which to rotate in radians \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily rot\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}). \\
\hline
\end{DoxyExceptions}


Definition at line 407 of file qubits.\+c.



References compact\+Unitary(), Complex\+::imag, Complex\+::real, Vector\+::x, Vector\+::y, and Vector\+::z.


\begin{DoxyCode}
407                                                                    \{
408         \hyperlink{structComplex}{Complex} alpha, beta;
409     \hyperlink{structVector}{Vector} unitAxis = \{0, 0, 1\};
410         alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} = cos(angle/2.0);
411         alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag} = -sin(angle/2.0)*unitAxis.\hyperlink{structVector_ad4e863651be7d6b7e2b28cd7445a0ccf}{z};   
412         beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} = 0;
413         beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag} = -sin(angle/2.0)*(unitAxis.\hyperlink{structVector_aac7abe171ba4bada50ed72acba6259fc}{x} + unitAxis.\hyperlink{structVector_a375ca805d4c808a53d7c4e0c737ae3de}{y});
414         \hyperlink{qubits_8h_a03b13dfcabd8c59b50dbdd3af44ba8b2}{compactUnitary}(multiQubit, rotQubit, alpha, beta);
415 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!s\+Gate@{s\+Gate}}
\index{s\+Gate@{s\+Gate}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{s\+Gate(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit)}{sGate(MultiQubit multiQubit, const int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void s\+Gate (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_adda6c47876a7676488ed0565a19eaa65}{}\label{qubits_8c_adda6c47876a7676488ed0565a19eaa65}


Apply the single-\/qubit S gate. 

This is a rotation of $\pi/2$ around the Z-\/axis on the Bloch sphere, or the unitary\+: \[ \begin{pmatrix} 1 & 0 \\ 0 & i \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {S}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to operate upon \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily target\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}) \\
\hline
\end{DoxyExceptions}


Definition at line 1553 of file qubits.\+c.



References phase\+Gate(), and S\+\_\+\+G\+A\+TE.


\begin{DoxyCode}
1554 \{
1555                 \hyperlink{qubits__env__local_8c_aae7a8a7f1ccbddb7f76b6c52b746bb43}{phaseGate}(multiQubit, targetQubit, \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{S\_GATE});
1556 \} 
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!sigma\+X\+Distributed@{sigma\+X\+Distributed}}
\index{sigma\+X\+Distributed@{sigma\+X\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{sigma\+X\+Distributed(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, Complex\+Array state\+Vec\+In, Complex\+Array state\+Vec\+Out)}{sigmaXDistributed(MultiQubit multiQubit, const int targetQubit, ComplexArray stateVecIn, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigma\+X\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+In, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a2275fff50824fe47485890ff5a857785}{}\label{qubits_8c_a2275fff50824fe47485890ff5a857785}


Rotate a single qubit by \{\{0,1\},\{1,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 1092 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, and R\+E\+AL.



Referenced by sigma\+X().


\begin{DoxyCode}
1095 \{
1096 
1097         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
1098         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1099 
1100         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1101         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1102 
1103 \textcolor{preprocessor}{# ifdef \_OPENMP}
1104 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1105 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1106 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) \(\backslash\)}
1107 \textcolor{preprocessor}{        private  (thisTask)}
1108 \textcolor{preprocessor}{# endif}
1109         \{
1110 \textcolor{preprocessor}{# ifdef \_OPENMP}
1111 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1112 \textcolor{preprocessor}{# endif}
1113                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1114                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
1115                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
1116                 \}
1117         \}
1118 \} 
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!sigma\+X\+Local@{sigma\+X\+Local}}
\index{sigma\+X\+Local@{sigma\+X\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{sigma\+X\+Local(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit)}{sigmaXLocal(MultiQubit multiQubit, const int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigma\+X\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a74822fd86bb5d81766e6e8dbdcd62df1}{}\label{qubits_8c_a74822fd86bb5d81766e6e8dbdcd62df1}


Definition at line 1033 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by sigma\+X().


\begin{DoxyCode}
1034 \{
1035         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
1036         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
1037              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
1038 
1039         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
1040         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1041         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1042 
1043         \textcolor{comment}{// set dimensions}
1044         sizeHalfBlock = 1LL << targetQubit;  
1045         sizeBlock     = 2LL * sizeHalfBlock; 
1046 
1047         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1048         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1049         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1050 
1051 \textcolor{preprocessor}{# ifdef \_OPENMP}
1052 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1053 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1054 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
1055 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) }
1056 \textcolor{preprocessor}{# endif}
1057         \{
1058 \textcolor{preprocessor}{# ifdef \_OPENMP}
1059 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1060 \textcolor{preprocessor}{# endif}
1061                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1062                         thisBlock   = thisTask / sizeHalfBlock;
1063                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1064                         indexLo     = indexUp + sizeHalfBlock;
1065 
1066                         stateRealUp = stateVecReal[indexUp];
1067                         stateImagUp = stateVecImag[indexUp];
1068 
1069                         stateVecReal[indexUp] = stateVecReal[indexLo];
1070                         stateVecImag[indexUp] = stateVecImag[indexLo];
1071 
1072                         stateVecReal[indexLo] = stateRealUp;
1073                         stateVecImag[indexLo] = stateImagUp;
1074                 \} 
1075         \}
1076 
1077 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!sigma\+Y\+Distributed@{sigma\+Y\+Distributed}}
\index{sigma\+Y\+Distributed@{sigma\+Y\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{sigma\+Y\+Distributed(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, Complex\+Array state\+Vec\+In, Complex\+Array state\+Vec\+Out, int update\+Upper)}{sigmaYDistributed(MultiQubit multiQubit, const int targetQubit, ComplexArray stateVecIn, ComplexArray stateVecOut, int updateUpper)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigma\+Y\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+In, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out, }
\item[{int}]{update\+Upper}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_af5ef5166f00c0572354b4ac53dcf40cf}{}\label{qubits_8c_af5ef5166f00c0572354b4ac53dcf40cf}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt in}  & {\em update\+Upper} & flag, 1\+: updating upper values, 0\+: updating lower values in block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 1279 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, and R\+E\+AL.



Referenced by sigma\+Y().


\begin{DoxyCode}
1283 \{
1284 
1285         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
1286         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1287 
1288         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1289         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1290 
1291         \textcolor{keywordtype}{int} realSign=1, imagSign=1;
1292         \textcolor{keywordflow}{if} (updateUpper) imagSign=-1;
1293         \textcolor{keywordflow}{else} realSign = -1;
1294 
1295 \textcolor{preprocessor}{# ifdef \_OPENMP}
1296 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1297 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1298 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,realSign,imagSign) \(\backslash\)}
1299 \textcolor{preprocessor}{        private  (thisTask)}
1300 \textcolor{preprocessor}{# endif}
1301         \{
1302 \textcolor{preprocessor}{# ifdef \_OPENMP}
1303 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1304 \textcolor{preprocessor}{# endif}
1305                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1306                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisTask];
1307                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisTask];
1308                 \}
1309         \}
1310 \} 
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!sigma\+Y\+Local@{sigma\+Y\+Local}}
\index{sigma\+Y\+Local@{sigma\+Y\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{sigma\+Y\+Local(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit)}{sigmaYLocal(MultiQubit multiQubit, const int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigma\+Y\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a81fbfaed65a742a7dfd622e17652245e}{}\label{qubits_8c_a81fbfaed65a742a7dfd622e17652245e}


Definition at line 1220 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by sigma\+Y().


\begin{DoxyCode}
1221 \{
1222         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
1223         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
1224              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
1225 
1226         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
1227         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1228         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1229 
1230         \textcolor{comment}{// set dimensions}
1231         sizeHalfBlock = 1LL << targetQubit;  
1232         sizeBlock     = 2LL * sizeHalfBlock; 
1233 
1234         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1235         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1236         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1237 
1238 \textcolor{preprocessor}{# ifdef \_OPENMP}
1239 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1240 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1241 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
1242 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) }
1243 \textcolor{preprocessor}{# endif}
1244         \{
1245 \textcolor{preprocessor}{# ifdef \_OPENMP}
1246 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1247 \textcolor{preprocessor}{# endif}
1248                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1249                         thisBlock   = thisTask / sizeHalfBlock;
1250                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1251                         indexLo     = indexUp + sizeHalfBlock;
1252 
1253                         stateRealUp = stateVecReal[indexUp];
1254                         stateImagUp = stateVecImag[indexUp];
1255 
1256                         stateVecReal[indexUp] = stateVecImag[indexLo];
1257                         stateVecImag[indexUp] = -stateVecReal[indexLo];
1258 
1259                         stateVecReal[indexLo] = -stateImagUp;
1260                         stateVecImag[indexLo] = stateRealUp;
1261                 \} 
1262         \}
1263 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!sigmaZ@{sigmaZ}}
\index{sigmaZ@{sigmaZ}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{sigma\+Z(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit)}{sigmaZ(MultiQubit multiQubit, const int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaZ (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_aebaab86326779de55d335cfea3efde8f}{}\label{qubits_8c_aebaab86326779de55d335cfea3efde8f}


Apply the single-\/qubit sigma-\/Z (also known as the Z, Pauli-\/Z or phase-\/flip) gate. 

This is a rotation of $\pi$ around the Z-\/axis (a phase shift) on the Bloch sphere. I.\+e. \[ \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$\sigma_z$}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to operate on \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily target\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}). \\
\hline
\end{DoxyExceptions}


Definition at line 1548 of file qubits.\+c.



References phase\+Gate(), and S\+I\+G\+M\+A\+\_\+Z.


\begin{DoxyCode}
1549 \{
1550                 \hyperlink{qubits__env__local_8c_aae7a8a7f1ccbddb7f76b6c52b746bb43}{phaseGate}(multiQubit, targetQubit, \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{SIGMA\_Z});
1551 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!t\+Gate@{t\+Gate}}
\index{t\+Gate@{t\+Gate}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{t\+Gate(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit)}{tGate(MultiQubit multiQubit, const int targetQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void t\+Gate (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_af764ea63a2e870098f4e1ce08562942e}{}\label{qubits_8c_af764ea63a2e870098f4e1ce08562942e}


Apply the single-\/qubit T gate. 

This is a rotation of $\pi/4$ around the Z-\/axis on the Bloch sphere, or the unitary\+: \[ \begin{pmatrix} 1 & 0 \\ 0 & \exp\left(i \frac{\pi}{4}\right) \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {T}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to operate upon \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily target\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}) \\
\hline
\end{DoxyExceptions}


Definition at line 1558 of file qubits.\+c.



References phase\+Gate(), and T\+\_\+\+G\+A\+TE.


\begin{DoxyCode}
1559 \{
1560                 \hyperlink{qubits__env__local_8c_aae7a8a7f1ccbddb7f76b6c52b746bb43}{phaseGate}(multiQubit, targetQubit, \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{T\_GATE});
1561 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!unitary\+Distributed@{unitary\+Distributed}}
\index{unitary\+Distributed@{unitary\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{unitary\+Distributed(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, Complex rot1, Complex rot2, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out)}{unitaryDistributed(MultiQubit multiQubit, const int targetQubit, Complex rot1, Complex rot2, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void unitary\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex}}]{rot1, }
\item[{{\bf Complex}}]{rot2, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a2343b7240118e89aa615e2c9140b770b}{}\label{qubits_8c_a2343b7240118e89aa615e2c9140b770b}


Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em u} & unitary matrix to apply \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 602 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, Complex\+::real, and R\+E\+AL.



Referenced by unitary().


\begin{DoxyCode}
607 \{
608 
609         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
610         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
611         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
612 
613         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
614         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
615         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
616         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
617         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
618 
619 
620 \textcolor{preprocessor}{# ifdef \_OPENMP}
621 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
622 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
623 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
624 \textcolor{preprocessor}{                        rot1Real, rot1Imag, rot2Real, rot2Imag) \(\backslash\)}
625 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
626 \textcolor{preprocessor}{# endif}
627         \{
628 \textcolor{preprocessor}{# ifdef \_OPENMP}
629 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
630 \textcolor{preprocessor}{# endif}
631                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
632                         \textcolor{comment}{// store current state vector values in temp variables}
633                         stateRealUp = stateVecRealUp[thisTask];
634                         stateImagUp = stateVecImagUp[thisTask];
635 
636                         stateRealLo = stateVecRealLo[thisTask];
637                         stateImagLo = stateVecImagLo[thisTask];
638 
639                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp 
640                                 + rot2Real*stateRealLo - rot2Imag*stateImagLo;
641                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp 
642                                 + rot2Real*stateImagLo + rot2Imag*stateRealLo;
643                 \}
644         \}
645 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!unitary\+Local@{unitary\+Local}}
\index{unitary\+Local@{unitary\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{unitary\+Local(\+Multi\+Qubit multi\+Qubit, const int target\+Qubit, Complex\+Matrix2 u)}{unitaryLocal(MultiQubit multiQubit, const int targetQubit, ComplexMatrix2 u)}}]{\setlength{\rightskip}{0pt plus 5cm}void unitary\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{{\bf Complex\+Matrix2}}]{u}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_ac134fb45b0a7248c5d15e16eb7139a35}{}\label{qubits_8c_ac134fb45b0a7248c5d15e16eb7139a35}


Definition at line 476 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Matrix2\+::r0c0, Complex\+Matrix2\+::r0c1, Complex\+Matrix2\+::r1c0, Complex\+Matrix2\+::r1c1, Complex\+Array\+::real, Complex\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by unitary().


\begin{DoxyCode}
477 \{
478         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
479         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
480              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
481 
482         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
483         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
484         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
485 
486         \textcolor{comment}{// set dimensions}
487         sizeHalfBlock = 1LL << targetQubit;  
488         sizeBlock     = 2LL * sizeHalfBlock; 
489 
490         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
491         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
492         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
493 
494 \textcolor{preprocessor}{# ifdef \_OPENMP}
495 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
496 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
497 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \(\backslash\)}
498 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
499 \textcolor{preprocessor}{# endif}
500         \{
501 \textcolor{preprocessor}{# ifdef \_OPENMP}
502 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
503 \textcolor{preprocessor}{# endif}
504                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
505 
506                         thisBlock   = thisTask / sizeHalfBlock;
507                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
508                         indexLo     = indexUp + sizeHalfBlock;
509 
510                         \textcolor{comment}{// store current state vector values in temp variables}
511                         stateRealUp = stateVecReal[indexUp];
512                         stateImagUp = stateVecImag[indexUp];
513 
514                         stateRealLo = stateVecReal[indexLo];
515                         stateImagLo = stateVecImag[indexLo];
516 
517 
518                         \textcolor{comment}{// state[indexUp] = u00 * state[indexUp] + u01 * state[indexLo]}
519                         stateVecReal[indexUp] = u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealUp - u.
      \hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagUp 
520                                 + u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealLo - u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.
      \hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagLo;
521                         stateVecImag[indexUp] = u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagUp + u.
      \hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealUp 
522                                 + u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagLo + u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.
      \hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealLo;
523 
524                         \textcolor{comment}{// state[indexLo] = u10  * state[indexUp] + u11 * state[indexLo]}
525                         stateVecReal[indexLo] = u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealUp  - u.
      \hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagUp 
526                                 + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateRealLo  -  u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.
      \hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateImagLo;
527                         stateVecImag[indexLo] = u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagUp + u.
      \hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealUp 
528                                 + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*stateImagLo + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.
      \hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*stateRealLo;
529 
530                 \} 
531         \}
532 \} 
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!validate\+Alpha\+Beta@{validate\+Alpha\+Beta}}
\index{validate\+Alpha\+Beta@{validate\+Alpha\+Beta}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{validate\+Alpha\+Beta(\+Complex alpha, Complex beta)}{validateAlphaBeta(Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}int validate\+Alpha\+Beta (
\begin{DoxyParamCaption}
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}{}\label{qubits_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}


Definition at line 365 of file qubits.\+c.



References Complex\+::imag, Complex\+::real, and R\+E\+A\+L\+\_\+\+E\+PS.



Referenced by compact\+Unitary(), and controlled\+Compact\+Unitary().


\begin{DoxyCode}
365                                                   \{
366         \textcolor{keywordflow}{if} ( fabs(alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} 
367                 + alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}
368                 + beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} 
369                 + beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag} - 1) > \hyperlink{precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS} ) \textcolor{keywordflow}{return} 0;
370         \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} 1;
371 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!validate\+Matrix\+Is\+Unitary@{validate\+Matrix\+Is\+Unitary}}
\index{validate\+Matrix\+Is\+Unitary@{validate\+Matrix\+Is\+Unitary}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{validate\+Matrix\+Is\+Unitary(\+Complex\+Matrix2 u)}{validateMatrixIsUnitary(ComplexMatrix2 u)}}]{\setlength{\rightskip}{0pt plus 5cm}int validate\+Matrix\+Is\+Unitary (
\begin{DoxyParamCaption}
\item[{{\bf Complex\+Matrix2}}]{u}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}{}\label{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}


Definition at line 340 of file qubits.\+c.



References Complex\+::imag, Complex\+Matrix2\+::r0c0, Complex\+Matrix2\+::r0c1, Complex\+Matrix2\+::r1c0, Complex\+Matrix2\+::r1c1, Complex\+::real, and R\+E\+A\+L\+\_\+\+E\+PS.



Referenced by controlled\+Unitary(), multi\+Controlled\+Unitary(), and unitary().


\begin{DoxyCode}
340                                              \{
341 
342         \textcolor{keywordflow}{if} ( fabs(u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} 
343                 + u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}
344                 + u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}
345                 + u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag} - 1) > \hyperlink{precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS} ) \textcolor{keywordflow}{return} 0;
346     \textcolor{comment}{// check}
347         \textcolor{keywordflow}{if} ( fabs(u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} 
348                 + u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}
349                 + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}
350                 + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag} - 1) > \hyperlink{precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS} ) \textcolor{keywordflow}{return} 0;
351 
352         \textcolor{keywordflow}{if} ( fabs(u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real} 
353                 + u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}
354                 + u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}
355                 + u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}*u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}) > \hyperlink{precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS} ) \textcolor{keywordflow}{return} 0;
356 
357         \textcolor{keywordflow}{if} ( fabs(u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}
358                 - u.\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}
359                 + u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}
360                 - u.\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}*u.\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}) > \hyperlink{precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS} ) \textcolor{keywordflow}{return} 0;
361 
362         \textcolor{keywordflow}{return} 1;
363 \}
\end{DoxyCode}
\index{qubits.\+c@{qubits.\+c}!validate\+Unit\+Vector@{validate\+Unit\+Vector}}
\index{validate\+Unit\+Vector@{validate\+Unit\+Vector}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{validate\+Unit\+Vector(\+R\+E\+A\+L ux, R\+E\+A\+L uy, R\+E\+A\+L uz)}{validateUnitVector(REAL ux, REAL uy, REAL uz)}}]{\setlength{\rightskip}{0pt plus 5cm}int validate\+Unit\+Vector (
\begin{DoxyParamCaption}
\item[{{\bf R\+E\+AL}}]{ux, }
\item[{{\bf R\+E\+AL}}]{uy, }
\item[{{\bf R\+E\+AL}}]{uz}
\end{DoxyParamCaption}
)}\hypertarget{qubits_8c_a71c14976f63cfcda70026fa20ee531fe}{}\label{qubits_8c_a71c14976f63cfcda70026fa20ee531fe}


Definition at line 373 of file qubits.\+c.



References R\+E\+A\+L\+\_\+\+E\+PS.


\begin{DoxyCode}
373                                                  \{
374         \textcolor{keywordflow}{if} ( fabs(sqrt(ux*ux + uy*uy + uz*uz) - 1) > \hyperlink{precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS} ) \textcolor{keywordflow}{return} 0;
375         \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} 1;
376 \}
\end{DoxyCode}


\subsubsection{Variable Documentation}
\index{qubits.\+c@{qubits.\+c}!error\+Codes@{error\+Codes}}
\index{error\+Codes@{error\+Codes}!qubits.\+c@{qubits.\+c}}
\paragraph[{\texorpdfstring{error\+Codes}{errorCodes}}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ error\+Codes\mbox{[}$\,$\mbox{]}}\hypertarget{qubits_8c_aac1637696885c75b73a1ecf381cea713}{}\label{qubits_8c_aac1637696885c75b73a1ecf381cea713}
{\bfseries Initial value\+:}
\begin{DoxyCode}
= \{
    \textcolor{stringliteral}{"Success"},                                              
    \textcolor{stringliteral}{"Invalid target qubit. Note qubits are zero indexed."},  
    \textcolor{stringliteral}{"Invalid control qubit. Note qubits are zero indexed."}, 
    \textcolor{stringliteral}{"Control qubit cannot equal target qubit."},             
    \textcolor{stringliteral}{"Invalid number of control qubits"},                     
    \textcolor{stringliteral}{"Invalid unitary matrix."},                              
    \textcolor{stringliteral}{"Invalid rotation arguments."},                          
    \textcolor{stringliteral}{"Invalid system size. Cannot print output for systems greater than 5 qubits."}, 
    \textcolor{stringliteral}{"Can't collapse to state with zero probability."} 
    \textcolor{stringliteral}{"Invalid number of qubits."} 
\}
\end{DoxyCode}


Definition at line 17 of file qubits.\+c.



Referenced by exit\+With\+Error().

