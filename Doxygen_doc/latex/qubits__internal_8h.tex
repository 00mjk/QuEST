\hypertarget{qubits__internal_8h}{
\subsection{qubits\_\-internal.h File Reference}
\label{qubits__internal_8h}\index{qubits\_\-internal.h@{qubits\_\-internal.h}}
}


Internal functions used to implement the public facing API in \hyperlink{qubits_8h}{qubits.h}.  
{\ttfamily \#include \char`\"{}precision.h\char`\"{}}\par
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}{compactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}{compactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}{unitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}{unitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}{controlledCompactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}{controlledCompactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}{controlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}{controlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}{multiControlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{multiControlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}{sigmaXLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}{sigmaXDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}{sigmaYLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}{sigmaYDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}{hadamardLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}{hadamardDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}{phaseGateLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}{phaseGateDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}{controlledNotLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit)
\item 
void \hyperlink{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}{controlledNotDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{findProbabilityOfZeroLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{findProbabilityOfZeroDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}{collapseToOutcomeLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int measureQubit, REAL totalProbability, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, const REAL totalProbability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Set all amplitudes in one chunk to 0. \item\end{DoxyCompactList}\item 
int \hyperlink{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}{validateMatrixIsUnitary} (\hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
int \hyperlink{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}{validateAlphaBeta} (\hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
int \hyperlink{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}{validateUnitVector} (REAL ux, REAL uy, REAL uz)
\item 
void \hyperlink{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}{phaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}{exitWithError} (int errorCode, const char $\ast$func)
\item 
void \hyperlink{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert} (int isValid, int errorCode, const char $\ast$func)
\end{DoxyCompactItemize}
\subsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \hyperlink{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}{errorCodes} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
Internal functions used to implement the public facing API in \hyperlink{qubits_8h}{qubits.h}. Do not call these functions directly. In general, \hyperlink{qubits__env__local_8c}{qubits\_\-env\_\-local.c} and \hyperlink{qubits__env__mpi_8c}{qubits\_\-env\_\-mpi.c} will implement the public API by choosing the correct function or combination of functions to use from those included here. 

Definition in file \hyperlink{qubits__internal_8h_source}{qubits\_\-internal.h}.

\subsubsection{Function Documentation}
\hypertarget{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}}
\index{collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeDistributedRenorm}]{\setlength{\rightskip}{0pt plus 5cm}REAL collapseToOutcomeDistributedRenorm ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  const REAL {\em totalProbability})}\hfill}
\label{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}


Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that the value 'outcome' has been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being zero \end{DoxyParams}


Definition at line 1898 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1899 {
1900         // ----- temp variables
1901         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1902         long long int numTasks=multiQubit.numAmps;
1903         // (good for shared memory parallelism)
1904 
1905         REAL renorm=1/sqrt(totalProbability);
1906         
1907         REAL *stateVecReal = multiQubit.stateVec.real;
1908         REAL *stateVecImag = multiQubit.stateVec.imag;
1909 
1910 # ifdef _OPENMP
1911 # pragma omp parallel \
1912         shared    (numTasks,stateVecReal,stateVecImag) \
1913         private   (thisTask)
1914 # endif
1915         {
1916 # ifdef _OPENMP
1917                 # pragma omp for schedule  (static)
1918 # endif
1919                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1920                         // summation -- simple implementation
1921                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
1922                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
1923                 }
1924         }
1925         return totalProbability;
1926 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}}
\index{collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeDistributedSetZero}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeDistributedSetZero ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}


Set all amplitudes in one chunk to 0. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that a zero have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}


Definition at line 1940 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1941 {
1942         // ----- temp variables
1943         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1944         long long int numTasks=multiQubit.numAmps;
1945         // (good for shared memory parallelism)
1946 
1947         // ---------------------------------------------------------------- //
1948         //            find probability                                      //
1949         // ---------------------------------------------------------------- //
1950 
1951         REAL *stateVecReal = multiQubit.stateVec.real;
1952         REAL *stateVecImag = multiQubit.stateVec.imag;
1953 
1954 # ifdef _OPENMP
1955 # pragma omp parallel \
1956         shared    (numTasks,stateVecReal,stateVecImag) \
1957         private   (thisTask)
1958 # endif
1959         {
1960 # ifdef _OPENMP
1961                 # pragma omp for schedule  (static)
1962 # endif
1963                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1964                         // summation -- simple implementation
1965                         stateVecReal[thisTask] = 0;
1966                         stateVecImag[thisTask] = 0;
1967                 }
1968         }
1969 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeLocal@{collapseToOutcomeLocal}}
\index{collapseToOutcomeLocal@{collapseToOutcomeLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeLocal}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeLocal ({\bf MultiQubit} {\em multiQubit}, \/  int {\em measureQubit}, \/  REAL {\em totalProbability}, \/  int {\em outcome})}\hfill}
\label{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}


Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. Performs an irreversible change to the state vector: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being either zero or one \item[\mbox{$\leftarrow$} {\em outcome}]to measure the probability of and set the state to -\/-\/ either zero or one \end{DoxyParams}


Definition at line 1816 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1817 {
1818         // ----- sizes
1819         long long int sizeBlock,                                           // siz
      e of blocks
1820         sizeHalfBlock;                                       // size of blocks ha
      lved
1821         // ----- indices
1822         long long int thisBlock,                                           // cur
      rent block
1823              index;                                               // current inde
      x for first half block
1824         // ----- measured probability
1825         REAL   renorm;                                    // probability (returne
      d) value
1826         // ----- temp variables
1827         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1828         // (good for shared memory parallelism)
1829         long long int numTasks=multiQubit.numAmps>>1;
1830 
1831         // ---------------------------------------------------------------- //
1832         //            dimensions                                            //
1833         // ---------------------------------------------------------------- //
1834         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1835         // and then the number to skip
1836         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1837         
1838         renorm=1/sqrt(totalProbability);
1839         REAL *stateVecReal = multiQubit.stateVec.real;
1840         REAL *stateVecImag = multiQubit.stateVec.imag;
1841 
1842 
1843 # ifdef _OPENMP
1844 # pragma omp parallel \
1845         default (none) \
1846         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,re
      norm,outcome) \
1847         private   (thisTask,thisBlock,index)
1848 # endif
1849         {
1850                 if (outcome==0){
1851                         // measure qubit is 0
1852 # ifdef _OPENMP
1853                         # pragma omp for schedule  (static)
1854 # endif
1855                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1856                                 thisBlock = thisTask / sizeHalfBlock;
1857                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
1858                                 stateVecReal[index]=stateVecReal[index]*renorm;
1859                                 stateVecImag[index]=stateVecImag[index]*renorm;
1860 
1861                                 stateVecReal[index+sizeHalfBlock]=0;
1862                                 stateVecImag[index+sizeHalfBlock]=0;
1863                         }
1864                 } else {
1865                         // measure qubit is 1
1866 # ifdef _OPENMP
1867                         # pragma omp for schedule  (static)
1868 # endif
1869                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1870                                 thisBlock = thisTask / sizeHalfBlock;
1871                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
1872                                 stateVecReal[index]=0;
1873                                 stateVecImag[index]=0;
1874 
1875                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[in
      dex+sizeHalfBlock]*renorm;
1876                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[in
      dex+sizeHalfBlock]*renorm;
1877                         }
1878                 }
1879         }
1880 
1881 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!compactUnitaryDistributed@{compactUnitaryDistributed}}
\index{compactUnitaryDistributed@{compactUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{compactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 573 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by compactUnitary().


\begin{DoxyCode}
578 {
579 
580         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
581         long long int thisTask;  
582         const long long int numTasks=multiQubit.numAmps;
583 
584         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
585         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
586         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
587         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
588         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
589 
590 # ifdef _OPENMP
591 # pragma omp parallel \
592         default  (none) \
593         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
594                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
595         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
596 # endif
597         {
598 # ifdef _OPENMP
599                 # pragma omp for schedule (static)
600 # endif
601                 for (thisTask=0; thisTask<numTasks; thisTask++) {
602                         // store current state vector values in temp variables
603                         stateRealUp = stateVecRealUp[thisTask];
604                         stateImagUp = stateVecImagUp[thisTask];
605 
606                         stateRealLo = stateVecRealLo[thisTask];
607                         stateImagLo = stateVecImagLo[thisTask];
608 
609                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
610                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
611                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
612                 }
613         }
614 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!compactUnitaryLocal@{compactUnitaryLocal}}
\index{compactUnitaryLocal@{compactUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{compactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}


Definition at line 444 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by compactUnitary().


\begin{DoxyCode}
445 {
446         long long int sizeBlock, sizeHalfBlock;
447         long long int thisBlock, // current block
448              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
449 
450         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
451         long long int thisTask;         
452         const long long int numTasks=multiQubit.numAmps>>1;
453 
454         // set dimensions
455         sizeHalfBlock = 1LL << targetQubit;  
456         sizeBlock     = 2LL * sizeHalfBlock; 
457 
458         // Can't use multiQubit.stateVec as a private OMP var
459         REAL *stateVecReal = multiQubit.stateVec.real;
460         REAL *stateVecImag = multiQubit.stateVec.imag;
461         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
462         REAL betaImag=beta.imag, betaReal=beta.real;
463 
464 # ifdef _OPENMP
465 # pragma omp parallel \
466         default  (none) \
467         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
468         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
469 # endif
470         {
471 # ifdef _OPENMP
472                 # pragma omp for schedule (static)
473 # endif
474                 for (thisTask=0; thisTask<numTasks; thisTask++) {
475 
476                         thisBlock   = thisTask / sizeHalfBlock;
477                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
478                         indexLo     = indexUp + sizeHalfBlock;
479 
480                         // store current state vector values in temp variables
481                         stateRealUp = stateVecReal[indexUp];
482                         stateImagUp = stateVecImag[indexUp];
483 
484                         stateRealLo = stateVecReal[indexLo];
485                         stateImagLo = stateVecImag[indexLo];
486 
487                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
488                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag
      *stateImagUp 
489                                 - betaReal*stateRealLo - betaImag*stateImagLo;
490                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag
      *stateRealUp 
491                                 - betaReal*stateImagLo + betaImag*stateRealLo;
492 
493                         // state[indexLo] = beta  * state[indexUp] + conj(alpha) 
      * state[indexLo]
494                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*s
      tateImagUp 
495                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
496                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*s
      tateRealUp 
497                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
498                 } 
499         }
500 
501 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}}
\index{controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledCompactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 883 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
888 {
889 
890         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
891         long long int thisTask;  
892         const long long int numTasks=multiQubit.numAmps;
893         const long long int chunkSize=multiQubit.numAmps;
894         const long long int chunkId=multiQubit.chunkId;
895 
896         int controlBit;
897 
898     REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
899         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
900         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
901         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
902         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
903 
904 # ifdef _OPENMP
905 # pragma omp parallel \
906         default  (none) \
907         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
908                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
909         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
910 # endif
911         {
912 # ifdef _OPENMP
913                 # pragma omp for schedule (static)
914 # endif
915                 for (thisTask=0; thisTask<numTasks; thisTask++) {
916                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
917                         if (controlBit){
918                                 // store current state vector values in temp vari
      ables
919                                 stateRealUp = stateVecRealUp[thisTask];
920                                 stateImagUp = stateVecImagUp[thisTask];
921 
922                                 stateRealLo = stateVecRealLo[thisTask];
923                                 stateImagLo = stateVecImagLo[thisTask];
924 
925                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
926                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp 
      - rot1Imag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
927                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp 
      + rot1Imag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
928                         }
929                 }
930         }
931 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}}
\index{controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledCompactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}


Definition at line 674 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
676 {
677         long long int sizeBlock, sizeHalfBlock;
678         long long int thisBlock, // current block
679              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
680 
681         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
682         long long int thisTask;         
683         const long long int numTasks=multiQubit.numAmps>>1;
684         const long long int chunkSize=multiQubit.numAmps;
685         const long long int chunkId=multiQubit.chunkId;
686 
687         int controlBit;
688 
689     // set dimensions
690         sizeHalfBlock = 1LL << targetQubit;  
691         sizeBlock     = 2LL * sizeHalfBlock; 
692 
693         // Can't use multiQubit.stateVec as a private OMP var
694         REAL *stateVecReal = multiQubit.stateVec.real;
695         REAL *stateVecImag = multiQubit.stateVec.imag;
696         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
697         REAL betaImag=beta.imag, betaReal=beta.real;
698 
699 # ifdef _OPENMP
700 # pragma omp parallel \
701         default  (none) \
702         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
703         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
704 # endif
705         {
706 # ifdef _OPENMP
707                 # pragma omp for schedule (static)
708 # endif
709                 for (thisTask=0; thisTask<numTasks; thisTask++) {
710 
711                         thisBlock   = thisTask / sizeHalfBlock;
712                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
713                         indexLo     = indexUp + sizeHalfBlock;
714 
715                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
716                         if (controlBit){
717                                 // store current state vector values in temp vari
      ables
718                                 stateRealUp = stateVecReal[indexUp];
719                                 stateImagUp = stateVecImag[indexUp];
720 
721                                 stateRealLo = stateVecReal[indexLo];
722                                 stateImagLo = stateVecImag[indexLo];
723 
724                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
725                                 stateVecReal[indexUp] = alphaReal*stateRealUp - a
      lphaImag*stateImagUp 
726                                         - betaReal*stateRealLo - betaImag*stateIm
      agLo;
727                                 stateVecImag[indexUp] = alphaReal*stateImagUp + a
      lphaImag*stateRealUp 
728                                         - betaReal*stateImagLo + betaImag*stateRe
      alLo;
729 
730                                 // state[indexLo] = beta  * state[indexUp] + conj
      (alpha) * state[indexLo]
731                                 stateVecReal[indexLo] = betaReal*stateRealUp - be
      taImag*stateImagUp 
732                                         + alphaReal*stateRealLo + alphaImag*state
      ImagLo;
733                                 stateVecImag[indexLo] = betaReal*stateImagUp + be
      taImag*stateRealUp 
734                                         + alphaReal*stateImagLo - alphaImag*state
      RealLo;
735                         }
736                 } 
737         }
738 
739 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledNotDistributed@{controlledNotDistributed}}
\index{controlledNotDistributed@{controlledNotDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledNotDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk. Only perform the rotation for elements where controlQubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1212 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by controlledNot().


\begin{DoxyCode}
1215 {
1216 
1217         long long int thisTask;  
1218         const long long int numTasks=multiQubit.numAmps;
1219         const long long int chunkSize=multiQubit.numAmps;
1220         const long long int chunkId=multiQubit.chunkId;
1221 
1222         int controlBit;
1223 
1224         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1225         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1226 
1227 # ifdef _OPENMP
1228 # pragma omp parallel \
1229         default  (none) \
1230         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1231         private  (thisTask,controlBit)
1232 # endif
1233         {
1234 # ifdef _OPENMP
1235                 # pragma omp for schedule (static)
1236 # endif
1237                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1238                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
1239                         if (controlBit){
1240                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTa
      sk];
1241                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTa
      sk];
1242                         }
1243                 }
1244         }
1245 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledNotLocal@{controlledNotLocal}}
\index{controlledNotLocal@{controlledNotLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledNotLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}


Definition at line 1147 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledNot().


\begin{DoxyCode}
1148 {
1149         long long int sizeBlock, sizeHalfBlock;
1150         long long int thisBlock, // current block
1151              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1152 
1153         REAL stateRealUp,stateImagUp;
1154         long long int thisTask;         
1155         const long long int numTasks=multiQubit.numAmps>>1;
1156         const long long int chunkSize=multiQubit.numAmps;
1157         const long long int chunkId=multiQubit.chunkId;
1158 
1159         int controlBit;
1160 
1161         // set dimensions
1162         sizeHalfBlock = 1LL << targetQubit;  
1163         sizeBlock     = 2LL * sizeHalfBlock; 
1164 
1165 
1166         // Can't use multiQubit.stateVec as a private OMP var
1167         REAL *stateVecReal = multiQubit.stateVec.real;
1168         REAL *stateVecImag = multiQubit.stateVec.imag;
1169 
1170 # ifdef _OPENMP
1171 # pragma omp parallel \
1172         default  (none) \
1173         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1174         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,co
      ntrolBit) 
1175 # endif
1176         {
1177 # ifdef _OPENMP
1178                 # pragma omp for schedule (static)
1179 # endif
1180                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1181                         thisBlock   = thisTask / sizeHalfBlock;
1182                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1183                         indexLo     = indexUp + sizeHalfBlock;
1184 
1185                         controlBit = extractBit(controlQubit, indexUp+chunkId*chu
      nkSize);
1186                         if (controlBit){
1187                                 stateRealUp = stateVecReal[indexUp];
1188                                 stateImagUp = stateVecImag[indexUp];
1189 
1190                                 stateVecReal[indexUp] = stateVecReal[indexLo];
1191                                 stateVecImag[indexUp] = stateVecImag[indexLo];
1192 
1193                                 stateVecReal[indexLo] = stateRealUp;
1194                                 stateVecImag[indexLo] = stateImagUp;
1195                         }
1196                 } 
1197         }
1198 
1199 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledUnitaryDistributed@{controlledUnitaryDistributed}}
\index{controlledUnitaryDistributed@{controlledUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 946 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledUnitary().


\begin{DoxyCode}
951 {
952 
953         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
954         long long int thisTask;  
955         const long long int numTasks=multiQubit.numAmps;
956         const long long int chunkSize=multiQubit.numAmps;
957         const long long int chunkId=multiQubit.chunkId;
958 
959         int controlBit;
960 
961         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
962         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
963         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
964         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
965         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
966 
967 # ifdef _OPENMP
968 # pragma omp parallel \
969         default  (none) \
970         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
971                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
972         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
973 # endif
974         {
975 # ifdef _OPENMP
976                 # pragma omp for schedule (static)
977 # endif
978                 for (thisTask=0; thisTask<numTasks; thisTask++) {
979                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
980                         if (controlBit){
981                                 // store current state vector values in temp vari
      ables
982                                 stateRealUp = stateVecRealUp[thisTask];
983                                 stateImagUp = stateVecImagUp[thisTask];
984 
985                                 stateRealLo = stateVecRealLo[thisTask];
986                                 stateImagLo = stateVecImagLo[thisTask];
987 
988                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
989                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
990                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
991                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
992                         }
993                 }
994         }
995 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledUnitaryLocal@{controlledUnitaryLocal}}
\index{controlledUnitaryLocal@{controlledUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}


Definition at line 804 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledUnitary().


\begin{DoxyCode}
806 {
807         long long int sizeBlock, sizeHalfBlock;
808         long long int thisBlock, // current block
809              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
810 
811         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
812         long long int thisTask;         
813         const long long int numTasks=multiQubit.numAmps>>1;
814         const long long int chunkSize=multiQubit.numAmps;
815         const long long int chunkId=multiQubit.chunkId;
816 
817         int controlBit;
818 
819     // set dimensions
820         sizeHalfBlock = 1LL << targetQubit;  
821         sizeBlock     = 2LL * sizeHalfBlock; 
822 
823         // Can't use multiQubit.stateVec as a private OMP var
824         REAL *stateVecReal = multiQubit.stateVec.real;
825         REAL *stateVecImag = multiQubit.stateVec.imag;
826 
827 # ifdef _OPENMP
828 # pragma omp parallel \
829         default  (none) \
830         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
831         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
832 # endif
833         {
834 # ifdef _OPENMP
835                 # pragma omp for schedule (static)
836 # endif
837                 for (thisTask=0; thisTask<numTasks; thisTask++) {
838 
839                         thisBlock   = thisTask / sizeHalfBlock;
840                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
841                         indexLo     = indexUp + sizeHalfBlock;
842 
843                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
844                         if (controlBit){
845                                 // store current state vector values in temp vari
      ables
846                                 stateRealUp = stateVecReal[indexUp];
847                                 stateImagUp = stateVecImag[indexUp];
848 
849                                 stateRealLo = stateVecReal[indexLo];
850                                 stateImagLo = stateVecImag[indexLo];
851 
852 
853                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
854                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
855                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
856                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
857                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
858 
859                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
860                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
861                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
862                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
863                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
864                         }
865                 } 
866         }
867 
868 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!exitWithError@{exitWithError}}
\index{exitWithError@{exitWithError}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{exitWithError}]{\setlength{\rightskip}{0pt plus 5cm}void exitWithError (int {\em errorCode}, \/  const char $\ast$ {\em func})}\hfill}
\label{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}


Definition at line 238 of file qubits\_\-env\_\-local.c.

References errorCodes.

Referenced by QuESTAssert().


\begin{DoxyCode}
238                                                    {
239     printf("!!!\n");
240     printf("QuEST Error in function %s: %s\n", func, errorCodes[errorCode]);
241     printf("!!!\n");
242     printf("exiting..\n");
243     exit(errorCode);
244 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}}
\index{findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{findProbabilityOfZeroDistributed}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}


Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. Size of regions to skip is a multiple of chunkSize.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1669 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1671 {
1672         // ----- measured probability
1673         REAL   totalProbability;                                    // probabilit
      y (returned) value
1674         // ----- temp variables
1675         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1676         long long int numTasks=multiQubit.numAmps;
1677 
1678         // ---------------------------------------------------------------- //
1679         //            find probability                                      //
1680         // ---------------------------------------------------------------- //
1681 
1682         // initialise returned value
1683         totalProbability = 0.0;
1684 
1685         REAL *stateVecReal = multiQubit.stateVec.real;
1686         REAL *stateVecImag = multiQubit.stateVec.imag;
1687 
1688 # ifdef _OPENMP
1689 # pragma omp parallel \
1690         shared    (numTasks,stateVecReal,stateVecImag) \
1691         private   (thisTask) \
1692         reduction ( +:totalProbability )
1693 # endif
1694         {
1695 # ifdef _OPENMP
1696                 # pragma omp for schedule  (static)
1697 # endif
1698                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1699                         // summation -- simple implementation
1700                         totalProbability += stateVecReal[thisTask]*stateVecReal[t
      hisTask]
1701                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
1702 
1703                         /*
1704                         // summation -- kahan correction
1705                         y = stateVecReal[thisTask]*stateVecReal[thisTask]
1706                         + stateVecImag[thisTask]*stateVecImag[thisTask] - c;
1707                         t = totalProbability + y;
1708                         c = (t - totalProbability) - y;
1709                         totalProbability = t;
1710                         */
1711 
1712                 }
1713         }
1714 
1715         return totalProbability;
1716 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}}
\index{findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{findProbabilityOfZeroLocal}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}


Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1597 of file qubits.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1599 {
1600         // ----- sizes
1601         long long int sizeBlock,                                           // siz
      e of blocks
1602         sizeHalfBlock;                                       // size of blocks ha
      lved
1603         // ----- indices
1604         long long int thisBlock,                                           // cur
      rent block
1605              index;                                               // current inde
      x for first half block
1606         // ----- measured probability
1607         REAL   totalProbability;                                    // probabilit
      y (returned) value
1608         // ----- temp variables
1609         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1610         long long int numTasks=multiQubit.numAmps>>1;
1611 
1612         // ---------------------------------------------------------------- //
1613         //            dimensions                                            //
1614         // ---------------------------------------------------------------- //
1615         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1616         // and then the number to skip
1617         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1618 
1619         // initialise returned value
1620         totalProbability = 0.0;
1621 
1622         // initialise correction for kahan summation
1623         if (DEBUG) printf("sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\n",sizeHa
      lfBlock,sizeBlock,numTasks);
1624 
1625         REAL *stateVecReal = multiQubit.stateVec.real;
1626         REAL *stateVecImag = multiQubit.stateVec.imag;
1627 
1628 # ifdef _OPENMP
1629 # pragma omp parallel \
1630         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
      
1631         private   (thisTask,thisBlock,index) \
1632         reduction ( +:totalProbability )
1633 # endif 
1634         {
1635 # ifdef _OPENMP
1636                 # pragma omp for schedule  (static)
1637 # endif
1638                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1639                         thisBlock = thisTask / sizeHalfBlock;
1640                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
      
1641 
1642                         if (index<0){ printf("ABORTING as index=%Ld with thisBloc
      k = %Ld  thisTask=%Ld \n", index,thisBlock,thisTask); exit(1);}
1643 
1644                         // summation -- simple implementation
1645                         totalProbability += stateVecReal[index]*stateVecReal[inde
      x]
1646                                 + stateVecImag[index]*stateVecImag[index];
1647 
1648                         /*
1649                         // summation -- kahan correction
1650                         y = stateVecReal[index]*stateVecReal[index]
1651                         + stateVecImag[index]*stateVecImag[index] - c;
1652                         t = totalProbability + y;
1653                         c = (t - totalProbability) - y;
1654                         totalProbability = t;
1655                         */
1656 
1657                 }
1658         }
1659         return totalProbability;
1660 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!hadamardDistributed@{hadamardDistributed}}
\index{hadamardDistributed@{hadamardDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{hadamardDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1400 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by hadamard().


\begin{DoxyCode}
1405 {
1406 
1407         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1408         long long int thisTask;  
1409         const long long int numTasks=multiQubit.numAmps;
1410 
1411         int sign;
1412         if (updateUpper) sign=1;
1413         else sign=-1;
1414 
1415         REAL recRoot2 = 1.0/sqrt(2);
1416 
1417         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1418         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1419         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1420 
1421 # ifdef _OPENMP
1422 # pragma omp parallel \
1423         default  (none) \
1424         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1425                         recRoot2, sign) \
1426         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1427 # endif
1428         {
1429 # ifdef _OPENMP
1430                 # pragma omp for schedule (static)
1431 # endif
1432                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1433                         // store current state vector values in temp variables
1434                         stateRealUp = stateVecRealUp[thisTask];
1435                         stateImagUp = stateVecImagUp[thisTask];
1436 
1437                         stateRealLo = stateVecRealLo[thisTask];
1438                         stateImagLo = stateVecImagLo[thisTask];
1439 
1440                         stateVecRealOut[thisTask] = recRoot2*(stateRealUp + sign*
      stateRealLo);
1441                         stateVecImagOut[thisTask] = recRoot2*(stateImagUp + sign*
      stateImagLo);
1442                 }
1443         }
1444 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!hadamardLocal@{hadamardLocal}}
\index{hadamardLocal@{hadamardLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{hadamardLocal}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}


Definition at line 1339 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by hadamard().


\begin{DoxyCode}
1340 {
1341         long long int sizeBlock, sizeHalfBlock;
1342         long long int thisBlock, // current block
1343              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1344 
1345         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1346         long long int thisTask;         
1347         const long long int numTasks=multiQubit.numAmps>>1;
1348 
1349         // set dimensions
1350         sizeHalfBlock = 1LL << targetQubit;  
1351         sizeBlock     = 2LL * sizeHalfBlock; 
1352 
1353         // Can't use multiQubit.stateVec as a private OMP var
1354         REAL *stateVecReal = multiQubit.stateVec.real;
1355         REAL *stateVecImag = multiQubit.stateVec.imag;
1356 
1357         REAL recRoot2 = 1.0/sqrt(2);
1358 
1359 # ifdef _OPENMP
1360 # pragma omp parallel \
1361         default  (none) \
1362         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \
      
1363         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
1364 # endif
1365         {
1366 # ifdef _OPENMP
1367                 # pragma omp for schedule (static)
1368 # endif
1369                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1370                         thisBlock   = thisTask / sizeHalfBlock;
1371                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1372                         indexLo     = indexUp + sizeHalfBlock;
1373 
1374                         stateRealUp = stateVecReal[indexUp];
1375                         stateImagUp = stateVecImag[indexUp];
1376 
1377                         stateRealLo = stateVecReal[indexLo];
1378                         stateImagLo = stateVecImag[indexLo];
1379 
1380                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateReal
      Lo);
1381                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImag
      Lo);
1382 
1383                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateReal
      Lo);
1384                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImag
      Lo);
1385                 } 
1386         }
1387 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}}
\index{multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{multiControlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}


Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where all the control qubits are 1.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1010 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
1017 {
1018 
1019         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1020         long long int thisTask;  
1021         const long long int numTasks=multiQubit.numAmps;
1022         const long long int chunkSize=multiQubit.numAmps;
1023         const long long int chunkId=multiQubit.chunkId;
1024 
1025         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
1026         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
1027         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1028         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1029         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1030 
1031 # ifdef _OPENMP
1032 # pragma omp parallel \
1033         default  (none) \
1034         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1035                         rot1Real,rot1Imag, rot2Real,rot2Imag, mask) \
1036         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1037 # endif
1038         {
1039 # ifdef _OPENMP
1040                 # pragma omp for schedule (static)
1041 # endif
1042                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1043                         if (mask == (mask & (thisTask+chunkId*chunkSize)) ){
1044                                 // store current state vector values in temp vari
      ables
1045                                 stateRealUp = stateVecRealUp[thisTask];
1046                                 stateImagUp = stateVecImagUp[thisTask];
1047 
1048                                 stateRealLo = stateVecRealLo[thisTask];
1049                                 stateImagLo = stateVecImagLo[thisTask];
1050 
1051                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
1052                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
1053                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
1054                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
1055                         }
1056                 }
1057         }
1058 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!multiControlledUnitaryLocal@{multiControlledUnitaryLocal}}
\index{multiControlledUnitaryLocal@{multiControlledUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{multiControlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}


Definition at line 741 of file qubits.c.

References MultiQubit::chunkId, Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
743 {
744         long long int sizeBlock, sizeHalfBlock;
745         long long int thisBlock, // current block
746              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
747 
748         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
749         long long int thisTask;         
750         const long long int numTasks=multiQubit.numAmps>>1;
751         const long long int chunkSize=multiQubit.numAmps;
752         const long long int chunkId=multiQubit.chunkId;
753 
754         // set dimensions
755         sizeHalfBlock = 1LL << targetQubit;  
756         sizeBlock     = 2LL * sizeHalfBlock; 
757 
758         // Can't use multiQubit.stateVec as a private OMP var
759         REAL *stateVecReal = multiQubit.stateVec.real;
760         REAL *stateVecImag = multiQubit.stateVec.imag;
761 
762 # ifdef _OPENMP
763 # pragma omp parallel \
764         default  (none) \
765         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u, mask) \
766         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
767 # endif
768         {
769 # ifdef _OPENMP
770                 # pragma omp for schedule (static)
771 # endif
772                 for (thisTask=0; thisTask<numTasks; thisTask++) {
773 
774                         thisBlock   = thisTask / sizeHalfBlock;
775                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
776                         indexLo     = indexUp + sizeHalfBlock;
777 
778                         if (mask == (mask & (indexUp+chunkId*chunkSize)) ){
779                                 // store current state vector values in temp vari
      ables
780                                 stateRealUp = stateVecReal[indexUp];
781                                 stateImagUp = stateVecImag[indexUp];
782 
783                                 stateRealLo = stateVecReal[indexLo];
784                                 stateImagLo = stateVecImag[indexLo];
785 
786 
787                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
788                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
789                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
790                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
791                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
792 
793                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
794                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
795                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
796                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
797                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
798                         }
799                 } 
800         }
801 
802 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGate@{phaseGate}}
\index{phaseGate@{phaseGate}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}


Definition at line 169 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, phaseGateDistributed(), phaseGateLocal(), and QuESTAssert().

Referenced by sGate(), sigmaZ(), and tGate().


\begin{DoxyCode}
170 {
171     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
172         phaseGateLocal(multiQubit, targetQubit, type);
173 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGateDistributed@{phaseGateDistributed}}
\index{phaseGateDistributed@{phaseGateDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGateDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}


Definition at line 1522 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1523 {
1524         REAL stateRealLo,stateImagLo;
1525         long long int thisTask;         
1526         const long long int numTasks=multiQubit.numAmps;
1527 
1528         // Can't use multiQubit.stateVec as a private OMP var
1529         REAL *stateVecReal = multiQubit.stateVec.real;
1530         REAL *stateVecImag = multiQubit.stateVec.imag;
1531 
1532         REAL recRoot2 = 1.0/sqrt(2);
1533 
1534 # ifdef _OPENMP
1535 # pragma omp parallel \
1536         default  (none) \
1537         shared   (stateVecReal,stateVecImag, recRoot2, type) \
1538         private  (thisTask,stateRealLo,stateImagLo) 
1539 # endif
1540         {
1541                 if (type==SIGMA_Z){
1542 # ifdef _OPENMP
1543                         # pragma omp for schedule (static)
1544 # endif
1545                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1546                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
      
1547                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
      
1548                         } 
1549                 } else if (type==S_GATE){
1550 # ifdef _OPENMP
1551                         # pragma omp for schedule (static)
1552 # endif
1553                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1554                                 stateRealLo = stateVecReal[thisTask];
1555                                 stateImagLo = stateVecImag[thisTask];
1556 
1557                                 stateVecReal[thisTask] = -stateImagLo;
1558                                 stateVecImag[thisTask] = stateRealLo;
1559                         } 
1560                 } else if (type==T_GATE){
1561 # ifdef _OPENMP
1562                         # pragma omp for schedule (static)
1563 # endif
1564                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1565                                 stateRealLo = stateVecReal[thisTask];
1566                                 stateImagLo = stateVecImag[thisTask];
1567 
1568                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo 
      - stateImagLo);
1569                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo 
      + stateImagLo);
1570                         } 
1571                 } else printf("Type %d is an invalid phase gate\n", type);
1572         }
1573 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGateLocal@{phaseGateLocal}}
\index{phaseGateLocal@{phaseGateLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGateLocal}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}


fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod? 

Definition at line 1446 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1447 {
1448         long long int sizeBlock, sizeHalfBlock;
1449         long long int thisBlock, // current block
1450              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1451 
1452         REAL stateRealLo,stateImagLo;
1453         long long int thisTask;         
1454         const long long int numTasks=multiQubit.numAmps>>1;
1455 
1456         // set dimensions
1457         sizeHalfBlock = 1LL << targetQubit;  
1458         sizeBlock     = 2LL * sizeHalfBlock; 
1459 
1460         // Can't use multiQubit.stateVec as a private OMP var
1461         REAL *stateVecReal = multiQubit.stateVec.real;
1462         REAL *stateVecImag = multiQubit.stateVec.imag;
1463 
1464         REAL recRoot2 = 1.0/sqrt(2);
1465 
1466 # ifdef _OPENMP
1467 # pragma omp parallel \
1468         default  (none) \
1469         shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type
      ) \
1470         private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) 
1471 # endif
1472         {
1473                 if (type==SIGMA_Z){
1474 # ifdef _OPENMP
1475                         # pragma omp for schedule (static)
1476 # endif
1477                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1479                                 thisBlock   = thisTask / sizeHalfBlock;
1480                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1481                                 indexLo     = indexUp + sizeHalfBlock;
1482 
1483                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
1484                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
1485                         } 
1486                 } 
1487                 
1488                 else if (type==S_GATE){
1489 # ifdef _OPENMP
1490                         # pragma omp for schedule (static)
1491 # endif
1492                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1494                                 thisBlock   = thisTask / sizeHalfBlock;
1495                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1496                                 indexLo     = indexUp + sizeHalfBlock;
1497                                 stateRealLo = stateVecReal[indexLo];
1498                                 stateImagLo = stateVecImag[indexLo];
1499 
1500                                 stateVecReal[indexLo] = -stateImagLo;
1501                                 stateVecImag[indexLo] = stateRealLo;
1502                         } 
1503                 } else if (type==T_GATE){
1504 # ifdef _OPENMP
1505                         # pragma omp for schedule (static)
1506 # endif
1507                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1509                                 thisBlock   = thisTask / sizeHalfBlock;
1510                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1511                                 indexLo     = indexUp + sizeHalfBlock;
1512                                 stateRealLo = stateVecReal[indexLo];
1513                                 stateImagLo = stateVecImag[indexLo];
1514 
1515                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo -
       stateImagLo);
1516                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo +
       stateImagLo);
1517                         } 
1518                 } else printf("Type %d is an invalid phase gate\n", type);
1519         }
1520 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!QuESTAssert@{QuESTAssert}}
\index{QuESTAssert@{QuESTAssert}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{QuESTAssert}]{\setlength{\rightskip}{0pt plus 5cm}void QuESTAssert (int {\em isValid}, \/  int {\em errorCode}, \/  const char $\ast$ {\em func})}\hfill}
\label{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}


Definition at line 246 of file qubits\_\-env\_\-local.c.

References exitWithError().

Referenced by collapseToOutcome(), compactUnitary(), controlledCompactUnitary(), controlledNot(), controlledPhaseGate(), controlledUnitary(), createMultiQubit(), findProbabilityOfOutcome(), hadamard(), measure(), measureWithStats(), multiControlledPhaseGate(), multiControlledUnitary(), phaseGate(), sigmaX(), sigmaY(), and unitary().


\begin{DoxyCode}
246                                                               {
247     if (!isValid) exitWithError(errorCode, func);
248 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaXDistributed@{sigmaXDistributed}}
\index{sigmaXDistributed@{sigmaXDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaXDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1119 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaX().


\begin{DoxyCode}
1122 {
1123 
1124         long long int thisTask;  
1125         const long long int numTasks=multiQubit.numAmps;
1126 
1127         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1128         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1129 
1130 # ifdef _OPENMP
1131 # pragma omp parallel \
1132         default  (none) \
1133         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1134         private  (thisTask)
1135 # endif
1136         {
1137 # ifdef _OPENMP
1138                 # pragma omp for schedule (static)
1139 # endif
1140                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1141                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
1142                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
1143                 }
1144         }
1145 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaXLocal@{sigmaXLocal}}
\index{sigmaXLocal@{sigmaXLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaXLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}


Definition at line 1060 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaX().


\begin{DoxyCode}
1061 {
1062         long long int sizeBlock, sizeHalfBlock;
1063         long long int thisBlock, // current block
1064              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1065 
1066         REAL stateRealUp,stateImagUp;
1067         long long int thisTask;         
1068         const long long int numTasks=multiQubit.numAmps>>1;
1069 
1070         // set dimensions
1071         sizeHalfBlock = 1LL << targetQubit;  
1072         sizeBlock     = 2LL * sizeHalfBlock; 
1073 
1074         // Can't use multiQubit.stateVec as a private OMP var
1075         REAL *stateVecReal = multiQubit.stateVec.real;
1076         REAL *stateVecImag = multiQubit.stateVec.imag;
1077 
1078 # ifdef _OPENMP
1079 # pragma omp parallel \
1080         default  (none) \
1081         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1082         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1083 # endif
1084         {
1085 # ifdef _OPENMP
1086                 # pragma omp for schedule (static)
1087 # endif
1088                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1089                         thisBlock   = thisTask / sizeHalfBlock;
1090                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1091                         indexLo     = indexUp + sizeHalfBlock;
1092 
1093                         stateRealUp = stateVecReal[indexUp];
1094                         stateImagUp = stateVecImag[indexUp];
1095 
1096                         stateVecReal[indexUp] = stateVecReal[indexLo];
1097                         stateVecImag[indexUp] = stateVecImag[indexLo];
1098 
1099                         stateVecReal[indexLo] = stateRealUp;
1100                         stateVecImag[indexLo] = stateImagUp;
1101                 } 
1102         }
1103 
1104 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaYDistributed@{sigmaYDistributed}}
\index{sigmaYDistributed@{sigmaYDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaYDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1306 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaY().


\begin{DoxyCode}
1310 {
1311 
1312         long long int thisTask;  
1313         const long long int numTasks=multiQubit.numAmps;
1314 
1315         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1316         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1317 
1318         int realSign=1, imagSign=1;
1319         if (updateUpper) imagSign=-1;
1320         else realSign = -1;
1321 
1322 # ifdef _OPENMP
1323 # pragma omp parallel \
1324         default  (none) \
1325         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,r
      ealSign,imagSign) \
1326         private  (thisTask)
1327 # endif
1328         {
1329 # ifdef _OPENMP
1330                 # pragma omp for schedule (static)
1331 # endif
1332                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1333                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisT
      ask];
1334                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisT
      ask];
1335                 }
1336         }
1337 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaYLocal@{sigmaYLocal}}
\index{sigmaYLocal@{sigmaYLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaYLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}


Definition at line 1247 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaY().


\begin{DoxyCode}
1248 {
1249         long long int sizeBlock, sizeHalfBlock;
1250         long long int thisBlock, // current block
1251              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1252 
1253         REAL stateRealUp,stateImagUp;
1254         long long int thisTask;         
1255         const long long int numTasks=multiQubit.numAmps>>1;
1256 
1257         // set dimensions
1258         sizeHalfBlock = 1LL << targetQubit;  
1259         sizeBlock     = 2LL * sizeHalfBlock; 
1260 
1261         // Can't use multiQubit.stateVec as a private OMP var
1262         REAL *stateVecReal = multiQubit.stateVec.real;
1263         REAL *stateVecImag = multiQubit.stateVec.imag;
1264 
1265 # ifdef _OPENMP
1266 # pragma omp parallel \
1267         default  (none) \
1268         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1269         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1270 # endif
1271         {
1272 # ifdef _OPENMP
1273                 # pragma omp for schedule (static)
1274 # endif
1275                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1276                         thisBlock   = thisTask / sizeHalfBlock;
1277                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1278                         indexLo     = indexUp + sizeHalfBlock;
1279 
1280                         stateRealUp = stateVecReal[indexUp];
1281                         stateImagUp = stateVecImag[indexUp];
1282 
1283                         stateVecReal[indexUp] = stateVecImag[indexLo];
1284                         stateVecImag[indexUp] = -stateVecReal[indexLo];
1285 
1286                         stateVecReal[indexLo] = -stateImagUp;
1287                         stateVecImag[indexLo] = stateRealUp;
1288                 } 
1289         }
1290 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!unitaryDistributed@{unitaryDistributed}}
\index{unitaryDistributed@{unitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{unitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}


Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em u}]unitary matrix to apply \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 629 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by unitary().


\begin{DoxyCode}
634 {
635 
636         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
637         long long int thisTask;  
638         const long long int numTasks=multiQubit.numAmps;
639 
640         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
641         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
642         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
643         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
644         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
645 
646 
647 # ifdef _OPENMP
648 # pragma omp parallel \
649         default  (none) \
650         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
651                         rot1Real, rot1Imag, rot2Real, rot2Imag) \
652         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
653 # endif
654         {
655 # ifdef _OPENMP
656                 # pragma omp for schedule (static)
657 # endif
658                 for (thisTask=0; thisTask<numTasks; thisTask++) {
659                         // store current state vector values in temp variables
660                         stateRealUp = stateVecRealUp[thisTask];
661                         stateImagUp = stateVecImagUp[thisTask];
662 
663                         stateRealLo = stateVecRealLo[thisTask];
664                         stateImagLo = stateVecImagLo[thisTask];
665 
666                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp 
667                                 + rot2Real*stateRealLo - rot2Imag*stateImagLo;
668                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp 
669                                 + rot2Real*stateImagLo + rot2Imag*stateRealLo;
670                 }
671         }
672 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!unitaryLocal@{unitaryLocal}}
\index{unitaryLocal@{unitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{unitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}


Definition at line 503 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by unitary().


\begin{DoxyCode}
504 {
505         long long int sizeBlock, sizeHalfBlock;
506         long long int thisBlock, // current block
507              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
508 
509         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
510         long long int thisTask;         
511         const long long int numTasks=multiQubit.numAmps>>1;
512 
513         // set dimensions
514         sizeHalfBlock = 1LL << targetQubit;  
515         sizeBlock     = 2LL * sizeHalfBlock; 
516 
517         // Can't use multiQubit.stateVec as a private OMP var
518         REAL *stateVecReal = multiQubit.stateVec.real;
519         REAL *stateVecImag = multiQubit.stateVec.imag;
520 
521 # ifdef _OPENMP
522 # pragma omp parallel \
523         default  (none) \
524         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
525         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
526 # endif
527         {
528 # ifdef _OPENMP
529                 # pragma omp for schedule (static)
530 # endif
531                 for (thisTask=0; thisTask<numTasks; thisTask++) {
532 
533                         thisBlock   = thisTask / sizeHalfBlock;
534                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
535                         indexLo     = indexUp + sizeHalfBlock;
536 
537                         // store current state vector values in temp variables
538                         stateRealUp = stateVecReal[indexUp];
539                         stateImagUp = stateVecImag[indexUp];
540 
541                         stateRealLo = stateVecReal[indexLo];
542                         stateImagLo = stateVecImag[indexLo];
543 
544 
545                         // state[indexUp] = u00 * state[indexUp] + u01 * state[in
      dexLo]
546                         stateVecReal[indexUp] = u.r0c0.real*stateRealUp - u.r0c0.
      imag*stateImagUp 
547                                 + u.r0c1.real*stateRealLo - u.r0c1.imag*stateImag
      Lo;
548                         stateVecImag[indexUp] = u.r0c0.real*stateImagUp + u.r0c0.
      imag*stateRealUp 
549                                 + u.r0c1.real*stateImagLo + u.r0c1.imag*stateReal
      Lo;
550 
551                         // state[indexLo] = u10  * state[indexUp] + u11 * state[i
      ndexLo]
552                         stateVecReal[indexLo] = u.r1c0.real*stateRealUp  - u.
      r1c0.imag*stateImagUp 
553                                 + u.r1c1.real*stateRealLo  -  u.r1c1.imag*stateIm
      agLo;
554                         stateVecImag[indexLo] = u.r1c0.real*stateImagUp + u.r1c0.
      imag*stateRealUp 
555                                 + u.r1c1.real*stateImagLo + u.r1c1.imag*stateReal
      Lo;
556 
557                 } 
558         }
559 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateAlphaBeta@{validateAlphaBeta}}
\index{validateAlphaBeta@{validateAlphaBeta}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateAlphaBeta}]{\setlength{\rightskip}{0pt plus 5cm}int validateAlphaBeta ({\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}


Definition at line 369 of file qubits.c.

References Complex::imag, Complex::real, and REAL\_\-EPS.

Referenced by compactUnitary(), and controlledCompactUnitary().


\begin{DoxyCode}
369                                                   {
370         if ( fabs(alpha.real*alpha.real 
371                 + alpha.imag*alpha.imag
372                 + beta.real*beta.real 
373                 + beta.imag*beta.imag - 1) > REAL_EPS ) return 0;
374         else return 1;
375 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateMatrixIsUnitary@{validateMatrixIsUnitary}}
\index{validateMatrixIsUnitary@{validateMatrixIsUnitary}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateMatrixIsUnitary}]{\setlength{\rightskip}{0pt plus 5cm}int validateMatrixIsUnitary ({\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}


Definition at line 344 of file qubits.c.

References Complex::imag, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, and REAL\_\-EPS.

Referenced by controlledUnitary(), multiControlledUnitary(), and unitary().


\begin{DoxyCode}
344                                              {
345 
346         if ( fabs(u.r0c0.real*u.r0c0.real 
347                 + u.r0c0.imag*u.r0c0.imag
348                 + u.r1c0.real*u.r1c0.real
349                 + u.r1c0.imag*u.r1c0.imag - 1) > REAL_EPS ) return 0;
350     // check
351         if ( fabs(u.r0c1.real*u.r0c1.real 
352                 + u.r0c1.imag*u.r0c1.imag
353                 + u.r1c1.real*u.r1c1.real
354                 + u.r1c1.imag*u.r1c1.imag - 1) > REAL_EPS ) return 0;
355 
356         if ( fabs(u.r0c0.real*u.r0c1.real 
357                 + u.r0c0.imag*u.r0c1.imag
358                 + u.r1c0.real*u.r1c1.real
359                 + u.r1c0.imag*u.r1c1.imag) > REAL_EPS ) return 0;
360 
361         if ( fabs(u.r0c1.real*u.r0c0.imag
362                 - u.r0c0.real*u.r0c1.imag
363                 + u.r1c1.real*u.r1c0.imag
364                 - u.r1c0.real*u.r1c1.imag) > REAL_EPS ) return 0;
365 
366         return 1;
367 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateUnitVector@{validateUnitVector}}
\index{validateUnitVector@{validateUnitVector}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateUnitVector}]{\setlength{\rightskip}{0pt plus 5cm}int validateUnitVector (REAL {\em ux}, \/  REAL {\em uy}, \/  REAL {\em uz})}\hfill}
\label{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}


Definition at line 377 of file qubits.c.

References REAL\_\-EPS.


\begin{DoxyCode}
377                                                  {
378         if ( fabs(sqrt(ux*ux + uy*uy + uz*uz) - 1) > REAL_EPS ) return 0;
379         else return 1;
380 }
\end{DoxyCode}


\subsubsection{Variable Documentation}
\hypertarget{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!errorCodes@{errorCodes}}
\index{errorCodes@{errorCodes}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{errorCodes}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ {\bf errorCodes}\mbox{[}$\,$\mbox{]}}\hfill}
\label{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}


Definition at line 20 of file qubits.c.

Referenced by exitWithError().