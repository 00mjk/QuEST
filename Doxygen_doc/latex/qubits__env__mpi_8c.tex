\hypertarget{qubits__env__mpi_8c}{
\subsection{qubits\_\-env\_\-mpi.c File Reference}
\label{qubits__env__mpi_8c}\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}}
}


An implementation of the API in \hyperlink{qubits_8h}{qubits.h} for an MPI environment.  
{\ttfamily \#include $<$unistd.h$>$}\par
{\ttfamily \#include $<$mpi.h$>$}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$stdio.h$>$}\par
{\ttfamily \#include $<$math.h$>$}\par
{\ttfamily \#include $<$omp.h$>$}\par
{\ttfamily \#include \char`\"{}precision.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}qubits.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}qubits\_\-internal.h\char`\"{}}\par
\subsubsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}{\_\-BSD\_\-SOURCE}
\item 
\#define \hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}~0
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{isChunkToSkipInFindPZero} (int chunkId, long long int chunkSize, int measureQubit)
\begin{DoxyCompactList}\small\item\em Find chunks to skip when calculating probability of qubit being zero. \item\end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper} (int chunkId, long long int chunkSize, int rotQubit)
\begin{DoxyCompactList}\small\item\em Returns whether a given chunk in position chunkId is in the upper or lower half of a block. \item\end{DoxyCompactList}\item 
static void \hyperlink{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{getRotAngle} (int chunkIsUpper, \hyperlink{structComplex}{Complex} $\ast$rot1, \hyperlink{structComplex}{Complex} $\ast$rot2, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Get rotation values for a given chunk. \item\end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{getChunkPairId} (int chunkIsUpper, int chunkId, long long int chunkSize, int rotQubit)
\begin{DoxyCompactList}\small\item\em get position of corresponding chunk, holding values required to update values in my chunk (with chunkId) when rotating rotQubit. \item\end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk} (long long int chunkSize, int rotQubit)
\begin{DoxyCompactList}\small\item\em return whether the current qubit rotation will use blocks that fit within a single chunk. \item\end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{getChunkIdFromIndex} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\item 
void \hyperlink{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}{initQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} $\ast$\hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Initialize QuEST environment. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{syncQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Guarantees that all code up to the given point has been executed on all nodes. \item\end{DoxyCompactList}\item 
int \hyperlink{qubits__env__mpi_8c_ac7e38d768a1bd79019f88cc1e6295092}{syncQuESTSuccess} (int successCode)
\begin{DoxyCompactList}\small\item\em Performs a logical AND on all successCodes held by all processes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}{closeQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Close QuEST environment. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}{reportQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Report information about the QuEST environment. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}{reportNodeList} (\hyperlink{structQuESTEnv}{QuESTEnv} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Report a list of CPU hostnames and the rank that is running on each if running with MPI enabled and an error message otherwise. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}{getRealAmpEl} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the real component of the probability amplitude at an index in the state vector. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}{getImagAmpEl} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the imaginary component of the probability amplitude at an index in the state vector. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}{calcTotalProbability} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Calculate the probability of being in any state by taking the norm of the entire state vector. \item\end{DoxyCompactList}\item 
static void \hyperlink{qubits__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}{getRotAngleFromUnitaryMatrix} (int chunkIsUpper, \hyperlink{structComplex}{Complex} $\ast$rot1, \hyperlink{structComplex}{Complex} $\ast$rot2, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Get rotation values for a given chunk given a unitary matrix. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int pairRank)
\item 
void \hyperlink{qubits__env__mpi_8c_ad13ae1902276195d0df106116e032aff}{compactUnitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ae74806cf36513b6d8447439a5bc1d615}{unitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits__env__mpi_8c_a96cc5075cff975f73885b50c093ba4a0}{controlledCompactUnitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, const int controlQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a4e135fd99abe7fa390c678937f0cebc9}{controlledUnitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, const int controlQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit given a control qubit Only perform the rotation for elements where the control qubit is one. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a1589779fdc2de60c784eabd8dd1c2a8c}{multiControlledUnitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int $\ast$controlQubits, const int numControlQubits, const int rotQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit given an array of control qubits Only perform the rotation for elements where all control qubits equal 1. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_acda82bebb0a62f419eec9c1e0575daad}{sigmaX} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a4f8f372ee665363241313307bc028c45}{controlledNot} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int rotQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$ and apply a phase of -\/i or i, only for elements when control qubit is 1. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a7b022c75cef77be046bd5d61e38a581e}{sigmaY} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$ and apply a phase of -\/i or i. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ae275b94c1a483dda43bf4ec947635605}{phaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ad247d084dc7150893e9051a438a5807e}{hadamard} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2 -\/-\/ turn a $|$0$>$ into a $|$+$>$ and a $|$1$>$ into a $|$-\/$>$. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{findProbabilityOfOutcome} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, int outcome)
\begin{DoxyCompactList}\small\item\em Find the probability of a specified qubit being in the zero or one state. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__env__mpi_8c_a07418ebac70fd9ae5d051d089961631d}{collapseToOutcome} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measureQubit=0 or measureQubit=1 according to the value of outcome. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ae5f9019826f35e8b51b1716cfe397b45}{exitWithError} (int errorCode, const char $\ast$func)
\item 
void \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert} (int isValid, int errorCode, const char $\ast$func)
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
An implementation of the API in \hyperlink{qubits_8h}{qubits.h} for an MPI environment. 

Definition in file \hyperlink{qubits__env__mpi_8c_source}{qubits\_\-env\_\-mpi.c}.

\subsubsection{Define Documentation}
\hypertarget{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!\_\-BSD\_\-SOURCE@{\_\-BSD\_\-SOURCE}}
\index{\_\-BSD\_\-SOURCE@{\_\-BSD\_\-SOURCE}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{\_\-BSD\_\-SOURCE}]{\setlength{\rightskip}{0pt plus 5cm}\#define \_\-BSD\_\-SOURCE}\hfill}
\label{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}


Definition at line 5 of file qubits\_\-env\_\-mpi.c.\hypertarget{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!DEBUG@{DEBUG}}
\index{DEBUG@{DEBUG}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{DEBUG}]{\setlength{\rightskip}{0pt plus 5cm}\#define DEBUG~0}\hfill}
\label{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}


Definition at line 18 of file qubits\_\-env\_\-mpi.c.

\subsubsection{Function Documentation}
\hypertarget{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!calcTotalProbability@{calcTotalProbability}}
\index{calcTotalProbability@{calcTotalProbability}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{calcTotalProbability}]{\setlength{\rightskip}{0pt plus 5cm}REAL calcTotalProbability ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}


Calculate the probability of being in any state by taking the norm of the entire state vector. Should be equal to 1. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \end{DoxyParams}
\begin{DoxyReturn}{Returns}
total probability 
\end{DoxyReturn}


Definition at line 108 of file qubits\_\-env\_\-mpi.c.

References DEBUG, ComplexArray::imag, MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by test\_\-compactUnitary(), and test\_\-unitary().


\begin{DoxyCode}
108                                                 {
109   /* IJB - implemented using Kahan summation for greater accuracy at a slight flo
      ating
110      point operation overhead. For more details see https://en.wikipedia.org/wiki
      /Kahan_summation_algorithm */
111   /* Don't change the bracketing in this routine! */
112   REAL pTotal=0; 
113   REAL y, t, c;
114   REAL allRankTotals=0;
115   long long int index;
116   long long int numAmpsPerRank = multiQubit.numAmps;
117   c = 0.0;
118   for (index=0; index<numAmpsPerRank; index++){ 
119     /* Perform pTotal+=multiQubit.stateVec.real[index]*multiQubit.stateVec.real[i
      ndex]; by Kahan */
120     y = multiQubit.stateVec.real[index]*multiQubit.stateVec.real[index] - c;
121     t = pTotal + y;
122     c = ( t - pTotal ) - y;
123     pTotal = t;
124     /* Perform pTotal+=multiQubit.stateVec.imag[index]*multiQubit.stateVec.imag[i
      ndex]; by Kahan */
125     y = multiQubit.stateVec.imag[index]*multiQubit.stateVec.imag[index] - c;
126     t = pTotal + y;
127     c = ( t - pTotal ) - y;
128     pTotal = t;
129   } 
130   if (DEBUG) printf("before calc prob. %d\n", multiQubit.numChunks);
131   if (multiQubit.numChunks>1) MPI_Allreduce(&pTotal, &allRankTotals, 1, 
      MPI_QuEST_REAL, MPI_SUM, MPI_COMM_WORLD);
132   else allRankTotals=pTotal;
133   
134   return allRankTotals;
135 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!chunkIsUpper@{chunkIsUpper}}
\index{chunkIsUpper@{chunkIsUpper}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{chunkIsUpper}]{\setlength{\rightskip}{0pt plus 5cm}static int chunkIsUpper (int {\em chunkId}, \/  long long int {\em chunkSize}, \/  int {\em rotQubit})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}


Returns whether a given chunk in position chunkId is in the upper or lower half of a block. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkId}]id of chunk in state vector \item[\mbox{$\leftarrow$} {\em chunkSize}]number of amps in chunk \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit being rotated \end{DoxyParams}
\begin{DoxyReturn}{Returns}
1: chunk is in upper half of block, 0: chunk is in lower half of block fix -\/-\/ is this the same as isChunkToSkip? 
\end{DoxyReturn}


Definition at line 146 of file qubits\_\-env\_\-mpi.c.

Referenced by compactUnitary(), controlledCompactUnitary(), controlledNot(), controlledUnitary(), hadamard(), multiControlledUnitary(), phaseGate(), sigmaX(), sigmaY(), and unitary().


\begin{DoxyCode}
147 {       
148         long long int sizeHalfBlock = 1LL << (rotQubit);
149         long long int sizeBlock = sizeHalfBlock*2;
150         long long int posInBlock = (chunkId*chunkSize) % sizeBlock;
151         return posInBlock<sizeHalfBlock;
152 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!closeQuESTEnv@{closeQuESTEnv}}
\index{closeQuESTEnv@{closeQuESTEnv}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{closeQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void closeQuESTEnv ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}


Close QuEST environment. If something needs to be done to clean up the execution environment, such as finalizing MPI when running in distributed mode, it is handled here 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 56 of file qubits\_\-env\_\-mpi.c.

Referenced by main().


\begin{DoxyCode}
56                                 {
57         int finalized;
58         MPI_Finalized(&finalized);
59         if (!finalized) MPI_Finalize();
60         else printf("ERROR: Trying to close QuESTEnv multiple times. Ignoring\n")
      ;
61 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a07418ebac70fd9ae5d051d089961631d}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!collapseToOutcome@{collapseToOutcome}}
\index{collapseToOutcome@{collapseToOutcome}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{collapseToOutcome}]{\setlength{\rightskip}{0pt plus 5cm}REAL collapseToOutcome ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  int {\em outcome})}\hfill}
\label{qubits__env__mpi_8c_a07418ebac70fd9ae5d051d089961631d}


Update the state vector to be consistent with measuring measureQubit=0 or measureQubit=1 according to the value of outcome. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that an outcome has been measured on the qubit indicated by measureQubit (where his label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 if outcome=0 or measureQubit=1 if outcome=1. It then returns the probability of making this measurement.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em outcome}]to measure the probability of and set the state to -\/-\/ either zero or one \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being either zero or one 
\end{DoxyReturn}


Definition at line 678 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, collapseToOutcomeDistributedRenorm(), collapseToOutcomeDistributedSetZero(), collapseToOutcomeLocal(), findProbabilityOfOutcome(), halfMatrixBlockFitsInChunk(), isChunkToSkipInFindPZero(), MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), REAL, and REAL\_\-EPS.

Referenced by test\_\-collapseToOutcome().


\begin{DoxyCode}
679 {
680     QuESTAssert(measureQubit >= 0 && measureQubit < multiQubit.numQubits, 2, __fu
      nc__);
681 
682         REAL totalStateProb=findProbabilityOfOutcome(multiQubit, measureQubit, ou
      tcome);
683     QuESTAssert(fabs(totalStateProb>REAL_EPS), 8, __func__);
684 
685         int skipValuesWithinRank = halfMatrixBlockFitsInChunk(multiQubit.numAmps,
       measureQubit);
686     if (skipValuesWithinRank) {
687         collapseToOutcomeLocal(multiQubit, measureQubit, totalStateProb, outcome)
      ;
688     } else {
689         if (!isChunkToSkipInFindPZero(multiQubit.chunkId, multiQubit.numAmps, mea
      sureQubit)){
690             // chunk has amps for q=0
691             if (outcome==0) collapseToOutcomeDistributedRenorm(multiQubit, measur
      eQubit, 
692                     totalStateProb);
693             else collapseToOutcomeDistributedSetZero(multiQubit, measureQubit);
694         } else {
695             // chunk has amps for q=1
696             if (outcome==1) collapseToOutcomeDistributedRenorm(multiQubit, measur
      eQubit, 
697                     totalStateProb);
698             else collapseToOutcomeDistributedSetZero(multiQubit, measureQubit);
699         }
700     }
701         return totalStateProb;
702 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ad13ae1902276195d0df106116e032aff}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!compactUnitary@{compactUnitary}}
\index{compactUnitary@{compactUnitary}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{compactUnitary}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitary ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__env__mpi_8c_ad13ae1902276195d0df106116e032aff}


Rotate a single qubit in the state vector of probability amplitudes. Given two complex numbers alpha and beta, applies the operation \par
 \mbox{[}alpha, -\/beta$\ast$ \par
 beta, alpha$\ast$\mbox{]} \par


\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}
alpha, beta must obey $|$alpha$|$$^\wedge$2 + $|$beta$|$$^\wedge$2 = 1


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 271 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), compactUnitaryDistributed(), compactUnitaryLocal(), exchangeStateVectors(), getChunkPairId(), getRotAngle(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, and validateAlphaBeta().

Referenced by rotateAroundAxis(), rotateX(), rotateY(), rotateZ(), test\_\-compactUnitary(), and test\_\-unitary().


\begin{DoxyCode}
272 {
273         QuESTAssert(rotQubit >= 0 && rotQubit < multiQubit.numQubits, 1, __func__
      );
274         QuESTAssert(validateAlphaBeta(alpha, beta), 6, __func__);
275 
276         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
277         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
278         Complex rot1, rot2;
279 
280         // rank's chunk is in upper half of block 
281         int rankIsUpper;
282         int pairRank; // rank of corresponding chunk
283 
284         if (useLocalDataOnly){
285                 // all values required to update state vector lie in this rank
286                 compactUnitaryLocal(multiQubit, rotQubit, alpha, beta);
287         } else {
288                 // need to get corresponding chunk of state vector from other ran
      k
289                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
290                 getRotAngle(rankIsUpper, &rot1, &rot2, alpha, beta);
291                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, rotQubit);
292                 // get corresponding values from my pair
293                         exchangeStateVectors(multiQubit, pairRank);
294 
295                 // this rank's values are either in the upper of lower half of th
      e block. 
296                         // send values to compactUnitaryDistributed in the correc
      t order
297                 if (rankIsUpper){
298                         compactUnitaryDistributed(multiQubit,rotQubit,rot1,rot2,
299                                 multiQubit.stateVec, //upper
300                                 multiQubit.pairStateVec, //lower
301                                 multiQubit.stateVec); //output
302                 } else {
303                         compactUnitaryDistributed(multiQubit,rotQubit,rot1,rot2,
304                                 multiQubit.pairStateVec, //upper
305                                 multiQubit.stateVec, //lower
306                                 multiQubit.stateVec); //output
307                 }
308         }
309 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a96cc5075cff975f73885b50c093ba4a0}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!controlledCompactUnitary@{controlledCompactUnitary}}
\index{controlledCompactUnitary@{controlledCompactUnitary}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{controlledCompactUnitary}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitary ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  const int {\em controlQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__env__mpi_8c_a96cc5075cff975f73885b50c093ba4a0}


Rotate a single qubit in the state vector of probability amplitudes. Given two complex numbers alpha and beta and a control qubit, applies the operation: \par
 \mbox{[}alpha, -\/beta$\ast$ \par
 beta, alpha$\ast$\mbox{]} \par
 Only when the control qubit is one.

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}
alpha, beta must obey $|$alpha$|$$^\wedge$2 + $|$beta$|$$^\wedge$2 = 1


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform rotation if this qubit is 1 \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 353 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), controlledCompactUnitaryDistributed(), controlledCompactUnitaryLocal(), exchangeStateVectors(), getChunkPairId(), getRotAngle(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, and validateAlphaBeta().

Referenced by test\_\-controlledCompactUnitary(), test\_\-controlledUnitary(), and test\_\-multiControlledUnitary().


\begin{DoxyCode}
354 {
355         QuESTAssert(rotQubit >= 0 && rotQubit < multiQubit.numQubits, 1, __func__
      );
356         QuESTAssert(controlQubit >= 0 && controlQubit < multiQubit.numQubits, 2, 
      __func__);
357         QuESTAssert(controlQubit != rotQubit, 3, __func__);
358         QuESTAssert(validateAlphaBeta(alpha, beta), 6, __func__);
359 
360         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
361         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
362         Complex rot1, rot2;
363 
364         // rank's chunk is in upper half of block 
365         int rankIsUpper;
366         int pairRank; // rank of corresponding chunk
367 
368         if (useLocalDataOnly){
369                 // all values required to update state vector lie in this rank
370                 controlledCompactUnitaryLocal(multiQubit, rotQubit, controlQubit,
       alpha, beta);
371         } else {
372                 // need to get corresponding chunk of state vector from other ran
      k
373                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
374                 getRotAngle(rankIsUpper, &rot1, &rot2, alpha, beta);
375                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, rotQubit);
376                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
377                 // get corresponding values from my pair
378                 exchangeStateVectors(multiQubit, pairRank);
379                 
380                 // this rank's values are either in the upper of lower half of th
      e block. send values to controlledCompactUnitaryDistributed
381                 // in the correct order
382                 if (rankIsUpper){
383                         controlledCompactUnitaryDistributed(multiQubit,rotQubit,c
      ontrolQubit,rot1,rot2,
384                                 multiQubit.stateVec, //upper
385                                 multiQubit.pairStateVec, //lower
386                                 multiQubit.stateVec); //output
387                 } else {
388                         controlledCompactUnitaryDistributed(multiQubit,rotQubit,c
      ontrolQubit,rot1,rot2,
389                                 multiQubit.pairStateVec, //upper
390                                 multiQubit.stateVec, //lower
391                                 multiQubit.stateVec); //output
392                 }
393         }
394 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a4f8f372ee665363241313307bc028c45}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!controlledNot@{controlledNot}}
\index{controlledNot@{controlledNot}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{controlledNot}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNot ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__env__mpi_8c_a4f8f372ee665363241313307bc028c45}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$ and apply a phase of -\/i or i, only for elements when control qubit is 1. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform sigmaX rotation if this qubit is 1 \end{DoxyParams}


Definition at line 515 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), controlledNotDistributed(), controlledNotLocal(), exchangeStateVectors(), getChunkPairId(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), and MultiQubit::stateVec.

Referenced by test\_\-controlledNot().


\begin{DoxyCode}
516 {
517         QuESTAssert(rotQubit >= 0 && rotQubit < multiQubit.numQubits, 1, __func__
      );
518         QuESTAssert(controlQubit >= 0 && controlQubit < multiQubit.numQubits, 2, 
      __func__);
519         QuESTAssert(controlQubit != rotQubit, 3, __func__);
520 
521         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
522         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
523 
524         // rank's chunk is in upper half of block 
525         int rankIsUpper;
526         int pairRank; // rank of corresponding chunk
527 
528         if (useLocalDataOnly){
529                 // all values required to update state vector lie in this rank
530                 controlledNotLocal(multiQubit, controlQubit, rotQubit);
531         } else {
532                 // need to get corresponding chunk of state vector from other ran
      k
533                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
534                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, rotQubit);
535                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
536                 // get corresponding values from my pair
537                 exchangeStateVectors(multiQubit, pairRank);
538                 // this rank's values are either in the upper of lower half of th
      e block. send values to controlledNot
539                 // in the correct order
540                 if (rankIsUpper){
541                         controlledNotDistributed(multiQubit,controlQubit,rotQubit
      ,
542                                 multiQubit.pairStateVec, //in
543                                 multiQubit.stateVec); //out
544                 } else {
545                         controlledNotDistributed(multiQubit,controlQubit,rotQubit
      ,
546                                 multiQubit.pairStateVec, //in
547                                 multiQubit.stateVec); //out
548                 }
549         }
550 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a4e135fd99abe7fa390c678937f0cebc9}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!controlledUnitary@{controlledUnitary}}
\index{controlledUnitary@{controlledUnitary}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{controlledUnitary}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitary ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  const int {\em controlQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__env__mpi_8c_a4e135fd99abe7fa390c678937f0cebc9}


Apply a unitary operation to a single qubit given a control qubit Only perform the rotation for elements where the control qubit is one. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform rotation if this qubit is 1 \item[\mbox{$\leftarrow$} {\em u}]unitary matrix to apply \end{DoxyParams}


Definition at line 396 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), controlledUnitaryDistributed(), controlledUnitaryLocal(), exchangeStateVectors(), getChunkPairId(), getRotAngleFromUnitaryMatrix(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, and validateMatrixIsUnitary().

Referenced by test\_\-controlledUnitary().


\begin{DoxyCode}
398 {
399         QuESTAssert(rotQubit >= 0 && rotQubit < multiQubit.numQubits, 1, __func__
      );
400         QuESTAssert(controlQubit >= 0 && controlQubit < multiQubit.numQubits, 2, 
      __func__);
401         QuESTAssert(controlQubit != rotQubit, 3, __func__);
402         QuESTAssert(validateMatrixIsUnitary(u), 5, __func__);
403 
404         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
405         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
406         Complex rot1, rot2;
407 
408         // rank's chunk is in upper half of block 
409         int rankIsUpper;
410         int pairRank; // rank of corresponding chunk
411 
412         if (useLocalDataOnly){
413                 // all values required to update state vector lie in this rank
414                 controlledUnitaryLocal(multiQubit, rotQubit, controlQubit, u);
415         } else {
416                 // need to get corresponding chunk of state vector from other ran
      k
417                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
418                 getRotAngleFromUnitaryMatrix(rankIsUpper, &rot1, &rot2, u);
419                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, rotQubit);
420                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
421                 // get corresponding values from my pair
422                 exchangeStateVectors(multiQubit, pairRank);
423                 
424                 // this rank's values are either in the upper of lower half of th
      e block. send values to controlledUnitaryDistributed
425                 // in the correct order
426                 if (rankIsUpper){
427                         controlledUnitaryDistributed(multiQubit,rotQubit,controlQ
      ubit,rot1,rot2,
428                                 multiQubit.stateVec, //upper
429                                 multiQubit.pairStateVec, //lower
430                                 multiQubit.stateVec); //output
431                 } else {
432                         controlledUnitaryDistributed(multiQubit,rotQubit,controlQ
      ubit,rot1,rot2,
433                                 multiQubit.pairStateVec, //upper
434                                 multiQubit.stateVec, //lower
435                                 multiQubit.stateVec); //output
436                 }
437         }
438 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!exchangeStateVectors@{exchangeStateVectors}}
\index{exchangeStateVectors@{exchangeStateVectors}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{exchangeStateVectors}]{\setlength{\rightskip}{0pt plus 5cm}void exchangeStateVectors ({\bf MultiQubit} {\em multiQubit}, \/  int {\em pairRank})}\hfill}
\label{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}


Definition at line 239 of file qubits\_\-env\_\-mpi.c.

References DEBUG, ComplexArray::imag, MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, MultiQubit::pairStateVec, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by compactUnitary(), controlledCompactUnitary(), controlledNot(), controlledUnitary(), hadamard(), multiControlledUnitary(), sigmaX(), sigmaY(), and unitary().


\begin{DoxyCode}
239                                                               {
240         // MPI send/receive vars
241         int TAG=100;
242         MPI_Status status;
243 
244         // Multiple messages are required as MPI uses int rather than long long i
      nt for count
245         // For openmpi, messages are further restricted to 2GB in size -- do this
       for all cases
246         // to be safe
247         long long int maxMessageCount = 1LL<<29;
248         if (sizeof(REAL)==8) maxMessageCount = (1LL<<28);
249         else if (sizeof(REAL)==16) maxMessageCount = (1LL<<27);
250 
251         if (multiQubit.numAmps<maxMessageCount) maxMessageCount = multiQubit.
      numAmps;
252         int numMessages = multiQubit.numAmps/maxMessageCount;
253         int i;
254         long long int offset;
255         if (DEBUG) printf("numMessages %d maxMessageCount %lld\n", numMessages, m
      axMessageCount);
256 
257         // send my state vector to pairRank's multiQubit.pairStateVec
258         // receive pairRank's state vector into multiQubit.pairStateVec
259         for (i=0; i<numMessages; i++){
260                 offset = i*maxMessageCount;
261                 MPI_Sendrecv(&multiQubit.stateVec.real[offset], maxMessageCount, 
      MPI_QuEST_REAL, pairRank, TAG,
262                                  &multiQubit.pairStateVec.real[offset], maxMessag
      eCount, MPI_QuEST_REAL,
263                                  pairRank, TAG, MPI_COMM_WORLD, &status);
264                 //printf("rank: %d err: %d\n", multiQubit.rank, err);
265                 MPI_Sendrecv(&multiQubit.stateVec.imag[offset], maxMessageCount, 
      MPI_QuEST_REAL, pairRank, TAG,
266                                 &multiQubit.pairStateVec.imag[offset], maxMessage
      Count, MPI_QuEST_REAL,
267                                 pairRank, TAG, MPI_COMM_WORLD, &status);
268         }
269 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ae5f9019826f35e8b51b1716cfe397b45}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!exitWithError@{exitWithError}}
\index{exitWithError@{exitWithError}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{exitWithError}]{\setlength{\rightskip}{0pt plus 5cm}void exitWithError (int {\em errorCode}, \/  const char $\ast$ {\em func})}\hfill}
\label{qubits__env__mpi_8c_ae5f9019826f35e8b51b1716cfe397b45}


Definition at line 704 of file qubits\_\-env\_\-mpi.c.

References errorCodes.


\begin{DoxyCode}
704                                                    {
705     printf("!!!\n");
706     printf("QuEST Error in function %s: %s\n", func, errorCodes[errorCode]);
707     printf("!!!\n");
708     printf("exiting..\n");
709     MPI_Abort(MPI_COMM_WORLD, errorCode);
710 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!findProbabilityOfOutcome@{findProbabilityOfOutcome}}
\index{findProbabilityOfOutcome@{findProbabilityOfOutcome}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{findProbabilityOfOutcome}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfOutcome ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  int {\em outcome})}\hfill}
\label{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}


Find the probability of a specified qubit being in the zero or one state. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em outcome}]to measure the probability of -\/-\/ either zero or one \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being either zero or one 
\end{DoxyReturn}


Definition at line 659 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, findProbabilityOfZeroDistributed(), findProbabilityOfZeroLocal(), halfMatrixBlockFitsInChunk(), isChunkToSkipInFindPZero(), MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), and REAL.

Referenced by collapseToOutcome(), main(), and test\_\-findProbabilityOfOutcome().


\begin{DoxyCode}
660 {
661     QuESTAssert(measureQubit >= 0 && measureQubit < multiQubit.numQubits, 2, __fu
      nc__);
662 
663         REAL stateProb=0, totalStateProb=0;
664         int skipValuesWithinRank = halfMatrixBlockFitsInChunk(multiQubit.numAmps,
       measureQubit);
665         if (skipValuesWithinRank) {
666                 stateProb = findProbabilityOfZeroLocal(multiQubit, measureQubit);
      
667         } else {
668                 if (!isChunkToSkipInFindPZero(multiQubit.chunkId, multiQubit.
      numAmps, measureQubit)){
669                         stateProb = findProbabilityOfZeroDistributed(multiQubit, 
      measureQubit);
670                 } else stateProb = 0;
671         }
672         MPI_Allreduce(&stateProb, &totalStateProb, 1, MPI_QuEST_REAL, MPI_SUM, MP
      I_COMM_WORLD);
673         if (outcome==1) totalStateProb = 1.0 - totalStateProb;
674         return totalStateProb;
675 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getChunkIdFromIndex@{getChunkIdFromIndex}}
\index{getChunkIdFromIndex@{getChunkIdFromIndex}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getChunkIdFromIndex}]{\setlength{\rightskip}{0pt plus 5cm}int getChunkIdFromIndex ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}


Definition at line 84 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::numAmps.

Referenced by getImagAmpEl(), and getRealAmpEl().


\begin{DoxyCode}
84                                                                    {
85         return index/multiQubit.numAmps; // this is numAmpsPerChunk
86 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getChunkPairId@{getChunkPairId}}
\index{getChunkPairId@{getChunkPairId}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getChunkPairId}]{\setlength{\rightskip}{0pt plus 5cm}static int getChunkPairId (int {\em chunkIsUpper}, \/  int {\em chunkId}, \/  long long int {\em chunkSize}, \/  int {\em rotQubit})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}


get position of corresponding chunk, holding values required to update values in my chunk (with chunkId) when rotating rotQubit. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkIsUpper}]1: chunk is in upper half of block, 0: chunk is in lower half \item[\mbox{$\leftarrow$} {\em chunkId}]id of chunk in state vector \item[\mbox{$\leftarrow$} {\em chunkSize}]number of amps in chunk \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit being rotated \end{DoxyParams}
\begin{DoxyReturn}{Returns}
chunkId of chunk required to rotate rotQubit 
\end{DoxyReturn}


Definition at line 213 of file qubits\_\-env\_\-mpi.c.

Referenced by compactUnitary(), controlledCompactUnitary(), controlledNot(), controlledUnitary(), hadamard(), multiControlledUnitary(), sigmaX(), sigmaY(), and unitary().


\begin{DoxyCode}
214 {
215         long long int sizeHalfBlock = 1LL << (rotQubit);
216         int chunksPerHalfBlock = sizeHalfBlock/chunkSize;
217         if (chunkIsUpper){
218                 return chunkId + chunksPerHalfBlock;
219         } else {
220                 return chunkId - chunksPerHalfBlock;
221         }
222 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getImagAmpEl@{getImagAmpEl}}
\index{getImagAmpEl@{getImagAmpEl}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getImagAmpEl}]{\setlength{\rightskip}{0pt plus 5cm}REAL getImagAmpEl ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})}\hfill}
\label{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}


Get the imaginary component of the probability amplitude at an index in the state vector. For debugging purposes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \item[\mbox{$\leftarrow$} {\em index}]index in state vector of probability amplitudes \end{DoxyParams}
\begin{DoxyReturn}{Returns}
imaginary component at that index 
\end{DoxyReturn}


Definition at line 98 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, getChunkIdFromIndex(), ComplexArray::imag, MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, REAL, and MultiQubit::stateVec.

Referenced by getProbEl().


\begin{DoxyCode}
98                                                              {
99         int chunkId = getChunkIdFromIndex(multiQubit, index);
100         REAL el; 
101         if (multiQubit.chunkId==chunkId){
102                 el = multiQubit.stateVec.imag[index-chunkId*multiQubit.numAmps];
103         }
104         MPI_Bcast(&el, 1, MPI_QuEST_REAL, chunkId, MPI_COMM_WORLD);
105         return el; 
106 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getRealAmpEl@{getRealAmpEl}}
\index{getRealAmpEl@{getRealAmpEl}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getRealAmpEl}]{\setlength{\rightskip}{0pt plus 5cm}REAL getRealAmpEl ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})}\hfill}
\label{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}


Get the real component of the probability amplitude at an index in the state vector. For debugging purposes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \item[\mbox{$\leftarrow$} {\em index}]index in state vector of probability amplitudes \end{DoxyParams}
\begin{DoxyReturn}{Returns}
real component at that index 
\end{DoxyReturn}


Definition at line 88 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, getChunkIdFromIndex(), MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by getProbEl().


\begin{DoxyCode}
88                                                              {
89         int chunkId = getChunkIdFromIndex(multiQubit, index);
90         REAL el; 
91         if (multiQubit.chunkId==chunkId){
92                 el = multiQubit.stateVec.real[index-chunkId*multiQubit.numAmps];
93         }
94         MPI_Bcast(&el, 1, MPI_QuEST_REAL, chunkId, MPI_COMM_WORLD);
95         return el; 
96 } 
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getRotAngle@{getRotAngle}}
\index{getRotAngle@{getRotAngle}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getRotAngle}]{\setlength{\rightskip}{0pt plus 5cm}static void getRotAngle (int {\em chunkIsUpper}, \/  {\bf Complex} $\ast$ {\em rot1}, \/  {\bf Complex} $\ast$ {\em rot2}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}


Get rotation values for a given chunk. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkIsUpper}]1: chunk is in upper half of block, 0: chunk is in lower half\item[\mbox{$\rightarrow$} {\em rot1,rot2}]rotation values to use, allocated for upper/lower such that \begin{DoxyVerb}
stateUpper = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 or \begin{DoxyVerb}
stateLower = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 \item[\mbox{$\leftarrow$} {\em alpha,beta}]initial rotation values \end{DoxyParams}


Definition at line 167 of file qubits\_\-env\_\-mpi.c.

References Complex::imag, and Complex::real.

Referenced by compactUnitary(), and controlledCompactUnitary().


\begin{DoxyCode}
168 {
169         if (chunkIsUpper){
170                 *rot1=alpha;
171                 rot2->real=-beta.real;
172                 rot2->imag=-beta.imag;
173         } else {
174                 *rot1=beta;
175                 *rot2=alpha;
176         }
177 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getRotAngleFromUnitaryMatrix@{getRotAngleFromUnitaryMatrix}}
\index{getRotAngleFromUnitaryMatrix@{getRotAngleFromUnitaryMatrix}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getRotAngleFromUnitaryMatrix}]{\setlength{\rightskip}{0pt plus 5cm}static void getRotAngleFromUnitaryMatrix (int {\em chunkIsUpper}, \/  {\bf Complex} $\ast$ {\em rot1}, \/  {\bf Complex} $\ast$ {\em rot2}, \/  {\bf ComplexMatrix2} {\em u})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}


Get rotation values for a given chunk given a unitary matrix. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkIsUpper}]1: chunk is in upper half of block, 0: chunk is in lower half\item[\mbox{$\rightarrow$} {\em rot1,rot2}]rotation values to use, allocated for upper/lower such that \begin{DoxyVerb}
stateUpper = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 or \begin{DoxyVerb}
stateLower = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 \item[\mbox{$\leftarrow$} {\em u}]unitary matrix operation \end{DoxyParams}


Definition at line 192 of file qubits\_\-env\_\-mpi.c.

References ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, and ComplexMatrix2::r1c1.

Referenced by controlledUnitary(), multiControlledUnitary(), and unitary().


\begin{DoxyCode}
193 {
194         if (chunkIsUpper){
195                 *rot1=u.r0c0;
196                 *rot2=u.r0c1;
197         } else {
198                 *rot1=u.r1c0;
199                 *rot2=u.r1c1;
200         }
201 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ad247d084dc7150893e9051a438a5807e}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!hadamard@{hadamard}}
\index{hadamard@{hadamard}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{hadamard}]{\setlength{\rightskip}{0pt plus 5cm}void hadamard ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit})}\hfill}
\label{qubits__env__mpi_8c_ad247d084dc7150893e9051a438a5807e}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2 -\/-\/ turn a $|$0$>$ into a $|$+$>$ and a $|$1$>$ into a $|$-\/$>$. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \end{DoxyParams}


Definition at line 601 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), hadamardDistributed(), hadamardLocal(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), and MultiQubit::stateVec.

Referenced by test\_\-hadamard().


\begin{DoxyCode}
602 {
603         QuESTAssert(rotQubit >= 0 && rotQubit < multiQubit.numQubits, 1, __func__
      );
604 
605         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
606         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
607 
608         // rank's chunk is in upper half of block 
609         int rankIsUpper;
610         int pairRank; // rank of corresponding chunk
611 
612         if (useLocalDataOnly){
613                 // all values required to update state vector lie in this rank
614                 hadamardLocal(multiQubit, rotQubit);
615         } else {
616                 // need to get corresponding chunk of state vector from other ran
      k
617                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
618                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, rotQubit);
619                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
620                 // get corresponding values from my pair
621                 exchangeStateVectors(multiQubit, pairRank);
622                 // this rank's values are either in the upper of lower half of th
      e block. send values to hadamardDistributed
623                 // in the correct order
624                 if (rankIsUpper){
625                         hadamardDistributed(multiQubit,rotQubit,
626                                 multiQubit.stateVec, //upper
627                                 multiQubit.pairStateVec, //lower
628                                 multiQubit.stateVec, rankIsUpper); //output
629                 } else {
630                         hadamardDistributed(multiQubit,rotQubit,
631                                 multiQubit.pairStateVec, //upper
632                                 multiQubit.stateVec, //lower
633                                 multiQubit.stateVec, rankIsUpper); //output
634                 }
635         }
636 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!halfMatrixBlockFitsInChunk@{halfMatrixBlockFitsInChunk}}
\index{halfMatrixBlockFitsInChunk@{halfMatrixBlockFitsInChunk}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{halfMatrixBlockFitsInChunk}]{\setlength{\rightskip}{0pt plus 5cm}static int halfMatrixBlockFitsInChunk (long long int {\em chunkSize}, \/  int {\em rotQubit})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}


return whether the current qubit rotation will use blocks that fit within a single chunk. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkSize}]number of amps in chunk \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit being rotated \end{DoxyParams}
\begin{DoxyReturn}{Returns}
1: one chunk fits in one block 0: chunk is larger than block 
\end{DoxyReturn}


Definition at line 232 of file qubits\_\-env\_\-mpi.c.

Referenced by collapseToOutcome(), compactUnitary(), controlledCompactUnitary(), controlledNot(), controlledUnitary(), findProbabilityOfOutcome(), hadamard(), multiControlledUnitary(), phaseGate(), sigmaX(), sigmaY(), and unitary().


\begin{DoxyCode}
233 {
234         long long int sizeHalfBlock = 1LL << (rotQubit);
235         if (chunkSize > sizeHalfBlock) return 1;
236         else return 0;
237 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!initQuESTEnv@{initQuESTEnv}}
\index{initQuESTEnv@{initQuESTEnv}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{initQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void initQuESTEnv ({\bf QuESTEnv} $\ast$ {\em env})}\hfill}
\label{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}


Initialize QuEST environment. If something needs to be done to set up the execution environment, such as initializing MPI when running in distributed mode, it is handled here 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 26 of file qubits\_\-env\_\-mpi.c.

References DEBUG, QuESTEnv::numRanks, and QuESTEnv::rank.

Referenced by main().


\begin{DoxyCode}
26                                 {
27         // init MPI environment
28         int rank, numRanks, initialized;
29         MPI_Initialized(&initialized);
30         if (!initialized){
31                 MPI_Init(NULL, NULL);
32                 MPI_Comm_size(MPI_COMM_WORLD, &numRanks);
33                 MPI_Comm_rank(MPI_COMM_WORLD, &rank);
34 
35                 if (DEBUG) {
36                         char hostName[256];
37                         int hostNameLen;
38                         MPI_Get_processor_name(hostName, &hostNameLen);
39                         printf("rank %d on host %s\n", rank, hostName);
40                 }
41                 env->rank=rank;
42                 env->numRanks=numRanks;
43         } else printf("ERROR: Trying to initialize QuESTEnv multiple times. Ignor
      ing\n");
44 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!isChunkToSkipInFindPZero@{isChunkToSkipInFindPZero}}
\index{isChunkToSkipInFindPZero@{isChunkToSkipInFindPZero}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{isChunkToSkipInFindPZero}]{\setlength{\rightskip}{0pt plus 5cm}static int isChunkToSkipInFindPZero (int {\em chunkId}, \/  long long int {\em chunkSize}, \/  int {\em measureQubit})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}


Find chunks to skip when calculating probability of qubit being zero. When calculating probability of a bit q being zero, sum up 2$^\wedge$q values, then skip 2$^\wedge$q values, etc. This function finds if an entire chunk is in the range of values to be skipped


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkId}]id of chunk in state vector \item[\mbox{$\leftarrow$} {\em chunkSize}]number of amps in chunk \item[\mbox{$\leftarrow$} {\em measureQubi}]qubit being measured \end{DoxyParams}
\begin{DoxyReturn}{Returns}
int -\/-\/ 1: skip, 0: don't skip 
\end{DoxyReturn}


Definition at line 650 of file qubits\_\-env\_\-mpi.c.

Referenced by collapseToOutcome(), and findProbabilityOfOutcome().


\begin{DoxyCode}
651 {
652         long long int sizeHalfBlock = 1LL << (measureQubit);
653         int numChunksToSkip = sizeHalfBlock/chunkSize;
654         // calculate probability by summing over numChunksToSkip, then skipping n
      umChunksToSkip, etc
655         int bitToCheck = chunkId & numChunksToSkip;
656         return bitToCheck;
657 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a1589779fdc2de60c784eabd8dd1c2a8c}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!multiControlledUnitary@{multiControlledUnitary}}
\index{multiControlledUnitary@{multiControlledUnitary}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{multiControlledUnitary}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitary ({\bf MultiQubit} {\em multiQubit}, \/  int $\ast$ {\em controlQubits}, \/  const int {\em numControlQubits}, \/  const int {\em rotQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__env__mpi_8c_a1589779fdc2de60c784eabd8dd1c2a8c}


Apply a unitary operation to a single qubit given an array of control qubits Only perform the rotation for elements where all control qubits equal 1. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubits}]perform rotation if all qubits in this array equal 1 \item[\mbox{$\leftarrow$} {\em numControlQubits}]number of control qubits \item[\mbox{$\leftarrow$} {\em u}]unitary matrix to apply \end{DoxyParams}


Definition at line 440 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), getRotAngleFromUnitaryMatrix(), halfMatrixBlockFitsInChunk(), multiControlledUnitaryDistributed(), multiControlledUnitaryLocal(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, and validateMatrixIsUnitary().

Referenced by test\_\-multiControlledUnitary().


\begin{DoxyCode}
441 {
442         QuESTAssert(rotQubit >= 0 && rotQubit < multiQubit.numQubits, 1, __func__
      );
443         QuESTAssert(numControlQubits >= 0 && numControlQubits < multiQubit.
      numQubits, 4, __func__);
444         QuESTAssert(validateMatrixIsUnitary(u), 5, __func__);
445          
446         long long int mask=0;
447         for (int i=0; i<numControlQubits; i++) mask = mask | (1LL<<controlQubits[
      i]);
448         QuESTAssert(mask >=0 && mask <= (1LL<<multiQubit.numQubits)-1, 2, __func_
      _);
449         QuESTAssert((mask & (1LL<<rotQubit)) != (1LL<<rotQubit), 3, __func__);
450         
451         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
452         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
453         Complex rot1, rot2;
454 
455         // rank's chunk is in upper half of block 
456         int rankIsUpper;
457         int pairRank; // rank of corresponding chunk
458 
459         if (useLocalDataOnly){
460                 // all values required to update state vector lie in this rank
461                 multiControlledUnitaryLocal(multiQubit, rotQubit, mask, u);
462         } else {
463                 // need to get corresponding chunk of state vector from other ran
      k
464                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
465                 getRotAngleFromUnitaryMatrix(rankIsUpper, &rot1, &rot2, u);
466                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, rotQubit);
467                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
468                 // get corresponding values from my pair
469                 exchangeStateVectors(multiQubit, pairRank);
470                 
471                 // this rank's values are either in the upper of lower half of th
      e block. send values to multiControlledUnitaryDistributed
472                 // in the correct order
473                 if (rankIsUpper){
474                         multiControlledUnitaryDistributed(multiQubit,rotQubit,mas
      k,rot1,rot2,
475                                 multiQubit.stateVec, //upper
476                                 multiQubit.pairStateVec, //lower
477                                 multiQubit.stateVec); //output
478                 } else {
479                         multiControlledUnitaryDistributed(multiQubit,rotQubit,mas
      k,rot1,rot2,
480                                 multiQubit.pairStateVec, //upper
481                                 multiQubit.stateVec, //lower
482                                 multiQubit.stateVec); //output
483                 }
484         }
485 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ae275b94c1a483dda43bf4ec947635605}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!phaseGate@{phaseGate}}
\index{phaseGate@{phaseGate}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{phaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__env__mpi_8c_ae275b94c1a483dda43bf4ec947635605}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em type}]the type of phase gate to apply -\/-\/ one of \{SIGMA\_\-Z, S\_\-GATE, T\_\-GATE\} \end{DoxyParams}


Definition at line 583 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, phaseGateDistributed(), phaseGateLocal(), and QuESTAssert().


\begin{DoxyCode}
584 {
585         QuESTAssert(rotQubit >= 0 && rotQubit < multiQubit.numQubits, 1, __func__
      );
586 
587         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
588         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
589 
590         // rank's chunk is in upper half of block 
591         int rankIsUpper;
592 
593         if (useLocalDataOnly){
594                 phaseGateLocal(multiQubit, rotQubit, type);
595         } else {
596                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
597                 if (!rankIsUpper) phaseGateDistributed(multiQubit, rotQubit, type
      );
598         }
599 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!QuESTAssert@{QuESTAssert}}
\index{QuESTAssert@{QuESTAssert}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{QuESTAssert}]{\setlength{\rightskip}{0pt plus 5cm}void QuESTAssert (int {\em isValid}, \/  int {\em errorCode}, \/  const char $\ast$ {\em func})}\hfill}
\label{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}


Definition at line 712 of file qubits\_\-env\_\-mpi.c.

References exitWithError().


\begin{DoxyCode}
712                                                               {
713     if (!isValid) exitWithError(errorCode, func);
714 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!reportNodeList@{reportNodeList}}
\index{reportNodeList@{reportNodeList}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{reportNodeList}]{\setlength{\rightskip}{0pt plus 5cm}void reportNodeList ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}


Report a list of CPU hostnames and the rank that is running on each if running with MPI enabled and an error message otherwise. For debugging purposes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 78 of file qubits\_\-env\_\-mpi.c.

References QuESTEnv::rank.


\begin{DoxyCode}
78                                  {
79         char hostName[256];
80         gethostname(hostName, 255);
81         printf("hostname on rank %d: %s\n", env.rank, hostName);
82 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!reportQuESTEnv@{reportQuESTEnv}}
\index{reportQuESTEnv@{reportQuESTEnv}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{reportQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void reportQuESTEnv ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}


Report information about the QuEST environment. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 63 of file qubits\_\-env\_\-mpi.c.

References QuESTEnv::numRanks, QuESTEnv::rank, and REAL.

Referenced by main().


\begin{DoxyCode}
63                                  {
64         if (env.rank==0){
65                 printf("EXECUTION ENVIRONMENT:\n"); 
66                 printf("Running distributed (MPI) version\n");
67                 printf("Number of ranks is %d\n", env.numRanks);
68 # ifdef _OPENMP
69                 printf("OpenMP enabled\n");
70                 printf("Number of threads available is %d\n", omp_get_max_threads
      ());
71 # else
72                 printf("OpenMP disabled\n");
73 # endif 
74                 printf("Precision: size of REAL is %ld bytes\n", sizeof(REAL));
75         }
76 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_acda82bebb0a62f419eec9c1e0575daad}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!sigmaX@{sigmaX}}
\index{sigmaX@{sigmaX}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{sigmaX}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaX ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit})}\hfill}
\label{qubits__env__mpi_8c_acda82bebb0a62f419eec9c1e0575daad}


Rotate a single qubit by \{\{0,1\},\{1,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \end{DoxyParams}


Definition at line 486 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), sigmaXDistributed(), sigmaXLocal(), and MultiQubit::stateVec.

Referenced by test\_\-sigmaX().


\begin{DoxyCode}
487 {
488         QuESTAssert(rotQubit >= 0 && rotQubit < multiQubit.numQubits, 1, __func__
      );
489 
490         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
491         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
492 
493         // rank's chunk is in upper half of block 
494         int rankIsUpper;
495         int pairRank; // rank of corresponding chunk
496 
497         if (useLocalDataOnly){
498                 // all values required to update state vector lie in this rank
499                 sigmaXLocal(multiQubit, rotQubit);
500         } else {
501                 // need to get corresponding chunk of state vector from other ran
      k
502                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
503                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, rotQubit);
504                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
505                 // get corresponding values from my pair
506                 exchangeStateVectors(multiQubit, pairRank);
507                 // this rank's values are either in the upper of lower half of th
      e block. sigmaX just replaces
508                 // this rank's values with pair values
509                 sigmaXDistributed(multiQubit, rotQubit,
510                         multiQubit.pairStateVec, // in
511                         multiQubit.stateVec); // out
512         }
513 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a7b022c75cef77be046bd5d61e38a581e}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!sigmaY@{sigmaY}}
\index{sigmaY@{sigmaY}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{sigmaY}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaY ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit})}\hfill}
\label{qubits__env__mpi_8c_a7b022c75cef77be046bd5d61e38a581e}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$ and apply a phase of -\/i or i. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \end{DoxyParams}


fix -\/-\/ put duplicate code (sigmaX, sigmaY) in seperate function 

Definition at line 552 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), sigmaYDistributed(), sigmaYLocal(), and MultiQubit::stateVec.

Referenced by test\_\-sigmaY().


\begin{DoxyCode}
553 {
554         QuESTAssert(rotQubit >= 0 && rotQubit < multiQubit.numQubits, 1, __func__
      );
555 
556         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
557         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
558 
559         // rank's chunk is in upper half of block 
560         int rankIsUpper;
561         int pairRank; // rank of corresponding chunk
562 
563         if (useLocalDataOnly){
564                 // all values required to update state vector lie in this rank
565                 sigmaYLocal(multiQubit, rotQubit);
566         } else {
568                 // need to get corresponding chunk of state vector from other ran
      k
569                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
570                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, rotQubit);
571                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
572                 // get corresponding values from my pair
573                 exchangeStateVectors(multiQubit, pairRank);
574                 // this rank's values are either in the upper of lower half of th
      e block. sigmaX just replaces
575                 // this rank's values with pair values
576                 sigmaYDistributed(multiQubit,rotQubit,
577                         multiQubit.pairStateVec, // in
578                         multiQubit.stateVec, // out
579                         rankIsUpper);
580         }
581 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!syncQuESTEnv@{syncQuESTEnv}}
\index{syncQuESTEnv@{syncQuESTEnv}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{syncQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void syncQuESTEnv ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}


Guarantees that all code up to the given point has been executed on all nodes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 46 of file qubits\_\-env\_\-mpi.c.

Referenced by initializeStateFromSingleFile(), main(), reportStateToScreen(), and test\_\-controlledNot().


\begin{DoxyCode}
46                                {
47         MPI_Barrier(MPI_COMM_WORLD);
48 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ac7e38d768a1bd79019f88cc1e6295092}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!syncQuESTSuccess@{syncQuESTSuccess}}
\index{syncQuESTSuccess@{syncQuESTSuccess}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{syncQuESTSuccess}]{\setlength{\rightskip}{0pt plus 5cm}int syncQuESTSuccess (int {\em successCode})}\hfill}
\label{qubits__env__mpi_8c_ac7e38d768a1bd79019f88cc1e6295092}


Performs a logical AND on all successCodes held by all processes. If any one process has a zero successCode all processes will return a zero success code. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \item[\mbox{$\leftarrow$} {\em successCode}]1 if process task succeeded, 0 if process task failed \end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if all processes succeeded, 0 if any one process failed 
\end{DoxyReturn}


Definition at line 50 of file qubits\_\-env\_\-mpi.c.

Referenced by main().


\begin{DoxyCode}
50                                      {
51         int totalSuccess;
52         MPI_Allreduce(&successCode, &totalSuccess, 1, MPI_INT, MPI_LAND, MPI_COMM
      _WORLD);
53         return totalSuccess;
54 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ae74806cf36513b6d8447439a5bc1d615}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!unitary@{unitary}}
\index{unitary@{unitary}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{unitary}]{\setlength{\rightskip}{0pt plus 5cm}void unitary ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__env__mpi_8c_ae74806cf36513b6d8447439a5bc1d615}


Definition at line 311 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), getRotAngleFromUnitaryMatrix(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, unitaryDistributed(), unitaryLocal(), and validateMatrixIsUnitary().

Referenced by test\_\-unitary().


\begin{DoxyCode}
312 {
313         QuESTAssert(rotQubit >= 0 && rotQubit < multiQubit.numQubits, 1, __func__
      );
314         QuESTAssert(validateMatrixIsUnitary(u), 5, __func__);
315 
316         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
317         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
318         Complex rot1, rot2;
319 
320         // rank's chunk is in upper half of block 
321         int rankIsUpper;
322         int pairRank; // rank of corresponding chunk
323 
324         if (useLocalDataOnly){
325                 // all values required to update state vector lie in this rank
326                 unitaryLocal(multiQubit, rotQubit, u);
327         } else {
328                 // need to get corresponding chunk of state vector from other ran
      k
329                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
330                 getRotAngleFromUnitaryMatrix(rankIsUpper, &rot1, &rot2, u);
331                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, rotQubit);
332                 // get corresponding values from my pair
333                         exchangeStateVectors(multiQubit, pairRank);
334 
335                 // this rank's values are either in the upper of lower half of th
      e block. 
336                 // send values to compactUnitaryDistributed in the correct order
337                 if (rankIsUpper){
338                         unitaryDistributed(multiQubit,rotQubit,rot1,rot2,
339                                 multiQubit.stateVec, //upper
340                                 multiQubit.pairStateVec, //lower
341                                 multiQubit.stateVec); //output
342                 } else {
343                         unitaryDistributed(multiQubit,rotQubit,rot1,rot2,
344                                 multiQubit.pairStateVec, //upper
345                                 multiQubit.stateVec, //lower
346                                 multiQubit.stateVec); //output
347                 }
348         }
349 
350 
351 }
\end{DoxyCode}
