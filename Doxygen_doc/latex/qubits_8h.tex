\hypertarget{qubits_8h}{
\subsection{qubits.h File Reference}
\label{qubits_8h}\index{qubits.h@{qubits.h}}
}


Structs and specifications for functions that can be used from any environment (local, MPI).  
\subsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structComplexArray}{ComplexArray}
\begin{DoxyCompactList}\small\item\em Represents an array of complex numbers grouped into an array of real components and an array of coressponding complex components. \item\end{DoxyCompactList}\item 
struct \hyperlink{structComplex}{Complex}
\begin{DoxyCompactList}\small\item\em Represents one complex number. \item\end{DoxyCompactList}\item 
struct \hyperlink{structMultiQubit}{MultiQubit}
\begin{DoxyCompactList}\small\item\em Represents a system of qubits. \item\end{DoxyCompactList}\item 
struct \hyperlink{structQUESTEnv}{QUESTEnv}
\begin{DoxyCompactList}\small\item\em Information about the environment the program is running in. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{qubits_8h_ae729f311efd2a426ce5161df3e017a16}{createMultiQubit} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit, int numQubits, \hyperlink{structQUESTEnv}{QUESTEnv} env)
\item 
void \hyperlink{qubits_8h_ab796aea79288b974f63474db650be878}{destroyMultiQubit} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, \hyperlink{structQUESTEnv}{QUESTEnv} env)
\item 
void \hyperlink{qubits_8h_a96f4de9ce7fefc7680a44d601fc3d894}{reportState} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\item 
void \hyperlink{qubits_8h_a492d10377278f685c7a1fabc3ee60623}{initStateVec} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes for a set of qubits to the zero state: $|$000...00$>$. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_acb059cbcb8c7910a5fc43d21da4f5dea}{rotateQubitLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a6ff67d25363f39fd57a4e76621a4bfd5}{rotateQubitDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
double \hyperlink{qubits_8h_a1c0a25823add0bd9f925a9164dc21870}{findProbabilityOfZeroLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state. \item\end{DoxyCompactList}\item 
double \hyperlink{qubits_8h_a2d302738d123129a388edf81b845fd89}{findProbabilityOfZeroDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state. \item\end{DoxyCompactList}\item 
int \hyperlink{qubits_8h_a420b30092dc60ff17188e23361d547a5}{extractBit} (const int locationOfBitFromRight, const long long int theEncodedNumber)
\item 
void \hyperlink{qubits_8h_a2cc0021ae64e2264e2aab4bdb204599e}{controlPhaseGate} (const int numQubits, const int idQubit1, const int idQubit2, double $\ast$restrict stateVecReal, double $\ast$restrict stateVecImag)
\begin{DoxyCompactList}\small\item\em Implement the control phase (the two qubit phase gate). \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_ae86c95cfe7c7953d6c821c53f2ea8d05}{quadCPhaseGate} (const int numQubits, const int idQubit1, const int idQubit2, const int idQubit3, const int idQubit4, double $\ast$restrict stateVecReal, double $\ast$restrict stateVecImag)
\item 
double \hyperlink{qubits_8h_a1048595256ae43d4fae6ced562f450f0}{measureInZero} (const int numQubits, const int measureQubit, double $\ast$restrict stateVecReal, double $\ast$restrict stateVecImag)
\item 
double \hyperlink{qubits_8h_ac0a6831f57a515c899796c9fed84012d}{filterOut111} (const int numQubits, const int idQubit1, const int idQubit2, const int idQubit3, double $\ast$restrict stateVecReal, double $\ast$restrict stateVecImag)
\item 
double \hyperlink{qubits_8h_ad1c169b3b62793c032a1dd50a9d5d95f}{probOfFilterOut111} (const int numQubits, const int idQubit1, const int idQubit2, const int idQubit3, double $\ast$restrict stateVecReal, double $\ast$restrict stateVecImag)
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
Structs and specifications for functions that can be used from any environment (local, MPI). 

Definition in file \hyperlink{qubits_8h_source}{qubits.h}.

\subsubsection{Function Documentation}
\hypertarget{qubits_8h_a2cc0021ae64e2264e2aab4bdb204599e}{
\index{qubits.h@{qubits.h}!controlPhaseGate@{controlPhaseGate}}
\index{controlPhaseGate@{controlPhaseGate}!qubits.h@{qubits.h}}
\paragraph[{controlPhaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void controlPhaseGate (const int {\em numQubits}, \/  const int {\em idQubit1}, \/  const int {\em idQubit2}, \/  double $\ast$restrict {\em stateVecReal}, \/  double $\ast$restrict {\em stateVecImag})}\hfill}
\label{qubits_8h_a2cc0021ae64e2264e2aab4bdb204599e}


Implement the control phase (the two qubit phase gate). REWRITE TO USE MULTIQUBIT input: // numQubits -\/-\/ number of qubits // idQubit1, -\/-\/ specified qubits // idQubit2 // stateVecReal, -\/-\/ real/imag parts of // stateVecImag the state vector // // output: // stateVecReal, -\/-\/ real/imag parts of // stateVecImag the state vector (overwritten) // // 

Definition at line 454 of file qubits.c.

References extractBit().


\begin{DoxyCode}
456 {
457         long long int index;
458         long long int stateVecSize;
459         int bit1, bit2;
460 
461         // ---------------------------------------------------------------- //
462         //            tests                                                 //
463         // ---------------------------------------------------------------- //
464 
465         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < numQubits && idQubit
      2 < numQubits);
466 
467 
468         // ---------------------------------------------------------------- //
469         //            initialise the state to |0000..0>                     //
470         // ---------------------------------------------------------------- //
471 
472         // dimension of the state vector
473         stateVecSize = 1LL << numQubits;
474 
475 # ifdef _OPENMP
476 # pragma omp parallel for \
477         default  (none)                      \
478         shared   (stateVecSize, stateVecReal,stateVecImag ) \
479         private  (index,bit1,bit2)                     \
480         schedule (static)
481 # endif
482         for (index=0; index<stateVecSize; index++) {
483                 bit1 = extractBit (idQubit1, index);
484                 bit2 = extractBit (idQubit2, index);
485                 if (bit1 && bit2) {
486                         stateVecReal [index] = - stateVecReal [index];
487                         stateVecImag [index] = - stateVecImag [index];
488                 }
489         }
490 }
\end{DoxyCode}
\hypertarget{qubits_8h_ae729f311efd2a426ce5161df3e017a16}{
\index{qubits.h@{qubits.h}!createMultiQubit@{createMultiQubit}}
\index{createMultiQubit@{createMultiQubit}!qubits.h@{qubits.h}}
\paragraph[{createMultiQubit}]{\setlength{\rightskip}{0pt plus 5cm}void createMultiQubit ({\bf MultiQubit} $\ast$ {\em multiQubit}, \/  int {\em numQubits}, \/  {\bf QUESTEnv} {\em env})}\hfill}
\label{qubits_8h_ae729f311efd2a426ce5161df3e017a16}


Definition at line 16 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, initStateVec(), MultiQubit::numAmps, MultiQubit::numChunks, MultiQubit::numQubits, QUESTEnv::numRanks, MultiQubit::pairStateVec, QUESTEnv::rank, ComplexArray::real, and MultiQubit::stateVec.

Referenced by main().


\begin{DoxyCode}
17 {
18         long long int numAmps = 1L << numQubits;
19         long long int numAmpsPerRank = numAmps/env.numRanks;
20 
21         multiQubit->stateVec.real = malloc(numAmpsPerRank * sizeof(multiQubit->
      stateVec.real));
22         multiQubit->stateVec.imag = malloc(numAmpsPerRank * sizeof(multiQubit->
      stateVec.imag));
23         if (env.numRanks>1){
24                 multiQubit->pairStateVec.real = malloc(numAmpsPerRank * sizeof(mu
      ltiQubit->pairStateVec.real));
25                 multiQubit->pairStateVec.imag = malloc(numAmpsPerRank * sizeof(mu
      ltiQubit->pairStateVec.imag));
26         }
27 
28         if ( (!(multiQubit->stateVec.real) || !(multiQubit->stateVec.imag))
29                  && numAmpsPerRank ) {
30                 printf("Could not allocate memory!");
31                 exit (EXIT_FAILURE);
32         }
33 
34         if ( env.numRanks>1 && (!(multiQubit->pairStateVec.real) || !(multiQubit-
      >pairStateVec.imag))
35                  && numAmpsPerRank ) {
36                 printf("Could not allocate memory!");
37                 exit (EXIT_FAILURE);
38         }
39 
40         multiQubit->numQubits = numQubits;
41         multiQubit->numAmps = numAmpsPerRank;
42         multiQubit->chunkId = env.rank;
43         multiQubit->numChunks = env.numRanks;
44 
45         initStateVec(multiQubit);
46         if (env.rank==0) printf("Number of amps per rank is %ld.\n", numAmpsPerRa
      nk);
47 }
\end{DoxyCode}
\hypertarget{qubits_8h_ab796aea79288b974f63474db650be878}{
\index{qubits.h@{qubits.h}!destroyMultiQubit@{destroyMultiQubit}}
\index{destroyMultiQubit@{destroyMultiQubit}!qubits.h@{qubits.h}}
\paragraph[{destroyMultiQubit}]{\setlength{\rightskip}{0pt plus 5cm}void destroyMultiQubit ({\bf MultiQubit} {\em multiQubit}, \/  {\bf QUESTEnv} {\em env})}\hfill}
\label{qubits_8h_ab796aea79288b974f63474db650be878}


Definition at line 49 of file qubits.c.

References ComplexArray::imag, QUESTEnv::numRanks, MultiQubit::pairStateVec, ComplexArray::real, and MultiQubit::stateVec.

Referenced by main().


\begin{DoxyCode}
49                                                            {
50         free(multiQubit.stateVec.real);
51         free(multiQubit.stateVec.imag);
52         if (env.numRanks>1){
53                 free(multiQubit.pairStateVec.real);
54                 free(multiQubit.pairStateVec.imag);
55         }
56 }
\end{DoxyCode}
\hypertarget{qubits_8h_a420b30092dc60ff17188e23361d547a5}{
\index{qubits.h@{qubits.h}!extractBit@{extractBit}}
\index{extractBit@{extractBit}!qubits.h@{qubits.h}}
\paragraph[{extractBit}]{\setlength{\rightskip}{0pt plus 5cm}int extractBit (const int {\em locationOfBitFromRight}, \/  const long long int {\em theEncodedNumber})}\hfill}
\label{qubits_8h_a420b30092dc60ff17188e23361d547a5}


Definition at line 433 of file qubits.c.

Referenced by controlPhaseGate(), filterOut111(), probOfFilterOut111(), and quadCPhaseGate().


\begin{DoxyCode}
434 {
435         return (theEncodedNumber & ( 1LL << locationOfBitFromRight )) >> location
      OfBitFromRight;
436 }
\end{DoxyCode}
\hypertarget{qubits_8h_ac0a6831f57a515c899796c9fed84012d}{
\index{qubits.h@{qubits.h}!filterOut111@{filterOut111}}
\index{filterOut111@{filterOut111}!qubits.h@{qubits.h}}
\paragraph[{filterOut111}]{\setlength{\rightskip}{0pt plus 5cm}double filterOut111 (const int {\em numQubits}, \/  const int {\em idQubit1}, \/  const int {\em idQubit2}, \/  const int {\em idQubit3}, \/  double $\ast$restrict {\em stateVecReal}, \/  double $\ast$restrict {\em stateVecImag})}\hfill}
\label{qubits_8h_ac0a6831f57a515c899796c9fed84012d}


Definition at line 623 of file qubits.c.

References extractBit().


\begin{DoxyCode}
626 {
627         long long int index;
628         long long int stateVecSize;
629         int bit1, bit2, bit3;
630 
631         // ---------------------------------------------------------------- //
632         //            tests                                                 //
633         // ---------------------------------------------------------------- //
634         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < numQubits && idQubit
      2 < numQubits);
635 
636         stateVecSize = 1LL << numQubits;
637         double probOfFilter=0;
638 
639 # ifdef _OPENMP
640 # pragma omp parallel for \
641         default  (none)                      \
642         shared   (stateVecSize, stateVecReal,stateVecImag ) \
643         private  (index,bit1,bit2,bit3)                \
644         schedule (static)\
645         reduction ( +:probOfFilter )
646 # endif
647         for (index=0; index<stateVecSize; index++) {
648                 bit1 = extractBit (idQubit1, index);
649                 bit2 = extractBit (idQubit2, index);
650                 bit3 = extractBit (idQubit3, index);
651                 if (!(bit1 && bit2 && bit3)) {
652                         probOfFilter+= stateVecReal[index]*stateVecReal[index] + 
      stateVecImag[index]* stateVecImag [index];
653                 }
654         }
655         if ( probOfFilter<1e-16 ){ printf("Extremely small or negative profOfFilt
      er=%.8e; aborting! \n",probOfFilter); exit(1);}
656         double myNorm=1/sqrt(probOfFilter);
657 
658 # ifdef _OPENMP
659 # pragma omp parallel for \
660         default  (none)                      \
661         shared   (stateVecSize, stateVecReal,stateVecImag, myNorm ) \
662         private  (index,bit1,bit2,bit3)                \
663         schedule (static)
664 # endif
665         for (index=0; index<stateVecSize; index++) {
666                 bit1 = extractBit (idQubit1, index);
667                 bit2 = extractBit (idQubit2, index);
668                 bit3 = extractBit (idQubit3, index);
669                 if ((bit1 && bit2 && bit3)) {
670                         stateVecReal[index]=0;
671                         stateVecImag [index]=0;
672                 }else{
673                         stateVecReal[index] *= myNorm;
674                         stateVecImag[index] *= myNorm;
675                 }
676         }
677         return probOfFilter;
678 }
\end{DoxyCode}
\hypertarget{qubits_8h_a2d302738d123129a388edf81b845fd89}{
\index{qubits.h@{qubits.h}!findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}}
\index{findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}!qubits.h@{qubits.h}}
\paragraph[{findProbabilityOfZeroDistributed}]{\setlength{\rightskip}{0pt plus 5cm}double findProbabilityOfZeroDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits_8h_a2d302738d123129a388edf81b845fd89}


Measure the probability of a specified qubit being in the zero state. Size of regions to skip is a multiple of chunkSize.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 375 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, and MultiQubit::stateVec.

Referenced by findProbabilityOfZero().


\begin{DoxyCode}
377 {
378         // ----- measured probability
379         double   totalProbability;                                    // probabil
      ity (returned) value
380         // ----- temp variables
381         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
382         long long int numTasks=multiQubit.numAmps;
383         // (good for shared memory parallelism)
384 
385         // ---------------------------------------------------------------- //
386         //            tests                                                 //
387         // ---------------------------------------------------------------- //
388         assert (measureQubit >= 0 && measureQubit < multiQubit.numQubits);
389 
390         // ---------------------------------------------------------------- //
391         //            find probability                                      //
392         // ---------------------------------------------------------------- //
393 
394         // initialise returned value
395         totalProbability = 0.0;
396 
397         // initialise correction for kahan summation
398 
399         //
400         // --- task-based shared-memory parallel implementation
401         //
402         
403         double *stateVecReal = multiQubit.stateVec.real;
404         double *stateVecImag = multiQubit.stateVec.imag;
405 
406 # ifdef _OPENMP
407 # pragma omp parallel for \
408         shared    (numTasks,stateVecReal,stateVecImag) \
409         private   (thisTask) \
410         schedule  (static) \
411         reduction ( +:totalProbability )
412 # endif
413         for (thisTask=0; thisTask<numTasks; thisTask++) {
414                 // summation -- simple implementation
415                 totalProbability += stateVecReal[thisTask]*stateVecReal[thisTask]
      
416                         + stateVecImag[thisTask]*stateVecImag[thisTask];
417 
418                 /*
419                 // summation -- kahan correction
420                 y = stateVecReal[thisTask]*stateVecReal[thisTask]
421                 + stateVecImag[thisTask]*stateVecImag[thisTask] - c;
422                 t = totalProbability + y;
423                 c = (t - totalProbability) - y;
424                 totalProbability = t;
425                 */
426 
427         }
428 
429         return totalProbability;
430 }
\end{DoxyCode}
\hypertarget{qubits_8h_a1c0a25823add0bd9f925a9164dc21870}{
\index{qubits.h@{qubits.h}!findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}}
\index{findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}!qubits.h@{qubits.h}}
\paragraph[{findProbabilityOfZeroLocal}]{\setlength{\rightskip}{0pt plus 5cm}double findProbabilityOfZeroLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits_8h_a1c0a25823add0bd9f925a9164dc21870}


Measure the probability of a specified qubit being in the zero state. Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 289 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, and MultiQubit::stateVec.

Referenced by findProbabilityOfZero().


\begin{DoxyCode}
291 {
292         // ----- sizes
293         long long int sizeBlock,                                           // siz
      e of blocks
294         sizeHalfBlock;                                       // size of blocks ha
      lved
295         // ----- indices
296         long long int thisBlock,                                           // cur
      rent block
297              index;                                               // current inde
      x for first half block
298         // ----- measured probability
299         double   totalProbability;                                    // probabil
      ity (returned) value
300         // ----- temp variables
301         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
302         long long int numTasks=multiQubit.numAmps>>1;
303         // (good for shared memory parallelism)
304 
305         // ---------------------------------------------------------------- //
306         //            tests                                                 //
307         // ---------------------------------------------------------------- //
308         assert (measureQubit >= 0 && measureQubit < multiQubit.numQubits);
309 
310 
311         // ---------------------------------------------------------------- //
312         //            dimensions                                            //
313         // ---------------------------------------------------------------- //
314         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
315         // and then the number to skip
316         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
317 
318         // ---------------------------------------------------------------- //
319         //            find probability                                      //
320         // ---------------------------------------------------------------- //
321 
322         // initialise returned value
323         totalProbability = 0.0;
324 
325         // initialise correction for kahan summation
326         printf("sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\n",sizeHalfBlock,siz
      eBlock,numTasks);
327 
328         //
329         // --- task-based shared-memory parallel implementation
330         //
331         
332         double *stateVecReal = multiQubit.stateVec.real;
333         double *stateVecImag = multiQubit.stateVec.imag;
334 
335 # ifdef _OPENMP
336 # pragma omp parallel for \
337         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
      
338         private   (thisTask,thisBlock,index) \
339         schedule  (static) \
340         reduction ( +:totalProbability )
341 # endif
342         for (thisTask=0; thisTask<numTasks; thisTask++) {
343                 thisBlock = thisTask / sizeHalfBlock;
344                 index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
345 
346                 if (index<0){ printf("ABORTING as index=%Ld with thisBlock = %Ld 
       thisTask=%Ld \n", index,thisBlock,thisTask); exit(1);}
347 
348                 // summation -- simple implementation
349                 totalProbability += stateVecReal[index]*stateVecReal[index]
350                         + stateVecImag[index]*stateVecImag[index];
351 
352                 /*
353                 // summation -- kahan correction
354                 y = stateVecReal[index]*stateVecReal[index]
355                 + stateVecImag[index]*stateVecImag[index] - c;
356                 t = totalProbability + y;
357                 c = (t - totalProbability) - y;
358                 totalProbability = t;
359                 */
360 
361         }
362 
363         return totalProbability;
364 }
\end{DoxyCode}
\hypertarget{qubits_8h_a492d10377278f685c7a1fabc3ee60623}{
\index{qubits.h@{qubits.h}!initStateVec@{initStateVec}}
\index{initStateVec@{initStateVec}!qubits.h@{qubits.h}}
\paragraph[{initStateVec}]{\setlength{\rightskip}{0pt plus 5cm}void initStateVec ({\bf MultiQubit} $\ast$ {\em multiQubit})}\hfill}
\label{qubits_8h_a492d10377278f685c7a1fabc3ee60623}


Initialise the state vector of probability amplitudes for a set of qubits to the zero state: $|$000...00$>$. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \end{DoxyParams}


Definition at line 76 of file qubits.c.

References MultiQubit::chunkId, DEBUG, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and MultiQubit::stateVec.

Referenced by createMultiQubit(), and main().


\begin{DoxyCode}
77 {
78         long long int stateVecSize;
79         long long int index;
80 
81         // dimension of the state vector
82         stateVecSize = multiQubit->numAmps;
83 
84         if (DEBUG) printf("stateVecSize=%Ld   now performing init with only one t
      hread:\n",stateVecSize);
85 
86         // Can't use multiQubit->stateVec as a private OMP var
87         double *stateVecReal = multiQubit->stateVec.real;
88         double *stateVecImag = multiQubit->stateVec.imag;
89 
90         // initialise the state to |0000..0000>
91 # ifdef _OPENMP
92 # pragma omp parallel for \
93         default  (none) \
94         shared   (stateVecSize, stateVecReal, stateVecImag) \
95         private  (index) \
96         schedule (static)
97 # endif
98         for (index=0; index<stateVecSize; index++) {
99                 stateVecReal[index] = 0.0;
100                 stateVecImag[index] = 0.0;
101         }
102 
103         if (multiQubit->chunkId==0){
104                 // zero state |0000..0000> has probability 1
105                 stateVecReal[0] = 1.0;
106                 stateVecImag[0] = 0.0;
107         }
108 
109         if (DEBUG) printf("COMPLETED INIT\n");
110 }
\end{DoxyCode}
\hypertarget{qubits_8h_a1048595256ae43d4fae6ced562f450f0}{
\index{qubits.h@{qubits.h}!measureInZero@{measureInZero}}
\index{measureInZero@{measureInZero}!qubits.h@{qubits.h}}
\paragraph[{measureInZero}]{\setlength{\rightskip}{0pt plus 5cm}double measureInZero (const int {\em numQubits}, \/  const int {\em measureQubit}, \/  double $\ast$restrict {\em stateVecReal}, \/  double $\ast$restrict {\em stateVecImag})}\hfill}
\label{qubits_8h_a1048595256ae43d4fae6ced562f450f0}


Definition at line 534 of file qubits.c.


\begin{DoxyCode}
538 {
539         // ----- sizes
540         long long int numBlocks,                                           // num
      ber of blocks
541         sizeBlock,                                           // size of blocks
542         sizeHalfBlock;                                       // size of blocks ha
      lved
543         // ----- indices
544         long long int thisBlock,                                           // cur
      rent block
545              index;                                               // current inde
      x for first half block
546         // ----- measured probability
547         double   totalProbability, renorm;                                    // 
      probability (returned) value
548         // ----- temp variables
549         long long int thisTask,numTasks;                                   // tas
      k based approach for expose loop with small granularity
550         // (good for shared memory parallelism)
551 
552         // ---------------------------------------------------------------- //
553         //            tests                                                 //
554         // ---------------------------------------------------------------- //
555         assert (measureQubit >= 0 && measureQubit < numQubits);
556 
557 
558         // ---------------------------------------------------------------- //
559         //            dimensions                                            //
560         // ---------------------------------------------------------------- //
561         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
562         // and then the number to skip
563         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
564 
565         // ---------------------------------------------------------------- //
566         //            find probability                                      //
567         // ---------------------------------------------------------------- //
568         numTasks = 1LL << (numQubits-1);
569 
570         // initialise returned value
571         totalProbability = 0.0;
572 
573         //
574         // --- task-based shared-memory parallel implementation
575         //
576 # ifdef _OPENMP
577 # pragma omp parallel for \
578         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
      
579         private   (thisTask,thisBlock,index) \
580         schedule  (static) \
581         reduction ( +:totalProbability )
582 # endif
583         for (thisTask=0; thisTask<numTasks; thisTask++) {
584                 thisBlock = thisTask / sizeHalfBlock;
585                 index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
586 
587                 totalProbability += stateVecReal[index]*stateVecReal[index]
588                         + stateVecImag[index]*stateVecImag[index];
589         }
590         renorm=1/sqrt(totalProbability);
591 
592 
593 # ifdef _OPENMP
594 # pragma omp parallel for \
595         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
      
596         private   (thisTask,thisBlock,index) \
597         schedule  (static) \
598         reduction ( +:totalProbability )
599 # endif
600         for (thisTask=0; thisTask<numTasks; thisTask++) {
601                 thisBlock = thisTask / sizeHalfBlock;
602                 index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
603                 stateVecReal[index]=stateVecReal[index]*renorm;
604                 stateVecImag[index]=stateVecImag[index]*renorm;
605 
606                 stateVecReal[index+sizeHalfBlock]=0;
607                 stateVecImag[index+sizeHalfBlock]=0;
608         }
609 
610         //SCB this is a debugging style check. It is probably useful to leave in,
       but it could be parallelised I guess
611         //  double checkTotal=1.;
612         //  for (index=0; index<2*numTasks; index++) {
613         //      checkTotal=checkTotal-(stateVecReal[index]*stateVecReal[index] + 
      stateVecImag[index]*stateVecImag[index]);
614         //  }
615         //  if (checkTotal>0.00001){printf("Deviation of sum squared amps from un
      ity is %.16f\n",checkTotal); exit(1);}
616 
617         return totalProbability;
618 }
\end{DoxyCode}
\hypertarget{qubits_8h_ad1c169b3b62793c032a1dd50a9d5d95f}{
\index{qubits.h@{qubits.h}!probOfFilterOut111@{probOfFilterOut111}}
\index{probOfFilterOut111@{probOfFilterOut111}!qubits.h@{qubits.h}}
\paragraph[{probOfFilterOut111}]{\setlength{\rightskip}{0pt plus 5cm}double probOfFilterOut111 (const int {\em numQubits}, \/  const int {\em idQubit1}, \/  const int {\em idQubit2}, \/  const int {\em idQubit3}, \/  double $\ast$restrict {\em stateVecReal}, \/  double $\ast$restrict {\em stateVecImag})}\hfill}
\label{qubits_8h_ad1c169b3b62793c032a1dd50a9d5d95f}


Definition at line 683 of file qubits.c.

References extractBit().


\begin{DoxyCode}
686 {
687         long long int index;
688         long long int stateVecSize;
689         int bit1, bit2, bit3;
690 
691         // ---------------------------------------------------------------- //
692         //            tests                                                 //
693         // ---------------------------------------------------------------- //
694         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < numQubits && idQubit
      2 < numQubits);
695 
696         stateVecSize = 1LL << numQubits;
697         double probOfFilter=0;
698 
699 # ifdef _OPENMP
700 # pragma omp parallel for \
701         default  (none)                      \
702         shared   (stateVecSize, stateVecReal,stateVecImag ) \
703         private  (index,bit1,bit2,bit3)                \
704         schedule (static)\
705         reduction ( +:probOfFilter )
706 # endif
707         for (index=0; index<stateVecSize; index++) {
708                 bit1 = extractBit (idQubit1, index);
709                 bit2 = extractBit (idQubit2, index);
710                 bit3 = extractBit (idQubit3, index);
711                 if (!(bit1 && bit2 && bit3)) {
712                         probOfFilter+= stateVecReal[index]*stateVecReal[index] + 
      stateVecImag[index]* stateVecImag [index];
713                 }
714         }
715         return probOfFilter;
716 }
\end{DoxyCode}
\hypertarget{qubits_8h_ae86c95cfe7c7953d6c821c53f2ea8d05}{
\index{qubits.h@{qubits.h}!quadCPhaseGate@{quadCPhaseGate}}
\index{quadCPhaseGate@{quadCPhaseGate}!qubits.h@{qubits.h}}
\paragraph[{quadCPhaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void quadCPhaseGate (const int {\em numQubits}, \/  const int {\em idQubit1}, \/  const int {\em idQubit2}, \/  const int {\em idQubit3}, \/  const int {\em idQubit4}, \/  double $\ast$restrict {\em stateVecReal}, \/  double $\ast$restrict {\em stateVecImag})}\hfill}
\label{qubits_8h_ae86c95cfe7c7953d6c821c53f2ea8d05}


Definition at line 496 of file qubits.c.

References extractBit().


\begin{DoxyCode}
497 {
498         long long int index;
499         long long int stateVecSize;
500         int bit1, bit2, bit3, bit4;
501 
502         // ---------------------------------------------------------------- //
503         //            tests                                                 //
504         // ---------------------------------------------------------------- //
505         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < numQubits && idQubit
      2 < numQubits);
506 
507         stateVecSize = 1LL << numQubits;
508 
509 # ifdef _OPENMP
510 # pragma omp parallel for \
511         default  (none)                      \
512         shared   (stateVecSize, stateVecReal,stateVecImag ) \
513         private  (index,bit1,bit2,bit3,bit4)                   \
514         schedule (static)
515 # endif
516         for (index=0; index<stateVecSize; index++) {
517                 bit1 = extractBit (idQubit1, index);
518                 bit2 = extractBit (idQubit2, index);
519                 bit3 = extractBit (idQubit3, index);
520                 bit4 = extractBit (idQubit4, index);
521                 if (bit1 && bit2 && bit3 && bit4) {
522                         stateVecReal [index] = - stateVecReal [index];
523                         stateVecImag [index] = - stateVecImag [index];
524                 }
525         }
526 }
\end{DoxyCode}
\hypertarget{qubits_8h_a96f4de9ce7fefc7680a44d601fc3d894}{
\index{qubits.h@{qubits.h}!reportState@{reportState}}
\index{reportState@{reportState}!qubits.h@{qubits.h}}
\paragraph[{reportState}]{\setlength{\rightskip}{0pt plus 5cm}void reportState ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits_8h_a96f4de9ce7fefc7680a44d601fc3d894}


Definition at line 58 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and MultiQubit::stateVec.

Referenced by main().


\begin{DoxyCode}
58                                        {
59         FILE *state;
60         char filename[100];
61         long long int index;
62         sprintf(filename, "state_rank_%d.csv", multiQubit.chunkId);
63         state = fopen(filename, "w");
64         if (multiQubit.chunkId==0) fprintf(state, "real, imag\n");
65 
66         for(index=0; index<multiQubit.numAmps; index++){
67                 fprintf(state, "%.12f, %.12f\n", multiQubit.stateVec.real[index],
       multiQubit.stateVec.imag[index]);
68         }
69         fclose(state);
70 }
\end{DoxyCode}
\hypertarget{qubits_8h_a6ff67d25363f39fd57a4e76621a4bfd5}{
\index{qubits.h@{qubits.h}!rotateQubitDistributed@{rotateQubitDistributed}}
\index{rotateQubitDistributed@{rotateQubitDistributed}!qubits.h@{qubits.h}}
\paragraph[{rotateQubitDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void rotateQubitDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8h_a6ff67d25363f39fd57a4e76621a4bfd5}


Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 224 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, MultiQubit::numQubits, ComplexArray::real, and Complex::real.

Referenced by rotateQubit().


\begin{DoxyCode}
229 {
230         // ----- temp variables
231         double   stateRealUp,stateRealLo,                             // storage 
      for previous state values
232         stateImagUp,stateImagLo;                             // (used in updates)
      
233         // ----- temp variables
234         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
235         const long long int numTasks=multiQubit.numAmps;
236 
237         // (good for shared memory parallelism)
238 
239         // ---------------------------------------------------------------- //
240         //            tests                                                 //
241         // ---------------------------------------------------------------- //
242         assert (rotQubit >= 0 && rotQubit < multiQubit.numQubits);
243 
244         // ---------------------------------------------------------------- //
245         //            rotate                                                //
246         // ---------------------------------------------------------------- //
247 
248         //
249         // --- task-based shared-memory parallel implementation
250         //
251         double rot1Real=rot1.real, rot1Imag=rot1.imag;
252         double rot2Real=rot2.real, rot2Imag=rot2.imag;
253         double *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
254         double *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
255         double *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
256 # pragma omp parallel \
257         default  (none) \
258         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
259                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
260         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
261         {
262 # pragma omp for \
263                 schedule (static)
264                 for (thisTask=0; thisTask<numTasks; thisTask++) {
265                         // store current state vector values in temp variables
266                         stateRealUp = stateVecRealUp[thisTask];
267                         stateImagUp = stateVecImagUp[thisTask];
268 
269                         stateRealLo = stateVecRealLo[thisTask];
270                         stateImagLo = stateVecImagLo[thisTask];
271 
272                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
273                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
274                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
275                 } // end for loop
276         }
277 } // end of function definition
\end{DoxyCode}
\hypertarget{qubits_8h_acb059cbcb8c7910a5fc43d21da4f5dea}{
\index{qubits.h@{qubits.h}!rotateQubitLocal@{rotateQubitLocal}}
\index{rotateQubitLocal@{rotateQubitLocal}!qubits.h@{qubits.h}}
\paragraph[{rotateQubitLocal}]{\setlength{\rightskip}{0pt plus 5cm}void rotateQubitLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits_8h_acb059cbcb8c7910a5fc43d21da4f5dea}


Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. alphaRe = cos(angle1) $\ast$ cos(angle2) \par
 alphaIm = cos(angle1) $\ast$ sin(angle2) \par
 betaRe = sin(angle1) $\ast$ cos(angle3) \par
 betaIm = sin(angle1) $\ast$ sin(angle3) \par


\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 126 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, Complex::real, ComplexArray::real, and MultiQubit::stateVec.

Referenced by rotateQubit().


\begin{DoxyCode}
127 {
128         // ----- sizes
129         long long int sizeBlock,                                           // siz
      e of blocks
130         sizeHalfBlock;                                       // size of blocks ha
      lved
131         // ----- indices
132         long long int thisBlock,                                           // cur
      rent block
133              indexUp,indexLo;                                     // current inde
      x and corresponding index in lower half block
134 
135         // ----- temp variables
136         double   stateRealUp,stateRealLo,                             // storage 
      for previous state values
137                  stateImagUp,stateImagLo;                             // (used in
       updates)
138         // ----- temp variables
139         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
140         const long long int numTasks=multiQubit.numAmps>>1;
141         // (good for shared memory parallelism)
142 
143 
144         // ---------------------------------------------------------------- //
145         //            tests                                                 //
146         // ---------------------------------------------------------------- //
147         assert (rotQubit >= 0 && rotQubit < multiQubit.numQubits);
148 
149 
150         // ---------------------------------------------------------------- //
151         //            dimensions                                            //
152         // ---------------------------------------------------------------- //
153         sizeHalfBlock = 1LL << rotQubit;                               // size of
       blocks halved
154         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks
155 
156 
157         // ---------------------------------------------------------------- //
158         //            rotate                                                //
159         // ---------------------------------------------------------------- //
160 
161         //
162         // --- task-based shared-memory parallel implementation
163         //
164         
165         // Can't use multiQubit.stateVec as a private OMP var
166         double *stateVecReal = multiQubit.stateVec.real;
167         double *stateVecImag = multiQubit.stateVec.imag;
168         double alphaImag=alpha.imag, alphaReal=alpha.real;
169         double betaImag=beta.imag, betaReal=beta.real;
170 
171 # ifdef _OPENMP
172 # pragma omp parallel \
173         default  (none) \
174         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
175         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
176 # endif
177         {
178 # ifdef _OPENMP
179 # pragma omp for \
180                 schedule (static)
181 # endif
182                 for (thisTask=0; thisTask<numTasks; thisTask++) {
183 
184                         thisBlock   = thisTask / sizeHalfBlock;
185                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
186                         indexLo     = indexUp + sizeHalfBlock;
187 
188                         // store current state vector values in temp variables
189                         stateRealUp = stateVecReal[indexUp];
190                         stateImagUp = stateVecImag[indexUp];
191 
192                         stateRealLo = stateVecReal[indexLo];
193                         stateImagLo = stateVecImag[indexLo];
194 
195                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
196                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag
      *stateImagUp - betaReal*stateRealLo - betaImag*stateImagLo;
197                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag
      *stateRealUp - betaReal*stateImagLo + betaImag*stateRealLo;
198 
199                         // state[indexLo] = beta  * state[indexUp] + conj(alpha) 
      * state[indexLo]
200                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*s
      tateImagUp + alphaReal*stateRealLo + alphaImag*stateImagLo;
201                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*s
      tateRealUp + alphaReal*stateImagLo - alphaImag*stateRealLo;
202                 } // end for loop
203         }
204 
205 } // end of function definition
\end{DoxyCode}
