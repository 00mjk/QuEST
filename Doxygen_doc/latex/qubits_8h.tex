\hypertarget{qubits_8h}{
\subsection{qubits.h File Reference}
\label{qubits_8h}\index{qubits.h@{qubits.h}}
}


The QuEST library API and objects.  
{\ttfamily \#include \char`\"{}precision.h\char`\"{}}\par
\subsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structComplexArray}{ComplexArray}
\begin{DoxyCompactList}\small\item\em Represents an array of complex numbers grouped into an array of real components and an array of coressponding complex components. \item\end{DoxyCompactList}\item 
struct \hyperlink{structComplex}{Complex}
\begin{DoxyCompactList}\small\item\em Represents one complex number. \item\end{DoxyCompactList}\item 
struct \hyperlink{structComplexMatrix2}{ComplexMatrix2}
\item 
struct \hyperlink{structVector}{Vector}
\item 
struct \hyperlink{structMultiQubit}{MultiQubit}
\begin{DoxyCompactList}\small\item\em Represents a system of qubits. \item\end{DoxyCompactList}\item 
struct \hyperlink{structQuESTEnv}{QuESTEnv}
\begin{DoxyCompactList}\small\item\em Information about the environment the program is running in. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} \{ \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{SIGMA\_\-Z} = 0, 
\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{S\_\-GATE} = 1, 
\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{T\_\-GATE} = 2
 \}
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{qubits_8h_a9c02591bc64c2918503afa231d90d83f}{createMultiQubit} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit, int numQubits, \hyperlink{structQuESTEnv}{QuESTEnv} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Create a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_ae5d6acc322314d7a3d8a2eccf00d3b19}{destroyMultiQubit} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, \hyperlink{structQuESTEnv}{QuESTEnv} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Deallocate a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits Free memory allocated to state vector of probability amplitudes, including temporary vector for values copied from another chunk if running the distributed version. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a96f4de9ce7fefc7680a44d601fc3d894}{reportState} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Print the current state vector of probability amplitudes for a set of qubits to file. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a842d6884e063a5865a2232cba56b65ac}{reportStateToScreen} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, \hyperlink{structQuESTEnv}{QuESTEnv} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env}, int reportRank)
\begin{DoxyCompactList}\small\item\em Print the current state vector of probability amplitudes for a set of qubits to standard out. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}{reportMultiQubitParams} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Report metainformation about a set of qubits: number of qubits, number of probability amplitudes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_acb5b2eff794339090004d29f02a70d9a}{initStateZero} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes for a set of qubits to the zero state: $|$000...00$>$. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a43bcb279fc9717fbd06a19cdef48b9d8}{initStatePlus} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes for a set of qubits to an equal real superposition of all amplitudes: $|$+++. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_afc1835c6b43b6e59ce7df7b13f274fc7}{multiControlledPhaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int $\ast$controlQubits, int numControlQubits)
\begin{DoxyCompactList}\small\item\em The multiple qubit control phase gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a11a96159191cbf1b01a1080e7f045aac}{controlledPhaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int idQubit1, const int idQubit2)
\begin{DoxyCompactList}\small\item\em The control phase (the two qubit phase gate). \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_aebaab86326779de55d335cfea3efde8f}{sigmaZ} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{\{0,-\/1\}\} -\/-\/ apply a phase of -\/1 to $|$1$>$. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_adda6c47876a7676488ed0565a19eaa65}{sGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits_8h_af764ea63a2e870098f4e1ce08562942e}{tGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits_8h_ad84a3ce68d1ca02b4e3f741ea45b6054}{initQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} $\ast$\hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Initialize QuEST environment. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_abd4bc926cd3f9b65610bb228d0c59fe0}{closeQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Close QuEST environment. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{syncQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Guarantees that all code up to the given point has been executed on all nodes. \item\end{DoxyCompactList}\item 
int \hyperlink{qubits_8h_ac7e38d768a1bd79019f88cc1e6295092}{syncQuESTSuccess} (int successCode)
\begin{DoxyCompactList}\small\item\em Performs a logical AND on all successCodes held by all processes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_af8a14ae79c3fb2c0b5f6255cc37bebf9}{reportQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Report information about the QuEST environment. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a8f10aabf9f607f19093aee54630caa21}{getEnvironmentString} (\hyperlink{structQuESTEnv}{QuESTEnv} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env}, \hyperlink{structMultiQubit}{MultiQubit} multiQubit, char str\mbox{[}200\mbox{]})
\item 
REAL \hyperlink{qubits_8h_a317b786f577fa6bc136ea7f0ee7330a7}{getRealAmpEl} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the real component of the probability amplitude at an index in the state vector. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8h_a3615f76fd5f57008d9b74bbd10533dd0}{getImagAmpEl} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the imaginary component of the probability amplitude at an index in the state vector. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8h_a799b10447d6dbdaf960a4d3eedd22014}{getProbEl} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the probability of the state at an index in the state vector. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8h_a818a4c7cd7252d2b10b896b12fa431d3}{calcTotalProbability} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Calculate the probability of being in any state by taking the norm of the entire state vector. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a03b13dfcabd8c59b50dbdd3af44ba8b2}{compactUnitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a7a0877e33700f6bad48adb51b7b3fb67}{unitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits_8h_a6cc7fa705a2f2e6b486b49c5589d5df5}{rotateX} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit a certain angle about the x-\/axis. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_ace0d3592d38a990e81a434c4e9681500}{rotateY} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit a certain angle about the y-\/axis. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_abd621412ad30c1b034f4ce153c4afe10}{rotateZ} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit a certain angle about the z-\/axis. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_ab4812953bc457405b3aa05a4c2f64f4a}{controlledCompactUnitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a7fadb225fc385db789e844c87fcba9e1}{rotateAroundAxis} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle, \hyperlink{structVector}{Vector} unitAxis)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit a certain angle about an axis. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a8a701526263392599aa21d0d0f05d9d8}{controlledUnitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit given a control qubit Only perform the rotation for elements where the control qubit is one. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_ae395a79690283ed81106afadd7a8cd8a}{multiControlledUnitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int $\ast$controlQubits, const int numControlQubits, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit given an array of control qubits Only perform the rotation for elements where all control qubits equal 1. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a86e396e06b7d527cac20ba0108872423}{sigmaX} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a1f54d70a42403f7e1c2e2c2007332f61}{sigmaY} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$ and apply a phase of -\/i or i. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_aa09b5dd93de6df1384b8f2c0041749ab}{hadamard} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2 -\/-\/ turn a $|$0$>$ into a $|$+$>$ and a $|$1$>$ into a $|$-\/$>$. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a67576895bbc65463481a8ea24d9b1e22}{controlledNot} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$ and apply a phase of -\/i or i, only for elements when control qubit is 1. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8h_ad315c941a51bc053d39ebfa2040fd32e}{findProbabilityOfOutcome} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, int outcome)
\begin{DoxyCompactList}\small\item\em Find the probability of a specified qubit being in the zero or one state. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8h_a07418ebac70fd9ae5d051d089961631d}{collapseToOutcome} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measureQubit=0 or measureQubit=1 according to the value of outcome. \item\end{DoxyCompactList}\item 
int \hyperlink{qubits_8h_ad5774247d836267175c664cd0e451bcb}{measure} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int measureQubit)
\item 
int \hyperlink{qubits_8h_a2ac46e470c750bf93c754e06c64b0a7a}{measureWithStats} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int measureQubit, REAL $\ast$stateProb)
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
The QuEST library API and objects. 

Definition in file \hyperlink{qubits_8h_source}{qubits.h}.

\subsubsection{Enumeration Type Documentation}
\hypertarget{qubits_8h_a5739021c733cecc49647956b2f7338ea}{
\index{qubits.h@{qubits.h}!phaseGateType@{phaseGateType}}
\index{phaseGateType@{phaseGateType}!qubits.h@{qubits.h}}
\paragraph[{phaseGateType}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf phaseGateType}}\hfill}
\label{qubits_8h_a5739021c733cecc49647956b2f7338ea}
\begin{Desc}
\item[Enumerator: ]\par
\begin{description}
\index{SIGMA\_\-Z@{SIGMA\_\-Z}!qubits.h@{qubits.h}}\index{qubits.h@{qubits.h}!SIGMA\_\-Z@{SIGMA\_\-Z}}\item[{\em 
\hypertarget{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{
SIGMA\_\-Z}
\label{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}
}]\index{S\_\-GATE@{S\_\-GATE}!qubits.h@{qubits.h}}\index{qubits.h@{qubits.h}!S\_\-GATE@{S\_\-GATE}}\item[{\em 
\hypertarget{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{
S\_\-GATE}
\label{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}
}]\index{T\_\-GATE@{T\_\-GATE}!qubits.h@{qubits.h}}\index{qubits.h@{qubits.h}!T\_\-GATE@{T\_\-GATE}}\item[{\em 
\hypertarget{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{
T\_\-GATE}
\label{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}
}]\end{description}
\end{Desc}



Definition at line 66 of file qubits.h.


\begin{DoxyCode}
66 {SIGMA_Z=0, S_GATE=1, T_GATE=2};
\end{DoxyCode}


\subsubsection{Function Documentation}
\hypertarget{qubits_8h_a818a4c7cd7252d2b10b896b12fa431d3}{
\index{qubits.h@{qubits.h}!calcTotalProbability@{calcTotalProbability}}
\index{calcTotalProbability@{calcTotalProbability}!qubits.h@{qubits.h}}
\paragraph[{calcTotalProbability}]{\setlength{\rightskip}{0pt plus 5cm}REAL calcTotalProbability ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits_8h_a818a4c7cd7252d2b10b896b12fa431d3}


Calculate the probability of being in any state by taking the norm of the entire state vector. Should be equal to 1. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \end{DoxyParams}
\begin{DoxyReturn}{Returns}
total probability 
\end{DoxyReturn}


Definition at line 61 of file qubits\_\-env\_\-local.c.

References DEBUG, ComplexArray::imag, MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by test\_\-compactUnitary(), and test\_\-unitary().


\begin{DoxyCode}
61                                                 {
62   /* IJB - implemented using Kahan summation for greater accuracy at a slight flo
      ating
63      point operation overhead. For more details see https://en.wikipedia.org/wiki
      /Kahan_summation_algorithm */
64   /* Don't change the bracketing in this routine! */
65   REAL pTotal=0; 
66   REAL y, t, c;
67   long long int index;
68   long long int numAmpsPerRank = multiQubit.numAmps;
69   c = 0.0;
70   for (index=0; index<numAmpsPerRank; index++){ 
71     /* Perform pTotal+=multiQubit.stateVec.real[index]*multiQubit.stateVec.real[i
      ndex]; by Kahan */
72    // pTotal+=multiQubit.stateVec.real[index]*multiQubit.stateVec.real[index];
73     
74     y = multiQubit.stateVec.real[index]*multiQubit.stateVec.real[index] - c;
75     t = pTotal + y;
76     c = ( t - pTotal ) - y;
77     pTotal = t;
78     
79     /* Perform pTotal+=multiQubit.stateVec.imag[index]*multiQubit.stateVec.imag[i
      ndex]; by Kahan */
80     //pTotal+=multiQubit.stateVec.imag[index]*multiQubit.stateVec.imag[index];
81     
82     
83     y = multiQubit.stateVec.imag[index]*multiQubit.stateVec.imag[index] - c;
84     t = pTotal + y;
85     c = ( t - pTotal ) - y;
86     pTotal = t;
87     
88     
89   } 
90   return pTotal;
91 }
\end{DoxyCode}
\hypertarget{qubits_8h_abd4bc926cd3f9b65610bb228d0c59fe0}{
\index{qubits.h@{qubits.h}!closeQuESTEnv@{closeQuESTEnv}}
\index{closeQuESTEnv@{closeQuESTEnv}!qubits.h@{qubits.h}}
\paragraph[{closeQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void closeQuESTEnv ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8h_abd4bc926cd3f9b65610bb228d0c59fe0}


Close QuEST environment. If something needs to be done to clean up the execution environment, such as finalizing MPI when running in distributed mode, it is handled here 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 40 of file qubits\_\-env\_\-local.c.

Referenced by main().


\begin{DoxyCode}
40                                 {
41         // MPI finalize goes here in MPI version. Call this function anyway for c
      onsistency
42 }
\end{DoxyCode}
\hypertarget{qubits_8h_a07418ebac70fd9ae5d051d089961631d}{
\index{qubits.h@{qubits.h}!collapseToOutcome@{collapseToOutcome}}
\index{collapseToOutcome@{collapseToOutcome}!qubits.h@{qubits.h}}
\paragraph[{collapseToOutcome}]{\setlength{\rightskip}{0pt plus 5cm}REAL collapseToOutcome ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  int {\em outcome})}\hfill}
\label{qubits_8h_a07418ebac70fd9ae5d051d089961631d}


Update the state vector to be consistent with measuring measureQubit=0 or measureQubit=1 according to the value of outcome. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that an outcome has been measured on the qubit indicated by measureQubit (where his label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 if outcome=0 or measureQubit=1 if outcome=1. It then returns the probability of making this measurement.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em outcome}]to measure the probability of and set the state to -\/-\/ either zero or one \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being either zero or one 
\end{DoxyReturn}


Definition at line 195 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, collapseToOutcomeDistributedRenorm(), collapseToOutcomeDistributedSetZero(), collapseToOutcomeLocal(), findProbabilityOfOutcome(), halfMatrixBlockFitsInChunk(), isChunkToSkipInFindPZero(), MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), REAL, and REAL\_\-EPS.

Referenced by test\_\-collapseToOutcome().


\begin{DoxyCode}
196 {
197     QuESTAssert(measureQubit >= 0 && measureQubit < multiQubit.numQubits, 2, __fu
      nc__);
198     REAL stateProb;
199         stateProb = findProbabilityOfOutcome(multiQubit, measureQubit, outcome);
200     QuESTAssert(fabs(stateProb>REAL_EPS), 8, __func__);
201     collapseToOutcomeLocal(multiQubit, measureQubit, stateProb, outcome);
202     return stateProb;
203 }
\end{DoxyCode}
\hypertarget{qubits_8h_a03b13dfcabd8c59b50dbdd3af44ba8b2}{
\index{qubits.h@{qubits.h}!compactUnitary@{compactUnitary}}
\index{compactUnitary@{compactUnitary}!qubits.h@{qubits.h}}
\paragraph[{compactUnitary}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitary ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits_8h_a03b13dfcabd8c59b50dbdd3af44ba8b2}


Rotate a single qubit in the state vector of probability amplitudes. Given two complex numbers alpha and beta, applies the operation \par
 \mbox{[}alpha, -\/beta$\ast$ \par
 beta, alpha$\ast$\mbox{]} \par


\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}
alpha, beta must obey $|$alpha$|$$^\wedge$2 + $|$beta$|$$^\wedge$2 = 1


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 101 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), compactUnitaryDistributed(), compactUnitaryLocal(), exchangeStateVectors(), getChunkPairId(), getRotAngle(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, and validateAlphaBeta().

Referenced by rotateAroundAxis(), rotateX(), rotateY(), rotateZ(), test\_\-compactUnitary(), and test\_\-unitary().


\begin{DoxyCode}
102 {
103     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
104     QuESTAssert(validateAlphaBeta(alpha, beta), 6, __func__);
105 
106         // all values required to update state vector lie in this rank
107         compactUnitaryLocal(multiQubit, targetQubit, alpha, beta);
108 }
\end{DoxyCode}
\hypertarget{qubits_8h_ab4812953bc457405b3aa05a4c2f64f4a}{
\index{qubits.h@{qubits.h}!controlledCompactUnitary@{controlledCompactUnitary}}
\index{controlledCompactUnitary@{controlledCompactUnitary}!qubits.h@{qubits.h}}
\paragraph[{controlledCompactUnitary}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitary ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits_8h_ab4812953bc457405b3aa05a4c2f64f4a}


Rotate a single qubit in the state vector of probability amplitudes. Given two complex numbers alpha and beta and a control qubit, applies the operation: \par
 \mbox{[}alpha, -\/beta$\ast$ \par
 beta, alpha$\ast$\mbox{]} \par
 Only when the control qubit is one.

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}
alpha, beta must obey $|$alpha$|$$^\wedge$2 + $|$beta$|$$^\wedge$2 = 1


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform rotation if this qubit is 1 \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 119 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), controlledCompactUnitaryDistributed(), controlledCompactUnitaryLocal(), exchangeStateVectors(), getChunkPairId(), getRotAngle(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, and validateAlphaBeta().

Referenced by test\_\-controlledCompactUnitary(), test\_\-controlledUnitary(), and test\_\-multiControlledUnitary().


\begin{DoxyCode}
120 {
121     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
122     QuESTAssert(controlQubit >= 0 && controlQubit < multiQubit.numQubits, 2, __fu
      nc__);
123     QuESTAssert(controlQubit != targetQubit, 3, __func__);
124     QuESTAssert(validateAlphaBeta(alpha, beta), 6, __func__);
125     
126 
127         controlledCompactUnitaryLocal(multiQubit, controlQubit, targetQubit, alph
      a, beta);
128 }
\end{DoxyCode}
\hypertarget{qubits_8h_a67576895bbc65463481a8ea24d9b1e22}{
\index{qubits.h@{qubits.h}!controlledNot@{controlledNot}}
\index{controlledNot@{controlledNot}!qubits.h@{qubits.h}}
\paragraph[{controlledNot}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNot ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8h_a67576895bbc65463481a8ea24d9b1e22}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$ and apply a phase of -\/i or i, only for elements when control qubit is 1. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform sigmaX rotation if this qubit is 1 \end{DoxyParams}


Definition at line 178 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), controlledNotDistributed(), controlledNotLocal(), exchangeStateVectors(), getChunkPairId(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), and MultiQubit::stateVec.

Referenced by test\_\-controlledNot().


\begin{DoxyCode}
179 {
180     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
181     QuESTAssert(controlQubit >= 0 && controlQubit < multiQubit.numQubits, 2, __fu
      nc__);
182     QuESTAssert(controlQubit != targetQubit, 3, __func__);
183         controlledNotLocal(multiQubit, controlQubit, targetQubit);
184 }
\end{DoxyCode}
\hypertarget{qubits_8h_a11a96159191cbf1b01a1080e7f045aac}{
\index{qubits.h@{qubits.h}!controlledPhaseGate@{controlledPhaseGate}}
\index{controlledPhaseGate@{controlledPhaseGate}!qubits.h@{qubits.h}}
\paragraph[{controlledPhaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void controlledPhaseGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em idQubit1}, \/  const int {\em idQubit2})}\hfill}
\label{qubits_8h_a11a96159191cbf1b01a1080e7f045aac}


The control phase (the two qubit phase gate). For each state, if both input qubits are equal to one, multiply the amplitude of that state by -\/1. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em idQubit1,idQubit2}]specified qubits \end{DoxyParams}


Definition at line 1898 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by test\_\-controlledPhaseGate().


\begin{DoxyCode}
1899 {
1900         long long int index;
1901         long long int stateVecSize;
1902         int bit1, bit2;
1903 
1904         const long long int chunkSize=multiQubit.numAmps;
1905         const long long int chunkId=multiQubit.chunkId;
1906 
1907     QuESTAssert(idQubit1 >= 0 && idQubit1 < multiQubit.numQubits, 2, __func__);
1908     QuESTAssert(idQubit2 >= 0 && idQubit2 < multiQubit.numQubits, 1, __func__);
1909     QuESTAssert(idQubit1 != idQubit2, 3, __func__);
1910 
1911         // dimension of the state vector
1912         stateVecSize = multiQubit.numAmps;
1913         REAL *stateVecReal = multiQubit.stateVec.real;
1914         REAL *stateVecImag = multiQubit.stateVec.imag;
1915 
1916 # ifdef _OPENMP
1917 # pragma omp parallel for \
1918         default  (none)                      \
1919         shared   (stateVecSize, stateVecReal,stateVecImag ) \
1920         private  (index,bit1,bit2)                     \
1921         schedule (static)
1922 # endif
1923         for (index=0; index<stateVecSize; index++) {
1924                 bit1 = extractBit (idQubit1, index+chunkId*chunkSize);
1925                 bit2 = extractBit (idQubit2, index+chunkId*chunkSize);
1926                 if (bit1 && bit2) {
1927                         stateVecReal [index] = - stateVecReal [index];
1928                         stateVecImag [index] = - stateVecImag [index];
1929                 }
1930         }
1931 }
\end{DoxyCode}
\hypertarget{qubits_8h_a8a701526263392599aa21d0d0f05d9d8}{
\index{qubits.h@{qubits.h}!controlledUnitary@{controlledUnitary}}
\index{controlledUnitary@{controlledUnitary}!qubits.h@{qubits.h}}
\paragraph[{controlledUnitary}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitary ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8h_a8a701526263392599aa21d0d0f05d9d8}


Apply a unitary operation to a single qubit given a control qubit Only perform the rotation for elements where the control qubit is one. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform rotation if this qubit is 1 \item[\mbox{$\leftarrow$} {\em u}]unitary matrix to apply \end{DoxyParams}


Definition at line 130 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), controlledUnitaryDistributed(), controlledUnitaryLocal(), exchangeStateVectors(), getChunkPairId(), getRotAngleFromUnitaryMatrix(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, and validateMatrixIsUnitary().

Referenced by test\_\-controlledUnitary().


\begin{DoxyCode}
131 {
132     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
133     QuESTAssert(controlQubit >= 0 && controlQubit < multiQubit.numQubits, 2, __fu
      nc__);
134     QuESTAssert(controlQubit != targetQubit, 3, __func__);
135     QuESTAssert(validateMatrixIsUnitary(u), 5, __func__);
136    
137         controlledUnitaryLocal(multiQubit, controlQubit, targetQubit, u);
138 }
\end{DoxyCode}
\hypertarget{qubits_8h_a9c02591bc64c2918503afa231d90d83f}{
\index{qubits.h@{qubits.h}!createMultiQubit@{createMultiQubit}}
\index{createMultiQubit@{createMultiQubit}!qubits.h@{qubits.h}}
\paragraph[{createMultiQubit}]{\setlength{\rightskip}{0pt plus 5cm}void createMultiQubit ({\bf MultiQubit} $\ast$ {\em multiQubit}, \/  int {\em numQubits}, \/  {\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8h_a9c02591bc64c2918503afa231d90d83f}


Create a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. Allocate space for state vector of probability amplitudes, including space for temporary values to be copied from one other chunk if running the distributed version. Define properties related to the size of the set of qubits. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em numQubits}]number of qubits in the system \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}


Definition at line 41 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, MultiQubit::numQubits, QuESTEnv::numRanks, MultiQubit::pairStateVec, QuESTAssert(), QuESTEnv::rank, ComplexArray::real, and MultiQubit::stateVec.

Referenced by main(), test\_\-collapseToOutcome(), test\_\-compactUnitary(), test\_\-controlledCompactUnitary(), test\_\-controlledNot(), test\_\-controlledPhaseGate(), test\_\-controlledUnitary(), test\_\-findProbabilityOfOutcome(), test\_\-hadamard(), test\_\-initStatePlus(), test\_\-initStateZero(), test\_\-measure(), test\_\-measureWithStats(), test\_\-multiControlledPhaseGate(), test\_\-multiControlledUnitary(), test\_\-sGate(), test\_\-sigmaX(), test\_\-sigmaY(), test\_\-sigmaZ(), test\_\-tGate(), and test\_\-unitary().


\begin{DoxyCode}
42 {
43     QuESTAssert(numQubits>0, 9, __func__);
44         long long int numAmps = 1L << numQubits;
45         long long int numAmpsPerRank = numAmps/env.numRanks;
46 
47         multiQubit->stateVec.real = malloc(numAmpsPerRank * sizeof(*(multiQubit->
      stateVec.real)));
48         multiQubit->stateVec.imag = malloc(numAmpsPerRank * sizeof(*(multiQubit->
      stateVec.imag)));
49         if (env.numRanks>1){
50                 multiQubit->pairStateVec.real = malloc(numAmpsPerRank * sizeof(*(
      multiQubit->pairStateVec.real)));
51                 multiQubit->pairStateVec.imag = malloc(numAmpsPerRank * sizeof(*(
      multiQubit->pairStateVec.imag)));
52         }
53 
54         if ( (!(multiQubit->stateVec.real) || !(multiQubit->stateVec.imag))
55                  && numAmpsPerRank ) {
56                 printf("Could not allocate memory!");
57                 exit (EXIT_FAILURE);
58         }
59 
60         if ( env.numRanks>1 && (!(multiQubit->pairStateVec.real) || !(multiQubit-
      >pairStateVec.imag))
61                  && numAmpsPerRank ) {
62                 printf("Could not allocate memory!");
63                 exit (EXIT_FAILURE);
64         }
65 
66         multiQubit->numQubits = numQubits;
67         multiQubit->numAmps = numAmpsPerRank;
68         multiQubit->chunkId = env.rank;
69         multiQubit->numChunks = env.numRanks;
70 
71 }
\end{DoxyCode}
\hypertarget{qubits_8h_ae5d6acc322314d7a3d8a2eccf00d3b19}{
\index{qubits.h@{qubits.h}!destroyMultiQubit@{destroyMultiQubit}}
\index{destroyMultiQubit@{destroyMultiQubit}!qubits.h@{qubits.h}}
\paragraph[{destroyMultiQubit}]{\setlength{\rightskip}{0pt plus 5cm}void destroyMultiQubit ({\bf MultiQubit} {\em multiQubit}, \/  {\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8h_ae5d6acc322314d7a3d8a2eccf00d3b19}


Deallocate a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits Free memory allocated to state vector of probability amplitudes, including temporary vector for values copied from another chunk if running the distributed version. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object to be deallocated \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}


Definition at line 78 of file qubits.c.

References ComplexArray::imag, QuESTEnv::numRanks, MultiQubit::pairStateVec, ComplexArray::real, and MultiQubit::stateVec.

Referenced by main(), test\_\-collapseToOutcome(), test\_\-compactUnitary(), test\_\-controlledCompactUnitary(), test\_\-controlledNot(), test\_\-controlledPhaseGate(), test\_\-controlledUnitary(), test\_\-findProbabilityOfOutcome(), test\_\-hadamard(), test\_\-initStatePlus(), test\_\-initStateZero(), test\_\-measure(), test\_\-measureWithStats(), test\_\-multiControlledPhaseGate(), test\_\-multiControlledUnitary(), test\_\-sGate(), test\_\-sigmaX(), test\_\-sigmaY(), test\_\-sigmaZ(), test\_\-tGate(), and test\_\-unitary().


\begin{DoxyCode}
78                                                            {
79         free(multiQubit.stateVec.real);
80         free(multiQubit.stateVec.imag);
81         if (env.numRanks>1){
82                 free(multiQubit.pairStateVec.real);
83                 free(multiQubit.pairStateVec.imag);
84         }
85 }
\end{DoxyCode}
\hypertarget{qubits_8h_ad315c941a51bc053d39ebfa2040fd32e}{
\index{qubits.h@{qubits.h}!findProbabilityOfOutcome@{findProbabilityOfOutcome}}
\index{findProbabilityOfOutcome@{findProbabilityOfOutcome}!qubits.h@{qubits.h}}
\paragraph[{findProbabilityOfOutcome}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfOutcome ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  int {\em outcome})}\hfill}
\label{qubits_8h_ad315c941a51bc053d39ebfa2040fd32e}


Find the probability of a specified qubit being in the zero or one state. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em outcome}]to measure the probability of -\/-\/ either zero or one \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being either zero or one 
\end{DoxyReturn}


Definition at line 186 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, findProbabilityOfZeroDistributed(), findProbabilityOfZeroLocal(), halfMatrixBlockFitsInChunk(), isChunkToSkipInFindPZero(), MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), and REAL.

Referenced by collapseToOutcome(), main(), measureWithStats(), and test\_\-findProbabilityOfOutcome().


\begin{DoxyCode}
187 {
188     QuESTAssert(measureQubit >= 0 && measureQubit < multiQubit.numQubits, 2, __fu
      nc__);
189         REAL stateProb=0;
190         stateProb = findProbabilityOfZeroLocal(multiQubit, measureQubit);
191         if (outcome==1) stateProb = 1.0 - stateProb;
192         return stateProb;
193 }
\end{DoxyCode}
\hypertarget{qubits_8h_a8f10aabf9f607f19093aee54630caa21}{
\index{qubits.h@{qubits.h}!getEnvironmentString@{getEnvironmentString}}
\index{getEnvironmentString@{getEnvironmentString}!qubits.h@{qubits.h}}
\paragraph[{getEnvironmentString}]{\setlength{\rightskip}{0pt plus 5cm}void getEnvironmentString ({\bf QuESTEnv} {\em env}, \/  {\bf MultiQubit} {\em multiQubit}, \/  char {\em str}\mbox{[}200\mbox{]})}\hfill}
\label{qubits_8h_a8f10aabf9f607f19093aee54630caa21}


Definition at line 164 of file qubits.c.

References MultiQubit::numQubits, and QuESTEnv::numRanks.


\begin{DoxyCode}
164                                                                              {
165         int numThreads=1;
166 # ifdef _OPENMP
167         numThreads=omp_get_max_threads(); 
168 # endif
169         sprintf(str, "%dqubits_CPU_%dranksx%dthreads", multiQubit.numQubits, env.
      numRanks, numThreads);
170 }
\end{DoxyCode}
\hypertarget{qubits_8h_a3615f76fd5f57008d9b74bbd10533dd0}{
\index{qubits.h@{qubits.h}!getImagAmpEl@{getImagAmpEl}}
\index{getImagAmpEl@{getImagAmpEl}!qubits.h@{qubits.h}}
\paragraph[{getImagAmpEl}]{\setlength{\rightskip}{0pt plus 5cm}REAL getImagAmpEl ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})}\hfill}
\label{qubits_8h_a3615f76fd5f57008d9b74bbd10533dd0}


Get the imaginary component of the probability amplitude at an index in the state vector. For debugging purposes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \item[\mbox{$\leftarrow$} {\em index}]index in state vector of probability amplitudes \end{DoxyParams}
\begin{DoxyReturn}{Returns}
imaginary component at that index 
\end{DoxyReturn}


Definition at line 97 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, getChunkIdFromIndex(), ComplexArray::imag, MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, REAL, and MultiQubit::stateVec.

Referenced by getProbEl().


\begin{DoxyCode}
97                                                              {
98         return multiQubit.stateVec.imag[index];
99 }
\end{DoxyCode}
\hypertarget{qubits_8h_a799b10447d6dbdaf960a4d3eedd22014}{
\index{qubits.h@{qubits.h}!getProbEl@{getProbEl}}
\index{getProbEl@{getProbEl}!qubits.h@{qubits.h}}
\paragraph[{getProbEl}]{\setlength{\rightskip}{0pt plus 5cm}REAL getProbEl ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})}\hfill}
\label{qubits_8h_a799b10447d6dbdaf960a4d3eedd22014}


Get the probability of the state at an index in the state vector. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \item[\mbox{$\leftarrow$} {\em index}]index in state vector of probability amplitudes \end{DoxyParams}
\begin{DoxyReturn}{Returns}
realEl$\ast$realEl + imagEl$\ast$imagEl
\end{DoxyReturn}
Get the probability of the state at an index in the state vector.

For debugging purposes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \item[\mbox{$\leftarrow$} {\em index}]index in state vector of probability amplitudes \end{DoxyParams}
\begin{DoxyReturn}{Returns}
real component $\ast$ real component + imag component $\ast$ imag component 
\end{DoxyReturn}


Definition at line 2152 of file qubits.c.

References getImagAmpEl(), getRealAmpEl(), and REAL.


\begin{DoxyCode}
2152                                                           {
2153         REAL real;
2154         REAL imag;
2155         real = getRealAmpEl(multiQubit, index);
2156         imag = getImagAmpEl(multiQubit, index);
2157         return real*real + imag*imag;
2158 }
\end{DoxyCode}
\hypertarget{qubits_8h_a317b786f577fa6bc136ea7f0ee7330a7}{
\index{qubits.h@{qubits.h}!getRealAmpEl@{getRealAmpEl}}
\index{getRealAmpEl@{getRealAmpEl}!qubits.h@{qubits.h}}
\paragraph[{getRealAmpEl}]{\setlength{\rightskip}{0pt plus 5cm}REAL getRealAmpEl ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})}\hfill}
\label{qubits_8h_a317b786f577fa6bc136ea7f0ee7330a7}


Get the real component of the probability amplitude at an index in the state vector. For debugging purposes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \item[\mbox{$\leftarrow$} {\em index}]index in state vector of probability amplitudes \end{DoxyParams}
\begin{DoxyReturn}{Returns}
real component at that index 
\end{DoxyReturn}


Definition at line 93 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, getChunkIdFromIndex(), MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, REAL, ComplexArray::real, and MultiQubit::stateVec.

Referenced by getProbEl().


\begin{DoxyCode}
93                                                              {
94         return multiQubit.stateVec.real[index];
95 }
\end{DoxyCode}
\hypertarget{qubits_8h_aa09b5dd93de6df1384b8f2c0041749ab}{
\index{qubits.h@{qubits.h}!hadamard@{hadamard}}
\index{hadamard@{hadamard}!qubits.h@{qubits.h}}
\paragraph[{hadamard}]{\setlength{\rightskip}{0pt plus 5cm}void hadamard ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8h_aa09b5dd93de6df1384b8f2c0041749ab}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2 -\/-\/ turn a $|$0$>$ into a $|$+$>$ and a $|$1$>$ into a $|$-\/$>$. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \end{DoxyParams}


Definition at line 172 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), hadamardDistributed(), hadamardLocal(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), and MultiQubit::stateVec.

Referenced by test\_\-hadamard().


\begin{DoxyCode}
173 {
174     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
175         hadamardLocal(multiQubit, targetQubit);
176 }
\end{DoxyCode}
\hypertarget{qubits_8h_ad84a3ce68d1ca02b4e3f741ea45b6054}{
\index{qubits.h@{qubits.h}!initQuESTEnv@{initQuESTEnv}}
\index{initQuESTEnv@{initQuESTEnv}!qubits.h@{qubits.h}}
\paragraph[{initQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void initQuESTEnv ({\bf QuESTEnv} $\ast$ {\em env})}\hfill}
\label{qubits_8h_ad84a3ce68d1ca02b4e3f741ea45b6054}


Initialize QuEST environment. If something needs to be done to set up the execution environment, such as initializing MPI when running in distributed mode, it is handled here 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 19 of file qubits\_\-env\_\-local.c.

References DEBUG, init\_\-by\_\-array(), QuESTEnv::numRanks, and QuESTEnv::rank.

Referenced by main().


\begin{DoxyCode}
19                                 {
20         // init MPI environment
21         env->rank=0;
22         env->numRanks=1;
23 
24     // init MT random number generator with two keys -- time and pid
25     unsigned long int secs = time(NULL);
26     unsigned long int pid = getpid();
27     unsigned long int key[2];
28     key[0] = secs; key[1] = pid;
29     init_by_array(key, 2);
30 }
\end{DoxyCode}
\hypertarget{qubits_8h_a43bcb279fc9717fbd06a19cdef48b9d8}{
\index{qubits.h@{qubits.h}!initStatePlus@{initStatePlus}}
\index{initStatePlus@{initStatePlus}!qubits.h@{qubits.h}}
\paragraph[{initStatePlus}]{\setlength{\rightskip}{0pt plus 5cm}void initStatePlus ({\bf MultiQubit} $\ast$ {\em multiQubit})}\hfill}
\label{qubits_8h_a43bcb279fc9717fbd06a19cdef48b9d8}


Initialise the state vector of probability amplitudes for a set of qubits to an equal real superposition of all amplitudes: $|$+++. ..++$>$ 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \end{DoxyParams}


Definition at line 218 of file qubits.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by test\_\-collapseToOutcome(), test\_\-compactUnitary(), test\_\-findProbabilityOfOutcome(), test\_\-initStatePlus(), test\_\-measure(), test\_\-measureWithStats(), and test\_\-unitary().


\begin{DoxyCode}
219 {
220         long long int chunkSize, stateVecSize;
221         long long int index;
222 
223         // dimension of the state vector
224         chunkSize = multiQubit->numAmps;
225         stateVecSize = chunkSize*multiQubit->numChunks;
226         REAL normFactor = 1.0/sqrt(stateVecSize);
227 
228         // Can't use multiQubit->stateVec as a private OMP var
229         REAL *stateVecReal = multiQubit->stateVec.real;
230         REAL *stateVecImag = multiQubit->stateVec.imag;
231 
232         // initialise the state to |0000..0000>
233 # ifdef _OPENMP
234 # pragma omp parallel \
235         default  (none) \
236         shared   (chunkSize, stateVecReal, stateVecImag, normFactor) \
237         private  (index) 
238 # endif
239         {
240 # ifdef _OPENMP
241                 # pragma omp for schedule (static)
242 # endif
243                 for (index=0; index<chunkSize; index++) {
244                         stateVecReal[index] = normFactor;
245                         stateVecImag[index] = 0.0;
246                 }
247         }
248         if (DEBUG) printf("COMPLETED INIT\n");
249 }
\end{DoxyCode}
\hypertarget{qubits_8h_acb5b2eff794339090004d29f02a70d9a}{
\index{qubits.h@{qubits.h}!initStateZero@{initStateZero}}
\index{initStateZero@{initStateZero}!qubits.h@{qubits.h}}
\paragraph[{initStateZero}]{\setlength{\rightskip}{0pt plus 5cm}void initStateZero ({\bf MultiQubit} $\ast$ {\em multiQubit})}\hfill}
\label{qubits_8h_acb5b2eff794339090004d29f02a70d9a}


Initialise the state vector of probability amplitudes for a set of qubits to the zero state: $|$000...00$>$. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \end{DoxyParams}


Definition at line 176 of file qubits.c.

References MultiQubit::chunkId, DEBUG, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by main(), test\_\-collapseToOutcome(), test\_\-findProbabilityOfOutcome(), test\_\-initStateZero(), test\_\-measure(), and test\_\-measureWithStats().


\begin{DoxyCode}
177 {
178         long long int stateVecSize;
179         long long int index;
180 
181         // dimension of the state vector
182         stateVecSize = multiQubit->numAmps;
183 
184         // Can't use multiQubit->stateVec as a private OMP var
185         REAL *stateVecReal = multiQubit->stateVec.real;
186         REAL *stateVecImag = multiQubit->stateVec.imag;
187 
188         // initialise the state to |0000..0000>
189 # ifdef _OPENMP
190 # pragma omp parallel \
191         default  (none) \
192         shared   (stateVecSize, stateVecReal, stateVecImag) \
193         private  (index) 
194 # endif
195         {
196 # ifdef _OPENMP
197                 # pragma omp for schedule (static)
198 # endif
199                 for (index=0; index<stateVecSize; index++) {
200                         stateVecReal[index] = 0.0;
201                         stateVecImag[index] = 0.0;
202                 }
203         }
204 
205         if (multiQubit->chunkId==0){
206                 // zero state |0000..0000> has probability 1
207                 stateVecReal[0] = 1.0;
208                 stateVecImag[0] = 0.0;
209         }
210 
211         if (DEBUG) printf("COMPLETED INIT\n");
212 }
\end{DoxyCode}
\hypertarget{qubits_8h_ad5774247d836267175c664cd0e451bcb}{
\index{qubits.h@{qubits.h}!measure@{measure}}
\index{measure@{measure}!qubits.h@{qubits.h}}
\paragraph[{measure}]{\setlength{\rightskip}{0pt plus 5cm}int measure ({\bf MultiQubit} {\em multiQubit}, \/  int {\em measureQubit})}\hfill}
\label{qubits_8h_ad5774247d836267175c664cd0e451bcb}


Definition at line 205 of file qubits\_\-env\_\-local.c.

References measureWithStats(), MultiQubit::numQubits, QuESTAssert(), and REAL.

Referenced by test\_\-measure().


\begin{DoxyCode}
205                                                     {
206     QuESTAssert(measureQubit >= 0 && measureQubit < multiQubit.numQubits, 2, __fu
      nc__);
207     REAL stateProb;
208     return measureWithStats(multiQubit, measureQubit, &stateProb);
209 }
\end{DoxyCode}
\hypertarget{qubits_8h_a2ac46e470c750bf93c754e06c64b0a7a}{
\index{qubits.h@{qubits.h}!measureWithStats@{measureWithStats}}
\index{measureWithStats@{measureWithStats}!qubits.h@{qubits.h}}
\paragraph[{measureWithStats}]{\setlength{\rightskip}{0pt plus 5cm}int measureWithStats ({\bf MultiQubit} {\em multiQubit}, \/  int {\em measureQubit}, \/  REAL $\ast$ {\em stateProb})}\hfill}
\label{qubits_8h_a2ac46e470c750bf93c754e06c64b0a7a}


Definition at line 211 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, collapseToOutcomeDistributedRenorm(), collapseToOutcomeDistributedSetZero(), collapseToOutcomeLocal(), findProbabilityOfOutcome(), genrand\_\-real1(), halfMatrixBlockFitsInChunk(), isChunkToSkipInFindPZero(), MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), REAL, and REAL\_\-EPS.

Referenced by measure(), and test\_\-measureWithStats().


\begin{DoxyCode}
211                                                                               {
212     QuESTAssert(measureQubit >= 0 && measureQubit < multiQubit.numQubits, 2, __fu
      nc__);
213 
214     int outcome;
215     // find probability of qubit being in state 1
216         REAL stateProbInternal = findProbabilityOfOutcome(multiQubit, measureQubi
      t, 1);
217 
218     // we can't collapse to a state that has a probability too close to zero
219     if (stateProbInternal<REAL_EPS) outcome=0;
220     else if (1-stateProbInternal<REAL_EPS) outcome=1;
221     else {
222         // ok. both P(0) and P(1) are large enough to resolve
223         // generate random float on [0,1]
224         float randNum = genrand_real1();
225         if (randNum<=stateProbInternal) outcome = 1;
226         else outcome = 0;
227     } 
228     if (outcome==0) stateProbInternal = 1-stateProbInternal;
229     collapseToOutcomeLocal(multiQubit, measureQubit, stateProbInternal, outcome);
      
230     *stateProb = stateProbInternal;
231     return outcome;
232 }
\end{DoxyCode}
\hypertarget{qubits_8h_afc1835c6b43b6e59ce7df7b13f274fc7}{
\index{qubits.h@{qubits.h}!multiControlledPhaseGate@{multiControlledPhaseGate}}
\index{multiControlledPhaseGate@{multiControlledPhaseGate}!qubits.h@{qubits.h}}
\paragraph[{multiControlledPhaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledPhaseGate ({\bf MultiQubit} {\em multiQubit}, \/  int $\ast$ {\em controlQubits}, \/  int {\em numControlQubits})}\hfill}
\label{qubits_8h_afc1835c6b43b6e59ce7df7b13f274fc7}


The multiple qubit control phase gate. For each state, if all input qubits are equal to one, multiply the amplitude of that state by -\/1. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em controlQubits}]array of input qubits \item[\mbox{$\leftarrow$} {\em numControlQubits}]number of input qubits \end{DoxyParams}


Definition at line 1939 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by test\_\-multiControlledPhaseGate().


\begin{DoxyCode}
1940 {
1941         long long int index;
1942         long long int stateVecSize;
1943         
1944         const long long int chunkSize=multiQubit.numAmps;
1945         const long long int chunkId=multiQubit.chunkId;
1946 
1947     QuESTAssert(numControlQubits > 0 && numControlQubits <= multiQubit.numQubits,
       4, __func__);
1948     long long int mask=0;
1949     for (int i=0; i<numControlQubits; i++) mask = mask | (1LL<<controlQubits[i]);
      
1950     QuESTAssert(mask >=0 && mask <= (1LL<<multiQubit.numQubits)-1, 2, __func__);
1951 
1952         stateVecSize = multiQubit.numAmps;
1953         REAL *stateVecReal = multiQubit.stateVec.real;
1954         REAL *stateVecImag = multiQubit.stateVec.imag;
1955 
1956 # ifdef _OPENMP
1957 # pragma omp parallel \
1958         default  (none)                      \
1959         shared   (stateVecSize, stateVecReal,stateVecImag, mask ) \
1960         private  (index)
1961 # endif
1962         {
1963 # ifdef _OPENMP
1964                 # pragma omp for schedule (static)
1965 # endif
1966                 for (index=0; index<stateVecSize; index++) {
1967                         if (mask == (mask & (index+chunkId*chunkSize)) ){
1968                                 stateVecReal [index] = - stateVecReal [index];
1969                                 stateVecImag [index] = - stateVecImag [index];
1970                         }
1971                 }
1972         }
1973 }
\end{DoxyCode}
\hypertarget{qubits_8h_ae395a79690283ed81106afadd7a8cd8a}{
\index{qubits.h@{qubits.h}!multiControlledUnitary@{multiControlledUnitary}}
\index{multiControlledUnitary@{multiControlledUnitary}!qubits.h@{qubits.h}}
\paragraph[{multiControlledUnitary}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitary ({\bf MultiQubit} {\em multiQubit}, \/  int $\ast$ {\em controlQubits}, \/  const int {\em numControlQubits}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8h_ae395a79690283ed81106afadd7a8cd8a}


Apply a unitary operation to a single qubit given an array of control qubits Only perform the rotation for elements where all control qubits equal 1. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubits}]perform rotation if all qubits in this array equal 1 \item[\mbox{$\leftarrow$} {\em numControlQubits}]number of control qubits \item[\mbox{$\leftarrow$} {\em u}]unitary matrix to apply \end{DoxyParams}


Definition at line 140 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), getRotAngleFromUnitaryMatrix(), halfMatrixBlockFitsInChunk(), multiControlledUnitaryDistributed(), multiControlledUnitaryLocal(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, and validateMatrixIsUnitary().

Referenced by test\_\-multiControlledUnitary().


\begin{DoxyCode}
141 {
142     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
143     QuESTAssert(numControlQubits > 0 && numControlQubits <= multiQubit.numQubits,
       4, __func__);
144     QuESTAssert(validateMatrixIsUnitary(u), 5, __func__);
145 
146     long long int mask=0; 
147     for (int i=0; i<numControlQubits; i++) mask = mask | (1LL<<controlQubits[i]);
      
148     QuESTAssert(mask >=0 && mask <= (1LL<<multiQubit.numQubits)-1, 2, __func__);
149     QuESTAssert((mask & (1LL<<targetQubit)) != (1LL<<targetQubit), 3, __func__);
150         
151     multiControlledUnitaryLocal(multiQubit, targetQubit, mask, u);
152 }
\end{DoxyCode}
\hypertarget{qubits_8h_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}{
\index{qubits.h@{qubits.h}!reportMultiQubitParams@{reportMultiQubitParams}}
\index{reportMultiQubitParams@{reportMultiQubitParams}!qubits.h@{qubits.h}}
\paragraph[{reportMultiQubitParams}]{\setlength{\rightskip}{0pt plus 5cm}void reportMultiQubitParams ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits_8h_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}


Report metainformation about a set of qubits: number of qubits, number of probability amplitudes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}


Definition at line 153 of file qubits.c.

References MultiQubit::chunkId, MultiQubit::numChunks, and MultiQubit::numQubits.

Referenced by main().


\begin{DoxyCode}
153                                                   {
154         long long int numAmps = 1L << multiQubit.numQubits;
155         long long int numAmpsPerRank = numAmps/multiQubit.numChunks;
156         if (multiQubit.chunkId==0){
157                 printf("QUBITS:\n");
158                 printf("Number of qubits is %d.\n", multiQubit.numQubits);
159                 printf("Number of amps is %lld.\n", numAmps);
160                 printf("Number of amps per rank is %lld.\n", numAmpsPerRank);
161         }
162 }
\end{DoxyCode}
\hypertarget{qubits_8h_af8a14ae79c3fb2c0b5f6255cc37bebf9}{
\index{qubits.h@{qubits.h}!reportQuESTEnv@{reportQuESTEnv}}
\index{reportQuESTEnv@{reportQuESTEnv}!qubits.h@{qubits.h}}
\paragraph[{reportQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void reportQuESTEnv ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8h_af8a14ae79c3fb2c0b5f6255cc37bebf9}


Report information about the QuEST environment. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 44 of file qubits\_\-env\_\-local.c.

References QuESTEnv::numRanks, QuESTEnv::rank, and REAL.

Referenced by main().


\begin{DoxyCode}
44                                  {
45         printf("EXECUTION ENVIRONMENT:\n");
46         printf("Running locally on one node\n");
47         printf("Number of ranks is %d\n", env.numRanks);
48 # ifdef _OPENMP
49         printf("OpenMP enabled\n");
50         printf("Number of threads available is %d\n", omp_get_max_threads());
51 # else
52         printf("OpenMP disabled\n");
53 # endif
54         printf("Precision: size of REAL is %ld bytes\n", sizeof(REAL));
55 }
\end{DoxyCode}
\hypertarget{qubits_8h_a96f4de9ce7fefc7680a44d601fc3d894}{
\index{qubits.h@{qubits.h}!reportState@{reportState}}
\index{reportState@{reportState}!qubits.h@{qubits.h}}
\paragraph[{reportState}]{\setlength{\rightskip}{0pt plus 5cm}void reportState ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits_8h_a96f4de9ce7fefc7680a44d601fc3d894}


Print the current state vector of probability amplitudes for a set of qubits to file. File format: \begin{DoxyVerb}
real, imag
realComponent1, imagComponent1
realComponent2, imagComponent2
...
realComponentN, imagComponentN
\end{DoxyVerb}


File naming convention:

For each node that the program runs on, a file 'state\_\-rank\_\-\mbox{[}node\_\-rank\mbox{]}.csv' is generated. If there is more than one node, ranks after the first do not include the header \begin{DoxyVerb}
real, imag
\end{DoxyVerb}
 so that files are easier to combine. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \end{DoxyParams}


Definition at line 107 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL\_\-STRING\_\-FORMAT, and MultiQubit::stateVec.


\begin{DoxyCode}
107                                        {
108         FILE *state;
109         char filename[100];
110         long long int index;
111         sprintf(filename, "state_rank_%d.csv", multiQubit.chunkId);
112         state = fopen(filename, "w");
113         if (multiQubit.chunkId==0) fprintf(state, "real, imag\n");
114 
115         for(index=0; index<multiQubit.numAmps; index++){
116                 fprintf(state, REAL_STRING_FORMAT "," REAL_STRING_FORMAT "\n", mu
      ltiQubit.stateVec.real[index], multiQubit.stateVec.imag[index]);
117         }
118         fclose(state);
119 }
\end{DoxyCode}
\hypertarget{qubits_8h_a842d6884e063a5865a2232cba56b65ac}{
\index{qubits.h@{qubits.h}!reportStateToScreen@{reportStateToScreen}}
\index{reportStateToScreen@{reportStateToScreen}!qubits.h@{qubits.h}}
\paragraph[{reportStateToScreen}]{\setlength{\rightskip}{0pt plus 5cm}void reportStateToScreen ({\bf MultiQubit} {\em multiQubit}, \/  {\bf QuESTEnv} {\em env}, \/  int {\em reportRank})}\hfill}
\label{qubits_8h_a842d6884e063a5865a2232cba56b65ac}


Print the current state vector of probability amplitudes for a set of qubits to standard out. For debugging purposes. Each rank should print output serially. Only print output for systems $<$= 5 qubits 

Definition at line 124 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, MultiQubit::numQubits, ComplexArray::real, REAL\_\-STRING\_\-FORMAT, MultiQubit::stateVec, and syncQuESTEnv().

Referenced by reportTest().


\begin{DoxyCode}
124                                                                              {
125         long long int index;
126         int rank;
127         if (multiQubit.numQubits<=5){
128                 for (rank=0; rank<multiQubit.numChunks; rank++){
129                         if (multiQubit.chunkId==rank){
130                                 if (reportRank) {
131                                         printf("Reporting state from rank %d [\n"
      , multiQubit.chunkId);
132                                         //printf("\trank, index, real, imag\n");
133                                         printf("real, imag\n");
134                                 } else if (rank==0) {
135                                         printf("Reporting state [\n");
136                                         printf("real, imag\n");
137                                 }
138 
139                                 for(index=0; index<multiQubit.numAmps; index++){
140                                         printf(REAL_STRING_FORMAT ", " 
      REAL_STRING_FORMAT "\n", multiQubit.stateVec.real[index], multiQubit.stateVec.
      imag[index]);
141                                 }
142                                 if (reportRank || rank==multiQubit.numChunks-1) p
      rintf("]\n");
143                         }
144                         syncQuESTEnv(env);
145                 }
146         } else printf("Error: reportStateToScreen will not print output for syste
      ms of more than 5 qubits.\n");
147 }
\end{DoxyCode}
\hypertarget{qubits_8h_a7fadb225fc385db789e844c87fcba9e1}{
\index{qubits.h@{qubits.h}!rotateAroundAxis@{rotateAroundAxis}}
\index{rotateAroundAxis@{rotateAroundAxis}!qubits.h@{qubits.h}}
\paragraph[{rotateAroundAxis}]{\setlength{\rightskip}{0pt plus 5cm}void rotateAroundAxis ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle}, \/  {\bf Vector} {\em unitAxis})}\hfill}
\label{qubits_8h_a7fadb225fc385db789e844c87fcba9e1}


Rotate a single qubit a certain angle about an axis. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \item[\mbox{$\leftarrow$} {\em unitAxis}]unit vector pointing along the axis about which to rotate. Does not need to be normalised \end{DoxyParams}


Definition at line 434 of file qubits.c.

References compactUnitary(), Complex::imag, Complex::real, Vector::x, Vector::y, and Vector::z.


\begin{DoxyCode}
434                                                                                  
                  {
435         Complex alpha, beta;
436         alpha.real = cos(angle/2.0);
437         alpha.imag = -sin(angle/2.0)*unitAxis.z;        
438         beta.real = 0;
439         beta.imag = -sin(angle/2.0)*(unitAxis.x + unitAxis.y);
440         compactUnitary(multiQubit, rotQubit, alpha, beta);
441 }
\end{DoxyCode}
\hypertarget{qubits_8h_a6cc7fa705a2f2e6b486b49c5589d5df5}{
\index{qubits.h@{qubits.h}!rotateX@{rotateX}}
\index{rotateX@{rotateX}!qubits.h@{qubits.h}}
\paragraph[{rotateX}]{\setlength{\rightskip}{0pt plus 5cm}void rotateX ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8h_a6cc7fa705a2f2e6b486b49c5589d5df5}


Rotate a single qubit a certain angle about the x-\/axis. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}


Definition at line 452 of file qubits.c.

References compactUnitary(), Complex::imag, Complex::real, Vector::x, Vector::y, and Vector::z.


\begin{DoxyCode}
452                                                                    {
453         Complex alpha, beta;
454     Vector unitAxis = {1, 0, 0};
455         alpha.real = cos(angle/2.0);
456         alpha.imag = -sin(angle/2.0)*unitAxis.z;        
457         beta.real = 0;
458         beta.imag = -sin(angle/2.0)*(unitAxis.x + unitAxis.y);
459         compactUnitary(multiQubit, rotQubit, alpha, beta);
460 }
\end{DoxyCode}
\hypertarget{qubits_8h_ace0d3592d38a990e81a434c4e9681500}{
\index{qubits.h@{qubits.h}!rotateY@{rotateY}}
\index{rotateY@{rotateY}!qubits.h@{qubits.h}}
\paragraph[{rotateY}]{\setlength{\rightskip}{0pt plus 5cm}void rotateY ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8h_ace0d3592d38a990e81a434c4e9681500}


Rotate a single qubit a certain angle about the y-\/axis. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}


Definition at line 471 of file qubits.c.

References compactUnitary(), Complex::imag, Complex::real, Vector::x, Vector::y, and Vector::z.


\begin{DoxyCode}
471                                                                    {
472         Complex alpha, beta;
473     Vector unitAxis = {0, 1, 0};
474         alpha.real = cos(angle/2.0);
475         alpha.imag = -sin(angle/2.0)*unitAxis.z;        
476         beta.real = 0;
477         beta.imag = -sin(angle/2.0)*(unitAxis.x + unitAxis.y);
478         compactUnitary(multiQubit, rotQubit, alpha, beta);
479 }
\end{DoxyCode}
\hypertarget{qubits_8h_abd621412ad30c1b034f4ce153c4afe10}{
\index{qubits.h@{qubits.h}!rotateZ@{rotateZ}}
\index{rotateZ@{rotateZ}!qubits.h@{qubits.h}}
\paragraph[{rotateZ}]{\setlength{\rightskip}{0pt plus 5cm}void rotateZ ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8h_abd621412ad30c1b034f4ce153c4afe10}


Rotate a single qubit a certain angle about the z-\/axis. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}


Definition at line 490 of file qubits.c.

References compactUnitary(), Complex::imag, Complex::real, Vector::x, Vector::y, and Vector::z.


\begin{DoxyCode}
490                                                                    {
491         Complex alpha, beta;
492     Vector unitAxis = {0, 0, 1};
493         alpha.real = cos(angle/2.0);
494         alpha.imag = -sin(angle/2.0)*unitAxis.z;        
495         beta.real = 0;
496         beta.imag = -sin(angle/2.0)*(unitAxis.x + unitAxis.y);
497         compactUnitary(multiQubit, rotQubit, alpha, beta);
498 }
\end{DoxyCode}
\hypertarget{qubits_8h_adda6c47876a7676488ed0565a19eaa65}{
\index{qubits.h@{qubits.h}!sGate@{sGate}}
\index{sGate@{sGate}!qubits.h@{qubits.h}}
\paragraph[{sGate}]{\setlength{\rightskip}{0pt plus 5cm}void sGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8h_adda6c47876a7676488ed0565a19eaa65}


Definition at line 1740 of file qubits.c.

References phaseGate(), and S\_\-GATE.

Referenced by test\_\-sGate().


\begin{DoxyCode}
1741 {
1742                 phaseGate(multiQubit, targetQubit, S_GATE);
1743 } 
\end{DoxyCode}
\hypertarget{qubits_8h_a86e396e06b7d527cac20ba0108872423}{
\index{qubits.h@{qubits.h}!sigmaX@{sigmaX}}
\index{sigmaX@{sigmaX}!qubits.h@{qubits.h}}
\paragraph[{sigmaX}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaX ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8h_a86e396e06b7d527cac20ba0108872423}


Rotate a single qubit by \{\{0,1\},\{1,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \end{DoxyParams}


Definition at line 154 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), sigmaXDistributed(), sigmaXLocal(), and MultiQubit::stateVec.

Referenced by test\_\-sigmaX().


\begin{DoxyCode}
155 {
156     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
157         sigmaXLocal(multiQubit, targetQubit);
158 }
\end{DoxyCode}
\hypertarget{qubits_8h_a1f54d70a42403f7e1c2e2c2007332f61}{
\index{qubits.h@{qubits.h}!sigmaY@{sigmaY}}
\index{sigmaY@{sigmaY}!qubits.h@{qubits.h}}
\paragraph[{sigmaY}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaY ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8h_a1f54d70a42403f7e1c2e2c2007332f61}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$ and apply a phase of -\/i or i. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \end{DoxyParams}


fix -\/-\/ put duplicate code (sigmaX, sigmaY) in seperate function 

Definition at line 160 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), sigmaYDistributed(), sigmaYLocal(), and MultiQubit::stateVec.

Referenced by test\_\-sigmaY().


\begin{DoxyCode}
161 {
162     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
163         sigmaYLocal(multiQubit, targetQubit);
164 }
\end{DoxyCode}
\hypertarget{qubits_8h_aebaab86326779de55d335cfea3efde8f}{
\index{qubits.h@{qubits.h}!sigmaZ@{sigmaZ}}
\index{sigmaZ@{sigmaZ}!qubits.h@{qubits.h}}
\paragraph[{sigmaZ}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaZ ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8h_aebaab86326779de55d335cfea3efde8f}


Rotate a single qubit by \{\{1,0\},\{\{0,-\/1\}\} -\/-\/ apply a phase of -\/1 to $|$1$>$. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \end{DoxyParams}


Definition at line 1735 of file qubits.c.

References phaseGate(), and SIGMA\_\-Z.

Referenced by test\_\-sigmaZ().


\begin{DoxyCode}
1736 {
1737                 phaseGate(multiQubit, targetQubit, SIGMA_Z);
1738 }
\end{DoxyCode}
\hypertarget{qubits_8h_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{
\index{qubits.h@{qubits.h}!syncQuESTEnv@{syncQuESTEnv}}
\index{syncQuESTEnv@{syncQuESTEnv}!qubits.h@{qubits.h}}
\paragraph[{syncQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void syncQuESTEnv ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8h_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}


Guarantees that all code up to the given point has been executed on all nodes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 32 of file qubits\_\-env\_\-local.c.

Referenced by initializeStateFromSingleFile(), main(), reportStateToScreen(), and test\_\-controlledNot().


\begin{DoxyCode}
32                                {
33         // MPI Barrier goes here in MPI version. 
34 } 
\end{DoxyCode}
\hypertarget{qubits_8h_ac7e38d768a1bd79019f88cc1e6295092}{
\index{qubits.h@{qubits.h}!syncQuESTSuccess@{syncQuESTSuccess}}
\index{syncQuESTSuccess@{syncQuESTSuccess}!qubits.h@{qubits.h}}
\paragraph[{syncQuESTSuccess}]{\setlength{\rightskip}{0pt plus 5cm}int syncQuESTSuccess (int {\em successCode})}\hfill}
\label{qubits_8h_ac7e38d768a1bd79019f88cc1e6295092}


Performs a logical AND on all successCodes held by all processes. If any one process has a zero successCode all processes will return a zero success code. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \item[\mbox{$\leftarrow$} {\em successCode}]1 if process task succeeded, 0 if process task failed \end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if all processes succeeded, 0 if any one process failed 
\end{DoxyReturn}


Definition at line 36 of file qubits\_\-env\_\-local.c.

Referenced by main().


\begin{DoxyCode}
36                                      {
37         return successCode;
38 }
\end{DoxyCode}
\hypertarget{qubits_8h_af764ea63a2e870098f4e1ce08562942e}{
\index{qubits.h@{qubits.h}!tGate@{tGate}}
\index{tGate@{tGate}!qubits.h@{qubits.h}}
\paragraph[{tGate}]{\setlength{\rightskip}{0pt plus 5cm}void tGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8h_af764ea63a2e870098f4e1ce08562942e}


Definition at line 1745 of file qubits.c.

References phaseGate(), and T\_\-GATE.

Referenced by test\_\-tGate().


\begin{DoxyCode}
1746 {
1747                 phaseGate(multiQubit, targetQubit, T_GATE);
1748 }
\end{DoxyCode}
\hypertarget{qubits_8h_a7a0877e33700f6bad48adb51b7b3fb67}{
\index{qubits.h@{qubits.h}!unitary@{unitary}}
\index{unitary@{unitary}!qubits.h@{qubits.h}}
\paragraph[{unitary}]{\setlength{\rightskip}{0pt plus 5cm}void unitary ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8h_a7a0877e33700f6bad48adb51b7b3fb67}


Definition at line 110 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), getRotAngleFromUnitaryMatrix(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, unitaryDistributed(), unitaryLocal(), and validateMatrixIsUnitary().

Referenced by test\_\-unitary().


\begin{DoxyCode}
111 {
112     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
113     QuESTAssert(validateMatrixIsUnitary(u), 5, __func__);
114 
115         // all values required to update state vector lie in this rank
116         unitaryLocal(multiQubit, targetQubit, u);
117 }
\end{DoxyCode}
