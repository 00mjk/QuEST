\hypertarget{qubits__internal_8h}{}\subsection{qubits\+\_\+internal.\+h File Reference}
\label{qubits__internal_8h}\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}


Internal functions used to implement the public facing A\+PI in \hyperlink{qubits_8h}{qubits.\+h}.  


\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}{rotate\+Qubit\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}{rotate\+Qubit\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
double \hyperlink{qubits__internal_8h_a1c0a25823add0bd9f925a9164dc21870}{find\+Probability\+Of\+Zero\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state. \end{DoxyCompactList}\item 
double \hyperlink{qubits__internal_8h_a2d302738d123129a388edf81b845fd89}{find\+Probability\+Of\+Zero\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state. \end{DoxyCompactList}\item 
int \hyperlink{qubits__internal_8h_a420b30092dc60ff17188e23361d547a5}{extract\+Bit} (const int location\+Of\+Bit\+From\+Right, const long long int the\+Encoded\+Number)
\item 
void \hyperlink{qubits__internal_8h_a2cc0021ae64e2264e2aab4bdb204599e}{control\+Phase\+Gate} (const int num\+Qubits, const int id\+Qubit1, const int id\+Qubit2, double $\ast$restrict state\+Vec\+Real, double $\ast$restrict state\+Vec\+Imag)
\begin{DoxyCompactList}\small\item\em Implement the control phase (the two qubit phase gate). \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ae86c95cfe7c7953d6c821c53f2ea8d05}{quad\+C\+Phase\+Gate} (const int num\+Qubits, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3, const int id\+Qubit4, double $\ast$restrict state\+Vec\+Real, double $\ast$restrict state\+Vec\+Imag)
\item 
double \hyperlink{qubits__internal_8h_a1048595256ae43d4fae6ced562f450f0}{measure\+In\+Zero} (const int num\+Qubits, const int measure\+Qubit, double $\ast$restrict state\+Vec\+Real, double $\ast$restrict state\+Vec\+Imag)
\item 
double \hyperlink{qubits__internal_8h_ac0a6831f57a515c899796c9fed84012d}{filter\+Out111} (const int num\+Qubits, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3, double $\ast$restrict state\+Vec\+Real, double $\ast$restrict state\+Vec\+Imag)
\item 
double \hyperlink{qubits__internal_8h_ad1c169b3b62793c032a1dd50a9d5d95f}{prob\+Of\+Filter\+Out111} (const int num\+Qubits, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3, double $\ast$restrict state\+Vec\+Real, double $\ast$restrict state\+Vec\+Imag)
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
Internal functions used to implement the public facing A\+PI in \hyperlink{qubits_8h}{qubits.\+h}. 

Do not call these functions directly. In general, \hyperlink{qubits__env__local_8c}{qubits\+\_\+env\+\_\+local.\+c} and \hyperlink{qubits__env__mpi_8c}{qubits\+\_\+env\+\_\+mpi.\+c} will implement the public A\+PI by choosing the correct function or combination of functions to use from those included here. 

\subsubsection{Function Documentation}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!control\+Phase\+Gate@{control\+Phase\+Gate}}
\index{control\+Phase\+Gate@{control\+Phase\+Gate}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{control\+Phase\+Gate(const int num\+Qubits, const int id\+Qubit1, const int id\+Qubit2, double $\ast$restrict state\+Vec\+Real, double $\ast$restrict state\+Vec\+Imag)}{controlPhaseGate(const int numQubits, const int idQubit1, const int idQubit2, double *restrict stateVecReal, double *restrict stateVecImag)}}]{\setlength{\rightskip}{0pt plus 5cm}void control\+Phase\+Gate (
\begin{DoxyParamCaption}
\item[{const int}]{num\+Qubits, }
\item[{const int}]{id\+Qubit1, }
\item[{const int}]{id\+Qubit2, }
\item[{double $\ast$restrict}]{state\+Vec\+Real, }
\item[{double $\ast$restrict}]{state\+Vec\+Imag}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a2cc0021ae64e2264e2aab4bdb204599e}{}\label{qubits__internal_8h_a2cc0021ae64e2264e2aab4bdb204599e}


Implement the control phase (the two qubit phase gate). 

R\+E\+W\+R\+I\+TE TO U\+SE M\+U\+L\+T\+I\+Q\+U\+B\+IT input\+: // num\+Qubits -- number of qubits // id\+Qubit1, -- specified qubits // id\+Qubit2 // state\+Vec\+Real, -- real/imag parts of // state\+Vec\+Imag the state vector //

output\+: // state\+Vec\+Real, -- real/imag parts of // state\+Vec\+Imag the state vector (overwritten) // 

Definition at line 517 of file qubits.\+c.



References extract\+Bit().


\begin{DoxyCode}
519 \{
520         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
521         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
522         \textcolor{keywordtype}{int} bit1, bit2;
523 
524         \textcolor{comment}{// ---------------------------------------------------------------- //}
525         \textcolor{comment}{//            tests                                                 //}
526         \textcolor{comment}{// ---------------------------------------------------------------- //}
527 
528         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < numQubits && idQubit2 < numQubits);
529 
530 
531         \textcolor{comment}{// ---------------------------------------------------------------- //}
532         \textcolor{comment}{//            initialise the state to |0000..0>                     //}
533         \textcolor{comment}{// ---------------------------------------------------------------- //}
534 
535         \textcolor{comment}{// dimension of the state vector}
536         stateVecSize = 1LL << numQubits;
537 
538 \textcolor{preprocessor}{# ifdef \_OPENMP}
539 \textcolor{preprocessor}{# pragma omp parallel for \(\backslash\)}
540 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
541 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag ) \(\backslash\)}
542 \textcolor{preprocessor}{        private  (index,bit1,bit2)                     \(\backslash\)}
543 \textcolor{preprocessor}{        schedule (static)}
544 \textcolor{preprocessor}{# endif}
545         \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
546                 bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
547                 bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
548                 \textcolor{keywordflow}{if} (bit1 && bit2) \{
549                         stateVecReal [index] = - stateVecReal [index];
550                         stateVecImag [index] = - stateVecImag [index];
551                 \}
552         \}
553 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!extract\+Bit@{extract\+Bit}}
\index{extract\+Bit@{extract\+Bit}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{extract\+Bit(const int location\+Of\+Bit\+From\+Right, const long long int the\+Encoded\+Number)}{extractBit(const int locationOfBitFromRight, const long long int theEncodedNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}int extract\+Bit (
\begin{DoxyParamCaption}
\item[{const int}]{location\+Of\+Bit\+From\+Right, }
\item[{const long long int}]{the\+Encoded\+Number}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a420b30092dc60ff17188e23361d547a5}{}\label{qubits__internal_8h_a420b30092dc60ff17188e23361d547a5}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!filter\+Out111@{filter\+Out111}}
\index{filter\+Out111@{filter\+Out111}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{filter\+Out111(const int num\+Qubits, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3, double $\ast$restrict state\+Vec\+Real, double $\ast$restrict state\+Vec\+Imag)}{filterOut111(const int numQubits, const int idQubit1, const int idQubit2, const int idQubit3, double *restrict stateVecReal, double *restrict stateVecImag)}}]{\setlength{\rightskip}{0pt plus 5cm}double filter\+Out111 (
\begin{DoxyParamCaption}
\item[{const int}]{num\+Qubits, }
\item[{const int}]{id\+Qubit1, }
\item[{const int}]{id\+Qubit2, }
\item[{const int}]{id\+Qubit3, }
\item[{double $\ast$restrict}]{state\+Vec\+Real, }
\item[{double $\ast$restrict}]{state\+Vec\+Imag}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_ac0a6831f57a515c899796c9fed84012d}{}\label{qubits__internal_8h_ac0a6831f57a515c899796c9fed84012d}


Definition at line 699 of file qubits.\+c.



References extract\+Bit().


\begin{DoxyCode}
702 \{
703         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
704         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
705         \textcolor{keywordtype}{int} bit1, bit2, bit3;
706 
707         \textcolor{comment}{// ---------------------------------------------------------------- //}
708         \textcolor{comment}{//            tests                                                 //}
709         \textcolor{comment}{// ---------------------------------------------------------------- //}
710         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < numQubits && idQubit2 < numQubits);
711 
712         stateVecSize = 1LL << numQubits;
713         \textcolor{keywordtype}{double} probOfFilter=0;
714 
715 \textcolor{preprocessor}{# ifdef \_OPENMP}
716 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
717 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
718 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag) \(\backslash\)}
719 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3)                \(\backslash\)}
720 \textcolor{preprocessor}{        reduction ( +:probOfFilter )}
721 \textcolor{preprocessor}{# endif}
722         \{
723 \textcolor{preprocessor}{# ifdef \_OPENMP}
724 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
725 \textcolor{preprocessor}{# endif}
726                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
727                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
728                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
729                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index);
730                         \textcolor{keywordflow}{if} (!(bit1 && bit2 && bit3)) \{
731                                 probOfFilter+= stateVecReal[index]*stateVecReal[index] + stateVecImag[index
      ]* stateVecImag [index];
732                         \}
733                 \}
734         \}
735         \textcolor{keywordflow}{if} ( probOfFilter<1e-16 )\{ printf(\textcolor{stringliteral}{"Extremely small or negative profOfFilter=%.8e; aborting! \(\backslash\)n"},
      probOfFilter); exit(1);\}
736         \textcolor{keywordtype}{double} myNorm=1/sqrt(probOfFilter);
737 
738 \textcolor{preprocessor}{# ifdef \_OPENMP}
739 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
740 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
741 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag, myNorm) \(\backslash\)}
742 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3)                }
743 \textcolor{preprocessor}{# endif }
744         \{
745 \textcolor{preprocessor}{# ifdef \_OPENMP}
746 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
747 \textcolor{preprocessor}{# endif}
748                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
749                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
750                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
751                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index);
752                         \textcolor{keywordflow}{if} ((bit1 && bit2 && bit3)) \{
753                                 stateVecReal[index]=0;
754                                 stateVecImag [index]=0;
755                         \}\textcolor{keywordflow}{else}\{
756                                 stateVecReal[index] *= myNorm;
757                                 stateVecImag[index] *= myNorm;
758                         \}
759                 \}
760         \}
761         \textcolor{keywordflow}{return} probOfFilter;
762 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}}
\index{find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{find\+Probability\+Of\+Zero\+Distributed(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit)}{findProbabilityOfZeroDistributed(MultiQubit multiQubit, const int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}double find\+Probability\+Of\+Zero\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a2d302738d123129a388edf81b845fd89}{}\label{qubits__internal_8h_a2d302738d123129a388edf81b845fd89}


Measure the probability of a specified qubit being in the zero state. 

Size of regions to skip is a multiple of chunk\+Size.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits to be initialised \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 429 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Zero().


\begin{DoxyCode}
431 \{
432         \textcolor{comment}{// ----- measured probability}
433         \textcolor{keywordtype}{double}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
434         \textcolor{comment}{// ----- temp variables}
435         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
436         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
437         \textcolor{comment}{// (good for shared memory parallelism)}
438 
439         \textcolor{comment}{// ---------------------------------------------------------------- //}
440         \textcolor{comment}{//            tests                                                 //}
441         \textcolor{comment}{// ---------------------------------------------------------------- //}
442         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
443 
444         \textcolor{comment}{// ---------------------------------------------------------------- //}
445         \textcolor{comment}{//            find probability                                      //}
446         \textcolor{comment}{// ---------------------------------------------------------------- //}
447 
448         \textcolor{comment}{// initialise returned value}
449         totalProbability = 0.0;
450 
451         \textcolor{comment}{// initialise correction for kahan summation}
452 
453         \textcolor{comment}{//}
454         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
455         \textcolor{comment}{//}
456         
457         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
458         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
459 
460 \textcolor{preprocessor}{# ifdef \_OPENMP}
461 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
462 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
463 \textcolor{preprocessor}{        private   (thisTask) \(\backslash\)}
464 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
465 \textcolor{preprocessor}{# endif}
466         \{
467 \textcolor{preprocessor}{# ifdef \_OPENMP}
468 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
469 \textcolor{preprocessor}{# endif}
470                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
471                         \textcolor{comment}{// summation -- simple implementation}
472                         totalProbability += stateVecReal[thisTask]*stateVecReal[thisTask]
473                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
474 
475                         \textcolor{comment}{/*}
476 \textcolor{comment}{                        // summation -- kahan correction}
477 \textcolor{comment}{                        y = stateVecReal[thisTask]*stateVecReal[thisTask]}
478 \textcolor{comment}{                        + stateVecImag[thisTask]*stateVecImag[thisTask] - c;}
479 \textcolor{comment}{                        t = totalProbability + y;}
480 \textcolor{comment}{                        c = (t - totalProbability) - y;}
481 \textcolor{comment}{                        totalProbability = t;}
482 \textcolor{comment}{                        */}
483 
484                 \}
485         \}
486 
487         \textcolor{keywordflow}{return} totalProbability;
488 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}}
\index{find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{find\+Probability\+Of\+Zero\+Local(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit)}{findProbabilityOfZeroLocal(MultiQubit multiQubit, const int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}double find\+Probability\+Of\+Zero\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a1c0a25823add0bd9f925a9164dc21870}{}\label{qubits__internal_8h_a1c0a25823add0bd9f925a9164dc21870}


Measure the probability of a specified qubit being in the zero state. 

Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits to be initialised \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 340 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Zero().


\begin{DoxyCode}
342 \{
343         \textcolor{comment}{// ----- sizes}
344         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
345         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
346         \textcolor{comment}{// ----- indices}
347         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
348              index;                                               \textcolor{comment}{// current index for first half block}
349         \textcolor{comment}{// ----- measured probability}
350         \textcolor{keywordtype}{double}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
351         \textcolor{comment}{// ----- temp variables}
352         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
353         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
354         \textcolor{comment}{// (good for shared memory parallelism)}
355 
356         \textcolor{comment}{// ---------------------------------------------------------------- //}
357         \textcolor{comment}{//            tests                                                 //}
358         \textcolor{comment}{// ---------------------------------------------------------------- //}
359         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
360 
361 
362         \textcolor{comment}{// ---------------------------------------------------------------- //}
363         \textcolor{comment}{//            dimensions                                            //}
364         \textcolor{comment}{// ---------------------------------------------------------------- //}
365         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
366         \textcolor{comment}{// and then the number to skip}
367         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
368 
369         \textcolor{comment}{// ---------------------------------------------------------------- //}
370         \textcolor{comment}{//            find probability                                      //}
371         \textcolor{comment}{// ---------------------------------------------------------------- //}
372 
373         \textcolor{comment}{// initialise returned value}
374         totalProbability = 0.0;
375 
376         \textcolor{comment}{// initialise correction for kahan summation}
377         printf(\textcolor{stringliteral}{"sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\(\backslash\)n"},sizeHalfBlock,sizeBlock,numTasks);
378 
379         \textcolor{comment}{//}
380         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
381         \textcolor{comment}{//}
382         
383         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
384         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
385 
386 \textcolor{preprocessor}{# ifdef \_OPENMP}
387 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
388 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
389 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index) \(\backslash\)}
390 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
391 \textcolor{preprocessor}{# endif }
392         \{
393 \textcolor{preprocessor}{# ifdef \_OPENMP}
394 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
395 \textcolor{preprocessor}{# endif}
396                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
397                         thisBlock = thisTask / sizeHalfBlock;
398                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
399 
400                         \textcolor{keywordflow}{if} (index<0)\{ printf(\textcolor{stringliteral}{"ABORTING as index=%Ld with thisBlock = %Ld  thisTask=%Ld \(\backslash\)n"},
       index,thisBlock,thisTask); exit(1);\}
401 
402                         \textcolor{comment}{// summation -- simple implementation}
403                         totalProbability += stateVecReal[index]*stateVecReal[index]
404                                 + stateVecImag[index]*stateVecImag[index];
405 
406                         \textcolor{comment}{/*}
407 \textcolor{comment}{                        // summation -- kahan correction}
408 \textcolor{comment}{                        y = stateVecReal[index]*stateVecReal[index]}
409 \textcolor{comment}{                        + stateVecImag[index]*stateVecImag[index] - c;}
410 \textcolor{comment}{                        t = totalProbability + y;}
411 \textcolor{comment}{                        c = (t - totalProbability) - y;}
412 \textcolor{comment}{                        totalProbability = t;}
413 \textcolor{comment}{                        */}
414 
415                 \}
416         \}
417         \textcolor{keywordflow}{return} totalProbability;
418 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!measure\+In\+Zero@{measure\+In\+Zero}}
\index{measure\+In\+Zero@{measure\+In\+Zero}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{measure\+In\+Zero(const int num\+Qubits, const int measure\+Qubit, double $\ast$restrict state\+Vec\+Real, double $\ast$restrict state\+Vec\+Imag)}{measureInZero(const int numQubits, const int measureQubit, double *restrict stateVecReal, double *restrict stateVecImag)}}]{\setlength{\rightskip}{0pt plus 5cm}double measure\+In\+Zero (
\begin{DoxyParamCaption}
\item[{const int}]{num\+Qubits, }
\item[{const int}]{measure\+Qubit, }
\item[{double $\ast$restrict}]{state\+Vec\+Real, }
\item[{double $\ast$restrict}]{state\+Vec\+Imag}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a1048595256ae43d4fae6ced562f450f0}{}\label{qubits__internal_8h_a1048595256ae43d4fae6ced562f450f0}


Definition at line 601 of file qubits.\+c.


\begin{DoxyCode}
605 \{
606         \textcolor{comment}{// ----- sizes}
607         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
608         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
609         \textcolor{comment}{// ----- indices}
610         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
611              index;                                               \textcolor{comment}{// current index for first half block}
612         \textcolor{comment}{// ----- measured probability}
613         \textcolor{keywordtype}{double}   totalProbability, renorm;                                    \textcolor{comment}{// probability (returned)
       value}
614         \textcolor{comment}{// ----- temp variables}
615         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask,numTasks;                                   \textcolor{comment}{// task based approach for
       expose loop with small granularity}
616         \textcolor{comment}{// (good for shared memory parallelism)}
617 
618         \textcolor{comment}{// ---------------------------------------------------------------- //}
619         \textcolor{comment}{//            tests                                                 //}
620         \textcolor{comment}{// ---------------------------------------------------------------- //}
621         assert (measureQubit >= 0 && measureQubit < numQubits);
622 
623 
624         \textcolor{comment}{// ---------------------------------------------------------------- //}
625         \textcolor{comment}{//            dimensions                                            //}
626         \textcolor{comment}{// ---------------------------------------------------------------- //}
627         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
628         \textcolor{comment}{// and then the number to skip}
629         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
630 
631         \textcolor{comment}{// ---------------------------------------------------------------- //}
632         \textcolor{comment}{//            find probability                                      //}
633         \textcolor{comment}{// ---------------------------------------------------------------- //}
634         numTasks = 1LL << (numQubits-1);
635 
636         \textcolor{comment}{// initialise returned value}
637         totalProbability = 0.0;
638 
639         \textcolor{comment}{//}
640         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
641         \textcolor{comment}{//}
642 \textcolor{preprocessor}{# ifdef \_OPENMP}
643 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
644 \textcolor{preprocessor}{        default (none) \(\backslash\)}
645 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
646 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index) \(\backslash\)}
647 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
648 \textcolor{preprocessor}{# endif}
649         \{
650 \textcolor{preprocessor}{# ifdef \_OPENMP}
651 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
652 \textcolor{preprocessor}{# endif}
653                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
654                         thisBlock = thisTask / sizeHalfBlock;
655                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
656 
657                         totalProbability += stateVecReal[index]*stateVecReal[index]
658                                 + stateVecImag[index]*stateVecImag[index];
659                 \}
660         \}
661 
662         renorm=1/sqrt(totalProbability);
663 
664 
665 \textcolor{preprocessor}{# ifdef \_OPENMP}
666 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
667 \textcolor{preprocessor}{        default (none) \(\backslash\)}
668 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,renorm) \(\backslash\)}
669 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index)}
670 \textcolor{preprocessor}{# endif}
671         \{
672 \textcolor{preprocessor}{# ifdef \_OPENMP}
673 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
674 \textcolor{preprocessor}{# endif}
675                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
676                         thisBlock = thisTask / sizeHalfBlock;
677                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
678                         stateVecReal[index]=stateVecReal[index]*renorm;
679                         stateVecImag[index]=stateVecImag[index]*renorm;
680 
681                         stateVecReal[index+sizeHalfBlock]=0;
682                         stateVecImag[index+sizeHalfBlock]=0;
683                 \}
684         \}
685 
686         \textcolor{comment}{//SCB this is a debugging style check. It is probably useful to leave in, but it could be
       parallelised I guess}
687         \textcolor{comment}{//  double checkTotal=1.;}
688         \textcolor{comment}{//  for (index=0; index<2*numTasks; index++) \{}
689         \textcolor{comment}{//      checkTotal=checkTotal-(stateVecReal[index]*stateVecReal[index] +
       stateVecImag[index]*stateVecImag[index]);}
690         \textcolor{comment}{//  \}}
691         \textcolor{comment}{//  if (checkTotal>0.00001)\{printf("Deviation of sum squared amps from unity is
       %.16f\(\backslash\)n",checkTotal); exit(1);\}}
692 
693         \textcolor{keywordflow}{return} totalProbability;
694 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!prob\+Of\+Filter\+Out111@{prob\+Of\+Filter\+Out111}}
\index{prob\+Of\+Filter\+Out111@{prob\+Of\+Filter\+Out111}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{prob\+Of\+Filter\+Out111(const int num\+Qubits, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3, double $\ast$restrict state\+Vec\+Real, double $\ast$restrict state\+Vec\+Imag)}{probOfFilterOut111(const int numQubits, const int idQubit1, const int idQubit2, const int idQubit3, double *restrict stateVecReal, double *restrict stateVecImag)}}]{\setlength{\rightskip}{0pt plus 5cm}double prob\+Of\+Filter\+Out111 (
\begin{DoxyParamCaption}
\item[{const int}]{num\+Qubits, }
\item[{const int}]{id\+Qubit1, }
\item[{const int}]{id\+Qubit2, }
\item[{const int}]{id\+Qubit3, }
\item[{double $\ast$restrict}]{state\+Vec\+Real, }
\item[{double $\ast$restrict}]{state\+Vec\+Imag}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_ad1c169b3b62793c032a1dd50a9d5d95f}{}\label{qubits__internal_8h_ad1c169b3b62793c032a1dd50a9d5d95f}


Definition at line 767 of file qubits.\+c.



References extract\+Bit().


\begin{DoxyCode}
770 \{
771         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
772         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
773         \textcolor{keywordtype}{int} bit1, bit2, bit3;
774 
775         \textcolor{comment}{// ---------------------------------------------------------------- //}
776         \textcolor{comment}{//            tests                                                 //}
777         \textcolor{comment}{// ---------------------------------------------------------------- //}
778         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < numQubits && idQubit2 < numQubits);
779 
780         stateVecSize = 1LL << numQubits;
781         \textcolor{keywordtype}{double} probOfFilter=0;
782 
783 \textcolor{preprocessor}{# ifdef \_OPENMP}
784 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
785 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
786 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag) \(\backslash\)}
787 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3)                \(\backslash\)}
788 \textcolor{preprocessor}{        reduction ( +:probOfFilter )}
789 \textcolor{preprocessor}{# endif}
790         \{
791 \textcolor{preprocessor}{# ifdef \_OPENMP}
792 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
793 \textcolor{preprocessor}{# endif}
794                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
795                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
796                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
797                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index);
798                         \textcolor{keywordflow}{if} (!(bit1 && bit2 && bit3)) \{
799                                 probOfFilter+= stateVecReal[index]*stateVecReal[index] + stateVecImag[index
      ]* stateVecImag [index];
800                         \}
801                 \}
802         \}
803         \textcolor{keywordflow}{return} probOfFilter;
804 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!quad\+C\+Phase\+Gate@{quad\+C\+Phase\+Gate}}
\index{quad\+C\+Phase\+Gate@{quad\+C\+Phase\+Gate}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{quad\+C\+Phase\+Gate(const int num\+Qubits, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3, const int id\+Qubit4, double $\ast$restrict state\+Vec\+Real, double $\ast$restrict state\+Vec\+Imag)}{quadCPhaseGate(const int numQubits, const int idQubit1, const int idQubit2, const int idQubit3, const int idQubit4, double *restrict stateVecReal, double *restrict stateVecImag)}}]{\setlength{\rightskip}{0pt plus 5cm}void quad\+C\+Phase\+Gate (
\begin{DoxyParamCaption}
\item[{const int}]{num\+Qubits, }
\item[{const int}]{id\+Qubit1, }
\item[{const int}]{id\+Qubit2, }
\item[{const int}]{id\+Qubit3, }
\item[{const int}]{id\+Qubit4, }
\item[{double $\ast$restrict}]{state\+Vec\+Real, }
\item[{double $\ast$restrict}]{state\+Vec\+Imag}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_ae86c95cfe7c7953d6c821c53f2ea8d05}{}\label{qubits__internal_8h_ae86c95cfe7c7953d6c821c53f2ea8d05}


Definition at line 559 of file qubits.\+c.



References extract\+Bit().


\begin{DoxyCode}
560 \{
561         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
562         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
563         \textcolor{keywordtype}{int} bit1, bit2, bit3, bit4;
564 
565         \textcolor{comment}{// ---------------------------------------------------------------- //}
566         \textcolor{comment}{//            tests                                                 //}
567         \textcolor{comment}{// ---------------------------------------------------------------- //}
568         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < numQubits && idQubit2 < numQubits);
569 
570         stateVecSize = 1LL << numQubits;
571 
572 \textcolor{preprocessor}{# ifdef \_OPENMP}
573 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
574 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
575 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag ) \(\backslash\)}
576 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3,bit4)}
577 \textcolor{preprocessor}{# endif}
578         \{
579 \textcolor{preprocessor}{# ifdef \_OPENMP}
580 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
581 \textcolor{preprocessor}{# endif}
582                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
583                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
584                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
585                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index);
586                         bit4 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit4, index);
587                         \textcolor{keywordflow}{if} (bit1 && bit2 && bit3 && bit4) \{
588                                 stateVecReal [index] = - stateVecReal [index];
589                                 stateVecImag [index] = - stateVecImag [index];
590                         \}
591                 \}
592         \}
593 \}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!rotate\+Qubit\+Distributed@{rotate\+Qubit\+Distributed}}
\index{rotate\+Qubit\+Distributed@{rotate\+Qubit\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{rotate\+Qubit\+Distributed(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, Complex rot1, Complex rot2, Complex\+Array state\+Vec\+Up, Complex\+Array state\+Vec\+Lo, Complex\+Array state\+Vec\+Out)}{rotateQubitDistributed(MultiQubit multiQubit, const int rotQubit, Complex rot1, Complex rot2, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut)}}]{\setlength{\rightskip}{0pt plus 5cm}void rotate\+Qubit\+Distributed (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf Complex}}]{rot1, }
\item[{{\bf Complex}}]{rot2, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Up, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Lo, }
\item[{{\bf Complex\+Array}}]{state\+Vec\+Out}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}{}\label{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}


Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits to be initialised \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 271 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Complex\+::real.



Referenced by rotate\+Qubit().


\begin{DoxyCode}
276 \{
277         \textcolor{comment}{// ----- temp variables}
278         \textcolor{keywordtype}{double}   stateRealUp,stateRealLo,                             \textcolor{comment}{// storage for previous state values}
279         stateImagUp,stateImagLo;                             \textcolor{comment}{// (used in updates)}
280         \textcolor{comment}{// ----- temp variables}
281         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
282         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
283 
284         \textcolor{comment}{// (good for shared memory parallelism)}
285 
286         \textcolor{comment}{// ---------------------------------------------------------------- //}
287         \textcolor{comment}{//            tests                                                 //}
288         \textcolor{comment}{// ---------------------------------------------------------------- //}
289         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
290 
291         \textcolor{comment}{// ---------------------------------------------------------------- //}
292         \textcolor{comment}{//            rotate                                                //}
293         \textcolor{comment}{// ---------------------------------------------------------------- //}
294 
295         \textcolor{comment}{//}
296         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
297         \textcolor{comment}{//}
298         \textcolor{keywordtype}{double} rot1Real=rot1.\hyperlink{structComplex_a0138f5fe2b2c6180b8fcda77a7aa51c5}{real}, rot1Imag=rot1.\hyperlink{structComplex_a2bb90cc563599c3c8bdec9acf9ea40a6}{imag};
299         \textcolor{keywordtype}{double} rot2Real=rot2.\hyperlink{structComplex_a0138f5fe2b2c6180b8fcda77a7aa51c5}{real}, rot2Imag=rot2.\hyperlink{structComplex_a2bb90cc563599c3c8bdec9acf9ea40a6}{imag};
300         \textcolor{keywordtype}{double} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
301         \textcolor{keywordtype}{double} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
302         \textcolor{keywordtype}{double} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
303 
304 \textcolor{preprocessor}{# ifdef \_OPENMP}
305 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
306 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
307 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
308 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag) \(\backslash\)}
309 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
310 \textcolor{preprocessor}{# endif}
311         \{
312 \textcolor{preprocessor}{# ifdef \_OPENMP}
313 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
314 \textcolor{preprocessor}{# endif}
315                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
316                         \textcolor{comment}{// store current state vector values in temp variables}
317                         stateRealUp = stateVecRealUp[thisTask];
318                         stateImagUp = stateVecImagUp[thisTask];
319 
320                         stateRealLo = stateVecRealLo[thisTask];
321                         stateImagLo = stateVecImagLo[thisTask];
322 
323                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
324                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp + rot2Real*
      stateRealLo + rot2Imag*stateImagLo;
325                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp + rot2Real*
      stateImagLo - rot2Imag*stateRealLo;
326                 \} \textcolor{comment}{// end for loop}
327         \}
328 \} \textcolor{comment}{// end of function definition}
\end{DoxyCode}
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!rotate\+Qubit\+Local@{rotate\+Qubit\+Local}}
\index{rotate\+Qubit\+Local@{rotate\+Qubit\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph[{\texorpdfstring{rotate\+Qubit\+Local(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, Complex alpha, Complex beta)}{rotateQubitLocal(MultiQubit multiQubit, const int rotQubit, Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}void rotate\+Qubit\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)}\hypertarget{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}{}\label{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}


Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. 

alpha\+Re = cos(angle1) $\ast$ cos(angle2) ~\newline
alpha\+Im = cos(angle1) $\ast$ sin(angle2) ~\newline
 beta\+Re = sin(angle1) $\ast$ cos(angle3) ~\newline
 beta\+Im = sin(angle1) $\ast$ sin(angle3) ~\newline


\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits to be initialised \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em alpha} & rotation angle \\
\hline
\mbox{\tt in}  & {\em beta} & rotation angle \\
\hline
\end{DoxyParams}


Definition at line 174 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, Complex\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by rotate\+Qubit().


\begin{DoxyCode}
175 \{
176         \textcolor{comment}{// ----- sizes}
177         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
178         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
179         \textcolor{comment}{// ----- indices}
180         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
181              indexUp,indexLo;                                     \textcolor{comment}{// current index and corresponding index
       in lower half block}
182 
183         \textcolor{comment}{// ----- temp variables}
184         \textcolor{keywordtype}{double}   stateRealUp,stateRealLo,                             \textcolor{comment}{// storage for previous state values}
185                  stateImagUp,stateImagLo;                             \textcolor{comment}{// (used in updates)}
186         \textcolor{comment}{// ----- temp variables}
187         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
188         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
189         \textcolor{comment}{// (good for shared memory parallelism)}
190 
191 
192         \textcolor{comment}{// ---------------------------------------------------------------- //}
193         \textcolor{comment}{//            tests                                                 //}
194         \textcolor{comment}{// ---------------------------------------------------------------- //}
195         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
196 
197 
198         \textcolor{comment}{// ---------------------------------------------------------------- //}
199         \textcolor{comment}{//            dimensions                                            //}
200         \textcolor{comment}{// ---------------------------------------------------------------- //}
201         sizeHalfBlock = 1LL << rotQubit;                               \textcolor{comment}{// size of blocks halved}
202         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks}
203 
204 
205         \textcolor{comment}{// ---------------------------------------------------------------- //}
206         \textcolor{comment}{//            rotate                                                //}
207         \textcolor{comment}{// ---------------------------------------------------------------- //}
208 
209         \textcolor{comment}{//}
210         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
211         \textcolor{comment}{//}
212         
213         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
214         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
215         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
216         \textcolor{keywordtype}{double} alphaImag=alpha.\hyperlink{structComplex_a2bb90cc563599c3c8bdec9acf9ea40a6}{imag}, alphaReal=alpha.\hyperlink{structComplex_a0138f5fe2b2c6180b8fcda77a7aa51c5}{real};
217         \textcolor{keywordtype}{double} betaImag=beta.\hyperlink{structComplex_a2bb90cc563599c3c8bdec9acf9ea40a6}{imag}, betaReal=beta.\hyperlink{structComplex_a0138f5fe2b2c6180b8fcda77a7aa51c5}{real};
218 
219 \textcolor{preprocessor}{# ifdef \_OPENMP}
220 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
221 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
222 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,alphaImag,
       betaReal,betaImag) \(\backslash\)}
223 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
224 \textcolor{preprocessor}{# endif}
225         \{
226 \textcolor{preprocessor}{# ifdef \_OPENMP}
227 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
228 \textcolor{preprocessor}{# endif}
229                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
230 
231                         thisBlock   = thisTask / sizeHalfBlock;
232                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
233                         indexLo     = indexUp + sizeHalfBlock;
234 
235                         \textcolor{comment}{// store current state vector values in temp variables}
236                         stateRealUp = stateVecReal[indexUp];
237                         stateImagUp = stateVecImag[indexUp];
238 
239                         stateRealLo = stateVecReal[indexLo];
240                         stateImagLo = stateVecImag[indexLo];
241 
242                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
243                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag*stateImagUp - betaReal*
      stateRealLo - betaImag*stateImagLo;
244                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag*stateRealUp - betaReal*
      stateImagLo + betaImag*stateRealLo;
245 
246                         \textcolor{comment}{// state[indexLo] = beta  * state[indexUp] + conj(alpha) * state[indexLo]}
247                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*stateImagUp + alphaReal*
      stateRealLo + alphaImag*stateImagLo;
248                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*stateRealUp + alphaReal*
      stateImagLo - alphaImag*stateRealLo;
249                 \} \textcolor{comment}{// end for loop}
250         \}
251 
252 \} \textcolor{comment}{// end of function definition}
\end{DoxyCode}
