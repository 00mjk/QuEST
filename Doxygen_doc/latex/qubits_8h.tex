\hypertarget{qubits_8h}{
\subsection{qubits.h File Reference}
\label{qubits_8h}\index{qubits.h@{qubits.h}}
}


The QuEST library API and objects.  
{\ttfamily \#include \char`\"{}precision.h\char`\"{}}\par
\subsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structComplexArray}{ComplexArray}
\begin{DoxyCompactList}\small\item\em Represents an array of complex numbers grouped into an array of real components and an array of coressponding complex components. \item\end{DoxyCompactList}\item 
struct \hyperlink{structComplex}{Complex}
\begin{DoxyCompactList}\small\item\em Represents one complex number. \item\end{DoxyCompactList}\item 
struct \hyperlink{structComplexMatrix2}{ComplexMatrix2}
\begin{DoxyCompactList}\small\item\em Represents a 2x2 matrix of complex numbers. \item\end{DoxyCompactList}\item 
struct \hyperlink{structVector}{Vector}
\begin{DoxyCompactList}\small\item\em Represents a 3-\/vector of real numbers. \item\end{DoxyCompactList}\item 
struct \hyperlink{structMultiQubit}{MultiQubit}
\begin{DoxyCompactList}\small\item\em Represents a system of qubits. \item\end{DoxyCompactList}\item 
struct \hyperlink{structQuESTEnv}{QuESTEnv}
\begin{DoxyCompactList}\small\item\em Information about the environment the program is running in. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} \{ \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{SIGMA\_\-Z} = 0, 
\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{S\_\-GATE} = 1, 
\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{T\_\-GATE} = 2
 \}
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{qubits_8h_a9c02591bc64c2918503afa231d90d83f}{createMultiQubit} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit, int numQubits, \hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Create a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_ae5d6acc322314d7a3d8a2eccf00d3b19}{destroyMultiQubit} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, \hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Deallocate a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a96f4de9ce7fefc7680a44d601fc3d894}{reportState} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Print the current state vector of probability amplitudes for a set of qubits to file. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a842d6884e063a5865a2232cba56b65ac}{reportStateToScreen} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, \hyperlink{structQuESTEnv}{QuESTEnv} env, int reportRank)
\begin{DoxyCompactList}\small\item\em Print the current state vector of probability amplitudes for a set of qubits to standard out. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}{reportMultiQubitParams} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Report metainformation about a set of qubits: number of qubits, number of probability amplitudes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_acb5b2eff794339090004d29f02a70d9a}{initStateZero} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit)
\begin{DoxyCompactList}\small\item\em Initialise a set of $ N $ qubits to the classical zero state $ {| 0 \rangle}^{\otimes N} $. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a43bcb279fc9717fbd06a19cdef48b9d8}{initStatePlus} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit)
\begin{DoxyCompactList}\small\item\em Initialise a set of $ N $ qubits to the plus state $ {| + \rangle}^{\otimes N} = \frac{1}{\sqrt{2^N}} (| 0 \rangle + | 1 \rangle)^{\otimes N} $. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_afc1835c6b43b6e59ce7df7b13f274fc7}{multiControlledPhaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int $\ast$controlQubits, int numControlQubits)
\begin{DoxyCompactList}\small\item\em Apply the multiple-\/qubit controlled phase gate, also known as the multiple-\/qubit controlled sigmaZ gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a11a96159191cbf1b01a1080e7f045aac}{controlledPhaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int idQubit1, const int idQubit2)
\begin{DoxyCompactList}\small\item\em Apply the (two-\/qubit) controlled phase gate, also known as the controlled sigmaZ gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_adda6c47876a7676488ed0565a19eaa65}{sGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit S gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_af764ea63a2e870098f4e1ce08562942e}{tGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit T gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_ad84a3ce68d1ca02b4e3f741ea45b6054}{initQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} $\ast$env)
\begin{DoxyCompactList}\small\item\em Initialize the QuEST environment. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_abd4bc926cd3f9b65610bb228d0c59fe0}{closeQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Close QuEST environment. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{syncQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Guarantees that all code up to the given point has been executed on all nodes (if running in distributed mode). \item\end{DoxyCompactList}\item 
int \hyperlink{qubits_8h_ac7e38d768a1bd79019f88cc1e6295092}{syncQuESTSuccess} (int successCode)
\begin{DoxyCompactList}\small\item\em Performs a logical AND on all successCodes held by all processes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_af8a14ae79c3fb2c0b5f6255cc37bebf9}{reportQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Report information about the QuEST environment. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a8f10aabf9f607f19093aee54630caa21}{getEnvironmentString} (\hyperlink{structQuESTEnv}{QuESTEnv} env, \hyperlink{structMultiQubit}{MultiQubit} multiQubit, char str\mbox{[}200\mbox{]})
\item 
REAL \hyperlink{qubits_8h_a317b786f577fa6bc136ea7f0ee7330a7}{getRealAmpEl} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the real component of the complex probability amplitude at an index in the state vector. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8h_a3615f76fd5f57008d9b74bbd10533dd0}{getImagAmpEl} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the imaginary component of the complex probability amplitude at an index in the state vector. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8h_a799b10447d6dbdaf960a4d3eedd22014}{getProbEl} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the probability of the state at an index in the full state vector. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8h_a818a4c7cd7252d2b10b896b12fa431d3}{calcTotalProbability} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Calculate the probability of being in any state by taking the norm of the entire state vector. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a03b13dfcabd8c59b50dbdd3af44ba8b2}{compactUnitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Apply a single-\/qubit unitary parameterised by two given complex scalars. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a7a0877e33700f6bad48adb51b7b3fb67}{unitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Apply a general single-\/qubit unitary (including a global phase factor). \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a6cc7fa705a2f2e6b486b49c5589d5df5}{rotateX} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around the X-\/axis of the Bloch-\/sphere. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_ace0d3592d38a990e81a434c4e9681500}{rotateY} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around the Y-\/axis of the Bloch-\/sphere. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_abd621412ad30c1b034f4ce153c4afe10}{rotateZ} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around the Z-\/axis of the Bloch-\/sphere (also known as a phase shift gate). \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a8810423457803005fecd415f4299f40d}{rotateAroundAxis} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle, \hyperlink{structVector}{Vector} axis)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around a given vector on the Bloch-\/sphere. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_ac6923ac57e67d9a21096e06f6a9012f6}{controlledRotateX} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Applies a controlled rotation by a given angle around the X-\/axis of the Bloch-\/sphere. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a71e90a2f7292116338c062934f9d1202}{controlledRotateY} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Applies a controlled rotation by a given angle around the Y-\/axis of the Bloch-\/sphere. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a668e5d2634b02e98bc73675ccb11d61c}{controlledRotateZ} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Applies a controlled rotation by a given angle around the Z-\/axis of the Bloch-\/sphere. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_ad41f82b41149393a642391b67b3a287e}{controlledRotateAroundAxis} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, REAL angle, \hyperlink{structVector}{Vector} axis)
\begin{DoxyCompactList}\small\item\em Applies a controlled rotation by a given angle around a given vector on the Bloch-\/sphere. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_ab4812953bc457405b3aa05a4c2f64f4a}{controlledCompactUnitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Apply a controlled unitary (single control, single target) parameterised by two given complex scalars. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a8a701526263392599aa21d0d0f05d9d8}{controlledUnitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Apply a general controlled unitary (single control, single target), which can include a global phase factor. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_ae395a79690283ed81106afadd7a8cd8a}{multiControlledUnitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int $\ast$controlQubits, const int numControlQubits, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Apply a general multiple-\/control single-\/target unitary, which can include a global phase factor. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a86e396e06b7d527cac20ba0108872423}{sigmaX} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit sigma-\/X (also known as the X, Pauli-\/X, NOT or bit-\/flip) gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a1f54d70a42403f7e1c2e2c2007332f61}{sigmaY} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit sigma-\/Y (also known as the Y or Pauli-\/Y) gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_aebaab86326779de55d335cfea3efde8f}{sigmaZ} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit sigma-\/Z (also known as the Z, Pauli-\/Z or phase-\/flip) gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_aa09b5dd93de6df1384b8f2c0041749ab}{hadamard} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit Hadamard gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8h_a67576895bbc65463481a8ea24d9b1e22}{controlledNot} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the controlled not (single control, single target) gate, also known as the c-\/X, c-\/sigma-\/X, c-\/Pauli-\/X and c-\/bit-\/flip gate. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8h_ad315c941a51bc053d39ebfa2040fd32e}{findProbabilityOfOutcome} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, int outcome)
\begin{DoxyCompactList}\small\item\em Gives the probability of a specified qubit being measured in the given outcome (0 or 1). \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8h_a07418ebac70fd9ae5d051d089961631d}{collapseToOutcome} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, int outcome)
\begin{DoxyCompactList}\small\item\em Updates the state vector to be consistent with measuring the measure qubit in the given outcome (0 or 1), and returns the probability of such a measurement outcome. \item\end{DoxyCompactList}\item 
int \hyperlink{qubits_8h_ad5774247d836267175c664cd0e451bcb}{measure} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int measureQubit)
\begin{DoxyCompactList}\small\item\em Measures a single qubit, collapsing it randomly to 0 or 1. \item\end{DoxyCompactList}\item 
int \hyperlink{qubits_8h_a2ac46e470c750bf93c754e06c64b0a7a}{measureWithStats} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int measureQubit, REAL $\ast$stateProb)
\begin{DoxyCompactList}\small\item\em Measures a single qubit, collapsing it randomly to 0 or 1, and additionally gives the probability of that outcome. \item\end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
The QuEST library API and objects. 

Definition in file \hyperlink{qubits_8h_source}{qubits.h}.

\subsubsection{Enumeration Type Documentation}
\hypertarget{qubits_8h_a5739021c733cecc49647956b2f7338ea}{
\index{qubits.h@{qubits.h}!phaseGateType@{phaseGateType}}
\index{phaseGateType@{phaseGateType}!qubits.h@{qubits.h}}
\paragraph[{phaseGateType}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf phaseGateType}}\hfill}
\label{qubits_8h_a5739021c733cecc49647956b2f7338ea}
\begin{Desc}
\item[Enumerator: ]\par
\begin{description}
\index{SIGMA\_\-Z@{SIGMA\_\-Z}!qubits.h@{qubits.h}}\index{qubits.h@{qubits.h}!SIGMA\_\-Z@{SIGMA\_\-Z}}\item[{\em 
\hypertarget{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{
SIGMA\_\-Z}
\label{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}
}]\index{S\_\-GATE@{S\_\-GATE}!qubits.h@{qubits.h}}\index{qubits.h@{qubits.h}!S\_\-GATE@{S\_\-GATE}}\item[{\em 
\hypertarget{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{
S\_\-GATE}
\label{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}
}]\index{T\_\-GATE@{T\_\-GATE}!qubits.h@{qubits.h}}\index{qubits.h@{qubits.h}!T\_\-GATE@{T\_\-GATE}}\item[{\em 
\hypertarget{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{
T\_\-GATE}
\label{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}
}]\end{description}
\end{Desc}



Definition at line 73 of file qubits.h.


\begin{DoxyCode}
73 {SIGMA_Z=0, S_GATE=1, T_GATE=2};
\end{DoxyCode}


\subsubsection{Function Documentation}
\hypertarget{qubits_8h_a818a4c7cd7252d2b10b896b12fa431d3}{
\index{qubits.h@{qubits.h}!calcTotalProbability@{calcTotalProbability}}
\index{calcTotalProbability@{calcTotalProbability}!qubits.h@{qubits.h}}
\paragraph[{calcTotalProbability}]{\setlength{\rightskip}{0pt plus 5cm}REAL calcTotalProbability ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits_8h_a818a4c7cd7252d2b10b896b12fa431d3}


Calculate the probability of being in any state by taking the norm of the entire state vector. Should be equal to 1.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \end{DoxyParams}
\begin{DoxyReturn}{Returns}
total probability 
\end{DoxyReturn}


Definition at line 64 of file qubits\_\-env\_\-local.c.

References DEBUG, ComplexArray::imag, MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
64                                                 {
65   /* IJB - implemented using Kahan summation for greater accuracy at a slight flo
      ating
66      point operation overhead. For more details see https://en.wikipedia.org/wiki
      /Kahan_summation_algorithm */
67   /* Don't change the bracketing in this routine! */
68   REAL pTotal=0; 
69   REAL y, t, c;
70   long long int index;
71   long long int numAmpsPerRank = multiQubit.numAmps;
72   c = 0.0;
73   for (index=0; index<numAmpsPerRank; index++){ 
74     /* Perform pTotal+=multiQubit.stateVec.real[index]*multiQubit.stateVec.real[i
      ndex]; by Kahan */
75    // pTotal+=multiQubit.stateVec.real[index]*multiQubit.stateVec.real[index];
76     
77     y = multiQubit.stateVec.real[index]*multiQubit.stateVec.real[index] - c;
78     t = pTotal + y;
79     c = ( t - pTotal ) - y;
80     pTotal = t;
81     
82     /* Perform pTotal+=multiQubit.stateVec.imag[index]*multiQubit.stateVec.imag[i
      ndex]; by Kahan */
83     //pTotal+=multiQubit.stateVec.imag[index]*multiQubit.stateVec.imag[index];
84     
85     
86     y = multiQubit.stateVec.imag[index]*multiQubit.stateVec.imag[index] - c;
87     t = pTotal + y;
88     c = ( t - pTotal ) - y;
89     pTotal = t;
90     
91     
92   } 
93   return pTotal;
94 }
\end{DoxyCode}
\hypertarget{qubits_8h_abd4bc926cd3f9b65610bb228d0c59fe0}{
\index{qubits.h@{qubits.h}!closeQuESTEnv@{closeQuESTEnv}}
\index{closeQuESTEnv@{closeQuESTEnv}!qubits.h@{qubits.h}}
\paragraph[{closeQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void closeQuESTEnv ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8h_abd4bc926cd3f9b65610bb228d0c59fe0}


Close QuEST environment. If something needs to be done to clean up the execution environment, such as finalizing MPI when running in distributed mode, it is handled here


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 43 of file qubits\_\-env\_\-local.c.


\begin{DoxyCode}
43                                 {
44         // MPI finalize goes here in MPI version. Call this function anyway for c
      onsistency
45 }
\end{DoxyCode}
\hypertarget{qubits_8h_a07418ebac70fd9ae5d051d089961631d}{
\index{qubits.h@{qubits.h}!collapseToOutcome@{collapseToOutcome}}
\index{collapseToOutcome@{collapseToOutcome}!qubits.h@{qubits.h}}
\paragraph[{collapseToOutcome}]{\setlength{\rightskip}{0pt plus 5cm}REAL collapseToOutcome ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  int {\em outcome})}\hfill}
\label{qubits_8h_a07418ebac70fd9ae5d051d089961631d}


Updates the state vector to be consistent with measuring the measure qubit in the given outcome (0 or 1), and returns the probability of such a measurement outcome. This is effectively performing a measurement and forcing the outcome. This is an irreversible change to the state vector, whereby incompatible states in the state vector are given zero amplitude and the remaining states are renormalised. Exits with error if the given outcome has $\sim$zero probability, and so cannot be collapsed into.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em outcome}]to force the measure qubit to enter \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of the (forced) measurement outcome 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily measureQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or if {\ttfamily outcome} is not in \{0, 1\}, or if the probability of {\ttfamily outcome} is zero (within machine epsilon) \end{DoxyExceptions}


Definition at line 198 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, collapseToOutcomeDistributedRenorm(), collapseToOutcomeDistributedSetZero(), collapseToOutcomeLocal(), findProbabilityOfOutcome(), halfMatrixBlockFitsInChunk(), isChunkToSkipInFindPZero(), MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), REAL, and REAL\_\-EPS.


\begin{DoxyCode}
199 {
200     QuESTAssert(measureQubit >= 0 && measureQubit < multiQubit.numQubits, 2, __fu
      nc__);
201     QuESTAssert((outcome==0 || outcome==1), 10, __func__);
202     REAL stateProb;
203         stateProb = findProbabilityOfOutcome(multiQubit, measureQubit, outcome);
204     QuESTAssert(fabs(stateProb)>REAL_EPS, 8, __func__);
205     collapseToOutcomeLocal(multiQubit, measureQubit, stateProb, outcome);
206     return stateProb;
207 }
\end{DoxyCode}
\hypertarget{qubits_8h_a03b13dfcabd8c59b50dbdd3af44ba8b2}{
\index{qubits.h@{qubits.h}!compactUnitary@{compactUnitary}}
\index{compactUnitary@{compactUnitary}!qubits.h@{qubits.h}}
\paragraph[{compactUnitary}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitary ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits_8h_a03b13dfcabd8c59b50dbdd3af44ba8b2}


Apply a single-\/qubit unitary parameterised by two given complex scalars. Given valid complex numbers $\alpha$ and $\beta$, applies the unitary \[ U = \begin{pmatrix} \alpha & -\beta^* \\ \beta & \alpha^* \end{pmatrix} \] which is general up to a global phase factor. Valid $\alpha$, $\beta$ satisfy $|\alpha|^2 + |\beta|^2 = 1$.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {U}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \item[\mbox{$\leftarrow$} {\em alpha}]complex unitary parameter (row 1, column 1) \item[\mbox{$\leftarrow$} {\em beta}]complex unitary parameter (row 2, column 1) \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or if {\ttfamily alpha}, {\ttfamily beta} don't satisfy $|${\ttfamily alpha$|$$^\wedge$2} + $|${\ttfamily beta$|$$^\wedge$2} = 1. \end{DoxyExceptions}


Definition at line 104 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), compactUnitaryDistributed(), compactUnitaryLocal(), exchangeStateVectors(), getChunkPairId(), getRotAngle(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, and validateAlphaBeta().

Referenced by rotateAroundAxis().


\begin{DoxyCode}
105 {
106     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
107     QuESTAssert(validateAlphaBeta(alpha, beta), 6, __func__);
108 
109         // all values required to update state vector lie in this rank
110         compactUnitaryLocal(multiQubit, targetQubit, alpha, beta);
111 }
\end{DoxyCode}
\hypertarget{qubits_8h_ab4812953bc457405b3aa05a4c2f64f4a}{
\index{qubits.h@{qubits.h}!controlledCompactUnitary@{controlledCompactUnitary}}
\index{controlledCompactUnitary@{controlledCompactUnitary}!qubits.h@{qubits.h}}
\paragraph[{controlledCompactUnitary}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitary ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits_8h_ab4812953bc457405b3aa05a4c2f64f4a}


Apply a controlled unitary (single control, single target) parameterised by two given complex scalars. Given valid complex numbers $\alpha$ and $\beta$, applies the two-\/qubit unitary \[ \begin{pmatrix} 1 \\ & 1 \\ & & \alpha & -\beta^* \\ & & \beta & \alpha^* \end{pmatrix} \] to the control and target qubits. Valid $\alpha$, $\beta$ satisfy $|\alpha|^2 + |\beta|^2 = 1$. The target unitary is general up to a global phase factor.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {control}; \node[draw=none] at (-3.5, 0) {target}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 1); \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$U_{\alpha, \beta}$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em controlQubit}]apply the target unitary if this qubit has value 1 \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit on which to apply the target unitary \item[\mbox{$\leftarrow$} {\em alpha}]complex unitary parameter (row 1, column 1) \item[\mbox{$\leftarrow$} {\em beta}]complex unitary parameter (row 2, column 1) \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if either {\ttfamily controlQubit} or {\ttfamily targetQubit} are outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) or are equal, or if {\ttfamily alpha}, {\ttfamily beta} don't satisfy $|${\ttfamily alpha$|$$^\wedge$2} + $|${\ttfamily beta$|$$^\wedge$2} = 1. \end{DoxyExceptions}


Definition at line 122 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), controlledCompactUnitaryDistributed(), controlledCompactUnitaryLocal(), exchangeStateVectors(), getChunkPairId(), getRotAngle(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, and validateAlphaBeta().

Referenced by controlledRotateAroundAxis().


\begin{DoxyCode}
123 {
124     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
125     QuESTAssert(controlQubit >= 0 && controlQubit < multiQubit.numQubits, 2, __fu
      nc__);
126     QuESTAssert(controlQubit != targetQubit, 3, __func__);
127     QuESTAssert(validateAlphaBeta(alpha, beta), 6, __func__);
128     
129 
130         controlledCompactUnitaryLocal(multiQubit, controlQubit, targetQubit, alph
      a, beta);
131 }
\end{DoxyCode}
\hypertarget{qubits_8h_a67576895bbc65463481a8ea24d9b1e22}{
\index{qubits.h@{qubits.h}!controlledNot@{controlledNot}}
\index{controlledNot@{controlledNot}!qubits.h@{qubits.h}}
\paragraph[{controlledNot}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNot ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8h_a67576895bbc65463481a8ea24d9b1e22}


Apply the controlled not (single control, single target) gate, also known as the c-\/X, c-\/sigma-\/X, c-\/Pauli-\/X and c-\/bit-\/flip gate. This applies sigmaX to the target qubit if the control qubit has value 1. This effects the two-\/qubit unitary \[ \begin{pmatrix} 1 \\ & 1 \\\ & & & 1 \\ & & 1 \end{pmatrix} \] on the control and target qubits.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {control}; \node[draw=none] at (-3.5, 0) {target}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, -.5); \draw (-2,0) -- (2, 0); \draw (0, 0) circle (.5); \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em controlQubit}]nots the target if this qubit is 1 \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to not \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if either {\ttfamily controlQubit} or {\ttfamily targetQubit} are outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or are equal. \end{DoxyExceptions}


Definition at line 181 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), controlledNotDistributed(), controlledNotLocal(), exchangeStateVectors(), getChunkPairId(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), and MultiQubit::stateVec.


\begin{DoxyCode}
182 {
183     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
184     QuESTAssert(controlQubit >= 0 && controlQubit < multiQubit.numQubits, 2, __fu
      nc__);
185     QuESTAssert(controlQubit != targetQubit, 3, __func__);
186         controlledNotLocal(multiQubit, controlQubit, targetQubit);
187 }
\end{DoxyCode}
\hypertarget{qubits_8h_a11a96159191cbf1b01a1080e7f045aac}{
\index{qubits.h@{qubits.h}!controlledPhaseGate@{controlledPhaseGate}}
\index{controlledPhaseGate@{controlledPhaseGate}!qubits.h@{qubits.h}}
\paragraph[{controlledPhaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void controlledPhaseGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em idQubit1}, \/  const int {\em idQubit2})}\hfill}
\label{qubits_8h_a11a96159191cbf1b01a1080e7f045aac}


Apply the (two-\/qubit) controlled phase gate, also known as the controlled sigmaZ gate. For each state, if both input qubits have value one, multiply the amplitude of that state by -\/1. This applies the two-\/qubit unitary: \[ \begin{pmatrix} 1 \\ & 1 \\\ & & 1 \\ & & & -1 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {idQubit1}; \node[draw=none] at (-3.5, 0) {idQubit2}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 0); \draw (-2,0) -- (2, 0); \draw[fill=black] (0, 0) circle (.2); \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em idQubit1,idQubit2}]qubits to operate upon \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily idQubit1} or {\ttfamily idQubit2} are outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or are equal \end{DoxyExceptions}


Definition at line 1729 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
1730 {
1731         long long int index;
1732         long long int stateVecSize;
1733         int bit1, bit2;
1734 
1735         const long long int chunkSize=multiQubit.numAmps;
1736         const long long int chunkId=multiQubit.chunkId;
1737 
1738     QuESTAssert(idQubit1 >= 0 && idQubit1 < multiQubit.numQubits, 2, __func__);
1739     QuESTAssert(idQubit2 >= 0 && idQubit2 < multiQubit.numQubits, 1, __func__);
1740     QuESTAssert(idQubit1 != idQubit2, 3, __func__);
1741 
1742         // dimension of the state vector
1743         stateVecSize = multiQubit.numAmps;
1744         REAL *stateVecReal = multiQubit.stateVec.real;
1745         REAL *stateVecImag = multiQubit.stateVec.imag;
1746 
1747 # ifdef _OPENMP
1748 # pragma omp parallel for \
1749         default  (none)                      \
1750         shared   (stateVecSize, stateVecReal,stateVecImag ) \
1751         private  (index,bit1,bit2)                     \
1752         schedule (static)
1753 # endif
1754         for (index=0; index<stateVecSize; index++) {
1755                 bit1 = extractBit (idQubit1, index+chunkId*chunkSize);
1756                 bit2 = extractBit (idQubit2, index+chunkId*chunkSize);
1757                 if (bit1 && bit2) {
1758                         stateVecReal [index] = - stateVecReal [index];
1759                         stateVecImag [index] = - stateVecImag [index];
1760                 }
1761         }
1762 }
\end{DoxyCode}
\hypertarget{qubits_8h_ad41f82b41149393a642391b67b3a287e}{
\index{qubits.h@{qubits.h}!controlledRotateAroundAxis@{controlledRotateAroundAxis}}
\index{controlledRotateAroundAxis@{controlledRotateAroundAxis}!qubits.h@{qubits.h}}
\paragraph[{controlledRotateAroundAxis}]{\setlength{\rightskip}{0pt plus 5cm}void controlledRotateAroundAxis ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  REAL {\em angle}, \/  {\bf Vector} {\em axis})}\hfill}
\label{qubits_8h_ad41f82b41149393a642391b67b3a287e}


Applies a controlled rotation by a given angle around a given vector on the Bloch-\/sphere. The vector must not be zero (else an error is thrown), but needn't be unit magnitude.

For angle $\theta$ and axis vector $\vec{n}$, applies $R_{\hat{n}} = \exp \left(- i \frac{\theta}{2} \hat{n} \cdot \vec{\sigma} \right) $ to states where the target qubit is 1 ($\vec{\sigma}$ is the vector of Pauli matrices).

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {control}; \node[draw=none] at (-3.5, 0) {target}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 1); \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_{\hat{n}}(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit with value 1 in the rotated states \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \item[\mbox{$\leftarrow$} {\em axis}]vector around which to rotate (can be non-\/unit; will be normalised) \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if either {\ttfamily controlQubit} or {\ttfamily targetQubit} are outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) or are equal or if {\ttfamily axis} is the zero vector \end{DoxyExceptions}


Definition at line 413 of file qubits.c.

References controlledCompactUnitary(), Complex::imag, Complex::real, Vector::x, Vector::y, and Vector::z.

Referenced by controlledRotateX(), controlledRotateY(), and controlledRotateZ().


\begin{DoxyCode}
413                                                                                  
                                                   {
414         
415         double mag = sqrt(pow(axis.x,2) + pow(axis.y,2) + pow(axis.z,2));
416         Vector unitAxis = {axis.x/mag, axis.y/mag, axis.z/mag};
417         
418         Complex alpha, beta;
419         alpha.real = cos(angle/2.0);
420         alpha.imag = -sin(angle/2.0)*unitAxis.z;        
421         beta.real = sin(angle/2.0)*unitAxis.y;
422         beta.imag = -sin(angle/2.0)*unitAxis.x;
423         controlledCompactUnitary(multiQubit, controlQubit, targetQubit, alpha, be
      ta);
424 }
\end{DoxyCode}
\hypertarget{qubits_8h_ac6923ac57e67d9a21096e06f6a9012f6}{
\index{qubits.h@{qubits.h}!controlledRotateX@{controlledRotateX}}
\index{controlledRotateX@{controlledRotateX}!qubits.h@{qubits.h}}
\paragraph[{controlledRotateX}]{\setlength{\rightskip}{0pt plus 5cm}void controlledRotateX ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8h_ac6923ac57e67d9a21096e06f6a9012f6}


Applies a controlled rotation by a given angle around the X-\/axis of the Bloch-\/sphere. The target qubit is rotated in states where the control qubit has value 1.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {control}; \node[draw=none] at (-3.5, 0) {target}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 1); \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_x(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit which has value 1 in the rotated states \item[\mbox{$\leftarrow$} {\em tagretQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate the target qubit in radians \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if either {\ttfamily controlQubit} or {\ttfamily targetQubit} are outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) or are equal. \end{DoxyExceptions}


Definition at line 426 of file qubits.c.

References controlledRotateAroundAxis().


\begin{DoxyCode}
426                                                                                  
                             {
427 
428         Vector unitAxis = {1, 0, 0};
429         controlledRotateAroundAxis(multiQubit, controlQubit, targetQubit, angle, 
      unitAxis);
430 }
\end{DoxyCode}
\hypertarget{qubits_8h_a71e90a2f7292116338c062934f9d1202}{
\index{qubits.h@{qubits.h}!controlledRotateY@{controlledRotateY}}
\index{controlledRotateY@{controlledRotateY}!qubits.h@{qubits.h}}
\paragraph[{controlledRotateY}]{\setlength{\rightskip}{0pt plus 5cm}void controlledRotateY ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8h_a71e90a2f7292116338c062934f9d1202}


Applies a controlled rotation by a given angle around the Y-\/axis of the Bloch-\/sphere. The target qubit is rotated in states where the control qubit has value 1.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {control}; \node[draw=none] at (-3.5, 0) {target}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 1); \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_y(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit which has value 1 in the rotated states \item[\mbox{$\leftarrow$} {\em tagretQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate the target qubit in radians \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if either {\ttfamily controlQubit} or {\ttfamily targetQubit} are outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) or are equal. \end{DoxyExceptions}


Definition at line 432 of file qubits.c.

References controlledRotateAroundAxis().


\begin{DoxyCode}
432                                                                                  
                             {
433 
434         Vector unitAxis = {0, 1, 0};
435         controlledRotateAroundAxis(multiQubit, controlQubit, targetQubit, angle, 
      unitAxis);
436 }
\end{DoxyCode}
\hypertarget{qubits_8h_a668e5d2634b02e98bc73675ccb11d61c}{
\index{qubits.h@{qubits.h}!controlledRotateZ@{controlledRotateZ}}
\index{controlledRotateZ@{controlledRotateZ}!qubits.h@{qubits.h}}
\paragraph[{controlledRotateZ}]{\setlength{\rightskip}{0pt plus 5cm}void controlledRotateZ ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8h_a668e5d2634b02e98bc73675ccb11d61c}


Applies a controlled rotation by a given angle around the Z-\/axis of the Bloch-\/sphere. The target qubit is rotated in states where the control qubit has value 1.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {control}; \node[draw=none] at (-3.5, 0) {target}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 1); \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_z(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit which has value 1 in the rotated states \item[\mbox{$\leftarrow$} {\em tagretQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate the target qubit in radians \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if either {\ttfamily controlQubit} or {\ttfamily targetQubit} are outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) or are equal. \end{DoxyExceptions}


Definition at line 438 of file qubits.c.

References controlledRotateAroundAxis().


\begin{DoxyCode}
438                                                                                  
                             {
439 
440         Vector unitAxis = {0, 0, 1};
441         controlledRotateAroundAxis(multiQubit, controlQubit, targetQubit, angle, 
      unitAxis);
442 }
\end{DoxyCode}
\hypertarget{qubits_8h_a8a701526263392599aa21d0d0f05d9d8}{
\index{qubits.h@{qubits.h}!controlledUnitary@{controlledUnitary}}
\index{controlledUnitary@{controlledUnitary}!qubits.h@{qubits.h}}
\paragraph[{controlledUnitary}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitary ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8h_a8a701526263392599aa21d0d0f05d9d8}


Apply a general controlled unitary (single control, single target), which can include a global phase factor. The given unitary is applied to the target qubit if the control qubit has value 1, effecting the two-\/qubit unitary \[ \begin{pmatrix} 1 \\ & 1 \\ & & u_{00} & u_{01}\\ & & u_{10} & u_{11} \end{pmatrix} \] on the control and target qubits.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {control}; \node[draw=none] at (-3.5, 0) {target}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 1); \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {U}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em controlQubit}]apply unitary if this qubit is 1 \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \item[\mbox{$\leftarrow$} {\em u}]single-\/qubit unitary matrix to apply \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if either {\ttfamily controlQubit} or {\ttfamily targetQubit} are outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) or are equal, or if {\ttfamily u} is not unitary. \end{DoxyExceptions}


Definition at line 133 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), controlledUnitaryDistributed(), controlledUnitaryLocal(), exchangeStateVectors(), getChunkPairId(), getRotAngleFromUnitaryMatrix(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, and validateMatrixIsUnitary().


\begin{DoxyCode}
134 {
135     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
136     QuESTAssert(controlQubit >= 0 && controlQubit < multiQubit.numQubits, 2, __fu
      nc__);
137     QuESTAssert(controlQubit != targetQubit, 3, __func__);
138     QuESTAssert(validateMatrixIsUnitary(u), 5, __func__);
139    
140         controlledUnitaryLocal(multiQubit, controlQubit, targetQubit, u);
141 }
\end{DoxyCode}
\hypertarget{qubits_8h_a9c02591bc64c2918503afa231d90d83f}{
\index{qubits.h@{qubits.h}!createMultiQubit@{createMultiQubit}}
\index{createMultiQubit@{createMultiQubit}!qubits.h@{qubits.h}}
\paragraph[{createMultiQubit}]{\setlength{\rightskip}{0pt plus 5cm}void createMultiQubit ({\bf MultiQubit} $\ast$ {\em multiQubit}, \/  int {\em numQubits}, \/  {\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8h_a9c02591bc64c2918503afa231d90d83f}


Create a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. Allocate space for state vector of probability amplitudes, including space for temporary values to be copied from one other chunk if running the distributed version. Define properties related to the size of the set of qubits. initStateZero should be called after this to initialise the qubits to the zero state.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]a pointer to an object representing the set of qubits \item[\mbox{$\leftarrow$} {\em numQubits}]number of qubits in the system \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily numQubits} $<$= 0 \end{DoxyExceptions}


Definition at line 39 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, MultiQubit::numQubits, QuESTEnv::numRanks, MultiQubit::pairStateVec, QuESTAssert(), QuESTEnv::rank, ComplexArray::real, and MultiQubit::stateVec.


\begin{DoxyCode}
40 {
41     QuESTAssert(numQubits>0, 9, __func__);
42         long long int numAmps = 1L << numQubits;
43         long long int numAmpsPerRank = numAmps/env.numRanks;
44 
45         multiQubit->stateVec.real = malloc(numAmpsPerRank * sizeof(*(multiQubit->
      stateVec.real)));
46         multiQubit->stateVec.imag = malloc(numAmpsPerRank * sizeof(*(multiQubit->
      stateVec.imag)));
47         if (env.numRanks>1){
48                 multiQubit->pairStateVec.real = malloc(numAmpsPerRank * sizeof(*(
      multiQubit->pairStateVec.real)));
49                 multiQubit->pairStateVec.imag = malloc(numAmpsPerRank * sizeof(*(
      multiQubit->pairStateVec.imag)));
50         }
51 
52         if ( (!(multiQubit->stateVec.real) || !(multiQubit->stateVec.imag))
53                  && numAmpsPerRank ) {
54                 printf("Could not allocate memory!");
55                 exit (EXIT_FAILURE);
56         }
57 
58         if ( env.numRanks>1 && (!(multiQubit->pairStateVec.real) || !(multiQubit-
      >pairStateVec.imag))
59                  && numAmpsPerRank ) {
60                 printf("Could not allocate memory!");
61                 exit (EXIT_FAILURE);
62         }
63 
64         multiQubit->numQubits = numQubits;
65         multiQubit->numAmps = numAmpsPerRank;
66         multiQubit->chunkId = env.rank;
67         multiQubit->numChunks = env.numRanks;
68 
69 }
\end{DoxyCode}
\hypertarget{qubits_8h_ae5d6acc322314d7a3d8a2eccf00d3b19}{
\index{qubits.h@{qubits.h}!destroyMultiQubit@{destroyMultiQubit}}
\index{destroyMultiQubit@{destroyMultiQubit}!qubits.h@{qubits.h}}
\paragraph[{destroyMultiQubit}]{\setlength{\rightskip}{0pt plus 5cm}void destroyMultiQubit ({\bf MultiQubit} {\em multiQubit}, \/  {\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8h_ae5d6acc322314d7a3d8a2eccf00d3b19}


Deallocate a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. Free memory allocated to state vector of probability amplitudes, including temporary vector for values copied from another chunk if running the distributed version.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object to be deallocated \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}


Definition at line 71 of file qubits.c.

References ComplexArray::imag, QuESTEnv::numRanks, MultiQubit::pairStateVec, ComplexArray::real, and MultiQubit::stateVec.


\begin{DoxyCode}
71                                                            {
72         free(multiQubit.stateVec.real);
73         free(multiQubit.stateVec.imag);
74         if (env.numRanks>1){
75                 free(multiQubit.pairStateVec.real);
76                 free(multiQubit.pairStateVec.imag);
77         }
78 }
\end{DoxyCode}
\hypertarget{qubits_8h_ad315c941a51bc053d39ebfa2040fd32e}{
\index{qubits.h@{qubits.h}!findProbabilityOfOutcome@{findProbabilityOfOutcome}}
\index{findProbabilityOfOutcome@{findProbabilityOfOutcome}!qubits.h@{qubits.h}}
\paragraph[{findProbabilityOfOutcome}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfOutcome ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  int {\em outcome})}\hfill}
\label{qubits_8h_ad315c941a51bc053d39ebfa2040fd32e}


Gives the probability of a specified qubit being measured in the given outcome (0 or 1). This performs no actual measurement and does not change the state of the qubits.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to study \item[\mbox{$\leftarrow$} {\em outcome}]for which to find the probability of the qubit being measured in \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being measured in the given outcome 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily measureQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or if {\ttfamily outcome} is not in \{0, 1\}. \end{DoxyExceptions}


Definition at line 189 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, findProbabilityOfZeroDistributed(), findProbabilityOfZeroLocal(), halfMatrixBlockFitsInChunk(), isChunkToSkipInFindPZero(), MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), and REAL.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
190 {
191     QuESTAssert(measureQubit >= 0 && measureQubit < multiQubit.numQubits, 2, __fu
      nc__);
192         REAL stateProb=0;
193         stateProb = findProbabilityOfZeroLocal(multiQubit, measureQubit);
194         if (outcome==1) stateProb = 1.0 - stateProb;
195         return stateProb;
196 }
\end{DoxyCode}
\hypertarget{qubits_8h_a8f10aabf9f607f19093aee54630caa21}{
\index{qubits.h@{qubits.h}!getEnvironmentString@{getEnvironmentString}}
\index{getEnvironmentString@{getEnvironmentString}!qubits.h@{qubits.h}}
\paragraph[{getEnvironmentString}]{\setlength{\rightskip}{0pt plus 5cm}void getEnvironmentString ({\bf QuESTEnv} {\em env}, \/  {\bf MultiQubit} {\em multiQubit}, \/  char {\em str}\mbox{[}200\mbox{]})}\hfill}
\label{qubits_8h_a8f10aabf9f607f19093aee54630caa21}


Definition at line 131 of file qubits.c.

References MultiQubit::numQubits, and QuESTEnv::numRanks.


\begin{DoxyCode}
131                                                                              {
132         int numThreads=1;
133 # ifdef _OPENMP
134         numThreads=omp_get_max_threads(); 
135 # endif
136         sprintf(str, "%dqubits_CPU_%dranksx%dthreads", multiQubit.numQubits, env.
      numRanks, numThreads);
137 }
\end{DoxyCode}
\hypertarget{qubits_8h_a3615f76fd5f57008d9b74bbd10533dd0}{
\index{qubits.h@{qubits.h}!getImagAmpEl@{getImagAmpEl}}
\index{getImagAmpEl@{getImagAmpEl}!qubits.h@{qubits.h}}
\paragraph[{getImagAmpEl}]{\setlength{\rightskip}{0pt plus 5cm}REAL getImagAmpEl ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})}\hfill}
\label{qubits_8h_a3615f76fd5f57008d9b74bbd10533dd0}


Get the imaginary component of the complex probability amplitude at an index in the state vector. For debugging purposes.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \item[\mbox{$\leftarrow$} {\em index}]index in state vector of probability amplitudes \end{DoxyParams}
\begin{DoxyReturn}{Returns}
imaginary component at that index 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily index} is outside \mbox{[}0, $2^{N}$) where $N = $ {\ttfamily multiQubit.numQubits} \end{DoxyExceptions}


Definition at line 100 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, getChunkIdFromIndex(), ComplexArray::imag, MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, REAL, and MultiQubit::stateVec.

Referenced by getProbEl().


\begin{DoxyCode}
100                                                              {
101         return multiQubit.stateVec.imag[index];
102 }
\end{DoxyCode}
\hypertarget{qubits_8h_a799b10447d6dbdaf960a4d3eedd22014}{
\index{qubits.h@{qubits.h}!getProbEl@{getProbEl}}
\index{getProbEl@{getProbEl}!qubits.h@{qubits.h}}
\paragraph[{getProbEl}]{\setlength{\rightskip}{0pt plus 5cm}REAL getProbEl ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})}\hfill}
\label{qubits_8h_a799b10447d6dbdaf960a4d3eedd22014}


Get the probability of the state at an index in the full state vector. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \item[\mbox{$\leftarrow$} {\em index}]index in state vector of probability amplitudes \end{DoxyParams}
\begin{DoxyReturn}{Returns}
realEl$\ast$realEl + imagEl$\ast$imagEl 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily index} is outside \mbox{[}0, $2^{N}$) where $N = $ {\ttfamily multiQubit.numQubits} \end{DoxyExceptions}


Definition at line 1971 of file qubits.c.

References getImagAmpEl(), getRealAmpEl(), and REAL.


\begin{DoxyCode}
1971                                                           {
1972         REAL real;
1973         REAL imag;
1974         real = getRealAmpEl(multiQubit, index);
1975         imag = getImagAmpEl(multiQubit, index);
1976         return real*real + imag*imag;
1977 }
\end{DoxyCode}
\hypertarget{qubits_8h_a317b786f577fa6bc136ea7f0ee7330a7}{
\index{qubits.h@{qubits.h}!getRealAmpEl@{getRealAmpEl}}
\index{getRealAmpEl@{getRealAmpEl}!qubits.h@{qubits.h}}
\paragraph[{getRealAmpEl}]{\setlength{\rightskip}{0pt plus 5cm}REAL getRealAmpEl ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})}\hfill}
\label{qubits_8h_a317b786f577fa6bc136ea7f0ee7330a7}


Get the real component of the complex probability amplitude at an index in the state vector. For debugging purposes.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \item[\mbox{$\leftarrow$} {\em index}]index in state vector of probability amplitudes \end{DoxyParams}
\begin{DoxyReturn}{Returns}
real component at that index 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily index} is outside \mbox{[}0, $2^{N}$) where $N = $ {\ttfamily multiQubit.numQubits} \end{DoxyExceptions}


Definition at line 96 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, getChunkIdFromIndex(), MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, REAL, ComplexArray::real, and MultiQubit::stateVec.

Referenced by getProbEl().


\begin{DoxyCode}
96                                                              {
97         return multiQubit.stateVec.real[index];
98 }
\end{DoxyCode}
\hypertarget{qubits_8h_aa09b5dd93de6df1384b8f2c0041749ab}{
\index{qubits.h@{qubits.h}!hadamard@{hadamard}}
\index{hadamard@{hadamard}!qubits.h@{qubits.h}}
\paragraph[{hadamard}]{\setlength{\rightskip}{0pt plus 5cm}void hadamard ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8h_aa09b5dd93de6df1384b8f2c0041749ab}


Apply the single-\/qubit Hadamard gate. This takes $|0\rangle$ to $|+\rangle$ and $|1\rangle$ to $|-\rangle$, and is equivalent to a rotation of $\pi$ around the x-\/axis then $\pi/2$ about the y-\/axis on the Bloch-\/sphere. I.e. \[ \frac{1}{\sqrt{2}} \begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {H}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 175 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), hadamardDistributed(), hadamardLocal(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), and MultiQubit::stateVec.


\begin{DoxyCode}
176 {
177     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
178         hadamardLocal(multiQubit, targetQubit);
179 }
\end{DoxyCode}
\hypertarget{qubits_8h_ad84a3ce68d1ca02b4e3f741ea45b6054}{
\index{qubits.h@{qubits.h}!initQuESTEnv@{initQuESTEnv}}
\index{initQuESTEnv@{initQuESTEnv}!qubits.h@{qubits.h}}
\paragraph[{initQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void initQuESTEnv ({\bf QuESTEnv} $\ast$ {\em env})}\hfill}
\label{qubits_8h_ad84a3ce68d1ca02b4e3f741ea45b6054}


Initialize the QuEST environment. If something needs to be done to set up the execution environment, such as initializing MPI when running in distributed mode, it is handled here


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 22 of file qubits\_\-env\_\-local.c.

References DEBUG, init\_\-by\_\-array(), QuESTEnv::numRanks, and QuESTEnv::rank.


\begin{DoxyCode}
22                                 {
23         // init MPI environment
24         env->rank=0;
25         env->numRanks=1;
26 
27     // init MT random number generator with two keys -- time and pid
28     unsigned long int secs = time(NULL);
29     unsigned long int pid = getpid();
30     unsigned long int key[2];
31     key[0] = secs; key[1] = pid;
32     init_by_array(key, 2);
33 }
\end{DoxyCode}
\hypertarget{qubits_8h_a43bcb279fc9717fbd06a19cdef48b9d8}{
\index{qubits.h@{qubits.h}!initStatePlus@{initStatePlus}}
\index{initStatePlus@{initStatePlus}!qubits.h@{qubits.h}}
\paragraph[{initStatePlus}]{\setlength{\rightskip}{0pt plus 5cm}void initStatePlus ({\bf MultiQubit} $\ast$ {\em multiQubit})}\hfill}
\label{qubits_8h_a43bcb279fc9717fbd06a19cdef48b9d8}


Initialise a set of $ N $ qubits to the plus state $ {| + \rangle}^{\otimes N} = \frac{1}{\sqrt{2^N}} (| 0 \rangle + | 1 \rangle)^{\otimes N} $. This is the product state of $N$ qubits where every classical state is uniformly populated with real coefficient $\frac{1}{\sqrt{2^N}}$. This is equivalent to applying a Hadamard to every qubit in the zero state: $ \hat{H}^{\otimes N} {|0\rangle}^{\otimes N} $


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]a pointer to the object representing the set of qubits to be initialised \end{DoxyParams}


Definition at line 177 of file qubits.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
178 {
179         long long int chunkSize, stateVecSize;
180         long long int index;
181 
182         // dimension of the state vector
183         chunkSize = multiQubit->numAmps;
184         stateVecSize = chunkSize*multiQubit->numChunks;
185         REAL normFactor = 1.0/sqrt((REAL)stateVecSize);
186 
187         // Can't use multiQubit->stateVec as a private OMP var
188         REAL *stateVecReal = multiQubit->stateVec.real;
189         REAL *stateVecImag = multiQubit->stateVec.imag;
190 
191         // initialise the state to |0000..0000>
192 # ifdef _OPENMP
193 # pragma omp parallel \
194         default  (none) \
195         shared   (chunkSize, stateVecReal, stateVecImag, normFactor) \
196         private  (index) 
197 # endif
198         {
199 # ifdef _OPENMP
200                 # pragma omp for schedule (static)
201 # endif
202                 for (index=0; index<chunkSize; index++) {
203                         stateVecReal[index] = normFactor;
204                         stateVecImag[index] = 0.0;
205                 }
206         }
207         if (DEBUG) printf("COMPLETED INIT\n");
208 }
\end{DoxyCode}
\hypertarget{qubits_8h_acb5b2eff794339090004d29f02a70d9a}{
\index{qubits.h@{qubits.h}!initStateZero@{initStateZero}}
\index{initStateZero@{initStateZero}!qubits.h@{qubits.h}}
\paragraph[{initStateZero}]{\setlength{\rightskip}{0pt plus 5cm}void initStateZero ({\bf MultiQubit} $\ast$ {\em multiQubit})}\hfill}
\label{qubits_8h_acb5b2eff794339090004d29f02a70d9a}


Initialise a set of $ N $ qubits to the classical zero state $ {| 0 \rangle}^{\otimes N} $. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]a pointer to the object representing the set of all qubits to initialise \end{DoxyParams}


Definition at line 139 of file qubits.c.

References MultiQubit::chunkId, DEBUG, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
140 {
141         long long int stateVecSize;
142         long long int index;
143 
144         // dimension of the state vector
145         stateVecSize = multiQubit->numAmps;
146 
147         // Can't use multiQubit->stateVec as a private OMP var
148         REAL *stateVecReal = multiQubit->stateVec.real;
149         REAL *stateVecImag = multiQubit->stateVec.imag;
150 
151         // initialise the state to |0000..0000>
152 # ifdef _OPENMP
153 # pragma omp parallel \
154         default  (none) \
155         shared   (stateVecSize, stateVecReal, stateVecImag) \
156         private  (index) 
157 # endif
158         {
159 # ifdef _OPENMP
160                 # pragma omp for schedule (static)
161 # endif
162                 for (index=0; index<stateVecSize; index++) {
163                         stateVecReal[index] = 0.0;
164                         stateVecImag[index] = 0.0;
165                 }
166         }
167 
168         if (multiQubit->chunkId==0){
169                 // zero state |0000..0000> has probability 1
170                 stateVecReal[0] = 1.0;
171                 stateVecImag[0] = 0.0;
172         }
173 
174         if (DEBUG) printf("COMPLETED INIT\n");
175 }
\end{DoxyCode}
\hypertarget{qubits_8h_ad5774247d836267175c664cd0e451bcb}{
\index{qubits.h@{qubits.h}!measure@{measure}}
\index{measure@{measure}!qubits.h@{qubits.h}}
\paragraph[{measure}]{\setlength{\rightskip}{0pt plus 5cm}int measure ({\bf MultiQubit} {\em multiQubit}, \/  int {\em measureQubit})}\hfill}
\label{qubits_8h_ad5774247d836267175c664cd0e451bcb}


Measures a single qubit, collapsing it randomly to 0 or 1. Outcome probabilities are weighted by the state vector, which is irreversibly changed after collapse to be consistent with the outcome.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
the measurement outcome, 0 or 1 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily measureQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) \end{DoxyExceptions}


Definition at line 209 of file qubits\_\-env\_\-local.c.

References measureWithStats(), MultiQubit::numQubits, QuESTAssert(), and REAL.


\begin{DoxyCode}
209                                                     {
210     QuESTAssert(measureQubit >= 0 && measureQubit < multiQubit.numQubits, 2, __fu
      nc__);
211     REAL stateProb;
212     return measureWithStats(multiQubit, measureQubit, &stateProb);
213 }
\end{DoxyCode}
\hypertarget{qubits_8h_a2ac46e470c750bf93c754e06c64b0a7a}{
\index{qubits.h@{qubits.h}!measureWithStats@{measureWithStats}}
\index{measureWithStats@{measureWithStats}!qubits.h@{qubits.h}}
\paragraph[{measureWithStats}]{\setlength{\rightskip}{0pt plus 5cm}int measureWithStats ({\bf MultiQubit} {\em multiQubit}, \/  int {\em measureQubit}, \/  REAL $\ast$ {\em stateProb})}\hfill}
\label{qubits_8h_a2ac46e470c750bf93c754e06c64b0a7a}


Measures a single qubit, collapsing it randomly to 0 or 1, and additionally gives the probability of that outcome. Outcome probabilities are weighted by the state vector, which is irreversibly changed after collapse to be consistent with the outcome.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\rightarrow$} {\em stateProb}]a pointer to a REAL which is set to the probability of the occurred outcome \end{DoxyParams}
\begin{DoxyReturn}{Returns}
the measurement outcome, 0 or 1 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily measureQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) \end{DoxyExceptions}


Definition at line 215 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, collapseToOutcomeDistributedRenorm(), collapseToOutcomeDistributedSetZero(), collapseToOutcomeLocal(), findProbabilityOfOutcome(), genrand\_\-real1(), halfMatrixBlockFitsInChunk(), isChunkToSkipInFindPZero(), MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), REAL, and REAL\_\-EPS.

Referenced by measure().


\begin{DoxyCode}
215                                                                               {
216     QuESTAssert(measureQubit >= 0 && measureQubit < multiQubit.numQubits, 2, __fu
      nc__);
217 
218     int outcome;
219     // find probability of qubit being in state 1
220         REAL stateProbInternal = findProbabilityOfOutcome(multiQubit, measureQubi
      t, 1);
221 
222     // we can't collapse to a state that has a probability too close to zero
223     if (stateProbInternal<REAL_EPS) outcome=0;
224     else if (1-stateProbInternal<REAL_EPS) outcome=1;
225     else {
226         // ok. both P(0) and P(1) are large enough to resolve
227         // generate random float on [0,1]
228         float randNum = genrand_real1();
229         if (randNum<=stateProbInternal) outcome = 1;
230         else outcome = 0;
231     } 
232     if (outcome==0) stateProbInternal = 1-stateProbInternal;
233     collapseToOutcomeLocal(multiQubit, measureQubit, stateProbInternal, outcome);
      
234     *stateProb = stateProbInternal;
235     return outcome;
236 }
\end{DoxyCode}
\hypertarget{qubits_8h_afc1835c6b43b6e59ce7df7b13f274fc7}{
\index{qubits.h@{qubits.h}!multiControlledPhaseGate@{multiControlledPhaseGate}}
\index{multiControlledPhaseGate@{multiControlledPhaseGate}!qubits.h@{qubits.h}}
\paragraph[{multiControlledPhaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledPhaseGate ({\bf MultiQubit} {\em multiQubit}, \/  int $\ast$ {\em controlQubits}, \/  int {\em numControlQubits})}\hfill}
\label{qubits_8h_afc1835c6b43b6e59ce7df7b13f274fc7}


Apply the multiple-\/qubit controlled phase gate, also known as the multiple-\/qubit controlled sigmaZ gate. For each state, if all control qubits have value one, multiply the amplitude of that state by -\/1. This applies the many-\/qubit unitary: \[ \begin{pmatrix} 1 \\ & 1 \\\ & & \ddots \\ & & & 1 \\ & & & & -1 \end{pmatrix} \] on the control qubits.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {controls}; \node[draw=none] at (0, 6) {$\vdots$}; \draw (0, 5) -- (0, 4); \draw (-2, 4) -- (2, 4); \draw[fill=black] (0, 4) circle (.2); \draw (0, 4) -- (0, 2); \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 0); \draw (-2,0) -- (2, 0); \draw[fill=black] (0, 0) circle (.2); \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em controlQubits}]array of input qubits \item[\mbox{$\leftarrow$} {\em numControlQubits}]number of input qubits \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily numControlQubits} is outside \mbox{[}1, {\ttfamily multiQubit.numQubits}) \end{DoxyExceptions}


Definition at line 1764 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
1765 {
1766         long long int index;
1767         long long int stateVecSize;
1768         
1769         const long long int chunkSize=multiQubit.numAmps;
1770         const long long int chunkId=multiQubit.chunkId;
1771 
1772     QuESTAssert(numControlQubits > 0 && numControlQubits <= multiQubit.numQubits,
       4, __func__);
1773     long long int mask=0;
1774     for (int i=0; i<numControlQubits; i++) mask = mask | (1LL<<controlQubits[i]);
      
1775     QuESTAssert(mask >=0 && mask <= (1LL<<multiQubit.numQubits)-1, 2, __func__);
1776 
1777         stateVecSize = multiQubit.numAmps;
1778         REAL *stateVecReal = multiQubit.stateVec.real;
1779         REAL *stateVecImag = multiQubit.stateVec.imag;
1780 
1781 # ifdef _OPENMP
1782 # pragma omp parallel \
1783         default  (none)                      \
1784         shared   (stateVecSize, stateVecReal,stateVecImag, mask ) \
1785         private  (index)
1786 # endif
1787         {
1788 # ifdef _OPENMP
1789                 # pragma omp for schedule (static)
1790 # endif
1791                 for (index=0; index<stateVecSize; index++) {
1792                         if (mask == (mask & (index+chunkId*chunkSize)) ){
1793                                 stateVecReal [index] = - stateVecReal [index];
1794                                 stateVecImag [index] = - stateVecImag [index];
1795                         }
1796                 }
1797         }
1798 }
\end{DoxyCode}
\hypertarget{qubits_8h_ae395a79690283ed81106afadd7a8cd8a}{
\index{qubits.h@{qubits.h}!multiControlledUnitary@{multiControlledUnitary}}
\index{multiControlledUnitary@{multiControlledUnitary}!qubits.h@{qubits.h}}
\paragraph[{multiControlledUnitary}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitary ({\bf MultiQubit} {\em multiQubit}, \/  int $\ast$ {\em controlQubits}, \/  const int {\em numControlQubits}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8h_ae395a79690283ed81106afadd7a8cd8a}


Apply a general multiple-\/control single-\/target unitary, which can include a global phase factor. Any number of control qubits can be specified, and if all have value 1, the given unitary is applied to the target qubit. This effects the many-\/qubit unitary \[ \begin{pmatrix} 1 \\ & 1 \\\ & & \ddots \\ & & & u_{00} & u_{01}\\ & & & u_{10} & u_{11} \end{pmatrix} \] on the control and target qubits. The given 2x2 ComplexMatrix must be unitary, otherwise an error is thrown.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 3) {controls}; \node[draw=none] at (-3.5, 0) {target}; \node[draw=none] at (0, 6) {$\vdots$}; \draw (0, 5) -- (0, 4); \draw (-2, 4) -- (2, 4); \draw[fill=black] (0, 4) circle (.2); \draw (0, 4) -- (0, 2); \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 1); \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {U}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em controlQubits}]applies unitary if all qubits in this array equal 1 \item[\mbox{$\leftarrow$} {\em numControlQubits}]number of control qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \item[\mbox{$\leftarrow$} {\em u}]single-\/qubit unitary matrix to apply \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily numControlQubits} is outside \mbox{[}1, {\ttfamily multiQubit.numQubits}\mbox{]}), or if any qubit index ({\ttfamily targetQubit} or one in {\ttfamily controlQubits}) is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}\mbox{]}), or if {\ttfamily controlQubits} contains {\ttfamily targetQubit}, or if {\ttfamily u} is not unitary. \end{DoxyExceptions}


Definition at line 143 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), getRotAngleFromUnitaryMatrix(), halfMatrixBlockFitsInChunk(), multiControlledUnitaryDistributed(), multiControlledUnitaryLocal(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, and validateMatrixIsUnitary().


\begin{DoxyCode}
144 {
145     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
146     QuESTAssert(numControlQubits > 0 && numControlQubits <= multiQubit.numQubits,
       4, __func__);
147     QuESTAssert(validateMatrixIsUnitary(u), 5, __func__);
148 
149     long long int mask=0; 
150     for (int i=0; i<numControlQubits; i++) mask = mask | (1LL<<controlQubits[i]);
      
151     QuESTAssert(mask >=0 && mask <= (1LL<<multiQubit.numQubits)-1, 2, __func__);
152     QuESTAssert((mask & (1LL<<targetQubit)) != (1LL<<targetQubit), 3, __func__);
153         
154     multiControlledUnitaryLocal(multiQubit, targetQubit, mask, u);
155 }
\end{DoxyCode}
\hypertarget{qubits_8h_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}{
\index{qubits.h@{qubits.h}!reportMultiQubitParams@{reportMultiQubitParams}}
\index{reportMultiQubitParams@{reportMultiQubitParams}!qubits.h@{qubits.h}}
\paragraph[{reportMultiQubitParams}]{\setlength{\rightskip}{0pt plus 5cm}void reportMultiQubitParams ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits_8h_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}


Report metainformation about a set of qubits: number of qubits, number of probability amplitudes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}


Definition at line 120 of file qubits.c.

References MultiQubit::chunkId, MultiQubit::numChunks, and MultiQubit::numQubits.


\begin{DoxyCode}
120                                                   {
121         long long int numAmps = 1L << multiQubit.numQubits;
122         long long int numAmpsPerRank = numAmps/multiQubit.numChunks;
123         if (multiQubit.chunkId==0){
124                 printf("QUBITS:\n");
125                 printf("Number of qubits is %d.\n", multiQubit.numQubits);
126                 printf("Number of amps is %lld.\n", numAmps);
127                 printf("Number of amps per rank is %lld.\n", numAmpsPerRank);
128         }
129 }
\end{DoxyCode}
\hypertarget{qubits_8h_af8a14ae79c3fb2c0b5f6255cc37bebf9}{
\index{qubits.h@{qubits.h}!reportQuESTEnv@{reportQuESTEnv}}
\index{reportQuESTEnv@{reportQuESTEnv}!qubits.h@{qubits.h}}
\paragraph[{reportQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void reportQuESTEnv ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8h_af8a14ae79c3fb2c0b5f6255cc37bebf9}


Report information about the QuEST environment. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 47 of file qubits\_\-env\_\-local.c.

References QuESTEnv::numRanks, QuESTEnv::rank, and REAL.


\begin{DoxyCode}
47                                  {
48         printf("EXECUTION ENVIRONMENT:\n");
49         printf("Running locally on one node\n");
50         printf("Number of ranks is %d\n", env.numRanks);
51 # ifdef _OPENMP
52         printf("OpenMP enabled\n");
53         printf("Number of threads available is %d\n", omp_get_max_threads());
54 # else
55         printf("OpenMP disabled\n");
56 # endif
57         printf("Precision: size of REAL is %ld bytes\n", sizeof(REAL));
58 }
\end{DoxyCode}
\hypertarget{qubits_8h_a96f4de9ce7fefc7680a44d601fc3d894}{
\index{qubits.h@{qubits.h}!reportState@{reportState}}
\index{reportState@{reportState}!qubits.h@{qubits.h}}
\paragraph[{reportState}]{\setlength{\rightskip}{0pt plus 5cm}void reportState ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits_8h_a96f4de9ce7fefc7680a44d601fc3d894}


Print the current state vector of probability amplitudes for a set of qubits to file. File format: \begin{DoxyVerb}
real, imag
realComponent1, imagComponent1
realComponent2, imagComponent2
...
realComponentN, imagComponentN
\end{DoxyVerb}


File naming convention:

For each node that the program runs on, a file 'state\_\-rank\_\-\mbox{[}node\_\-rank\mbox{]}.csv' is generated. If there is more than one node, ranks after the first do not include the header \begin{DoxyVerb}
real, imag
\end{DoxyVerb}
 so that files are easier to combine.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \end{DoxyParams}


Definition at line 81 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL\_\-STRING\_\-FORMAT, and MultiQubit::stateVec.


\begin{DoxyCode}
81                                        {
82         FILE *state;
83         char filename[100];
84         long long int index;
85         sprintf(filename, "state_rank_%d.csv", multiQubit.chunkId);
86         state = fopen(filename, "w");
87         if (multiQubit.chunkId==0) fprintf(state, "real, imag\n");
88 
89         for(index=0; index<multiQubit.numAmps; index++){
90                 fprintf(state, REAL_STRING_FORMAT "," REAL_STRING_FORMAT "\n", mu
      ltiQubit.stateVec.real[index], multiQubit.stateVec.imag[index]);
91         }
92         fclose(state);
93 }
\end{DoxyCode}
\hypertarget{qubits_8h_a842d6884e063a5865a2232cba56b65ac}{
\index{qubits.h@{qubits.h}!reportStateToScreen@{reportStateToScreen}}
\index{reportStateToScreen@{reportStateToScreen}!qubits.h@{qubits.h}}
\paragraph[{reportStateToScreen}]{\setlength{\rightskip}{0pt plus 5cm}void reportStateToScreen ({\bf MultiQubit} {\em multiQubit}, \/  {\bf QuESTEnv} {\em env}, \/  int {\em reportRank})}\hfill}
\label{qubits_8h_a842d6884e063a5865a2232cba56b65ac}


Print the current state vector of probability amplitudes for a set of qubits to standard out. For debugging purposes. Each rank should print output serially. Only print output for systems $<$= 5 qubits 

Definition at line 95 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, MultiQubit::numQubits, ComplexArray::real, REAL\_\-STRING\_\-FORMAT, MultiQubit::stateVec, and syncQuESTEnv().


\begin{DoxyCode}
95                                                                              {
96         long long int index;
97         int rank;
98         if (multiQubit.numQubits<=5){
99                 for (rank=0; rank<multiQubit.numChunks; rank++){
100                         if (multiQubit.chunkId==rank){
101                                 if (reportRank) {
102                                         printf("Reporting state from rank %d [\n"
      , multiQubit.chunkId);
103                                         //printf("\trank, index, real, imag\n");
104                                         printf("real, imag\n");
105                                 } else if (rank==0) {
106                                         printf("Reporting state [\n");
107                                         printf("real, imag\n");
108                                 }
109 
110                                 for(index=0; index<multiQubit.numAmps; index++){
111                                         printf(REAL_STRING_FORMAT ", " 
      REAL_STRING_FORMAT "\n", multiQubit.stateVec.real[index], multiQubit.stateVec.
      imag[index]);
112                                 }
113                                 if (reportRank || rank==multiQubit.numChunks-1) p
      rintf("]\n");
114                         }
115                         syncQuESTEnv(env);
116                 }
117         } else printf("Error: reportStateToScreen will not print output for syste
      ms of more than 5 qubits.\n");
118 }
\end{DoxyCode}
\hypertarget{qubits_8h_a8810423457803005fecd415f4299f40d}{
\index{qubits.h@{qubits.h}!rotateAroundAxis@{rotateAroundAxis}}
\index{rotateAroundAxis@{rotateAroundAxis}!qubits.h@{qubits.h}}
\paragraph[{rotateAroundAxis}]{\setlength{\rightskip}{0pt plus 5cm}void rotateAroundAxis ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle}, \/  {\bf Vector} {\em axis})}\hfill}
\label{qubits_8h_a8810423457803005fecd415f4299f40d}


Rotate a single qubit by a given angle around a given vector on the Bloch-\/sphere. The vector must not be zero (else an error is thrown), but needn't be unit magnitude.

For angle $\theta$ and axis vector $\vec{n}$, applies $R_{\hat{n}} = \exp \left(- i \frac{\theta}{2} \hat{n} \cdot \vec{\sigma} \right) $ where $\vec{\sigma}$ is the vector of Pauli matrices.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \item[\mbox{$\leftarrow$} {\em axis}]vector around which to rotate (can be non-\/unit; will be normalised) \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily rotQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or if {\ttfamily axis} is the zero vector \end{DoxyExceptions}


Definition at line 382 of file qubits.c.

References compactUnitary(), Complex::imag, Complex::real, Vector::x, Vector::y, and Vector::z.

Referenced by rotateX(), rotateY(), and rotateZ().


\begin{DoxyCode}
382                                                                                  
              {
383         
384         double mag = sqrt(pow(axis.x,2) + pow(axis.y,2) + pow(axis.z,2));
385         Vector unitAxis = {axis.x/mag, axis.y/mag, axis.z/mag};
386         
387         Complex alpha, beta;
388         alpha.real = cos(angle/2.0);
389         alpha.imag = -sin(angle/2.0)*unitAxis.z;        
390         beta.real = sin(angle/2.0)*unitAxis.y;
391         beta.imag = -sin(angle/2.0)*unitAxis.x;
392         compactUnitary(multiQubit, rotQubit, alpha, beta);
393 }
\end{DoxyCode}
\hypertarget{qubits_8h_a6cc7fa705a2f2e6b486b49c5589d5df5}{
\index{qubits.h@{qubits.h}!rotateX@{rotateX}}
\index{rotateX@{rotateX}!qubits.h@{qubits.h}}
\paragraph[{rotateX}]{\setlength{\rightskip}{0pt plus 5cm}void rotateX ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8h_a6cc7fa705a2f2e6b486b49c5589d5df5}


Rotate a single qubit by a given angle around the X-\/axis of the Bloch-\/sphere. For angle $\theta$, applies \[ \begin{pmatrix} \cos\theta/2 & -i \sin \theta/2\\ -i \sin \theta/2 & \cos \theta/2 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {rot}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_x(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily rotQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 395 of file qubits.c.

References rotateAroundAxis().


\begin{DoxyCode}
395                                                                    {
396 
397         Vector unitAxis = {1, 0, 0};
398         rotateAroundAxis(multiQubit, rotQubit, angle, unitAxis);
399 }
\end{DoxyCode}
\hypertarget{qubits_8h_ace0d3592d38a990e81a434c4e9681500}{
\index{qubits.h@{qubits.h}!rotateY@{rotateY}}
\index{rotateY@{rotateY}!qubits.h@{qubits.h}}
\paragraph[{rotateY}]{\setlength{\rightskip}{0pt plus 5cm}void rotateY ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8h_ace0d3592d38a990e81a434c4e9681500}


Rotate a single qubit by a given angle around the Y-\/axis of the Bloch-\/sphere. For angle $\theta$, applies \[ \begin{pmatrix} \cos\theta/2 & - \sin \theta/2\\ \sin \theta/2 & \cos \theta/2 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {rot}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_y(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily rotQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 401 of file qubits.c.

References rotateAroundAxis().


\begin{DoxyCode}
401                                                                    {
402         
403         Vector unitAxis = {0, 1, 0};
404         rotateAroundAxis(multiQubit, rotQubit, angle, unitAxis);
405 }
\end{DoxyCode}
\hypertarget{qubits_8h_abd621412ad30c1b034f4ce153c4afe10}{
\index{qubits.h@{qubits.h}!rotateZ@{rotateZ}}
\index{rotateZ@{rotateZ}!qubits.h@{qubits.h}}
\paragraph[{rotateZ}]{\setlength{\rightskip}{0pt plus 5cm}void rotateZ ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8h_abd621412ad30c1b034f4ce153c4afe10}


Rotate a single qubit by a given angle around the Z-\/axis of the Bloch-\/sphere (also known as a phase shift gate). For angle $\theta$, applies \[ \begin{pmatrix} \exp(-i \theta/2) & 0 \\ 0 & \exp(i \theta/2) \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {rot}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_z(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily rotQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 407 of file qubits.c.

References rotateAroundAxis().


\begin{DoxyCode}
407                                                                    {
408         
409         Vector unitAxis = {0, 0, 1};
410         rotateAroundAxis(multiQubit, rotQubit, angle, unitAxis);
411 }
\end{DoxyCode}
\hypertarget{qubits_8h_adda6c47876a7676488ed0565a19eaa65}{
\index{qubits.h@{qubits.h}!sGate@{sGate}}
\index{sGate@{sGate}!qubits.h@{qubits.h}}
\paragraph[{sGate}]{\setlength{\rightskip}{0pt plus 5cm}void sGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8h_adda6c47876a7676488ed0565a19eaa65}


Apply the single-\/qubit S gate. This is a rotation of $\pi/2$ around the Z-\/axis on the Bloch sphere, or the unitary: \[ \begin{pmatrix} 1 & 0 \\ 0 & i \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {S}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate upon \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) \end{DoxyExceptions}


Definition at line 1580 of file qubits.c.

References phaseGate(), and S\_\-GATE.


\begin{DoxyCode}
1581 {
1582                 phaseGate(multiQubit, targetQubit, S_GATE);
1583 } 
\end{DoxyCode}
\hypertarget{qubits_8h_a86e396e06b7d527cac20ba0108872423}{
\index{qubits.h@{qubits.h}!sigmaX@{sigmaX}}
\index{sigmaX@{sigmaX}!qubits.h@{qubits.h}}
\paragraph[{sigmaX}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaX ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8h_a86e396e06b7d527cac20ba0108872423}


Apply the single-\/qubit sigma-\/X (also known as the X, Pauli-\/X, NOT or bit-\/flip) gate. This is a rotation of $\pi$ around the x-\/axis on the Bloch sphere. I.e. \[ \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (2, 0); \draw (0, 0) circle (.5); \draw (0, .5) -- (0, -.5); \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 157 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), sigmaXDistributed(), sigmaXLocal(), and MultiQubit::stateVec.


\begin{DoxyCode}
158 {
159     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
160         sigmaXLocal(multiQubit, targetQubit);
161 }
\end{DoxyCode}
\hypertarget{qubits_8h_a1f54d70a42403f7e1c2e2c2007332f61}{
\index{qubits.h@{qubits.h}!sigmaY@{sigmaY}}
\index{sigmaY@{sigmaY}!qubits.h@{qubits.h}}
\paragraph[{sigmaY}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaY ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8h_a1f54d70a42403f7e1c2e2c2007332f61}


Apply the single-\/qubit sigma-\/Y (also known as the Y or Pauli-\/Y) gate. This is a rotation of $\pi$ around the Y-\/axis on the Bloch sphere. I.e. \[ \begin{pmatrix} 0 & -i \\ i & 0 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$\sigma_y$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


fix -\/-\/ put duplicate code (sigmaX, sigmaY) in seperate function 

Definition at line 163 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), sigmaYDistributed(), sigmaYLocal(), and MultiQubit::stateVec.


\begin{DoxyCode}
164 {
165     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
166         sigmaYLocal(multiQubit, targetQubit);
167 }
\end{DoxyCode}
\hypertarget{qubits_8h_aebaab86326779de55d335cfea3efde8f}{
\index{qubits.h@{qubits.h}!sigmaZ@{sigmaZ}}
\index{sigmaZ@{sigmaZ}!qubits.h@{qubits.h}}
\paragraph[{sigmaZ}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaZ ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8h_aebaab86326779de55d335cfea3efde8f}


Apply the single-\/qubit sigma-\/Z (also known as the Z, Pauli-\/Z or phase-\/flip) gate. This is a rotation of $\pi$ around the Z-\/axis (a phase shift) on the Bloch sphere. I.e. \[ \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$\sigma_z$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 1575 of file qubits.c.

References phaseGate(), and SIGMA\_\-Z.


\begin{DoxyCode}
1576 {
1577                 phaseGate(multiQubit, targetQubit, SIGMA_Z);
1578 }
\end{DoxyCode}
\hypertarget{qubits_8h_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{
\index{qubits.h@{qubits.h}!syncQuESTEnv@{syncQuESTEnv}}
\index{syncQuESTEnv@{syncQuESTEnv}!qubits.h@{qubits.h}}
\paragraph[{syncQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void syncQuESTEnv ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8h_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}


Guarantees that all code up to the given point has been executed on all nodes (if running in distributed mode). 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 35 of file qubits\_\-env\_\-local.c.

Referenced by initializeStateFromSingleFile(), and reportStateToScreen().


\begin{DoxyCode}
35                                {
36         // MPI Barrier goes here in MPI version. 
37 } 
\end{DoxyCode}
\hypertarget{qubits_8h_ac7e38d768a1bd79019f88cc1e6295092}{
\index{qubits.h@{qubits.h}!syncQuESTSuccess@{syncQuESTSuccess}}
\index{syncQuESTSuccess@{syncQuESTSuccess}!qubits.h@{qubits.h}}
\paragraph[{syncQuESTSuccess}]{\setlength{\rightskip}{0pt plus 5cm}int syncQuESTSuccess (int {\em successCode})}\hfill}
\label{qubits_8h_ac7e38d768a1bd79019f88cc1e6295092}


Performs a logical AND on all successCodes held by all processes. If any one process has a zero successCode all processes will return a zero success code.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \item[\mbox{$\leftarrow$} {\em successCode}]1 if process task succeeded, 0 if process task failed \end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if all processes succeeded, 0 if any one process failed 
\end{DoxyReturn}


Definition at line 39 of file qubits\_\-env\_\-local.c.


\begin{DoxyCode}
39                                      {
40         return successCode;
41 }
\end{DoxyCode}
\hypertarget{qubits_8h_af764ea63a2e870098f4e1ce08562942e}{
\index{qubits.h@{qubits.h}!tGate@{tGate}}
\index{tGate@{tGate}!qubits.h@{qubits.h}}
\paragraph[{tGate}]{\setlength{\rightskip}{0pt plus 5cm}void tGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8h_af764ea63a2e870098f4e1ce08562942e}


Apply the single-\/qubit T gate. This is a rotation of $\pi/4$ around the Z-\/axis on the Bloch sphere, or the unitary: \[ \begin{pmatrix} 1 & 0 \\ 0 & \exp\left(i \frac{\pi}{4}\right) \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {T}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate upon \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) \end{DoxyExceptions}


Definition at line 1585 of file qubits.c.

References phaseGate(), and T\_\-GATE.


\begin{DoxyCode}
1586 {
1587                 phaseGate(multiQubit, targetQubit, T_GATE);
1588 }
\end{DoxyCode}
\hypertarget{qubits_8h_a7a0877e33700f6bad48adb51b7b3fb67}{
\index{qubits.h@{qubits.h}!unitary@{unitary}}
\index{unitary@{unitary}!qubits.h@{qubits.h}}
\paragraph[{unitary}]{\setlength{\rightskip}{0pt plus 5cm}void unitary ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8h_a7a0877e33700f6bad48adb51b7b3fb67}


Apply a general single-\/qubit unitary (including a global phase factor). The passed 2x2 ComplexMatrix must be unitary, otherwise an error is thrown.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {U}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \item[\mbox{$\leftarrow$} {\em u}]unitary matrix to apply \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or matrix {\ttfamily u} is not unitary. \end{DoxyExceptions}


Definition at line 113 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), getRotAngleFromUnitaryMatrix(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, unitaryDistributed(), unitaryLocal(), and validateMatrixIsUnitary().


\begin{DoxyCode}
114 {
115     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
116     QuESTAssert(validateMatrixIsUnitary(u), 5, __func__);
117 
118         // all values required to update state vector lie in this rank
119         unitaryLocal(multiQubit, targetQubit, u);
120 }
\end{DoxyCode}
