\hypertarget{qubits__internal_8h}{
\subsection{qubits\_\-internal.h File Reference}
\label{qubits__internal_8h}\index{qubits\_\-internal.h@{qubits\_\-internal.h}}
}


Internal functions used to implement the public facing API in \hyperlink{qubits_8h}{qubits.h}.  
{\ttfamily \#include \char`\"{}precision.h\char`\"{}}\par
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}{compactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}{compactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}{unitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}{unitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}{controlledCompactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}{controlledCompactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}{controlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}{controlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}{multiControlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{multiControlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}{sigmaXLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}{sigmaXDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}{sigmaYLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}{sigmaYDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}{hadamardLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}{hadamardDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}{phaseGateLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}{phaseGateDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}{controlledNotLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\} for elements where controlQubit is one. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}{controlledNotDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{findProbabilityOfZeroLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{findProbabilityOfZeroDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}{collapseToOutcomeLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int measureQubit, REAL totalProbability, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, const REAL totalProbability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Set all amplitudes in one chunk to 0. \item\end{DoxyCompactList}\item 
int \hyperlink{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}{validateMatrixIsUnitary} (\hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
int \hyperlink{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}{validateAlphaBeta} (\hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
int \hyperlink{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}{validateUnitVector} (REAL ux, REAL uy, REAL uz)
\item 
void \hyperlink{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}{phaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}{exitWithError} (int errorCode, const char $\ast$func)
\item 
void \hyperlink{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert} (int isValid, int errorCode, const char $\ast$func)
\end{DoxyCompactItemize}
\subsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \hyperlink{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}{errorCodes} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
Internal functions used to implement the public facing API in \hyperlink{qubits_8h}{qubits.h}. Do not call these functions directly. In general, \hyperlink{qubits__env__local_8c}{qubits\_\-env\_\-local.c} and \hyperlink{qubits__env__mpi_8c}{qubits\_\-env\_\-mpi.c} will implement the public API by choosing the correct function or combination of functions to use from those included here. 

Definition in file \hyperlink{qubits__internal_8h_source}{qubits\_\-internal.h}.

\subsubsection{Function Documentation}
\hypertarget{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}}
\index{collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeDistributedRenorm}]{\setlength{\rightskip}{0pt plus 5cm}REAL collapseToOutcomeDistributedRenorm ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  const REAL {\em totalProbability})}\hfill}
\label{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}


Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that the value 'outcome' has been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being zero \end{DoxyParams}


Definition at line 2073 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
2074 {
2075         // ----- temp variables
2076         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
2077         long long int numTasks=multiQubit.numAmps;
2078         // (good for shared memory parallelism)
2079 
2080         REAL renorm=1/sqrt(totalProbability);
2081         
2082         REAL *stateVecReal = multiQubit.stateVec.real;
2083         REAL *stateVecImag = multiQubit.stateVec.imag;
2084 
2085 # ifdef _OPENMP
2086 # pragma omp parallel \
2087         shared    (numTasks,stateVecReal,stateVecImag) \
2088         private   (thisTask)
2089 # endif
2090         {
2091 # ifdef _OPENMP
2092                 # pragma omp for schedule  (static)
2093 # endif
2094                 for (thisTask=0; thisTask<numTasks; thisTask++) {
2095                         // summation -- simple implementation
2096                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
2097                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
2098                 }
2099         }
2100         return totalProbability;
2101 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}}
\index{collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeDistributedSetZero}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeDistributedSetZero ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}


Set all amplitudes in one chunk to 0. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that a zero have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}


Definition at line 2116 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
2117 {
2118         // ----- temp variables
2119         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
2120         long long int numTasks=multiQubit.numAmps;
2121         // (good for shared memory parallelism)
2122 
2123         // ---------------------------------------------------------------- //
2124         //            find probability                                      //
2125         // ---------------------------------------------------------------- //
2126 
2127         REAL *stateVecReal = multiQubit.stateVec.real;
2128         REAL *stateVecImag = multiQubit.stateVec.imag;
2129 
2130 # ifdef _OPENMP
2131 # pragma omp parallel \
2132         shared    (numTasks,stateVecReal,stateVecImag) \
2133         private   (thisTask)
2134 # endif
2135         {
2136 # ifdef _OPENMP
2137                 # pragma omp for schedule  (static)
2138 # endif
2139                 for (thisTask=0; thisTask<numTasks; thisTask++) {
2140                         // summation -- simple implementation
2141                         stateVecReal[thisTask] = 0;
2142                         stateVecImag[thisTask] = 0;
2143                 }
2144         }
2145 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeLocal@{collapseToOutcomeLocal}}
\index{collapseToOutcomeLocal@{collapseToOutcomeLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeLocal}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeLocal ({\bf MultiQubit} {\em multiQubit}, \/  int {\em measureQubit}, \/  REAL {\em totalProbability}, \/  int {\em outcome})}\hfill}
\label{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}


Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. Performs an irreversible change to the state vector: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being either zero or one \item[\mbox{$\leftarrow$} {\em outcome}]to measure the probability of and set the state to -\/-\/ either zero or one \end{DoxyParams}


Definition at line 1990 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1991 {
1992         // ----- sizes
1993         long long int sizeBlock,                                           // siz
      e of blocks
1994         sizeHalfBlock;                                       // size of blocks ha
      lved
1995         // ----- indices
1996         long long int thisBlock,                                           // cur
      rent block
1997              index;                                               // current inde
      x for first half block
1998         // ----- measured probability
1999         REAL   renorm;                                    // probability (returne
      d) value
2000         // ----- temp variables
2001         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
2002         // (good for shared memory parallelism)
2003         long long int numTasks=multiQubit.numAmps>>1;
2004 
2005         // ---------------------------------------------------------------- //
2006         //            dimensions                                            //
2007         // ---------------------------------------------------------------- //
2008         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
2009         // and then the number to skip
2010         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
2011         
2012         renorm=1/sqrt(totalProbability);
2013         REAL *stateVecReal = multiQubit.stateVec.real;
2014         REAL *stateVecImag = multiQubit.stateVec.imag;
2015 
2016 
2017 # ifdef _OPENMP
2018 # pragma omp parallel \
2019         default (none) \
2020         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,re
      norm,outcome) \
2021         private   (thisTask,thisBlock,index)
2022 # endif
2023         {
2024                 if (outcome==0){
2025                         // measure qubit is 0
2026 # ifdef _OPENMP
2027                         # pragma omp for schedule  (static)
2028 # endif
2029                         for (thisTask=0; thisTask<numTasks; thisTask++) {
2030                                 thisBlock = thisTask / sizeHalfBlock;
2031                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
2032                                 stateVecReal[index]=stateVecReal[index]*renorm;
2033                                 stateVecImag[index]=stateVecImag[index]*renorm;
2034 
2035                                 stateVecReal[index+sizeHalfBlock]=0;
2036                                 stateVecImag[index+sizeHalfBlock]=0;
2037                         }
2038                 } else {
2039                         // measure qubit is 1
2040 # ifdef _OPENMP
2041                         # pragma omp for schedule  (static)
2042 # endif
2043                         for (thisTask=0; thisTask<numTasks; thisTask++) {
2044                                 thisBlock = thisTask / sizeHalfBlock;
2045                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
2046                                 stateVecReal[index]=0;
2047                                 stateVecImag[index]=0;
2048 
2049                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[in
      dex+sizeHalfBlock]*renorm;
2050                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[in
      dex+sizeHalfBlock]*renorm;
2051                         }
2052                 }
2053         }
2054 
2055 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!compactUnitaryDistributed@{compactUnitaryDistributed}}
\index{compactUnitaryDistributed@{compactUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{compactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 648 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by compactUnitary().


\begin{DoxyCode}
653 {
654 
655         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
656         long long int thisTask;  
657         const long long int numTasks=multiQubit.numAmps;
658 
659         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
660         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
661         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
662         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
663         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
664 
665 # ifdef _OPENMP
666 # pragma omp parallel \
667         default  (none) \
668         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
669                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
670         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
671 # endif
672         {
673 # ifdef _OPENMP
674                 # pragma omp for schedule (static)
675 # endif
676                 for (thisTask=0; thisTask<numTasks; thisTask++) {
677                         // store current state vector values in temp variables
678                         stateRealUp = stateVecRealUp[thisTask];
679                         stateImagUp = stateVecImagUp[thisTask];
680 
681                         stateRealLo = stateVecRealLo[thisTask];
682                         stateImagLo = stateVecImagLo[thisTask];
683 
684                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
685                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
686                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
687                 }
688         }
689 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!compactUnitaryLocal@{compactUnitaryLocal}}
\index{compactUnitaryLocal@{compactUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{compactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}


Rotate a single qubit in the state vector of probability amplitudes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 509 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by compactUnitary().


\begin{DoxyCode}
510 {
511         long long int sizeBlock, sizeHalfBlock;
512         long long int thisBlock, // current block
513              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
514 
515         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
516         long long int thisTask;         
517         const long long int numTasks=multiQubit.numAmps>>1;
518 
519         // set dimensions
520         sizeHalfBlock = 1LL << targetQubit;  
521         sizeBlock     = 2LL * sizeHalfBlock; 
522 
523         // Can't use multiQubit.stateVec as a private OMP var
524         REAL *stateVecReal = multiQubit.stateVec.real;
525         REAL *stateVecImag = multiQubit.stateVec.imag;
526         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
527         REAL betaImag=beta.imag, betaReal=beta.real;
528 
529 # ifdef _OPENMP
530 # pragma omp parallel \
531         default  (none) \
532         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
533         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
534 # endif
535         {
536 # ifdef _OPENMP
537                 # pragma omp for schedule (static)
538 # endif
539                 for (thisTask=0; thisTask<numTasks; thisTask++) {
540 
541                         thisBlock   = thisTask / sizeHalfBlock;
542                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
543                         indexLo     = indexUp + sizeHalfBlock;
544 
545                         // store current state vector values in temp variables
546                         stateRealUp = stateVecReal[indexUp];
547                         stateImagUp = stateVecImag[indexUp];
548 
549                         stateRealLo = stateVecReal[indexLo];
550                         stateImagLo = stateVecImag[indexLo];
551 
552                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
553                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag
      *stateImagUp 
554                                 - betaReal*stateRealLo - betaImag*stateImagLo;
555                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag
      *stateRealUp 
556                                 - betaReal*stateImagLo + betaImag*stateRealLo;
557 
558                         // state[indexLo] = beta  * state[indexUp] + conj(alpha) 
      * state[indexLo]
559                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*s
      tateImagUp 
560                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
561                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*s
      tateRealUp 
562                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
563                 } 
564         }
565 
566 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}}
\index{controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledCompactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 993 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
998 {
999 
1000         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1001         long long int thisTask;  
1002         const long long int numTasks=multiQubit.numAmps;
1003         const long long int chunkSize=multiQubit.numAmps;
1004         const long long int chunkId=multiQubit.chunkId;
1005 
1006         int controlBit;
1007 
1008     REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
1009         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
1010         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1011         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1012         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1013 
1014 # ifdef _OPENMP
1015 # pragma omp parallel \
1016         default  (none) \
1017         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1018                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
1019         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
1020 # endif
1021         {
1022 # ifdef _OPENMP
1023                 # pragma omp for schedule (static)
1024 # endif
1025                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1026                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
1027                         if (controlBit){
1028                                 // store current state vector values in temp vari
      ables
1029                                 stateRealUp = stateVecRealUp[thisTask];
1030                                 stateImagUp = stateVecImagUp[thisTask];
1031 
1032                                 stateRealLo = stateVecRealLo[thisTask];
1033                                 stateImagLo = stateVecImagLo[thisTask];
1034 
1035                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
1036                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp 
      - rot1Imag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
1037                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp 
      + rot1Imag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
1038                         }
1039                 }
1040         }
1041 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}}
\index{controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledCompactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. Only perform the rotation for elements where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform rotation if this qubit is 1 \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 762 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
764 {
765         long long int sizeBlock, sizeHalfBlock;
766         long long int thisBlock, // current block
767              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
768 
769         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
770         long long int thisTask;         
771         const long long int numTasks=multiQubit.numAmps>>1;
772         const long long int chunkSize=multiQubit.numAmps;
773         const long long int chunkId=multiQubit.chunkId;
774 
775         int controlBit;
776 
777     // set dimensions
778         sizeHalfBlock = 1LL << targetQubit;  
779         sizeBlock     = 2LL * sizeHalfBlock; 
780 
781         // Can't use multiQubit.stateVec as a private OMP var
782         REAL *stateVecReal = multiQubit.stateVec.real;
783         REAL *stateVecImag = multiQubit.stateVec.imag;
784         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
785         REAL betaImag=beta.imag, betaReal=beta.real;
786 
787 # ifdef _OPENMP
788 # pragma omp parallel \
789         default  (none) \
790         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
791         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
792 # endif
793         {
794 # ifdef _OPENMP
795                 # pragma omp for schedule (static)
796 # endif
797                 for (thisTask=0; thisTask<numTasks; thisTask++) {
798 
799                         thisBlock   = thisTask / sizeHalfBlock;
800                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
801                         indexLo     = indexUp + sizeHalfBlock;
802 
803                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
804                         if (controlBit){
805                                 // store current state vector values in temp vari
      ables
806                                 stateRealUp = stateVecReal[indexUp];
807                                 stateImagUp = stateVecImag[indexUp];
808 
809                                 stateRealLo = stateVecReal[indexLo];
810                                 stateImagLo = stateVecImag[indexLo];
811 
812                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
813                                 stateVecReal[indexUp] = alphaReal*stateRealUp - a
      lphaImag*stateImagUp 
814                                         - betaReal*stateRealLo - betaImag*stateIm
      agLo;
815                                 stateVecImag[indexUp] = alphaReal*stateImagUp + a
      lphaImag*stateRealUp 
816                                         - betaReal*stateImagLo + betaImag*stateRe
      alLo;
817 
818                                 // state[indexLo] = beta  * state[indexUp] + conj
      (alpha) * state[indexLo]
819                                 stateVecReal[indexLo] = betaReal*stateRealUp - be
      taImag*stateImagUp 
820                                         + alphaReal*stateRealLo + alphaImag*state
      ImagLo;
821                                 stateVecImag[indexLo] = betaReal*stateImagUp + be
      taImag*stateRealUp 
822                                         + alphaReal*stateImagLo - alphaImag*state
      RealLo;
823                         }
824                 } 
825         }
826 
827 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledNotDistributed@{controlledNotDistributed}}
\index{controlledNotDistributed@{controlledNotDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledNotDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk. Only perform the rotation for elements where controlQubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1340 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by controlledNot().


\begin{DoxyCode}
1343 {
1344 
1345         long long int thisTask;  
1346         const long long int numTasks=multiQubit.numAmps;
1347         const long long int chunkSize=multiQubit.numAmps;
1348         const long long int chunkId=multiQubit.chunkId;
1349 
1350         int controlBit;
1351 
1352         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1353         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1354 
1355 # ifdef _OPENMP
1356 # pragma omp parallel \
1357         default  (none) \
1358         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1359         private  (thisTask,controlBit)
1360 # endif
1361         {
1362 # ifdef _OPENMP
1363                 # pragma omp for schedule (static)
1364 # endif
1365                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1366                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
1367                         if (controlBit){
1368                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTa
      sk];
1369                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTa
      sk];
1370                         }
1371                 }
1372         }
1373 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledNotLocal@{controlledNotLocal}}
\index{controlledNotLocal@{controlledNotLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledNotLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}


Rotate a single qubit by \{\{0,1\},\{1,0\} for elements where controlQubit is one. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \end{DoxyParams}


Definition at line 1274 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledNot().


\begin{DoxyCode}
1275 {
1276         long long int sizeBlock, sizeHalfBlock;
1277         long long int thisBlock, // current block
1278              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1279 
1280         REAL stateRealUp,stateImagUp;
1281         long long int thisTask;         
1282         const long long int numTasks=multiQubit.numAmps>>1;
1283         const long long int chunkSize=multiQubit.numAmps;
1284         const long long int chunkId=multiQubit.chunkId;
1285 
1286         int controlBit;
1287 
1288         // set dimensions
1289         sizeHalfBlock = 1LL << targetQubit;  
1290         sizeBlock     = 2LL * sizeHalfBlock; 
1291 
1292 
1293         // Can't use multiQubit.stateVec as a private OMP var
1294         REAL *stateVecReal = multiQubit.stateVec.real;
1295         REAL *stateVecImag = multiQubit.stateVec.imag;
1296 
1297 # ifdef _OPENMP
1298 # pragma omp parallel \
1299         default  (none) \
1300         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1301         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,co
      ntrolBit) 
1302 # endif
1303         {
1304 # ifdef _OPENMP
1305                 # pragma omp for schedule (static)
1306 # endif
1307                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1308                         thisBlock   = thisTask / sizeHalfBlock;
1309                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1310                         indexLo     = indexUp + sizeHalfBlock;
1311 
1312                         controlBit = extractBit(controlQubit, indexUp+chunkId*chu
      nkSize);
1313                         if (controlBit){
1314                                 stateRealUp = stateVecReal[indexUp];
1315                                 stateImagUp = stateVecImag[indexUp];
1316 
1317                                 stateVecReal[indexUp] = stateVecReal[indexLo];
1318                                 stateVecImag[indexUp] = stateVecImag[indexLo];
1319 
1320                                 stateVecReal[indexLo] = stateRealUp;
1321                                 stateVecImag[indexLo] = stateImagUp;
1322                         }
1323                 } 
1324         }
1325 
1326 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledUnitaryDistributed@{controlledUnitaryDistributed}}
\index{controlledUnitaryDistributed@{controlledUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1056 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledUnitary().


\begin{DoxyCode}
1061 {
1062 
1063         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1064         long long int thisTask;  
1065         const long long int numTasks=multiQubit.numAmps;
1066         const long long int chunkSize=multiQubit.numAmps;
1067         const long long int chunkId=multiQubit.chunkId;
1068 
1069         int controlBit;
1070 
1071         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
1072         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
1073         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1074         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1075         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1076 
1077 # ifdef _OPENMP
1078 # pragma omp parallel \
1079         default  (none) \
1080         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1081                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
1082         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
1083 # endif
1084         {
1085 # ifdef _OPENMP
1086                 # pragma omp for schedule (static)
1087 # endif
1088                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1089                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
1090                         if (controlBit){
1091                                 // store current state vector values in temp vari
      ables
1092                                 stateRealUp = stateVecRealUp[thisTask];
1093                                 stateImagUp = stateVecImagUp[thisTask];
1094 
1095                                 stateRealLo = stateVecRealLo[thisTask];
1096                                 stateImagLo = stateVecImagLo[thisTask];
1097 
1098                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
1099                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
1100                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
1101                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
1102                         }
1103                 }
1104         }
1105 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledUnitaryLocal@{controlledUnitaryLocal}}
\index{controlledUnitaryLocal@{controlledUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. Only perform the rotation for elements where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform rotation if this qubit is 1 \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 914 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledUnitary().


\begin{DoxyCode}
916 {
917         long long int sizeBlock, sizeHalfBlock;
918         long long int thisBlock, // current block
919              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
920 
921         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
922         long long int thisTask;         
923         const long long int numTasks=multiQubit.numAmps>>1;
924         const long long int chunkSize=multiQubit.numAmps;
925         const long long int chunkId=multiQubit.chunkId;
926 
927         int controlBit;
928 
929     // set dimensions
930         sizeHalfBlock = 1LL << targetQubit;  
931         sizeBlock     = 2LL * sizeHalfBlock; 
932 
933         // Can't use multiQubit.stateVec as a private OMP var
934         REAL *stateVecReal = multiQubit.stateVec.real;
935         REAL *stateVecImag = multiQubit.stateVec.imag;
936 
937 # ifdef _OPENMP
938 # pragma omp parallel \
939         default  (none) \
940         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
941         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
942 # endif
943         {
944 # ifdef _OPENMP
945                 # pragma omp for schedule (static)
946 # endif
947                 for (thisTask=0; thisTask<numTasks; thisTask++) {
948 
949                         thisBlock   = thisTask / sizeHalfBlock;
950                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
951                         indexLo     = indexUp + sizeHalfBlock;
952 
953                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
954                         if (controlBit){
955                                 // store current state vector values in temp vari
      ables
956                                 stateRealUp = stateVecReal[indexUp];
957                                 stateImagUp = stateVecImag[indexUp];
958 
959                                 stateRealLo = stateVecReal[indexLo];
960                                 stateImagLo = stateVecImag[indexLo];
961 
962 
963                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
964                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
965                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
966                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
967                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
968 
969                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
970                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
971                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
972                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
973                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
974                         }
975                 } 
976         }
977 
978 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!exitWithError@{exitWithError}}
\index{exitWithError@{exitWithError}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{exitWithError}]{\setlength{\rightskip}{0pt plus 5cm}void exitWithError (int {\em errorCode}, \/  const char $\ast$ {\em func})}\hfill}
\label{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}


Definition at line 234 of file qubits\_\-env\_\-local.c.

References errorCodes.

Referenced by QuESTAssert().


\begin{DoxyCode}
234                                                    {
235     printf("!!!\n");
236     printf("QuEST Error in function %s: %s\n", func, errorCodes[errorCode]);
237     printf("!!!\n");
238     printf("exiting..\n");
239     exit(errorCode);
240 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}}
\index{findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{findProbabilityOfZeroDistributed}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}


Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. Size of regions to skip is a multiple of chunkSize.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1832 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1834 {
1835         // ----- measured probability
1836         REAL   totalProbability;                                    // probabilit
      y (returned) value
1837         // ----- temp variables
1838         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1839         long long int numTasks=multiQubit.numAmps;
1840 
1841         // ---------------------------------------------------------------- //
1842         //            find probability                                      //
1843         // ---------------------------------------------------------------- //
1844 
1845         // initialise returned value
1846         totalProbability = 0.0;
1847 
1848         REAL *stateVecReal = multiQubit.stateVec.real;
1849         REAL *stateVecImag = multiQubit.stateVec.imag;
1850 
1851 # ifdef _OPENMP
1852 # pragma omp parallel \
1853         shared    (numTasks,stateVecReal,stateVecImag) \
1854         private   (thisTask) \
1855         reduction ( +:totalProbability )
1856 # endif
1857         {
1858 # ifdef _OPENMP
1859                 # pragma omp for schedule  (static)
1860 # endif
1861                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1862                         // summation -- simple implementation
1863                         totalProbability += stateVecReal[thisTask]*stateVecReal[t
      hisTask]
1864                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
1865 
1866                         /*
1867                         // summation -- kahan correction
1868                         y = stateVecReal[thisTask]*stateVecReal[thisTask]
1869                         + stateVecImag[thisTask]*stateVecImag[thisTask] - c;
1870                         t = totalProbability + y;
1871                         c = (t - totalProbability) - y;
1872                         totalProbability = t;
1873                         */
1874 
1875                 }
1876         }
1877 
1878         return totalProbability;
1879 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}}
\index{findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{findProbabilityOfZeroLocal}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}


Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1759 of file qubits.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1761 {
1762         // ----- sizes
1763         long long int sizeBlock,                                           // siz
      e of blocks
1764         sizeHalfBlock;                                       // size of blocks ha
      lved
1765         // ----- indices
1766         long long int thisBlock,                                           // cur
      rent block
1767              index;                                               // current inde
      x for first half block
1768         // ----- measured probability
1769         REAL   totalProbability;                                    // probabilit
      y (returned) value
1770         // ----- temp variables
1771         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1772         long long int numTasks=multiQubit.numAmps>>1;
1773 
1774         // ---------------------------------------------------------------- //
1775         //            dimensions                                            //
1776         // ---------------------------------------------------------------- //
1777         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1778         // and then the number to skip
1779         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1780 
1781         // initialise returned value
1782         totalProbability = 0.0;
1783 
1784         // initialise correction for kahan summation
1785         if (DEBUG) printf("sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\n",sizeHa
      lfBlock,sizeBlock,numTasks);
1786 
1787         REAL *stateVecReal = multiQubit.stateVec.real;
1788         REAL *stateVecImag = multiQubit.stateVec.imag;
1789 
1790 # ifdef _OPENMP
1791 # pragma omp parallel \
1792         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
      
1793         private   (thisTask,thisBlock,index) \
1794         reduction ( +:totalProbability )
1795 # endif 
1796         {
1797 # ifdef _OPENMP
1798                 # pragma omp for schedule  (static)
1799 # endif
1800                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1801                         thisBlock = thisTask / sizeHalfBlock;
1802                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
      
1803 
1804                         if (index<0){ printf("ABORTING as index=%Ld with thisBloc
      k = %Ld  thisTask=%Ld \n", index,thisBlock,thisTask); exit(1);}
1805 
1806                         // summation -- simple implementation
1807                         totalProbability += stateVecReal[index]*stateVecReal[inde
      x]
1808                                 + stateVecImag[index]*stateVecImag[index];
1809 
1810                         /*
1811                         // summation -- kahan correction
1812                         y = stateVecReal[index]*stateVecReal[index]
1813                         + stateVecImag[index]*stateVecImag[index] - c;
1814                         t = totalProbability + y;
1815                         c = (t - totalProbability) - y;
1816                         totalProbability = t;
1817                         */
1818 
1819                 }
1820         }
1821         return totalProbability;
1822 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!hadamardDistributed@{hadamardDistributed}}
\index{hadamardDistributed@{hadamardDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{hadamardDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1546 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by hadamard().


\begin{DoxyCode}
1551 {
1552 
1553         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1554         long long int thisTask;  
1555         const long long int numTasks=multiQubit.numAmps;
1556 
1557         int sign;
1558         if (updateUpper) sign=1;
1559         else sign=-1;
1560 
1561         REAL recRoot2 = 1.0/sqrt(2);
1562 
1563         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1564         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1565         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1566 
1567 # ifdef _OPENMP
1568 # pragma omp parallel \
1569         default  (none) \
1570         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1571                         recRoot2, sign) \
1572         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1573 # endif
1574         {
1575 # ifdef _OPENMP
1576                 # pragma omp for schedule (static)
1577 # endif
1578                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1579                         // store current state vector values in temp variables
1580                         stateRealUp = stateVecRealUp[thisTask];
1581                         stateImagUp = stateVecImagUp[thisTask];
1582 
1583                         stateRealLo = stateVecRealLo[thisTask];
1584                         stateImagLo = stateVecImagLo[thisTask];
1585 
1586                         stateVecRealOut[thisTask] = recRoot2*(stateRealUp + sign*
      stateRealLo);
1587                         stateVecImagOut[thisTask] = recRoot2*(stateImagUp + sign*
      stateImagLo);
1588                 }
1589         }
1590 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!hadamardLocal@{hadamardLocal}}
\index{hadamardLocal@{hadamardLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{hadamardLocal}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \end{DoxyParams}


Definition at line 1484 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by hadamard().


\begin{DoxyCode}
1485 {
1486         long long int sizeBlock, sizeHalfBlock;
1487         long long int thisBlock, // current block
1488              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1489 
1490         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1491         long long int thisTask;         
1492         const long long int numTasks=multiQubit.numAmps>>1;
1493 
1494         // set dimensions
1495         sizeHalfBlock = 1LL << targetQubit;  
1496         sizeBlock     = 2LL * sizeHalfBlock; 
1497 
1498         // Can't use multiQubit.stateVec as a private OMP var
1499         REAL *stateVecReal = multiQubit.stateVec.real;
1500         REAL *stateVecImag = multiQubit.stateVec.imag;
1501 
1502         REAL recRoot2 = 1.0/sqrt(2);
1503 
1504 # ifdef _OPENMP
1505 # pragma omp parallel \
1506         default  (none) \
1507         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \
      
1508         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
1509 # endif
1510         {
1511 # ifdef _OPENMP
1512                 # pragma omp for schedule (static)
1513 # endif
1514                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1515                         thisBlock   = thisTask / sizeHalfBlock;
1516                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1517                         indexLo     = indexUp + sizeHalfBlock;
1518 
1519                         stateRealUp = stateVecReal[indexUp];
1520                         stateImagUp = stateVecImag[indexUp];
1521 
1522                         stateRealLo = stateVecReal[indexLo];
1523                         stateImagLo = stateVecImag[indexLo];
1524 
1525                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateReal
      Lo);
1526                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImag
      Lo);
1527 
1528                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateReal
      Lo);
1529                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImag
      Lo);
1530                 } 
1531         }
1532 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}}
\index{multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{multiControlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}


Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where all the control qubits are 1.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1120 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
1127 {
1128 
1129         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1130         long long int thisTask;  
1131         const long long int numTasks=multiQubit.numAmps;
1132         const long long int chunkSize=multiQubit.numAmps;
1133         const long long int chunkId=multiQubit.chunkId;
1134 
1135         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
1136         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
1137         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1138         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1139         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1140 
1141 # ifdef _OPENMP
1142 # pragma omp parallel \
1143         default  (none) \
1144         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1145                         rot1Real,rot1Imag, rot2Real,rot2Imag, mask) \
1146         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1147 # endif
1148         {
1149 # ifdef _OPENMP
1150                 # pragma omp for schedule (static)
1151 # endif
1152                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1153                         if (mask == (mask & (thisTask+chunkId*chunkSize)) ){
1154                                 // store current state vector values in temp vari
      ables
1155                                 stateRealUp = stateVecRealUp[thisTask];
1156                                 stateImagUp = stateVecImagUp[thisTask];
1157 
1158                                 stateRealLo = stateVecRealLo[thisTask];
1159                                 stateImagLo = stateVecImagLo[thisTask];
1160 
1161                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
1162                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
1163                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
1164                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
1165                         }
1166                 }
1167         }
1168 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!multiControlledUnitaryLocal@{multiControlledUnitaryLocal}}
\index{multiControlledUnitaryLocal@{multiControlledUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{multiControlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. Only perform the rotation for elements where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform rotation if this qubit is 1 \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 840 of file qubits.c.

References MultiQubit::chunkId, Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
842 {
843         long long int sizeBlock, sizeHalfBlock;
844         long long int thisBlock, // current block
845              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
846 
847         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
848         long long int thisTask;         
849         const long long int numTasks=multiQubit.numAmps>>1;
850         const long long int chunkSize=multiQubit.numAmps;
851         const long long int chunkId=multiQubit.chunkId;
852 
853         // set dimensions
854         sizeHalfBlock = 1LL << targetQubit;  
855         sizeBlock     = 2LL * sizeHalfBlock; 
856 
857         // Can't use multiQubit.stateVec as a private OMP var
858         REAL *stateVecReal = multiQubit.stateVec.real;
859         REAL *stateVecImag = multiQubit.stateVec.imag;
860 
861 # ifdef _OPENMP
862 # pragma omp parallel \
863         default  (none) \
864         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u, mask) \
865         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
866 # endif
867         {
868 # ifdef _OPENMP
869                 # pragma omp for schedule (static)
870 # endif
871                 for (thisTask=0; thisTask<numTasks; thisTask++) {
872 
873                         thisBlock   = thisTask / sizeHalfBlock;
874                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
875                         indexLo     = indexUp + sizeHalfBlock;
876 
877                         if (mask == (mask & (indexUp+chunkId*chunkSize)) ){
878                                 // store current state vector values in temp vari
      ables
879                                 stateRealUp = stateVecReal[indexUp];
880                                 stateImagUp = stateVecImag[indexUp];
881 
882                                 stateRealLo = stateVecReal[indexLo];
883                                 stateImagLo = stateVecImag[indexLo];
884 
885 
886                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
887                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
888                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
889                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
890                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
891 
892                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
893                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
894                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
895                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
896                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
897                         }
898                 } 
899         }
900 
901 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGate@{phaseGate}}
\index{phaseGate@{phaseGate}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em type}]the type of phase gate to apply -\/-\/ one of \{SIGMA\_\-Z, S\_\-GATE, T\_\-GATE\} \end{DoxyParams}


Definition at line 166 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, phaseGateDistributed(), phaseGateLocal(), and QuESTAssert().

Referenced by sGate(), sigmaZ(), and tGate().


\begin{DoxyCode}
167 {
168     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
169         phaseGateLocal(multiQubit, targetQubit, type);
170 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGateDistributed@{phaseGateDistributed}}
\index{phaseGateDistributed@{phaseGateDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGateDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em type}]the type of phase gate to apply -\/-\/ one of \{SIGMA\_\-Z, S\_\-GATE, T\_\-GATE\} \end{DoxyParams}


Definition at line 1682 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1683 {
1684         REAL stateRealLo,stateImagLo;
1685         long long int thisTask;         
1686         const long long int numTasks=multiQubit.numAmps;
1687 
1688         // Can't use multiQubit.stateVec as a private OMP var
1689         REAL *stateVecReal = multiQubit.stateVec.real;
1690         REAL *stateVecImag = multiQubit.stateVec.imag;
1691 
1692         REAL recRoot2 = 1.0/sqrt(2);
1693 
1694 # ifdef _OPENMP
1695 # pragma omp parallel \
1696         default  (none) \
1697         shared   (stateVecReal,stateVecImag, recRoot2, type) \
1698         private  (thisTask,stateRealLo,stateImagLo) 
1699 # endif
1700         {
1701                 if (type==SIGMA_Z){
1702 # ifdef _OPENMP
1703                         # pragma omp for schedule (static)
1704 # endif
1705                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1706                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
      
1707                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
      
1708                         } 
1709                 } else if (type==S_GATE){
1710 # ifdef _OPENMP
1711                         # pragma omp for schedule (static)
1712 # endif
1713                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1714                                 stateRealLo = stateVecReal[thisTask];
1715                                 stateImagLo = stateVecImag[thisTask];
1716 
1717                                 stateVecReal[thisTask] = -stateImagLo;
1718                                 stateVecImag[thisTask] = stateRealLo;
1719                         } 
1720                 } else if (type==T_GATE){
1721 # ifdef _OPENMP
1722                         # pragma omp for schedule (static)
1723 # endif
1724                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1725                                 stateRealLo = stateVecReal[thisTask];
1726                                 stateImagLo = stateVecImag[thisTask];
1727 
1728                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo 
      - stateImagLo);
1729                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo 
      + stateImagLo);
1730                         } 
1731                 } else printf("Type %d is an invalid phase gate\n", type);
1732         }
1733 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGateLocal@{phaseGateLocal}}
\index{phaseGateLocal@{phaseGateLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGateLocal}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em type}]the type of phase gate to apply -\/-\/ one of \{SIGMA\_\-Z, S\_\-GATE, T\_\-GATE\} \end{DoxyParams}


fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod? 

Definition at line 1599 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1600 {
1601         long long int sizeBlock, sizeHalfBlock;
1602         long long int thisBlock, // current block
1603              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1604 
1605         REAL stateRealLo,stateImagLo;
1606         long long int thisTask;         
1607         const long long int numTasks=multiQubit.numAmps>>1;
1608 
1609         // set dimensions
1610         sizeHalfBlock = 1LL << targetQubit;  
1611         sizeBlock     = 2LL * sizeHalfBlock; 
1612 
1613         // Can't use multiQubit.stateVec as a private OMP var
1614         REAL *stateVecReal = multiQubit.stateVec.real;
1615         REAL *stateVecImag = multiQubit.stateVec.imag;
1616 
1617         REAL recRoot2 = 1.0/sqrt(2);
1618 
1619 # ifdef _OPENMP
1620 # pragma omp parallel \
1621         default  (none) \
1622         shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type
      ) \
1623         private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) 
1624 # endif
1625         {
1626                 if (type==SIGMA_Z){
1627 # ifdef _OPENMP
1628                         # pragma omp for schedule (static)
1629 # endif
1630                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1632                                 thisBlock   = thisTask / sizeHalfBlock;
1633                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1634                                 indexLo     = indexUp + sizeHalfBlock;
1635 
1636                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
1637                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
1638                         } 
1639                 } 
1640                 
1641                 else if (type==S_GATE){
1642 # ifdef _OPENMP
1643                         # pragma omp for schedule (static)
1644 # endif
1645                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1647                                 thisBlock   = thisTask / sizeHalfBlock;
1648                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1649                                 indexLo     = indexUp + sizeHalfBlock;
1650                                 stateRealLo = stateVecReal[indexLo];
1651                                 stateImagLo = stateVecImag[indexLo];
1652 
1653                                 stateVecReal[indexLo] = -stateImagLo;
1654                                 stateVecImag[indexLo] = stateRealLo;
1655                         } 
1656                 } else if (type==T_GATE){
1657 # ifdef _OPENMP
1658                         # pragma omp for schedule (static)
1659 # endif
1660                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1662                                 thisBlock   = thisTask / sizeHalfBlock;
1663                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1664                                 indexLo     = indexUp + sizeHalfBlock;
1665                                 stateRealLo = stateVecReal[indexLo];
1666                                 stateImagLo = stateVecImag[indexLo];
1667 
1668                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo -
       stateImagLo);
1669                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo +
       stateImagLo);
1670                         } 
1671                 } else printf("Type %d is an invalid phase gate\n", type);
1672         }
1673 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!QuESTAssert@{QuESTAssert}}
\index{QuESTAssert@{QuESTAssert}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{QuESTAssert}]{\setlength{\rightskip}{0pt plus 5cm}void QuESTAssert (int {\em isValid}, \/  int {\em errorCode}, \/  const char $\ast$ {\em func})}\hfill}
\label{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}


Definition at line 242 of file qubits\_\-env\_\-local.c.

References exitWithError().

Referenced by collapseToOutcome(), compactUnitary(), controlledCompactUnitary(), controlledNot(), controlledPhaseGate(), controlledUnitary(), createMultiQubit(), findProbabilityOfOutcome(), hadamard(), measure(), measureWithStats(), multiControlledPhaseGate(), multiControlledUnitary(), phaseGate(), sigmaX(), sigmaY(), and unitary().


\begin{DoxyCode}
242                                                               {
243     if (!isValid) exitWithError(errorCode, func);
244 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaXDistributed@{sigmaXDistributed}}
\index{sigmaXDistributed@{sigmaXDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaXDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1237 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaX().


\begin{DoxyCode}
1240 {
1241 
1242         long long int thisTask;  
1243         const long long int numTasks=multiQubit.numAmps;
1244 
1245         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1246         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1247 
1248 # ifdef _OPENMP
1249 # pragma omp parallel \
1250         default  (none) \
1251         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1252         private  (thisTask)
1253 # endif
1254         {
1255 # ifdef _OPENMP
1256                 # pragma omp for schedule (static)
1257 # endif
1258                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1259                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
1260                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
1261                 }
1262         }
1263 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaXLocal@{sigmaXLocal}}
\index{sigmaXLocal@{sigmaXLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaXLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}


Rotate a single qubit by \{\{0,1\},\{1,0\}. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \end{DoxyParams}


Definition at line 1177 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaX().


\begin{DoxyCode}
1178 {
1179         long long int sizeBlock, sizeHalfBlock;
1180         long long int thisBlock, // current block
1181              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1182 
1183         REAL stateRealUp,stateImagUp;
1184         long long int thisTask;         
1185         const long long int numTasks=multiQubit.numAmps>>1;
1186 
1187         // set dimensions
1188         sizeHalfBlock = 1LL << targetQubit;  
1189         sizeBlock     = 2LL * sizeHalfBlock; 
1190 
1191         // Can't use multiQubit.stateVec as a private OMP var
1192         REAL *stateVecReal = multiQubit.stateVec.real;
1193         REAL *stateVecImag = multiQubit.stateVec.imag;
1194 
1195 # ifdef _OPENMP
1196 # pragma omp parallel \
1197         default  (none) \
1198         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1199         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1200 # endif
1201         {
1202 # ifdef _OPENMP
1203                 # pragma omp for schedule (static)
1204 # endif
1205                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1206                         thisBlock   = thisTask / sizeHalfBlock;
1207                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1208                         indexLo     = indexUp + sizeHalfBlock;
1209 
1210                         stateRealUp = stateVecReal[indexUp];
1211                         stateImagUp = stateVecImag[indexUp];
1212 
1213                         stateVecReal[indexUp] = stateVecReal[indexLo];
1214                         stateVecImag[indexUp] = stateVecImag[indexLo];
1215 
1216                         stateVecReal[indexLo] = stateRealUp;
1217                         stateVecImag[indexLo] = stateImagUp;
1218                 } 
1219         }
1220 
1221 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaYDistributed@{sigmaYDistributed}}
\index{sigmaYDistributed@{sigmaYDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaYDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1444 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaY().


\begin{DoxyCode}
1448 {
1449 
1450         long long int thisTask;  
1451         const long long int numTasks=multiQubit.numAmps;
1452 
1453         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1454         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1455 
1456         int realSign=1, imagSign=1;
1457         if (updateUpper) imagSign=-1;
1458         else realSign = -1;
1459 
1460 # ifdef _OPENMP
1461 # pragma omp parallel \
1462         default  (none) \
1463         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,r
      ealSign,imagSign) \
1464         private  (thisTask)
1465 # endif
1466         {
1467 # ifdef _OPENMP
1468                 # pragma omp for schedule (static)
1469 # endif
1470                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1471                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisT
      ask];
1472                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisT
      ask];
1473                 }
1474         }
1475 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaYLocal@{sigmaYLocal}}
\index{sigmaYLocal@{sigmaYLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaYLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \end{DoxyParams}


Definition at line 1384 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaY().


\begin{DoxyCode}
1385 {
1386         long long int sizeBlock, sizeHalfBlock;
1387         long long int thisBlock, // current block
1388              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1389 
1390         REAL stateRealUp,stateImagUp;
1391         long long int thisTask;         
1392         const long long int numTasks=multiQubit.numAmps>>1;
1393 
1394         // set dimensions
1395         sizeHalfBlock = 1LL << targetQubit;  
1396         sizeBlock     = 2LL * sizeHalfBlock; 
1397 
1398         // Can't use multiQubit.stateVec as a private OMP var
1399         REAL *stateVecReal = multiQubit.stateVec.real;
1400         REAL *stateVecImag = multiQubit.stateVec.imag;
1401 
1402 # ifdef _OPENMP
1403 # pragma omp parallel \
1404         default  (none) \
1405         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1406         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1407 # endif
1408         {
1409 # ifdef _OPENMP
1410                 # pragma omp for schedule (static)
1411 # endif
1412                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1413                         thisBlock   = thisTask / sizeHalfBlock;
1414                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1415                         indexLo     = indexUp + sizeHalfBlock;
1416 
1417                         stateRealUp = stateVecReal[indexUp];
1418                         stateImagUp = stateVecImag[indexUp];
1419 
1420                         stateVecReal[indexUp] = stateVecImag[indexLo];
1421                         stateVecImag[indexUp] = -stateVecReal[indexLo];
1422 
1423                         stateVecReal[indexLo] = -stateImagUp;
1424                         stateVecImag[indexLo] = stateRealUp;
1425                 } 
1426         }
1427 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!unitaryDistributed@{unitaryDistributed}}
\index{unitaryDistributed@{unitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{unitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}


Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em u}]unitary matrix to apply \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 706 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by unitary().


\begin{DoxyCode}
711 {
712 
713         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
714         long long int thisTask;  
715         const long long int numTasks=multiQubit.numAmps;
716 
717         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
718         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
719         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
720         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
721         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
722 
723 
724 # ifdef _OPENMP
725 # pragma omp parallel \
726         default  (none) \
727         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
728                         rot1Real, rot1Imag, rot2Real, rot2Imag) \
729         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
730 # endif
731         {
732 # ifdef _OPENMP
733                 # pragma omp for schedule (static)
734 # endif
735                 for (thisTask=0; thisTask<numTasks; thisTask++) {
736                         // store current state vector values in temp variables
737                         stateRealUp = stateVecRealUp[thisTask];
738                         stateImagUp = stateVecImagUp[thisTask];
739 
740                         stateRealLo = stateVecRealLo[thisTask];
741                         stateImagLo = stateVecImagLo[thisTask];
742 
743                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp 
744                                 + rot2Real*stateRealLo - rot2Imag*stateImagLo;
745                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp 
746                                 + rot2Real*stateImagLo + rot2Imag*stateRealLo;
747                 }
748         }
749 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!unitaryLocal@{unitaryLocal}}
\index{unitaryLocal@{unitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{unitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}


Definition at line 577 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by unitary().


\begin{DoxyCode}
578 {
579         long long int sizeBlock, sizeHalfBlock;
580         long long int thisBlock, // current block
581              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
582 
583         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
584         long long int thisTask;         
585         const long long int numTasks=multiQubit.numAmps>>1;
586 
587         // set dimensions
588         sizeHalfBlock = 1LL << targetQubit;  
589         sizeBlock     = 2LL * sizeHalfBlock; 
590 
591         // Can't use multiQubit.stateVec as a private OMP var
592         REAL *stateVecReal = multiQubit.stateVec.real;
593         REAL *stateVecImag = multiQubit.stateVec.imag;
594 
595 # ifdef _OPENMP
596 # pragma omp parallel \
597         default  (none) \
598         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
599         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
600 # endif
601         {
602 # ifdef _OPENMP
603                 # pragma omp for schedule (static)
604 # endif
605                 for (thisTask=0; thisTask<numTasks; thisTask++) {
606 
607                         thisBlock   = thisTask / sizeHalfBlock;
608                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
609                         indexLo     = indexUp + sizeHalfBlock;
610 
611                         // store current state vector values in temp variables
612                         stateRealUp = stateVecReal[indexUp];
613                         stateImagUp = stateVecImag[indexUp];
614 
615                         stateRealLo = stateVecReal[indexLo];
616                         stateImagLo = stateVecImag[indexLo];
617 
618 
619                         // state[indexUp] = u00 * state[indexUp] + u01 * state[in
      dexLo]
620                         stateVecReal[indexUp] = u.r0c0.real*stateRealUp - u.r0c0.
      imag*stateImagUp 
621                                 + u.r0c1.real*stateRealLo - u.r0c1.imag*stateImag
      Lo;
622                         stateVecImag[indexUp] = u.r0c0.real*stateImagUp + u.r0c0.
      imag*stateRealUp 
623                                 + u.r0c1.real*stateImagLo + u.r0c1.imag*stateReal
      Lo;
624 
625                         // state[indexLo] = u10  * state[indexUp] + u11 * state[i
      ndexLo]
626                         stateVecReal[indexLo] = u.r1c0.real*stateRealUp  - u.
      r1c0.imag*stateImagUp 
627                                 + u.r1c1.real*stateRealLo  -  u.r1c1.imag*stateIm
      agLo;
628                         stateVecImag[indexLo] = u.r1c0.real*stateImagUp + u.r1c0.
      imag*stateRealUp 
629                                 + u.r1c1.real*stateImagLo + u.r1c1.imag*stateReal
      Lo;
630 
631                 } 
632         }
633 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateAlphaBeta@{validateAlphaBeta}}
\index{validateAlphaBeta@{validateAlphaBeta}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateAlphaBeta}]{\setlength{\rightskip}{0pt plus 5cm}int validateAlphaBeta ({\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}


Definition at line 410 of file qubits.c.

References Complex::imag, Complex::real, and REAL\_\-EPS.

Referenced by compactUnitary(), and controlledCompactUnitary().


\begin{DoxyCode}
410                                                   {
411         if ( fabs(alpha.real*alpha.real 
412                 + alpha.imag*alpha.imag
413                 + beta.real*beta.real 
414                 + beta.imag*beta.imag - 1) > REAL_EPS ) return 0;
415         else return 1;
416 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateMatrixIsUnitary@{validateMatrixIsUnitary}}
\index{validateMatrixIsUnitary@{validateMatrixIsUnitary}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateMatrixIsUnitary}]{\setlength{\rightskip}{0pt plus 5cm}int validateMatrixIsUnitary ({\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}


Definition at line 385 of file qubits.c.

References Complex::imag, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, and REAL\_\-EPS.

Referenced by controlledUnitary(), multiControlledUnitary(), and unitary().


\begin{DoxyCode}
385                                              {
386 
387         if ( fabs(u.r0c0.real*u.r0c0.real 
388                 + u.r0c0.imag*u.r0c0.imag
389                 + u.r1c0.real*u.r1c0.real
390                 + u.r1c0.imag*u.r1c0.imag - 1) > REAL_EPS ) return 0;
391     // check
392         if ( fabs(u.r0c1.real*u.r0c1.real 
393                 + u.r0c1.imag*u.r0c1.imag
394                 + u.r1c1.real*u.r1c1.real
395                 + u.r1c1.imag*u.r1c1.imag - 1) > REAL_EPS ) return 0;
396 
397         if ( fabs(u.r0c0.real*u.r0c1.real 
398                 + u.r0c0.imag*u.r0c1.imag
399                 + u.r1c0.real*u.r1c1.real
400                 + u.r1c0.imag*u.r1c1.imag) > REAL_EPS ) return 0;
401 
402         if ( fabs(u.r0c1.real*u.r0c0.imag
403                 - u.r0c0.real*u.r0c1.imag
404                 + u.r1c1.real*u.r1c0.imag
405                 - u.r1c0.real*u.r1c1.imag) > REAL_EPS ) return 0;
406 
407         return 1;
408 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateUnitVector@{validateUnitVector}}
\index{validateUnitVector@{validateUnitVector}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateUnitVector}]{\setlength{\rightskip}{0pt plus 5cm}int validateUnitVector (REAL {\em ux}, \/  REAL {\em uy}, \/  REAL {\em uz})}\hfill}
\label{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}


Definition at line 418 of file qubits.c.

References REAL\_\-EPS.


\begin{DoxyCode}
418                                                  {
419         if ( fabs(sqrt(ux*ux + uy*uy + uz*uz) - 1) > REAL_EPS ) return 0;
420         else return 1;
421 }
\end{DoxyCode}


\subsubsection{Variable Documentation}
\hypertarget{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!errorCodes@{errorCodes}}
\index{errorCodes@{errorCodes}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{errorCodes}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ {\bf errorCodes}\mbox{[}$\,$\mbox{]}}\hfill}
\label{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}


Definition at line 17 of file qubits.c.

Referenced by exitWithError().