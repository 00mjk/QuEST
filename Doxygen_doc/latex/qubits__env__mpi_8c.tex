\hypertarget{qubits__env__mpi_8c}{
\subsection{qubits\_\-env\_\-mpi.c File Reference}
\label{qubits__env__mpi_8c}\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}}
}


An implementation of the API in \hyperlink{qubits_8h}{qubits.h} for an MPI environment.  
{\ttfamily \#include $<$unistd.h$>$}\par
{\ttfamily \#include $<$mpi.h$>$}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$stdio.h$>$}\par
{\ttfamily \#include $<$math.h$>$}\par
{\ttfamily \#include $<$omp.h$>$}\par
{\ttfamily \#include \char`\"{}precision.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}qubits.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}qubits\_\-internal.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}mt19937ar.h\char`\"{}}\par
{\ttfamily \#include $<$time.h$>$}\par
{\ttfamily \#include $<$sys/types.h$>$}\par
\subsubsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}{\_\-BSD\_\-SOURCE}
\item 
\#define \hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}~0
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{isChunkToSkipInFindPZero} (int chunkId, long long int chunkSize, int measureQubit)
\begin{DoxyCompactList}\small\item\em Find chunks to skip when calculating probability of qubit being zero. \item\end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper} (int chunkId, long long int chunkSize, int targetQubit)
\begin{DoxyCompactList}\small\item\em Returns whether a given chunk in position chunkId is in the upper or lower half of a block. \item\end{DoxyCompactList}\item 
static void \hyperlink{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{getRotAngle} (int chunkIsUpper, \hyperlink{structComplex}{Complex} $\ast$rot1, \hyperlink{structComplex}{Complex} $\ast$rot2, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Get rotation values for a given chunk. \item\end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId} (int chunkIsUpper, int chunkId, long long int chunkSize, int targetQubit)
\begin{DoxyCompactList}\small\item\em get position of corresponding chunk, holding values required to update values in my chunk (with chunkId) when rotating targetQubit. \item\end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk} (long long int chunkSize, int targetQubit)
\begin{DoxyCompactList}\small\item\em return whether the current qubit rotation will use blocks that fit within a single chunk. \item\end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{getChunkIdFromIndex} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\item 
void \hyperlink{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}{initQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} $\ast$env)
\begin{DoxyCompactList}\small\item\em Initialize the QuEST environment. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{syncQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Guarantees that all code up to the given point has been executed on all nodes (if running in distributed mode). \item\end{DoxyCompactList}\item 
int \hyperlink{qubits__env__mpi_8c_ac7e38d768a1bd79019f88cc1e6295092}{syncQuESTSuccess} (int successCode)
\begin{DoxyCompactList}\small\item\em Performs a logical AND on all successCodes held by all processes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}{closeQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Close QuEST environment. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}{reportQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Report information about the QuEST environment. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}{reportNodeList} (\hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Report a list of CPU hostnames and the rank that is running on each if running with MPI enabled and an error message otherwise. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}{getRealAmpEl} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the real component of the complex probability amplitude at an index in the state vector. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}{getImagAmpEl} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the imaginary component of the complex probability amplitude at an index in the state vector. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}{calcTotalProbability} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Calculate the probability of being in any state by taking the norm of the entire state vector. \item\end{DoxyCompactList}\item 
static void \hyperlink{qubits__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}{getRotAngleFromUnitaryMatrix} (int chunkIsUpper, \hyperlink{structComplex}{Complex} $\ast$rot1, \hyperlink{structComplex}{Complex} $\ast$rot2, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Get rotation values for a given chunk given a unitary matrix. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int pairRank)
\item 
void \hyperlink{qubits__env__mpi_8c_a03b13dfcabd8c59b50dbdd3af44ba8b2}{compactUnitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Apply a single-\/qubit unitary parameterised by two given complex scalars. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a7a0877e33700f6bad48adb51b7b3fb67}{unitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Apply a general single-\/qubit unitary (including a global phase factor). \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ab4812953bc457405b3aa05a4c2f64f4a}{controlledCompactUnitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Apply a controlled unitary (single control, single target) parameterised by two given complex scalars. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a8a701526263392599aa21d0d0f05d9d8}{controlledUnitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Apply a general controlled unitary (single control, single target), which can include a global phase factor. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ae395a79690283ed81106afadd7a8cd8a}{multiControlledUnitary} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int $\ast$controlQubits, const int numControlQubits, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Apply a general multiple-\/control single-\/target unitary, which can include a global phase factor. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a86e396e06b7d527cac20ba0108872423}{sigmaX} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit sigma-\/X (also known as the X, Pauli-\/X, NOT or bit-\/flip) gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a67576895bbc65463481a8ea24d9b1e22}{controlledNot} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the controlled not (single control, single target) gate, also known as the c-\/X, c-\/sigma-\/X, c-\/Pauli-\/X and c-\/bit-\/flip gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a1f54d70a42403f7e1c2e2c2007332f61}{sigmaY} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit sigma-\/Y (also known as the Y or Pauli-\/Y) gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_aae7a8a7f1ccbddb7f76b6c52b746bb43}{phaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits__env__mpi_8c_aa09b5dd93de6df1384b8f2c0041749ab}{hadamard} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit Hadamard gate. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{findProbabilityOfOutcome} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, int outcome)
\begin{DoxyCompactList}\small\item\em Gives the probability of a specified qubit being measured in the given outcome (0 or 1). \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__env__mpi_8c_a07418ebac70fd9ae5d051d089961631d}{collapseToOutcome} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, int outcome)
\begin{DoxyCompactList}\small\item\em Updates the state vector to be consistent with measuring the measure qubit in the given outcome (0 or 1), and returns the probability of such a measurement outcome. \item\end{DoxyCompactList}\item 
int \hyperlink{qubits__env__mpi_8c_ad5774247d836267175c664cd0e451bcb}{measure} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int measureQubit)
\begin{DoxyCompactList}\small\item\em Measures a single qubit, collapsing it randomly to 0 or 1. \item\end{DoxyCompactList}\item 
int \hyperlink{qubits__env__mpi_8c_a2ac46e470c750bf93c754e06c64b0a7a}{measureWithStats} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int measureQubit, REAL $\ast$stateProb)
\begin{DoxyCompactList}\small\item\em Measures a single qubit, collapsing it randomly to 0 or 1, and additionally gives the probability of that outcome. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ae5f9019826f35e8b51b1716cfe397b45}{exitWithError} (int errorCode, const char $\ast$func)
\item 
void \hyperlink{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert} (int isValid, int errorCode, const char $\ast$func)
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
An implementation of the API in \hyperlink{qubits_8h}{qubits.h} for an MPI environment. 

Definition in file \hyperlink{qubits__env__mpi_8c_source}{qubits\_\-env\_\-mpi.c}.

\subsubsection{Define Documentation}
\hypertarget{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!\_\-BSD\_\-SOURCE@{\_\-BSD\_\-SOURCE}}
\index{\_\-BSD\_\-SOURCE@{\_\-BSD\_\-SOURCE}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{\_\-BSD\_\-SOURCE}]{\setlength{\rightskip}{0pt plus 5cm}\#define \_\-BSD\_\-SOURCE}\hfill}
\label{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}


Definition at line 8 of file qubits\_\-env\_\-mpi.c.\hypertarget{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!DEBUG@{DEBUG}}
\index{DEBUG@{DEBUG}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{DEBUG}]{\setlength{\rightskip}{0pt plus 5cm}\#define DEBUG~0}\hfill}
\label{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}


Definition at line 27 of file qubits\_\-env\_\-mpi.c.

\subsubsection{Function Documentation}
\hypertarget{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!calcTotalProbability@{calcTotalProbability}}
\index{calcTotalProbability@{calcTotalProbability}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{calcTotalProbability}]{\setlength{\rightskip}{0pt plus 5cm}REAL calcTotalProbability ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}


Calculate the probability of being in any state by taking the norm of the entire state vector. Should be equal to 1.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \end{DoxyParams}
\begin{DoxyReturn}{Returns}
total probability 
\end{DoxyReturn}


Definition at line 126 of file qubits\_\-env\_\-mpi.c.

References DEBUG, ComplexArray::imag, MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
126                                                 {
127   /* IJB - implemented using Kahan summation for greater accuracy at a slight flo
      ating
128      point operation overhead. For more details see https://en.wikipedia.org/wiki
      /Kahan_summation_algorithm */
129   /* Don't change the bracketing in this routine! */
130   REAL pTotal=0; 
131   REAL y, t, c;
132   REAL allRankTotals=0;
133   long long int index;
134   long long int numAmpsPerRank = multiQubit.numAmps;
135   c = 0.0;
136   for (index=0; index<numAmpsPerRank; index++){ 
137     /* Perform pTotal+=multiQubit.stateVec.real[index]*multiQubit.stateVec.real[i
      ndex]; by Kahan */
138     y = multiQubit.stateVec.real[index]*multiQubit.stateVec.real[index] - c;
139     t = pTotal + y;
140     c = ( t - pTotal ) - y;
141     pTotal = t;
142     /* Perform pTotal+=multiQubit.stateVec.imag[index]*multiQubit.stateVec.imag[i
      ndex]; by Kahan */
143     y = multiQubit.stateVec.imag[index]*multiQubit.stateVec.imag[index] - c;
144     t = pTotal + y;
145     c = ( t - pTotal ) - y;
146     pTotal = t;
147   } 
148   if (DEBUG) printf("before calc prob. %d\n", multiQubit.numChunks);
149   if (multiQubit.numChunks>1) MPI_Allreduce(&pTotal, &allRankTotals, 1, 
      MPI_QuEST_REAL, MPI_SUM, MPI_COMM_WORLD);
150   else allRankTotals=pTotal;
151   
152   return allRankTotals;
153 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!chunkIsUpper@{chunkIsUpper}}
\index{chunkIsUpper@{chunkIsUpper}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{chunkIsUpper}]{\setlength{\rightskip}{0pt plus 5cm}static int chunkIsUpper (int {\em chunkId}, \/  long long int {\em chunkSize}, \/  int {\em targetQubit})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}


Returns whether a given chunk in position chunkId is in the upper or lower half of a block. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkId}]id of chunk in state vector \item[\mbox{$\leftarrow$} {\em chunkSize}]number of amps in chunk \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit being rotated \end{DoxyParams}
\begin{DoxyReturn}{Returns}
1: chunk is in upper half of block, 0: chunk is in lower half of block fix -\/-\/ is this the same as isChunkToSkip? 
\end{DoxyReturn}


Definition at line 164 of file qubits\_\-env\_\-mpi.c.

Referenced by compactUnitary(), controlledCompactUnitary(), controlledNot(), controlledUnitary(), hadamard(), multiControlledUnitary(), phaseGate(), sigmaX(), sigmaY(), and unitary().


\begin{DoxyCode}
165 {       
166         long long int sizeHalfBlock = 1LL << (targetQubit);
167         long long int sizeBlock = sizeHalfBlock*2;
168         long long int posInBlock = (chunkId*chunkSize) % sizeBlock;
169         return posInBlock<sizeHalfBlock;
170 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!closeQuESTEnv@{closeQuESTEnv}}
\index{closeQuESTEnv@{closeQuESTEnv}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{closeQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void closeQuESTEnv ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}


Close QuEST environment. If something needs to be done to clean up the execution environment, such as finalizing MPI when running in distributed mode, it is handled here


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 74 of file qubits\_\-env\_\-mpi.c.


\begin{DoxyCode}
74                                 {
75         int finalized;
76         MPI_Finalized(&finalized);
77         if (!finalized) MPI_Finalize();
78         else printf("ERROR: Trying to close QuESTEnv multiple times. Ignoring\n")
      ;
79 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a07418ebac70fd9ae5d051d089961631d}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!collapseToOutcome@{collapseToOutcome}}
\index{collapseToOutcome@{collapseToOutcome}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{collapseToOutcome}]{\setlength{\rightskip}{0pt plus 5cm}REAL collapseToOutcome ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  int {\em outcome})}\hfill}
\label{qubits__env__mpi_8c_a07418ebac70fd9ae5d051d089961631d}


Updates the state vector to be consistent with measuring the measure qubit in the given outcome (0 or 1), and returns the probability of such a measurement outcome. This is effectively performing a measurement and forcing the outcome. This is an irreversible change to the state vector, whereby incompatible states in the state vector are given zero amplitude and the remaining states are renormalised. Exits with error if the given outcome has $\sim$zero probability, and so cannot be collapsed into.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em outcome}]to force the measure qubit to enter \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of the (forced) measurement outcome 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily measureQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or if {\ttfamily outcome} is not in \{0, 1\}, or if the probability of {\ttfamily outcome} is zero (within machine epsilon) \end{DoxyExceptions}


Definition at line 694 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, collapseToOutcomeDistributedRenorm(), collapseToOutcomeDistributedSetZero(), collapseToOutcomeLocal(), findProbabilityOfOutcome(), halfMatrixBlockFitsInChunk(), isChunkToSkipInFindPZero(), MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), REAL, and REAL\_\-EPS.


\begin{DoxyCode}
695 {
696     QuESTAssert(measureQubit >= 0 && measureQubit < multiQubit.numQubits, 2, __fu
      nc__);
697     QuESTAssert((outcome==0 || outcome==1), 10, __func__);
698 
699         REAL totalStateProb=findProbabilityOfOutcome(multiQubit, measureQubit, ou
      tcome);
700     QuESTAssert(fabs(totalStateProb)>REAL_EPS, 8, __func__);
701 
702         int skipValuesWithinRank = halfMatrixBlockFitsInChunk(multiQubit.numAmps,
       measureQubit);
703     if (skipValuesWithinRank) {
704         collapseToOutcomeLocal(multiQubit, measureQubit, totalStateProb, outcome)
      ;
705     } else {
706         if (!isChunkToSkipInFindPZero(multiQubit.chunkId, multiQubit.numAmps, mea
      sureQubit)){
707             // chunk has amps for q=0
708             if (outcome==0) collapseToOutcomeDistributedRenorm(multiQubit, measur
      eQubit, 
709                     totalStateProb);
710             else collapseToOutcomeDistributedSetZero(multiQubit, measureQubit);
711         } else {
712             // chunk has amps for q=1
713             if (outcome==1) collapseToOutcomeDistributedRenorm(multiQubit, measur
      eQubit, 
714                     totalStateProb);
715             else collapseToOutcomeDistributedSetZero(multiQubit, measureQubit);
716         }
717     }
718         return totalStateProb;
719 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a03b13dfcabd8c59b50dbdd3af44ba8b2}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!compactUnitary@{compactUnitary}}
\index{compactUnitary@{compactUnitary}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{compactUnitary}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitary ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__env__mpi_8c_a03b13dfcabd8c59b50dbdd3af44ba8b2}


Apply a single-\/qubit unitary parameterised by two given complex scalars. Given valid complex numbers $\alpha$ and $\beta$, applies the unitary \[ U = \begin{pmatrix} \alpha & -\beta^* \\ \beta & \alpha^* \end{pmatrix} \] which is general up to a global phase factor. Valid $\alpha$, $\beta$ satisfy $|\alpha|^2 + |\beta|^2 = 1$.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {U}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \item[\mbox{$\leftarrow$} {\em alpha}]complex unitary parameter (row 1, column 1) \item[\mbox{$\leftarrow$} {\em beta}]complex unitary parameter (row 2, column 1) \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or if {\ttfamily alpha}, {\ttfamily beta} don't satisfy $|${\ttfamily alpha$|$$^\wedge$2} + $|${\ttfamily beta$|$$^\wedge$2} = 1. \end{DoxyExceptions}


Definition at line 288 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), compactUnitaryDistributed(), compactUnitaryLocal(), exchangeStateVectors(), getChunkPairId(), getRotAngle(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, and validateAlphaBeta().

Referenced by rotateAroundAxis().


\begin{DoxyCode}
289 {
290         QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __
      func__);
291         QuESTAssert(validateAlphaBeta(alpha, beta), 6, __func__);
292 
293         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
294         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, tar
      getQubit);
295         Complex rot1, rot2;
296 
297         // rank's chunk is in upper half of block 
298         int rankIsUpper;
299         int pairRank; // rank of corresponding chunk
300 
301         if (useLocalDataOnly){
302                 // all values required to update state vector lie in this rank
303                 compactUnitaryLocal(multiQubit, targetQubit, alpha, beta);
304         } else {
305                 // need to get corresponding chunk of state vector from other ran
      k
306                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, targetQubit);
307                 getRotAngle(rankIsUpper, &rot1, &rot2, alpha, beta);
308                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, targetQubit);
309                 // get corresponding values from my pair
310                         exchangeStateVectors(multiQubit, pairRank);
311 
312                 // this rank's values are either in the upper of lower half of th
      e block. 
313                         // send values to compactUnitaryDistributed in the correc
      t order
314                 if (rankIsUpper){
315                         compactUnitaryDistributed(multiQubit,targetQubit,rot1,rot
      2,
316                                 multiQubit.stateVec, //upper
317                                 multiQubit.pairStateVec, //lower
318                                 multiQubit.stateVec); //output
319                 } else {
320                         compactUnitaryDistributed(multiQubit,targetQubit,rot1,rot
      2,
321                                 multiQubit.pairStateVec, //upper
322                                 multiQubit.stateVec, //lower
323                                 multiQubit.stateVec); //output
324                 }
325         }
326 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ab4812953bc457405b3aa05a4c2f64f4a}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!controlledCompactUnitary@{controlledCompactUnitary}}
\index{controlledCompactUnitary@{controlledCompactUnitary}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{controlledCompactUnitary}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitary ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__env__mpi_8c_ab4812953bc457405b3aa05a4c2f64f4a}


Apply a controlled unitary (single control, single target) parameterised by two given complex scalars. Given valid complex numbers $\alpha$ and $\beta$, applies the two-\/qubit unitary \[ \begin{pmatrix} 1 \\ & 1 \\ & & \alpha & -\beta^* \\ & & \beta & \alpha^* \end{pmatrix} \] to the control and target qubits. Valid $\alpha$, $\beta$ satisfy $|\alpha|^2 + |\beta|^2 = 1$. The target unitary is general up to a global phase factor.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {control}; \node[draw=none] at (-3.5, 0) {target}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 1); \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$U_{\alpha, \beta}$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em controlQubit}]apply the target unitary if this qubit has value 1 \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit on which to apply the target unitary \item[\mbox{$\leftarrow$} {\em alpha}]complex unitary parameter (row 1, column 1) \item[\mbox{$\leftarrow$} {\em beta}]complex unitary parameter (row 2, column 1) \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if either {\ttfamily controlQubit} or {\ttfamily targetQubit} are outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) or are equal, or if {\ttfamily alpha}, {\ttfamily beta} don't satisfy $|${\ttfamily alpha$|$$^\wedge$2} + $|${\ttfamily beta$|$$^\wedge$2} = 1. \end{DoxyExceptions}


Definition at line 370 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), controlledCompactUnitaryDistributed(), controlledCompactUnitaryLocal(), exchangeStateVectors(), getChunkPairId(), getRotAngle(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, and validateAlphaBeta().

Referenced by controlledRotateAroundAxis().


\begin{DoxyCode}
371 {
372         QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __
      func__);
373         QuESTAssert(controlQubit >= 0 && controlQubit < multiQubit.numQubits, 2, 
      __func__);
374         QuESTAssert(controlQubit != targetQubit, 3, __func__);
375         QuESTAssert(validateAlphaBeta(alpha, beta), 6, __func__);
376 
377         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
378         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, tar
      getQubit);
379         Complex rot1, rot2;
380 
381         // rank's chunk is in upper half of block 
382         int rankIsUpper;
383         int pairRank; // rank of corresponding chunk
384 
385         if (useLocalDataOnly){
386                 // all values required to update state vector lie in this rank
387                 controlledCompactUnitaryLocal(multiQubit, controlQubit, targetQub
      it, alpha, beta);
388         } else {
389                 // need to get corresponding chunk of state vector from other ran
      k
390                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, targetQubit);
391                 getRotAngle(rankIsUpper, &rot1, &rot2, alpha, beta);
392                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, targetQubit);
393                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
394                 // get corresponding values from my pair
395                 exchangeStateVectors(multiQubit, pairRank);
396                 
397                 // this rank's values are either in the upper of lower half of th
      e block. send values to controlledCompactUnitaryDistributed
398                 // in the correct order
399                 if (rankIsUpper){
400                         controlledCompactUnitaryDistributed(multiQubit,controlQub
      it,targetQubit,rot1,rot2,
401                                 multiQubit.stateVec, //upper
402                                 multiQubit.pairStateVec, //lower
403                                 multiQubit.stateVec); //output
404                 } else {
405                         controlledCompactUnitaryDistributed(multiQubit,controlQub
      it,targetQubit,rot1,rot2,
406                                 multiQubit.pairStateVec, //upper
407                                 multiQubit.stateVec, //lower
408                                 multiQubit.stateVec); //output
409                 }
410         }
411 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a67576895bbc65463481a8ea24d9b1e22}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!controlledNot@{controlledNot}}
\index{controlledNot@{controlledNot}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{controlledNot}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNot ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__env__mpi_8c_a67576895bbc65463481a8ea24d9b1e22}


Apply the controlled not (single control, single target) gate, also known as the c-\/X, c-\/sigma-\/X, c-\/Pauli-\/X and c-\/bit-\/flip gate. This applies sigmaX to the target qubit if the control qubit has value 1. This effects the two-\/qubit unitary \[ \begin{pmatrix} 1 \\ & 1 \\\ & & & 1 \\ & & 1 \end{pmatrix} \] on the control and target qubits.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {control}; \node[draw=none] at (-3.5, 0) {target}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, -.5); \draw (-2,0) -- (2, 0); \draw (0, 0) circle (.5); \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em controlQubit}]nots the target if this qubit is 1 \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to not \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if either {\ttfamily controlQubit} or {\ttfamily targetQubit} are outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or are equal. \end{DoxyExceptions}


Definition at line 532 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), controlledNotDistributed(), controlledNotLocal(), exchangeStateVectors(), getChunkPairId(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), and MultiQubit::stateVec.


\begin{DoxyCode}
533 {
534         QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __
      func__);
535         QuESTAssert(controlQubit >= 0 && controlQubit < multiQubit.numQubits, 2, 
      __func__);
536         QuESTAssert(controlQubit != targetQubit, 3, __func__);
537 
538         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
539         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, tar
      getQubit);
540 
541         // rank's chunk is in upper half of block 
542         int rankIsUpper;
543         int pairRank; // rank of corresponding chunk
544 
545         if (useLocalDataOnly){
546                 // all values required to update state vector lie in this rank
547                 controlledNotLocal(multiQubit, controlQubit, targetQubit);
548         } else {
549                 // need to get corresponding chunk of state vector from other ran
      k
550                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, targetQubit);
551                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, targetQubit);
552                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
553                 // get corresponding values from my pair
554                 exchangeStateVectors(multiQubit, pairRank);
555                 // this rank's values are either in the upper of lower half of th
      e block. send values to controlledNot
556                 // in the correct order
557                 if (rankIsUpper){
558                         controlledNotDistributed(multiQubit,controlQubit,targetQu
      bit,
559                                 multiQubit.pairStateVec, //in
560                                 multiQubit.stateVec); //out
561                 } else {
562                         controlledNotDistributed(multiQubit,controlQubit,targetQu
      bit,
563                                 multiQubit.pairStateVec, //in
564                                 multiQubit.stateVec); //out
565                 }
566         }
567 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a8a701526263392599aa21d0d0f05d9d8}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!controlledUnitary@{controlledUnitary}}
\index{controlledUnitary@{controlledUnitary}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{controlledUnitary}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitary ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__env__mpi_8c_a8a701526263392599aa21d0d0f05d9d8}


Apply a general controlled unitary (single control, single target), which can include a global phase factor. The given unitary is applied to the target qubit if the control qubit has value 1, effecting the two-\/qubit unitary \[ \begin{pmatrix} 1 \\ & 1 \\ & & u_{00} & u_{01}\\ & & u_{10} & u_{11} \end{pmatrix} \] on the control and target qubits.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {control}; \node[draw=none] at (-3.5, 0) {target}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 1); \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {U}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em controlQubit}]apply unitary if this qubit is 1 \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \item[\mbox{$\leftarrow$} {\em u}]single-\/qubit unitary matrix to apply \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if either {\ttfamily controlQubit} or {\ttfamily targetQubit} are outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) or are equal, or if {\ttfamily u} is not unitary. \end{DoxyExceptions}


Definition at line 413 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), controlledUnitaryDistributed(), controlledUnitaryLocal(), exchangeStateVectors(), getChunkPairId(), getRotAngleFromUnitaryMatrix(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, and validateMatrixIsUnitary().


\begin{DoxyCode}
415 {
416         QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __
      func__);
417         QuESTAssert(controlQubit >= 0 && controlQubit < multiQubit.numQubits, 2, 
      __func__);
418         QuESTAssert(controlQubit != targetQubit, 3, __func__);
419         QuESTAssert(validateMatrixIsUnitary(u), 5, __func__);
420 
421         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
422         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, tar
      getQubit);
423         Complex rot1, rot2;
424 
425         // rank's chunk is in upper half of block 
426         int rankIsUpper;
427         int pairRank; // rank of corresponding chunk
428 
429         if (useLocalDataOnly){
430                 // all values required to update state vector lie in this rank
431                 controlledUnitaryLocal(multiQubit, controlQubit, targetQubit, u);
      
432         } else {
433                 // need to get corresponding chunk of state vector from other ran
      k
434                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, targetQubit);
435                 getRotAngleFromUnitaryMatrix(rankIsUpper, &rot1, &rot2, u);
436                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, targetQubit);
437                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
438                 // get corresponding values from my pair
439                 exchangeStateVectors(multiQubit, pairRank);
440                 
441                 // this rank's values are either in the upper of lower half of th
      e block. send values to controlledUnitaryDistributed
442                 // in the correct order
443                 if (rankIsUpper){
444                         controlledUnitaryDistributed(multiQubit,controlQubit,targ
      etQubit,rot1,rot2,
445                                 multiQubit.stateVec, //upper
446                                 multiQubit.pairStateVec, //lower
447                                 multiQubit.stateVec); //output
448                 } else {
449                         controlledUnitaryDistributed(multiQubit,controlQubit,targ
      etQubit,rot1,rot2,
450                                 multiQubit.pairStateVec, //upper
451                                 multiQubit.stateVec, //lower
452                                 multiQubit.stateVec); //output
453                 }
454         }
455 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!exchangeStateVectors@{exchangeStateVectors}}
\index{exchangeStateVectors@{exchangeStateVectors}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{exchangeStateVectors}]{\setlength{\rightskip}{0pt plus 5cm}void exchangeStateVectors ({\bf MultiQubit} {\em multiQubit}, \/  int {\em pairRank})}\hfill}
\label{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}


Definition at line 256 of file qubits\_\-env\_\-mpi.c.

References DEBUG, ComplexArray::imag, MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, MultiQubit::pairStateVec, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by compactUnitary(), controlledCompactUnitary(), controlledNot(), controlledUnitary(), hadamard(), multiControlledUnitary(), sigmaX(), sigmaY(), and unitary().


\begin{DoxyCode}
256                                                               {
257         // MPI send/receive vars
258         int TAG=100;
259         MPI_Status status;
260 
261         // Multiple messages are required as MPI uses int rather than long long i
      nt for count
262         // For openmpi, messages are further restricted to 2GB in size -- do this
       for all cases
263         // to be safe
264         long long int maxMessageCount = 1LL<<29;
265         if (sizeof(REAL)==8) maxMessageCount = (1LL<<28);
266         else if (sizeof(REAL)==16) maxMessageCount = (1LL<<27);
267 
268         if (multiQubit.numAmps<maxMessageCount) maxMessageCount = multiQubit.
      numAmps;
269         int numMessages = multiQubit.numAmps/maxMessageCount;
270         int i;
271         long long int offset;
272         if (DEBUG) printf("numMessages %d maxMessageCount %lld\n", numMessages, m
      axMessageCount);
273 
274         // send my state vector to pairRank's multiQubit.pairStateVec
275         // receive pairRank's state vector into multiQubit.pairStateVec
276         for (i=0; i<numMessages; i++){
277                 offset = i*maxMessageCount;
278                 MPI_Sendrecv(&multiQubit.stateVec.real[offset], maxMessageCount, 
      MPI_QuEST_REAL, pairRank, TAG,
279                                  &multiQubit.pairStateVec.real[offset], maxMessag
      eCount, MPI_QuEST_REAL,
280                                  pairRank, TAG, MPI_COMM_WORLD, &status);
281                 //printf("rank: %d err: %d\n", multiQubit.rank, err);
282                 MPI_Sendrecv(&multiQubit.stateVec.imag[offset], maxMessageCount, 
      MPI_QuEST_REAL, pairRank, TAG,
283                                 &multiQubit.pairStateVec.imag[offset], maxMessage
      Count, MPI_QuEST_REAL,
284                                 pairRank, TAG, MPI_COMM_WORLD, &status);
285         }
286 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ae5f9019826f35e8b51b1716cfe397b45}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!exitWithError@{exitWithError}}
\index{exitWithError@{exitWithError}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{exitWithError}]{\setlength{\rightskip}{0pt plus 5cm}void exitWithError (int {\em errorCode}, \/  const char $\ast$ {\em func})}\hfill}
\label{qubits__env__mpi_8c_ae5f9019826f35e8b51b1716cfe397b45}


Definition at line 768 of file qubits\_\-env\_\-mpi.c.

References errorCodes.


\begin{DoxyCode}
768                                                    {
769     printf("!!!\n");
770     printf("QuEST Error in function %s: %s\n", func, errorCodes[errorCode]);
771     printf("!!!\n");
772     printf("exiting..\n");
773     MPI_Abort(MPI_COMM_WORLD, errorCode);
774 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!findProbabilityOfOutcome@{findProbabilityOfOutcome}}
\index{findProbabilityOfOutcome@{findProbabilityOfOutcome}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{findProbabilityOfOutcome}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfOutcome ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  int {\em outcome})}\hfill}
\label{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}


Gives the probability of a specified qubit being measured in the given outcome (0 or 1). This performs no actual measurement and does not change the state of the qubits.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to study \item[\mbox{$\leftarrow$} {\em outcome}]for which to find the probability of the qubit being measured in \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being measured in the given outcome 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily measureQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or if {\ttfamily outcome} is not in \{0, 1\}. \end{DoxyExceptions}


Definition at line 675 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, findProbabilityOfZeroDistributed(), findProbabilityOfZeroLocal(), halfMatrixBlockFitsInChunk(), isChunkToSkipInFindPZero(), MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), and REAL.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
676 {
677     QuESTAssert(measureQubit >= 0 && measureQubit < multiQubit.numQubits, 2, __fu
      nc__);
678 
679         REAL stateProb=0, totalStateProb=0;
680         int skipValuesWithinRank = halfMatrixBlockFitsInChunk(multiQubit.numAmps,
       measureQubit);
681         if (skipValuesWithinRank) {
682                 stateProb = findProbabilityOfZeroLocal(multiQubit, measureQubit);
      
683         } else {
684                 if (!isChunkToSkipInFindPZero(multiQubit.chunkId, multiQubit.
      numAmps, measureQubit)){
685                         stateProb = findProbabilityOfZeroDistributed(multiQubit, 
      measureQubit);
686                 } else stateProb = 0;
687         }
688         MPI_Allreduce(&stateProb, &totalStateProb, 1, MPI_QuEST_REAL, MPI_SUM, MP
      I_COMM_WORLD);
689         if (outcome==1) totalStateProb = 1.0 - totalStateProb;
690         return totalStateProb;
691 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getChunkIdFromIndex@{getChunkIdFromIndex}}
\index{getChunkIdFromIndex@{getChunkIdFromIndex}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getChunkIdFromIndex}]{\setlength{\rightskip}{0pt plus 5cm}int getChunkIdFromIndex ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}


Definition at line 102 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::numAmps.

Referenced by getImagAmpEl(), and getRealAmpEl().


\begin{DoxyCode}
102                                                                    {
103         return index/multiQubit.numAmps; // this is numAmpsPerChunk
104 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getChunkPairId@{getChunkPairId}}
\index{getChunkPairId@{getChunkPairId}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getChunkPairId}]{\setlength{\rightskip}{0pt plus 5cm}static int getChunkPairId (int {\em chunkIsUpper}, \/  int {\em chunkId}, \/  long long int {\em chunkSize}, \/  int {\em targetQubit})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}


get position of corresponding chunk, holding values required to update values in my chunk (with chunkId) when rotating targetQubit. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkIsUpper}]1: chunk is in upper half of block, 0: chunk is in lower half \item[\mbox{$\leftarrow$} {\em chunkId}]id of chunk in state vector \item[\mbox{$\leftarrow$} {\em chunkSize}]number of amps in chunk \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit being rotated \end{DoxyParams}
\begin{DoxyReturn}{Returns}
chunkId of chunk required to rotate targetQubit 
\end{DoxyReturn}


Definition at line 231 of file qubits\_\-env\_\-mpi.c.

Referenced by compactUnitary(), controlledCompactUnitary(), controlledNot(), controlledUnitary(), hadamard(), multiControlledUnitary(), sigmaX(), sigmaY(), and unitary().


\begin{DoxyCode}
232 {
233         long long int sizeHalfBlock = 1LL << (targetQubit);
234         int chunksPerHalfBlock = sizeHalfBlock/chunkSize;
235         if (chunkIsUpper){
236                 return chunkId + chunksPerHalfBlock;
237         } else {
238                 return chunkId - chunksPerHalfBlock;
239         }
240 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getImagAmpEl@{getImagAmpEl}}
\index{getImagAmpEl@{getImagAmpEl}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getImagAmpEl}]{\setlength{\rightskip}{0pt plus 5cm}REAL getImagAmpEl ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})}\hfill}
\label{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}


Get the imaginary component of the complex probability amplitude at an index in the state vector. For debugging purposes.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \item[\mbox{$\leftarrow$} {\em index}]index in state vector of probability amplitudes \end{DoxyParams}
\begin{DoxyReturn}{Returns}
imaginary component at that index 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily index} is outside \mbox{[}0, $2^{N}$) where $N = $ {\ttfamily multiQubit.numQubits} \end{DoxyExceptions}


Definition at line 116 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, getChunkIdFromIndex(), ComplexArray::imag, MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, REAL, and MultiQubit::stateVec.

Referenced by getProbEl().


\begin{DoxyCode}
116                                                              {
117         int chunkId = getChunkIdFromIndex(multiQubit, index);
118         REAL el; 
119         if (multiQubit.chunkId==chunkId){
120                 el = multiQubit.stateVec.imag[index-chunkId*multiQubit.numAmps];
121         }
122         MPI_Bcast(&el, 1, MPI_QuEST_REAL, chunkId, MPI_COMM_WORLD);
123         return el; 
124 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getRealAmpEl@{getRealAmpEl}}
\index{getRealAmpEl@{getRealAmpEl}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getRealAmpEl}]{\setlength{\rightskip}{0pt plus 5cm}REAL getRealAmpEl ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})}\hfill}
\label{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}


Get the real component of the complex probability amplitude at an index in the state vector. For debugging purposes.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \item[\mbox{$\leftarrow$} {\em index}]index in state vector of probability amplitudes \end{DoxyParams}
\begin{DoxyReturn}{Returns}
real component at that index 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily index} is outside \mbox{[}0, $2^{N}$) where $N = $ {\ttfamily multiQubit.numQubits} \end{DoxyExceptions}


Definition at line 106 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, getChunkIdFromIndex(), MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by getProbEl().


\begin{DoxyCode}
106                                                              {
107         int chunkId = getChunkIdFromIndex(multiQubit, index);
108         REAL el; 
109         if (multiQubit.chunkId==chunkId){
110                 el = multiQubit.stateVec.real[index-chunkId*multiQubit.numAmps];
111         }
112         MPI_Bcast(&el, 1, MPI_QuEST_REAL, chunkId, MPI_COMM_WORLD);
113         return el; 
114 } 
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getRotAngle@{getRotAngle}}
\index{getRotAngle@{getRotAngle}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getRotAngle}]{\setlength{\rightskip}{0pt plus 5cm}static void getRotAngle (int {\em chunkIsUpper}, \/  {\bf Complex} $\ast$ {\em rot1}, \/  {\bf Complex} $\ast$ {\em rot2}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}


Get rotation values for a given chunk. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkIsUpper}]1: chunk is in upper half of block, 0: chunk is in lower half\item[\mbox{$\rightarrow$} {\em rot1,rot2}]rotation values to use, allocated for upper/lower such that \begin{DoxyVerb}
stateUpper = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 or \begin{DoxyVerb}
stateLower = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
\item[\mbox{$\leftarrow$} {\em alpha,beta}]initial rotation values \end{DoxyParams}


Definition at line 186 of file qubits\_\-env\_\-mpi.c.

References Complex::imag, and Complex::real.

Referenced by compactUnitary(), and controlledCompactUnitary().


\begin{DoxyCode}
187 {
188         if (chunkIsUpper){
189                 *rot1=alpha;
190                 rot2->real=-beta.real;
191                 rot2->imag=-beta.imag;
192         } else {
193                 *rot1=beta;
194                 *rot2=alpha;
195         }
196 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getRotAngleFromUnitaryMatrix@{getRotAngleFromUnitaryMatrix}}
\index{getRotAngleFromUnitaryMatrix@{getRotAngleFromUnitaryMatrix}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getRotAngleFromUnitaryMatrix}]{\setlength{\rightskip}{0pt plus 5cm}static void getRotAngleFromUnitaryMatrix (int {\em chunkIsUpper}, \/  {\bf Complex} $\ast$ {\em rot1}, \/  {\bf Complex} $\ast$ {\em rot2}, \/  {\bf ComplexMatrix2} {\em u})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}


Get rotation values for a given chunk given a unitary matrix. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkIsUpper}]1: chunk is in upper half of block, 0: chunk is in lower half\item[\mbox{$\rightarrow$} {\em rot1,rot2}]rotation values to use, allocated for upper/lower such that \begin{DoxyVerb}
stateUpper = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 or \begin{DoxyVerb}
stateLower = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 \item[\mbox{$\leftarrow$} {\em u}]unitary matrix operation \end{DoxyParams}


Definition at line 211 of file qubits\_\-env\_\-mpi.c.

References ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, and ComplexMatrix2::r1c1.

Referenced by controlledUnitary(), multiControlledUnitary(), and unitary().


\begin{DoxyCode}
212 {
213         if (chunkIsUpper){
214                 *rot1=u.r0c0;
215                 *rot2=u.r0c1;
216         } else {
217                 *rot1=u.r1c0;
218                 *rot2=u.r1c1;
219         }
220 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_aa09b5dd93de6df1384b8f2c0041749ab}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!hadamard@{hadamard}}
\index{hadamard@{hadamard}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{hadamard}]{\setlength{\rightskip}{0pt plus 5cm}void hadamard ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__env__mpi_8c_aa09b5dd93de6df1384b8f2c0041749ab}


Apply the single-\/qubit Hadamard gate. This takes $|0\rangle$ to $|+\rangle$ and $|1\rangle$ to $|-\rangle$, and is equivalent to a rotation of $\pi$ around the x-\/axis then $\pi/2$ about the y-\/axis on the Bloch-\/sphere. I.e. \[ \frac{1}{\sqrt{2}} \begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {H}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 618 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), hadamardDistributed(), hadamardLocal(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), and MultiQubit::stateVec.


\begin{DoxyCode}
619 {
620         QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __
      func__);
621 
622         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
623         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, tar
      getQubit);
624 
625         // rank's chunk is in upper half of block 
626         int rankIsUpper;
627         int pairRank; // rank of corresponding chunk
628 
629         if (useLocalDataOnly){
630                 // all values required to update state vector lie in this rank
631                 hadamardLocal(multiQubit, targetQubit);
632         } else {
633                 // need to get corresponding chunk of state vector from other ran
      k
634                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, targetQubit);
635                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, targetQubit);
636                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
637                 // get corresponding values from my pair
638                 exchangeStateVectors(multiQubit, pairRank);
639                 // this rank's values are either in the upper of lower half of th
      e block. send values to hadamardDistributed
640                 // in the correct order
641                 if (rankIsUpper){
642                         hadamardDistributed(multiQubit,targetQubit,
643                                 multiQubit.stateVec, //upper
644                                 multiQubit.pairStateVec, //lower
645                                 multiQubit.stateVec, rankIsUpper); //output
646                 } else {
647                         hadamardDistributed(multiQubit,targetQubit,
648                                 multiQubit.pairStateVec, //upper
649                                 multiQubit.stateVec, //lower
650                                 multiQubit.stateVec, rankIsUpper); //output
651                 }
652         }
653 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!halfMatrixBlockFitsInChunk@{halfMatrixBlockFitsInChunk}}
\index{halfMatrixBlockFitsInChunk@{halfMatrixBlockFitsInChunk}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{halfMatrixBlockFitsInChunk}]{\setlength{\rightskip}{0pt plus 5cm}static int halfMatrixBlockFitsInChunk (long long int {\em chunkSize}, \/  int {\em targetQubit})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}


return whether the current qubit rotation will use blocks that fit within a single chunk. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkSize}]number of amps in chunk \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit being rotated \end{DoxyParams}
\begin{DoxyReturn}{Returns}
1: one chunk fits in one block 0: chunk is larger than block 
\end{DoxyReturn}


Definition at line 249 of file qubits\_\-env\_\-mpi.c.

Referenced by collapseToOutcome(), compactUnitary(), controlledCompactUnitary(), controlledNot(), controlledUnitary(), findProbabilityOfOutcome(), hadamard(), measureWithStats(), multiControlledUnitary(), phaseGate(), sigmaX(), sigmaY(), and unitary().


\begin{DoxyCode}
250 {
251         long long int sizeHalfBlock = 1LL << (targetQubit);
252         if (chunkSize > sizeHalfBlock) return 1;
253         else return 0;
254 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!initQuESTEnv@{initQuESTEnv}}
\index{initQuESTEnv@{initQuESTEnv}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{initQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void initQuESTEnv ({\bf QuESTEnv} $\ast$ {\em env})}\hfill}
\label{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}


Initialize the QuEST environment. If something needs to be done to set up the execution environment, such as initializing MPI when running in distributed mode, it is handled here


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 35 of file qubits\_\-env\_\-mpi.c.

References DEBUG, init\_\-by\_\-array(), QuESTEnv::numRanks, and QuESTEnv::rank.


\begin{DoxyCode}
35                                 {
36         // init MPI environment
37         int rank, numRanks, initialized;
38         MPI_Initialized(&initialized);
39         if (!initialized){
40                 MPI_Init(NULL, NULL);
41                 MPI_Comm_size(MPI_COMM_WORLD, &numRanks);
42                 MPI_Comm_rank(MPI_COMM_WORLD, &rank);
43 
44                 if (DEBUG) {
45                         char hostName[256];
46                         int hostNameLen;
47                         MPI_Get_processor_name(hostName, &hostNameLen);
48                         printf("rank %d on host %s\n", rank, hostName);
49                 }
50                 env->rank=rank;
51                 env->numRanks=numRanks;
52 
53         // init MT random number generator with two keys -- time and pid 
54         // it is ok that all procs will get the same seed as random numbers will 
      only be 
55         // used by the master process
56         unsigned long int secs = time(NULL);
57         unsigned long int pid = getpid();
58         unsigned long int key[2];
59         key[0] = secs; key[1] = pid;
60         init_by_array(key, 2);
61         } else printf("ERROR: Trying to initialize QuESTEnv multiple times. Ignor
      ing\n");
62 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!isChunkToSkipInFindPZero@{isChunkToSkipInFindPZero}}
\index{isChunkToSkipInFindPZero@{isChunkToSkipInFindPZero}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{isChunkToSkipInFindPZero}]{\setlength{\rightskip}{0pt plus 5cm}static int isChunkToSkipInFindPZero (int {\em chunkId}, \/  long long int {\em chunkSize}, \/  int {\em measureQubit})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}


Find chunks to skip when calculating probability of qubit being zero. When calculating probability of a bit q being zero, sum up 2$^\wedge$q values, then skip 2$^\wedge$q values, etc. This function finds if an entire chunk is in the range of values to be skipped


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkId}]id of chunk in state vector \item[\mbox{$\leftarrow$} {\em chunkSize}]number of amps in chunk \item[\mbox{$\leftarrow$} {\em measureQubi}]qubit being measured \end{DoxyParams}
\begin{DoxyReturn}{Returns}
int -\/-\/ 1: skip, 0: don't skip 
\end{DoxyReturn}


Definition at line 666 of file qubits\_\-env\_\-mpi.c.

Referenced by collapseToOutcome(), findProbabilityOfOutcome(), and measureWithStats().


\begin{DoxyCode}
667 {
668         long long int sizeHalfBlock = 1LL << (measureQubit);
669         int numChunksToSkip = sizeHalfBlock/chunkSize;
670         // calculate probability by summing over numChunksToSkip, then skipping n
      umChunksToSkip, etc
671         int bitToCheck = chunkId & numChunksToSkip;
672         return bitToCheck;
673 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ad5774247d836267175c664cd0e451bcb}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!measure@{measure}}
\index{measure@{measure}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{measure}]{\setlength{\rightskip}{0pt plus 5cm}int measure ({\bf MultiQubit} {\em multiQubit}, \/  int {\em measureQubit})}\hfill}
\label{qubits__env__mpi_8c_ad5774247d836267175c664cd0e451bcb}


Measures a single qubit, collapsing it randomly to 0 or 1. Outcome probabilities are weighted by the state vector, which is irreversibly changed after collapse to be consistent with the outcome.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
the measurement outcome, 0 or 1 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily measureQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) \end{DoxyExceptions}


Definition at line 722 of file qubits\_\-env\_\-mpi.c.

References measureWithStats(), MultiQubit::numQubits, QuESTAssert(), and REAL.


\begin{DoxyCode}
722                                                     {
723     QuESTAssert(measureQubit >= 0 && measureQubit < multiQubit.numQubits, 2, __fu
      nc__);
724     REAL stateProb; 
725     return measureWithStats(multiQubit, measureQubit, &stateProb); 
726 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a2ac46e470c750bf93c754e06c64b0a7a}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!measureWithStats@{measureWithStats}}
\index{measureWithStats@{measureWithStats}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{measureWithStats}]{\setlength{\rightskip}{0pt plus 5cm}int measureWithStats ({\bf MultiQubit} {\em multiQubit}, \/  int {\em measureQubit}, \/  REAL $\ast$ {\em stateProb})}\hfill}
\label{qubits__env__mpi_8c_a2ac46e470c750bf93c754e06c64b0a7a}


Measures a single qubit, collapsing it randomly to 0 or 1, and additionally gives the probability of that outcome. Outcome probabilities are weighted by the state vector, which is irreversibly changed after collapse to be consistent with the outcome.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\rightarrow$} {\em stateProb}]a pointer to a REAL which is set to the probability of the occurred outcome \end{DoxyParams}
\begin{DoxyReturn}{Returns}
the measurement outcome, 0 or 1 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily measureQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) \end{DoxyExceptions}


Definition at line 728 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, collapseToOutcomeDistributedRenorm(), collapseToOutcomeDistributedSetZero(), collapseToOutcomeLocal(), findProbabilityOfOutcome(), genrand\_\-real1(), halfMatrixBlockFitsInChunk(), isChunkToSkipInFindPZero(), MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), REAL, and REAL\_\-EPS.

Referenced by measure().


\begin{DoxyCode}
728                                                                               {
729     QuESTAssert(measureQubit >= 0 && measureQubit < multiQubit.numQubits, 2, __fu
      nc__);
730 
731     int outcome;
732     // find probability of qubit being in state 1
733     REAL stateProbInternal = findProbabilityOfOutcome(multiQubit, measureQubit, 1
      );
734 
735     // we can't collapse to a state that has a probability too close to zero
736     if (stateProbInternal<REAL_EPS) outcome=0;
737     else if (1-stateProbInternal<REAL_EPS) outcome=1;
738     else {
739         // ok. both P(0) and P(1) are large enough to resolve
740         // generate random float on [0,1]
741         float randNum = genrand_real1();
742         if (randNum<=stateProbInternal) outcome = 1;
743         else outcome = 0;
744     } 
745     if (outcome==0) stateProbInternal = 1-stateProbInternal;
746 
747         int skipValuesWithinRank = halfMatrixBlockFitsInChunk(multiQubit.numAmps,
       measureQubit);
748     if (skipValuesWithinRank) {
749         collapseToOutcomeLocal(multiQubit, measureQubit, stateProbInternal, outco
      me);
750     } else {
751         if (!isChunkToSkipInFindPZero(multiQubit.chunkId, multiQubit.numAmps, mea
      sureQubit)){
752             // chunk has amps for q=0
753             if (outcome==0) collapseToOutcomeDistributedRenorm(multiQubit, measur
      eQubit, 
754                     stateProbInternal);
755             else collapseToOutcomeDistributedSetZero(multiQubit, measureQubit);
756         } else {
757             // chunk has amps for q=1
758             if (outcome==1) collapseToOutcomeDistributedRenorm(multiQubit, measur
      eQubit, 
759                     stateProbInternal);
760             else collapseToOutcomeDistributedSetZero(multiQubit, measureQubit);
761         }
762     }
763 
764     *stateProb = stateProbInternal;
765     return outcome;
766 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ae395a79690283ed81106afadd7a8cd8a}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!multiControlledUnitary@{multiControlledUnitary}}
\index{multiControlledUnitary@{multiControlledUnitary}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{multiControlledUnitary}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitary ({\bf MultiQubit} {\em multiQubit}, \/  int $\ast$ {\em controlQubits}, \/  const int {\em numControlQubits}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__env__mpi_8c_ae395a79690283ed81106afadd7a8cd8a}


Apply a general multiple-\/control single-\/target unitary, which can include a global phase factor. Any number of control qubits can be specified, and if all have value 1, the given unitary is applied to the target qubit. This effects the many-\/qubit unitary \[ \begin{pmatrix} 1 \\ & 1 \\\ & & \ddots \\ & & & u_{00} & u_{01}\\ & & & u_{10} & u_{11} \end{pmatrix} \] on the control and target qubits. The given 2x2 ComplexMatrix must be unitary, otherwise an error is thrown.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 3) {controls}; \node[draw=none] at (-3.5, 0) {target}; \node[draw=none] at (0, 6) {$\vdots$}; \draw (0, 5) -- (0, 4); \draw (-2, 4) -- (2, 4); \draw[fill=black] (0, 4) circle (.2); \draw (0, 4) -- (0, 2); \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 1); \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {U}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em controlQubits}]applies unitary if all qubits in this array equal 1 \item[\mbox{$\leftarrow$} {\em numControlQubits}]number of control qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \item[\mbox{$\leftarrow$} {\em u}]single-\/qubit unitary matrix to apply \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily numControlQubits} is outside \mbox{[}1, {\ttfamily multiQubit.numQubits}\mbox{]}), or if any qubit index ({\ttfamily targetQubit} or one in {\ttfamily controlQubits}) is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}\mbox{]}), or if {\ttfamily controlQubits} contains {\ttfamily targetQubit}, or if {\ttfamily u} is not unitary. \end{DoxyExceptions}


Definition at line 457 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), getRotAngleFromUnitaryMatrix(), halfMatrixBlockFitsInChunk(), multiControlledUnitaryDistributed(), multiControlledUnitaryLocal(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, and validateMatrixIsUnitary().


\begin{DoxyCode}
458 {
459         QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __
      func__);
460         QuESTAssert(numControlQubits > 0 && numControlQubits <= multiQubit.
      numQubits, 4, __func__);
461         QuESTAssert(validateMatrixIsUnitary(u), 5, __func__);
462          
463         long long int mask=0;
464         for (int i=0; i<numControlQubits; i++) mask = mask | (1LL<<controlQubits[
      i]);
465         QuESTAssert(mask >=0 && mask <= (1LL<<multiQubit.numQubits)-1, 2, __func_
      _);
466         QuESTAssert((mask & (1LL<<targetQubit)) != (1LL<<targetQubit), 3, __func_
      _);
467         
468         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
469         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, tar
      getQubit);
470         Complex rot1, rot2;
471 
472         // rank's chunk is in upper half of block 
473         int rankIsUpper;
474         int pairRank; // rank of corresponding chunk
475 
476         if (useLocalDataOnly){
477                 // all values required to update state vector lie in this rank
478                 multiControlledUnitaryLocal(multiQubit, targetQubit, mask, u);
479         } else {
480                 // need to get corresponding chunk of state vector from other ran
      k
481                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, targetQubit);
482                 getRotAngleFromUnitaryMatrix(rankIsUpper, &rot1, &rot2, u);
483                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, targetQubit);
484                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
485                 // get corresponding values from my pair
486                 exchangeStateVectors(multiQubit, pairRank);
487                 
488                 // this rank's values are either in the upper of lower half of th
      e block. send values to multiControlledUnitaryDistributed
489                 // in the correct order
490                 if (rankIsUpper){
491                         multiControlledUnitaryDistributed(multiQubit,targetQubit,
      mask,rot1,rot2,
492                                 multiQubit.stateVec, //upper
493                                 multiQubit.pairStateVec, //lower
494                                 multiQubit.stateVec); //output
495                 } else {
496                         multiControlledUnitaryDistributed(multiQubit,targetQubit,
      mask,rot1,rot2,
497                                 multiQubit.pairStateVec, //upper
498                                 multiQubit.stateVec, //lower
499                                 multiQubit.stateVec); //output
500                 }
501         }
502 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_aae7a8a7f1ccbddb7f76b6c52b746bb43}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!phaseGate@{phaseGate}}
\index{phaseGate@{phaseGate}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{phaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__env__mpi_8c_aae7a8a7f1ccbddb7f76b6c52b746bb43}


Definition at line 600 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, phaseGateDistributed(), phaseGateLocal(), and QuESTAssert().


\begin{DoxyCode}
601 {
602         QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __
      func__);
603 
604         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
605         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, tar
      getQubit);
606 
607         // rank's chunk is in upper half of block 
608         int rankIsUpper;
609 
610         if (useLocalDataOnly){
611                 phaseGateLocal(multiQubit, targetQubit, type);
612         } else {
613                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, targetQubit);
614                 if (!rankIsUpper) phaseGateDistributed(multiQubit, targetQubit, t
      ype);
615         }
616 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!QuESTAssert@{QuESTAssert}}
\index{QuESTAssert@{QuESTAssert}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{QuESTAssert}]{\setlength{\rightskip}{0pt plus 5cm}void QuESTAssert (int {\em isValid}, \/  int {\em errorCode}, \/  const char $\ast$ {\em func})}\hfill}
\label{qubits__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}


Definition at line 776 of file qubits\_\-env\_\-mpi.c.

References exitWithError().


\begin{DoxyCode}
776                                                               {
777     if (!isValid) exitWithError(errorCode, func);
778 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!reportNodeList@{reportNodeList}}
\index{reportNodeList@{reportNodeList}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{reportNodeList}]{\setlength{\rightskip}{0pt plus 5cm}void reportNodeList ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}


Report a list of CPU hostnames and the rank that is running on each if running with MPI enabled and an error message otherwise. For debugging purposes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 96 of file qubits\_\-env\_\-mpi.c.

References QuESTEnv::rank.


\begin{DoxyCode}
96                                  {
97         char hostName[256];
98         gethostname(hostName, 255);
99         printf("hostname on rank %d: %s\n", env.rank, hostName);
100 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!reportQuESTEnv@{reportQuESTEnv}}
\index{reportQuESTEnv@{reportQuESTEnv}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{reportQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void reportQuESTEnv ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}


Report information about the QuEST environment. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 81 of file qubits\_\-env\_\-mpi.c.

References QuESTEnv::numRanks, QuESTEnv::rank, and REAL.


\begin{DoxyCode}
81                                  {
82         if (env.rank==0){
83                 printf("EXECUTION ENVIRONMENT:\n"); 
84                 printf("Running distributed (MPI) version\n");
85                 printf("Number of ranks is %d\n", env.numRanks);
86 # ifdef _OPENMP
87                 printf("OpenMP enabled\n");
88                 printf("Number of threads available is %d\n", omp_get_max_threads
      ());
89 # else
90                 printf("OpenMP disabled\n");
91 # endif 
92                 printf("Precision: size of REAL is %ld bytes\n", sizeof(REAL));
93         }
94 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a86e396e06b7d527cac20ba0108872423}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!sigmaX@{sigmaX}}
\index{sigmaX@{sigmaX}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{sigmaX}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaX ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__env__mpi_8c_a86e396e06b7d527cac20ba0108872423}


Apply the single-\/qubit sigma-\/X (also known as the X, Pauli-\/X, NOT or bit-\/flip) gate. This is a rotation of $\pi$ around the x-\/axis on the Bloch sphere. I.e. \[ \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (2, 0); \draw (0, 0) circle (.5); \draw (0, .5) -- (0, -.5); \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 503 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), sigmaXDistributed(), sigmaXLocal(), and MultiQubit::stateVec.


\begin{DoxyCode}
504 {
505         QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __
      func__);
506 
507         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
508         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, tar
      getQubit);
509 
510         // rank's chunk is in upper half of block 
511         int rankIsUpper;
512         int pairRank; // rank of corresponding chunk
513 
514         if (useLocalDataOnly){
515                 // all values required to update state vector lie in this rank
516                 sigmaXLocal(multiQubit, targetQubit);
517         } else {
518                 // need to get corresponding chunk of state vector from other ran
      k
519                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, targetQubit);
520                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, targetQubit);
521                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
522                 // get corresponding values from my pair
523                 exchangeStateVectors(multiQubit, pairRank);
524                 // this rank's values are either in the upper of lower half of th
      e block. sigmaX just replaces
525                 // this rank's values with pair values
526                 sigmaXDistributed(multiQubit, targetQubit,
527                         multiQubit.pairStateVec, // in
528                         multiQubit.stateVec); // out
529         }
530 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a1f54d70a42403f7e1c2e2c2007332f61}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!sigmaY@{sigmaY}}
\index{sigmaY@{sigmaY}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{sigmaY}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaY ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__env__mpi_8c_a1f54d70a42403f7e1c2e2c2007332f61}


Apply the single-\/qubit sigma-\/Y (also known as the Y or Pauli-\/Y) gate. This is a rotation of $\pi$ around the Y-\/axis on the Bloch sphere. I.e. \[ \begin{pmatrix} 0 & -i \\ i & 0 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$\sigma_y$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


fix -\/-\/ put duplicate code (sigmaX, sigmaY) in seperate function 

Definition at line 569 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), sigmaYDistributed(), sigmaYLocal(), and MultiQubit::stateVec.


\begin{DoxyCode}
570 {
571         QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __
      func__);
572 
573         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
574         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, tar
      getQubit);
575 
576         // rank's chunk is in upper half of block 
577         int rankIsUpper;
578         int pairRank; // rank of corresponding chunk
579 
580         if (useLocalDataOnly){
581                 // all values required to update state vector lie in this rank
582                 sigmaYLocal(multiQubit, targetQubit);
583         } else {
585                 // need to get corresponding chunk of state vector from other ran
      k
586                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, targetQubit);
587                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, targetQubit);
588                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
589                 // get corresponding values from my pair
590                 exchangeStateVectors(multiQubit, pairRank);
591                 // this rank's values are either in the upper of lower half of th
      e block. sigmaX just replaces
592                 // this rank's values with pair values
593                 sigmaYDistributed(multiQubit,targetQubit,
594                         multiQubit.pairStateVec, // in
595                         multiQubit.stateVec, // out
596                         rankIsUpper);
597         }
598 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!syncQuESTEnv@{syncQuESTEnv}}
\index{syncQuESTEnv@{syncQuESTEnv}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{syncQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void syncQuESTEnv ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}


Guarantees that all code up to the given point has been executed on all nodes (if running in distributed mode). 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 64 of file qubits\_\-env\_\-mpi.c.

Referenced by initializeStateFromSingleFile(), and reportStateToScreen().


\begin{DoxyCode}
64                                {
65         MPI_Barrier(MPI_COMM_WORLD);
66 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ac7e38d768a1bd79019f88cc1e6295092}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!syncQuESTSuccess@{syncQuESTSuccess}}
\index{syncQuESTSuccess@{syncQuESTSuccess}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{syncQuESTSuccess}]{\setlength{\rightskip}{0pt plus 5cm}int syncQuESTSuccess (int {\em successCode})}\hfill}
\label{qubits__env__mpi_8c_ac7e38d768a1bd79019f88cc1e6295092}


Performs a logical AND on all successCodes held by all processes. If any one process has a zero successCode all processes will return a zero success code.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \item[\mbox{$\leftarrow$} {\em successCode}]1 if process task succeeded, 0 if process task failed \end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if all processes succeeded, 0 if any one process failed 
\end{DoxyReturn}


Definition at line 68 of file qubits\_\-env\_\-mpi.c.


\begin{DoxyCode}
68                                      {
69         int totalSuccess;
70         MPI_Allreduce(&successCode, &totalSuccess, 1, MPI_INT, MPI_LAND, MPI_COMM
      _WORLD);
71         return totalSuccess;
72 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a7a0877e33700f6bad48adb51b7b3fb67}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!unitary@{unitary}}
\index{unitary@{unitary}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{unitary}]{\setlength{\rightskip}{0pt plus 5cm}void unitary ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__env__mpi_8c_a7a0877e33700f6bad48adb51b7b3fb67}


Apply a general single-\/qubit unitary (including a global phase factor). The passed 2x2 ComplexMatrix must be unitary, otherwise an error is thrown.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {U}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \item[\mbox{$\leftarrow$} {\em u}]unitary matrix to apply \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or matrix {\ttfamily u} is not unitary. \end{DoxyExceptions}


Definition at line 328 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), getRotAngleFromUnitaryMatrix(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, MultiQubit::pairStateVec, QuESTAssert(), MultiQubit::stateVec, unitaryDistributed(), unitaryLocal(), and validateMatrixIsUnitary().


\begin{DoxyCode}
329 {
330         QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __
      func__);
331         QuESTAssert(validateMatrixIsUnitary(u), 5, __func__);
332 
333         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
334         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, tar
      getQubit);
335         Complex rot1, rot2;
336 
337         // rank's chunk is in upper half of block 
338         int rankIsUpper;
339         int pairRank; // rank of corresponding chunk
340 
341         if (useLocalDataOnly){
342                 // all values required to update state vector lie in this rank
343                 unitaryLocal(multiQubit, targetQubit, u);
344         } else {
345                 // need to get corresponding chunk of state vector from other ran
      k
346                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, targetQubit);
347                 getRotAngleFromUnitaryMatrix(rankIsUpper, &rot1, &rot2, u);
348                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, targetQubit);
349                 // get corresponding values from my pair
350                         exchangeStateVectors(multiQubit, pairRank);
351 
352                 // this rank's values are either in the upper of lower half of th
      e block. 
353                 // send values to compactUnitaryDistributed in the correct order
354                 if (rankIsUpper){
355                         unitaryDistributed(multiQubit,targetQubit,rot1,rot2,
356                                 multiQubit.stateVec, //upper
357                                 multiQubit.pairStateVec, //lower
358                                 multiQubit.stateVec); //output
359                 } else {
360                         unitaryDistributed(multiQubit,targetQubit,rot1,rot2,
361                                 multiQubit.pairStateVec, //upper
362                                 multiQubit.stateVec, //lower
363                                 multiQubit.stateVec); //output
364                 }
365         }
366 
367 
368 }
\end{DoxyCode}
