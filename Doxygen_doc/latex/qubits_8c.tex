\hypertarget{qubits_8c}{
\subsection{qubits.c File Reference}
\label{qubits_8c}\index{qubits.c@{qubits.c}}
}


The core of the QuEST Library.  
{\ttfamily \#include $<$math.h$>$}\par
{\ttfamily \#include $<$stdio.h$>$}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$assert.h$>$}\par
{\ttfamily \#include \char`\"{}precision.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}qubits.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}qubits\_\-internal.h\char`\"{}}\par
{\ttfamily \#include $<$omp.h$>$}\par
\subsubsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}~0
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (const int locationOfBitFromRight, const long long int theEncodedNumber)
\begin{DoxyCompactList}\small\item\em Get the value of the bit at a particular index in a number. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a9c02591bc64c2918503afa231d90d83f}{createMultiQubit} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit, int numQubits, \hyperlink{structQuESTEnv}{QuESTEnv} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Create a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}{destroyMultiQubit} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, \hyperlink{structQuESTEnv}{QuESTEnv} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Deallocate a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits Free memory allocated to state vector of probability amplitudes, including temporary vector for values copied from another chunk if running the distributed version. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}{reportState} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Print the current state vector of probability amplitudes for a set of qubits to file. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a842d6884e063a5865a2232cba56b65ac}{reportStateToScreen} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, \hyperlink{structQuESTEnv}{QuESTEnv} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env}, int reportRank)
\begin{DoxyCompactList}\small\item\em Print the current state vector of probability amplitudes for a set of qubits to standard out. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}{reportMultiQubitParams} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Report metainformation about a set of qubits: number of qubits, number of probability amplitudes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a8f10aabf9f607f19093aee54630caa21}{getEnvironmentString} (\hyperlink{structQuESTEnv}{QuESTEnv} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env}, \hyperlink{structMultiQubit}{MultiQubit} multiQubit, char str\mbox{[}200\mbox{]})
\item 
void \hyperlink{qubits_8c_acb5b2eff794339090004d29f02a70d9a}{initStateZero} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes for a set of qubits to the zero state: $|$000...00$>$. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}{initStatePlus} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes for a set of qubits to an equal real superposition of all amplitudes: $|$+++. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a7169fd0442cbc3418f3fac4d13363ca2}{initStateOfSingleQubit} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit, int qubitId, int outcome)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes such that one qubit is set to 'outcome' and all other qubits are in an equal superposition of zero and one. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}{initStateDebug} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes to an (unphysical) state with each component of each probability amplitude a unique floating point value. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a433876ee9f3bcc54af346300f571fc3c}{initializeStateFromSingleFile} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit, char filename\mbox{[}200\mbox{]}, \hyperlink{structQuESTEnv}{QuESTEnv} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\item 
int \hyperlink{qubits_8c_a793584932ae384c82e7e42db7d35d18d}{compareStates} (\hyperlink{structMultiQubit}{MultiQubit} mq1, \hyperlink{structMultiQubit}{MultiQubit} mq2, REAL precision)
\item 
int \hyperlink{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}{validateMatrixIsUnitary} (\hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
int \hyperlink{qubits_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}{validateAlphaBeta} (\hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
int \hyperlink{qubits_8c_a71c14976f63cfcda70026fa20ee531fe}{validateUnitVector} (REAL ux, REAL uy, REAL uz)
\item 
void \hyperlink{qubits_8c_a7fadb225fc385db789e844c87fcba9e1}{rotateAroundAxis} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle, \hyperlink{structVector}{Vector} unitAxis)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit a certain angle about an axis. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a6cc7fa705a2f2e6b486b49c5589d5df5}{rotateX} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit a certain angle about the x-\/axis. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ace0d3592d38a990e81a434c4e9681500}{rotateY} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit a certain angle about the y-\/axis. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_abd621412ad30c1b034f4ce153c4afe10}{rotateZ} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit a certain angle about the z-\/axis. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a9cee2d8716667a3318420a3b672f5b92}{compactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ac134fb45b0a7248c5d15e16eb7139a35}{unitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits_8c_a20ee1878a63ae6112e8845f4a8787592}{compactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a2343b7240118e89aa615e2c9140b770b}{unitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_afc77657651d52c47403b44b923a098a8}{controlledCompactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a1309eabcba3cb97fbc3cd2e606d17766}{multiControlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a8a4afcff70195a306c082b8ed8d4e09a}{controlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a717855e835e3161e08c18cdc15325d27}{controlledCompactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a642093063a1f889f61a1311f6d6f2d3f}{controlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{multiControlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a74822fd86bb5d81766e6e8dbdcd62df1}{sigmaXLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a2275fff50824fe47485890ff5a857785}{sigmaXDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ad357a43e80e3baf013975b1b70942f4c}{controlledNotLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\} for elements where controlQubit is one. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a05875a70b539a3efb28d027823403f34}{controlledNotDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a81fbfaed65a742a7dfd622e17652245e}{sigmaYLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_af5ef5166f00c0572354b4ac53dcf40cf}{sigmaYDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_aa9f0718b4dd794a3e1b143e3b153bfc5}{hadamardLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ae6a897066979fc52d977007d959ca09d}{hadamardDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a3a54566b73ac84c312d7da4f56ffbc3b}{phaseGateLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_af832ed00b02a0597b7fe0b714032c54a}{phaseGateDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_aebaab86326779de55d335cfea3efde8f}{sigmaZ} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{\{0,-\/1\}\} -\/-\/ apply a phase of -\/1 to $|$1$>$. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_adda6c47876a7676488ed0565a19eaa65}{sGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits_8c_af764ea63a2e870098f4e1ce08562942e}{tGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
REAL \hyperlink{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}{findProbabilityOfZeroLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}{findProbabilityOfZeroDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a11a96159191cbf1b01a1080e7f045aac}{controlledPhaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int idQubit1, const int idQubit2)
\begin{DoxyCompactList}\small\item\em The control phase (the two qubit phase gate). \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_afc1835c6b43b6e59ce7df7b13f274fc7}{multiControlledPhaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int $\ast$controlQubits, int numControlQubits)
\begin{DoxyCompactList}\small\item\em The multiple qubit control phase gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a01d9a8b7ff0e09ec399e158389783aa9}{collapseToOutcomeLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int measureQubit, REAL totalProbability, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, const REAL totalProbability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Set all amplitudes in one chunk to 0. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}{getProbEl} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get probability of the state at an index in the state vector. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \hyperlink{qubits_8c_aac1637696885c75b73a1ecf381cea713}{errorCodes} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
The core of the QuEST Library. 

Definition in file \hyperlink{qubits_8c_source}{qubits.c}.

\subsubsection{Define Documentation}
\hypertarget{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{
\index{qubits.c@{qubits.c}!DEBUG@{DEBUG}}
\index{DEBUG@{DEBUG}!qubits.c@{qubits.c}}
\paragraph[{DEBUG}]{\setlength{\rightskip}{0pt plus 5cm}\#define DEBUG~0}\hfill}
\label{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}


Definition at line 15 of file qubits.c.

Referenced by calcTotalProbability(), exchangeStateVectors(), findProbabilityOfZeroLocal(), initQuESTEnv(), initStateOfSingleQubit(), initStatePlus(), and initStateZero().

\subsubsection{Function Documentation}
\hypertarget{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{
\index{qubits.c@{qubits.c}!collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}}
\index{collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}!qubits.c@{qubits.c}}
\paragraph[{collapseToOutcomeDistributedRenorm}]{\setlength{\rightskip}{0pt plus 5cm}REAL collapseToOutcomeDistributedRenorm ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  const REAL {\em totalProbability})}\hfill}
\label{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}


Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that the value 'outcome' has been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being zero \end{DoxyParams}


Definition at line 2073 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
2074 {
2075         // ----- temp variables
2076         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
2077         long long int numTasks=multiQubit.numAmps;
2078         // (good for shared memory parallelism)
2079 
2080         REAL renorm=1/sqrt(totalProbability);
2081         
2082         REAL *stateVecReal = multiQubit.stateVec.real;
2083         REAL *stateVecImag = multiQubit.stateVec.imag;
2084 
2085 # ifdef _OPENMP
2086 # pragma omp parallel \
2087         shared    (numTasks,stateVecReal,stateVecImag) \
2088         private   (thisTask)
2089 # endif
2090         {
2091 # ifdef _OPENMP
2092                 # pragma omp for schedule  (static)
2093 # endif
2094                 for (thisTask=0; thisTask<numTasks; thisTask++) {
2095                         // summation -- simple implementation
2096                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
2097                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
2098                 }
2099         }
2100         return totalProbability;
2101 }
\end{DoxyCode}
\hypertarget{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{
\index{qubits.c@{qubits.c}!collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}}
\index{collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}!qubits.c@{qubits.c}}
\paragraph[{collapseToOutcomeDistributedSetZero}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeDistributedSetZero ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}


Set all amplitudes in one chunk to 0. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that a zero have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}


Definition at line 2116 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
2117 {
2118         // ----- temp variables
2119         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
2120         long long int numTasks=multiQubit.numAmps;
2121         // (good for shared memory parallelism)
2122 
2123         // ---------------------------------------------------------------- //
2124         //            find probability                                      //
2125         // ---------------------------------------------------------------- //
2126 
2127         REAL *stateVecReal = multiQubit.stateVec.real;
2128         REAL *stateVecImag = multiQubit.stateVec.imag;
2129 
2130 # ifdef _OPENMP
2131 # pragma omp parallel \
2132         shared    (numTasks,stateVecReal,stateVecImag) \
2133         private   (thisTask)
2134 # endif
2135         {
2136 # ifdef _OPENMP
2137                 # pragma omp for schedule  (static)
2138 # endif
2139                 for (thisTask=0; thisTask<numTasks; thisTask++) {
2140                         // summation -- simple implementation
2141                         stateVecReal[thisTask] = 0;
2142                         stateVecImag[thisTask] = 0;
2143                 }
2144         }
2145 }
\end{DoxyCode}
\hypertarget{qubits_8c_a01d9a8b7ff0e09ec399e158389783aa9}{
\index{qubits.c@{qubits.c}!collapseToOutcomeLocal@{collapseToOutcomeLocal}}
\index{collapseToOutcomeLocal@{collapseToOutcomeLocal}!qubits.c@{qubits.c}}
\paragraph[{collapseToOutcomeLocal}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeLocal ({\bf MultiQubit} {\em multiQubit}, \/  int {\em measureQubit}, \/  REAL {\em totalProbability}, \/  int {\em outcome})}\hfill}
\label{qubits_8c_a01d9a8b7ff0e09ec399e158389783aa9}


Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. Performs an irreversible change to the state vector: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being either zero or one \item[\mbox{$\leftarrow$} {\em outcome}]to measure the probability of and set the state to -\/-\/ either zero or one \end{DoxyParams}


Definition at line 1990 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1991 {
1992         // ----- sizes
1993         long long int sizeBlock,                                           // siz
      e of blocks
1994         sizeHalfBlock;                                       // size of blocks ha
      lved
1995         // ----- indices
1996         long long int thisBlock,                                           // cur
      rent block
1997              index;                                               // current inde
      x for first half block
1998         // ----- measured probability
1999         REAL   renorm;                                    // probability (returne
      d) value
2000         // ----- temp variables
2001         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
2002         // (good for shared memory parallelism)
2003         long long int numTasks=multiQubit.numAmps>>1;
2004 
2005         // ---------------------------------------------------------------- //
2006         //            dimensions                                            //
2007         // ---------------------------------------------------------------- //
2008         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
2009         // and then the number to skip
2010         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
2011         
2012         renorm=1/sqrt(totalProbability);
2013         REAL *stateVecReal = multiQubit.stateVec.real;
2014         REAL *stateVecImag = multiQubit.stateVec.imag;
2015 
2016 
2017 # ifdef _OPENMP
2018 # pragma omp parallel \
2019         default (none) \
2020         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,re
      norm,outcome) \
2021         private   (thisTask,thisBlock,index)
2022 # endif
2023         {
2024                 if (outcome==0){
2025                         // measure qubit is 0
2026 # ifdef _OPENMP
2027                         # pragma omp for schedule  (static)
2028 # endif
2029                         for (thisTask=0; thisTask<numTasks; thisTask++) {
2030                                 thisBlock = thisTask / sizeHalfBlock;
2031                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
2032                                 stateVecReal[index]=stateVecReal[index]*renorm;
2033                                 stateVecImag[index]=stateVecImag[index]*renorm;
2034 
2035                                 stateVecReal[index+sizeHalfBlock]=0;
2036                                 stateVecImag[index+sizeHalfBlock]=0;
2037                         }
2038                 } else {
2039                         // measure qubit is 1
2040 # ifdef _OPENMP
2041                         # pragma omp for schedule  (static)
2042 # endif
2043                         for (thisTask=0; thisTask<numTasks; thisTask++) {
2044                                 thisBlock = thisTask / sizeHalfBlock;
2045                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
2046                                 stateVecReal[index]=0;
2047                                 stateVecImag[index]=0;
2048 
2049                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[in
      dex+sizeHalfBlock]*renorm;
2050                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[in
      dex+sizeHalfBlock]*renorm;
2051                         }
2052                 }
2053         }
2054 
2055 }
\end{DoxyCode}
\hypertarget{qubits_8c_a20ee1878a63ae6112e8845f4a8787592}{
\index{qubits.c@{qubits.c}!compactUnitaryDistributed@{compactUnitaryDistributed}}
\index{compactUnitaryDistributed@{compactUnitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{compactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a20ee1878a63ae6112e8845f4a8787592}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 648 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by compactUnitary().


\begin{DoxyCode}
653 {
654 
655         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
656         long long int thisTask;  
657         const long long int numTasks=multiQubit.numAmps;
658 
659         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
660         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
661         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
662         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
663         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
664 
665 # ifdef _OPENMP
666 # pragma omp parallel \
667         default  (none) \
668         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
669                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
670         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
671 # endif
672         {
673 # ifdef _OPENMP
674                 # pragma omp for schedule (static)
675 # endif
676                 for (thisTask=0; thisTask<numTasks; thisTask++) {
677                         // store current state vector values in temp variables
678                         stateRealUp = stateVecRealUp[thisTask];
679                         stateImagUp = stateVecImagUp[thisTask];
680 
681                         stateRealLo = stateVecRealLo[thisTask];
682                         stateImagLo = stateVecImagLo[thisTask];
683 
684                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
685                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
686                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
687                 }
688         }
689 }
\end{DoxyCode}
\hypertarget{qubits_8c_a9cee2d8716667a3318420a3b672f5b92}{
\index{qubits.c@{qubits.c}!compactUnitaryLocal@{compactUnitaryLocal}}
\index{compactUnitaryLocal@{compactUnitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{compactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits_8c_a9cee2d8716667a3318420a3b672f5b92}


Rotate a single qubit in the state vector of probability amplitudes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 509 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by compactUnitary().


\begin{DoxyCode}
510 {
511         long long int sizeBlock, sizeHalfBlock;
512         long long int thisBlock, // current block
513              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
514 
515         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
516         long long int thisTask;         
517         const long long int numTasks=multiQubit.numAmps>>1;
518 
519         // set dimensions
520         sizeHalfBlock = 1LL << targetQubit;  
521         sizeBlock     = 2LL * sizeHalfBlock; 
522 
523         // Can't use multiQubit.stateVec as a private OMP var
524         REAL *stateVecReal = multiQubit.stateVec.real;
525         REAL *stateVecImag = multiQubit.stateVec.imag;
526         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
527         REAL betaImag=beta.imag, betaReal=beta.real;
528 
529 # ifdef _OPENMP
530 # pragma omp parallel \
531         default  (none) \
532         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
533         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
534 # endif
535         {
536 # ifdef _OPENMP
537                 # pragma omp for schedule (static)
538 # endif
539                 for (thisTask=0; thisTask<numTasks; thisTask++) {
540 
541                         thisBlock   = thisTask / sizeHalfBlock;
542                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
543                         indexLo     = indexUp + sizeHalfBlock;
544 
545                         // store current state vector values in temp variables
546                         stateRealUp = stateVecReal[indexUp];
547                         stateImagUp = stateVecImag[indexUp];
548 
549                         stateRealLo = stateVecReal[indexLo];
550                         stateImagLo = stateVecImag[indexLo];
551 
552                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
553                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag
      *stateImagUp 
554                                 - betaReal*stateRealLo - betaImag*stateImagLo;
555                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag
      *stateRealUp 
556                                 - betaReal*stateImagLo + betaImag*stateRealLo;
557 
558                         // state[indexLo] = beta  * state[indexUp] + conj(alpha) 
      * state[indexLo]
559                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*s
      tateImagUp 
560                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
561                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*s
      tateRealUp 
562                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
563                 } 
564         }
565 
566 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a793584932ae384c82e7e42db7d35d18d}{
\index{qubits.c@{qubits.c}!compareStates@{compareStates}}
\index{compareStates@{compareStates}!qubits.c@{qubits.c}}
\paragraph[{compareStates}]{\setlength{\rightskip}{0pt plus 5cm}int compareStates ({\bf MultiQubit} {\em mq1}, \/  {\bf MultiQubit} {\em mq2}, \/  REAL {\em precision})}\hfill}
\label{qubits_8c_a793584932ae384c82e7e42db7d35d18d}


Definition at line 371 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by test\_\-collapseToOutcome(), test\_\-compactUnitary(), test\_\-controlledCompactUnitary(), test\_\-controlledNot(), test\_\-controlledPhaseGate(), test\_\-controlledUnitary(), test\_\-hadamard(), test\_\-initStatePlus(), test\_\-initStateZero(), test\_\-measure(), test\_\-measureWithStats(), test\_\-multiControlledPhaseGate(), test\_\-multiControlledUnitary(), test\_\-sGate(), test\_\-sigmaX(), test\_\-sigmaY(), test\_\-sigmaZ(), test\_\-tGate(), and test\_\-unitary().


\begin{DoxyCode}
371                                                                  {
372         REAL diff;
373         int chunkSize = mq1.numAmps;
374         for (int i=0; i<chunkSize; i++){
375                 diff = mq1.stateVec.real[i] - mq2.stateVec.real[i];
376                 if (diff<0) diff *= -1;
377                 if (diff>precision) return 0;
378                 diff = mq1.stateVec.imag[i] - mq2.stateVec.imag[i];
379                 if (diff<0) diff *= -1;
380                 if (diff>precision) return 0;
381         }
382         return 1;
383 }
\end{DoxyCode}
\hypertarget{qubits_8c_a717855e835e3161e08c18cdc15325d27}{
\index{qubits.c@{qubits.c}!controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}}
\index{controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{controlledCompactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a717855e835e3161e08c18cdc15325d27}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 993 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
998 {
999 
1000         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1001         long long int thisTask;  
1002         const long long int numTasks=multiQubit.numAmps;
1003         const long long int chunkSize=multiQubit.numAmps;
1004         const long long int chunkId=multiQubit.chunkId;
1005 
1006         int controlBit;
1007 
1008     REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
1009         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
1010         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1011         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1012         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1013 
1014 # ifdef _OPENMP
1015 # pragma omp parallel \
1016         default  (none) \
1017         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1018                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
1019         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
1020 # endif
1021         {
1022 # ifdef _OPENMP
1023                 # pragma omp for schedule (static)
1024 # endif
1025                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1026                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
1027                         if (controlBit){
1028                                 // store current state vector values in temp vari
      ables
1029                                 stateRealUp = stateVecRealUp[thisTask];
1030                                 stateImagUp = stateVecImagUp[thisTask];
1031 
1032                                 stateRealLo = stateVecRealLo[thisTask];
1033                                 stateImagLo = stateVecImagLo[thisTask];
1034 
1035                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
1036                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp 
      - rot1Imag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
1037                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp 
      + rot1Imag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
1038                         }
1039                 }
1040         }
1041 }
\end{DoxyCode}
\hypertarget{qubits_8c_afc77657651d52c47403b44b923a098a8}{
\index{qubits.c@{qubits.c}!controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}}
\index{controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{controlledCompactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits_8c_afc77657651d52c47403b44b923a098a8}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. Only perform the rotation for elements where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform rotation if this qubit is 1 \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 762 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
764 {
765         long long int sizeBlock, sizeHalfBlock;
766         long long int thisBlock, // current block
767              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
768 
769         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
770         long long int thisTask;         
771         const long long int numTasks=multiQubit.numAmps>>1;
772         const long long int chunkSize=multiQubit.numAmps;
773         const long long int chunkId=multiQubit.chunkId;
774 
775         int controlBit;
776 
777     // set dimensions
778         sizeHalfBlock = 1LL << targetQubit;  
779         sizeBlock     = 2LL * sizeHalfBlock; 
780 
781         // Can't use multiQubit.stateVec as a private OMP var
782         REAL *stateVecReal = multiQubit.stateVec.real;
783         REAL *stateVecImag = multiQubit.stateVec.imag;
784         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
785         REAL betaImag=beta.imag, betaReal=beta.real;
786 
787 # ifdef _OPENMP
788 # pragma omp parallel \
789         default  (none) \
790         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
791         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
792 # endif
793         {
794 # ifdef _OPENMP
795                 # pragma omp for schedule (static)
796 # endif
797                 for (thisTask=0; thisTask<numTasks; thisTask++) {
798 
799                         thisBlock   = thisTask / sizeHalfBlock;
800                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
801                         indexLo     = indexUp + sizeHalfBlock;
802 
803                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
804                         if (controlBit){
805                                 // store current state vector values in temp vari
      ables
806                                 stateRealUp = stateVecReal[indexUp];
807                                 stateImagUp = stateVecImag[indexUp];
808 
809                                 stateRealLo = stateVecReal[indexLo];
810                                 stateImagLo = stateVecImag[indexLo];
811 
812                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
813                                 stateVecReal[indexUp] = alphaReal*stateRealUp - a
      lphaImag*stateImagUp 
814                                         - betaReal*stateRealLo - betaImag*stateIm
      agLo;
815                                 stateVecImag[indexUp] = alphaReal*stateImagUp + a
      lphaImag*stateRealUp 
816                                         - betaReal*stateImagLo + betaImag*stateRe
      alLo;
817 
818                                 // state[indexLo] = beta  * state[indexUp] + conj
      (alpha) * state[indexLo]
819                                 stateVecReal[indexLo] = betaReal*stateRealUp - be
      taImag*stateImagUp 
820                                         + alphaReal*stateRealLo + alphaImag*state
      ImagLo;
821                                 stateVecImag[indexLo] = betaReal*stateImagUp + be
      taImag*stateRealUp 
822                                         + alphaReal*stateImagLo - alphaImag*state
      RealLo;
823                         }
824                 } 
825         }
826 
827 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a05875a70b539a3efb28d027823403f34}{
\index{qubits.c@{qubits.c}!controlledNotDistributed@{controlledNotDistributed}}
\index{controlledNotDistributed@{controlledNotDistributed}!qubits.c@{qubits.c}}
\paragraph[{controlledNotDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a05875a70b539a3efb28d027823403f34}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk. Only perform the rotation for elements where controlQubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1340 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by controlledNot().


\begin{DoxyCode}
1343 {
1344 
1345         long long int thisTask;  
1346         const long long int numTasks=multiQubit.numAmps;
1347         const long long int chunkSize=multiQubit.numAmps;
1348         const long long int chunkId=multiQubit.chunkId;
1349 
1350         int controlBit;
1351 
1352         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1353         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1354 
1355 # ifdef _OPENMP
1356 # pragma omp parallel \
1357         default  (none) \
1358         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1359         private  (thisTask,controlBit)
1360 # endif
1361         {
1362 # ifdef _OPENMP
1363                 # pragma omp for schedule (static)
1364 # endif
1365                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1366                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
1367                         if (controlBit){
1368                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTa
      sk];
1369                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTa
      sk];
1370                         }
1371                 }
1372         }
1373 } 
\end{DoxyCode}
\hypertarget{qubits_8c_ad357a43e80e3baf013975b1b70942f4c}{
\index{qubits.c@{qubits.c}!controlledNotLocal@{controlledNotLocal}}
\index{controlledNotLocal@{controlledNotLocal}!qubits.c@{qubits.c}}
\paragraph[{controlledNotLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_ad357a43e80e3baf013975b1b70942f4c}


Rotate a single qubit by \{\{0,1\},\{1,0\} for elements where controlQubit is one. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \end{DoxyParams}


Definition at line 1274 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledNot().


\begin{DoxyCode}
1275 {
1276         long long int sizeBlock, sizeHalfBlock;
1277         long long int thisBlock, // current block
1278              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1279 
1280         REAL stateRealUp,stateImagUp;
1281         long long int thisTask;         
1282         const long long int numTasks=multiQubit.numAmps>>1;
1283         const long long int chunkSize=multiQubit.numAmps;
1284         const long long int chunkId=multiQubit.chunkId;
1285 
1286         int controlBit;
1287 
1288         // set dimensions
1289         sizeHalfBlock = 1LL << targetQubit;  
1290         sizeBlock     = 2LL * sizeHalfBlock; 
1291 
1292 
1293         // Can't use multiQubit.stateVec as a private OMP var
1294         REAL *stateVecReal = multiQubit.stateVec.real;
1295         REAL *stateVecImag = multiQubit.stateVec.imag;
1296 
1297 # ifdef _OPENMP
1298 # pragma omp parallel \
1299         default  (none) \
1300         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1301         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,co
      ntrolBit) 
1302 # endif
1303         {
1304 # ifdef _OPENMP
1305                 # pragma omp for schedule (static)
1306 # endif
1307                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1308                         thisBlock   = thisTask / sizeHalfBlock;
1309                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1310                         indexLo     = indexUp + sizeHalfBlock;
1311 
1312                         controlBit = extractBit(controlQubit, indexUp+chunkId*chu
      nkSize);
1313                         if (controlBit){
1314                                 stateRealUp = stateVecReal[indexUp];
1315                                 stateImagUp = stateVecImag[indexUp];
1316 
1317                                 stateVecReal[indexUp] = stateVecReal[indexLo];
1318                                 stateVecImag[indexUp] = stateVecImag[indexLo];
1319 
1320                                 stateVecReal[indexLo] = stateRealUp;
1321                                 stateVecImag[indexLo] = stateImagUp;
1322                         }
1323                 } 
1324         }
1325 
1326 }
\end{DoxyCode}
\hypertarget{qubits_8c_a11a96159191cbf1b01a1080e7f045aac}{
\index{qubits.c@{qubits.c}!controlledPhaseGate@{controlledPhaseGate}}
\index{controlledPhaseGate@{controlledPhaseGate}!qubits.c@{qubits.c}}
\paragraph[{controlledPhaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void controlledPhaseGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em idQubit1}, \/  const int {\em idQubit2})}\hfill}
\label{qubits_8c_a11a96159191cbf1b01a1080e7f045aac}


The control phase (the two qubit phase gate). For each state, if both input qubits are equal to one, multiply the amplitude of that state by -\/1. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em idQubit1,idQubit2}]specified qubits \end{DoxyParams}


Definition at line 1898 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by test\_\-controlledPhaseGate().


\begin{DoxyCode}
1899 {
1900         long long int index;
1901         long long int stateVecSize;
1902         int bit1, bit2;
1903 
1904         const long long int chunkSize=multiQubit.numAmps;
1905         const long long int chunkId=multiQubit.chunkId;
1906 
1907     QuESTAssert(idQubit1 >= 0 && idQubit1 < multiQubit.numQubits, 2, __func__);
1908     QuESTAssert(idQubit2 >= 0 && idQubit2 < multiQubit.numQubits, 1, __func__);
1909     QuESTAssert(idQubit1 != idQubit2, 3, __func__);
1910 
1911         // dimension of the state vector
1912         stateVecSize = multiQubit.numAmps;
1913         REAL *stateVecReal = multiQubit.stateVec.real;
1914         REAL *stateVecImag = multiQubit.stateVec.imag;
1915 
1916 # ifdef _OPENMP
1917 # pragma omp parallel for \
1918         default  (none)                      \
1919         shared   (stateVecSize, stateVecReal,stateVecImag ) \
1920         private  (index,bit1,bit2)                     \
1921         schedule (static)
1922 # endif
1923         for (index=0; index<stateVecSize; index++) {
1924                 bit1 = extractBit (idQubit1, index+chunkId*chunkSize);
1925                 bit2 = extractBit (idQubit2, index+chunkId*chunkSize);
1926                 if (bit1 && bit2) {
1927                         stateVecReal [index] = - stateVecReal [index];
1928                         stateVecImag [index] = - stateVecImag [index];
1929                 }
1930         }
1931 }
\end{DoxyCode}
\hypertarget{qubits_8c_a642093063a1f889f61a1311f6d6f2d3f}{
\index{qubits.c@{qubits.c}!controlledUnitaryDistributed@{controlledUnitaryDistributed}}
\index{controlledUnitaryDistributed@{controlledUnitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{controlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a642093063a1f889f61a1311f6d6f2d3f}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1056 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledUnitary().


\begin{DoxyCode}
1061 {
1062 
1063         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1064         long long int thisTask;  
1065         const long long int numTasks=multiQubit.numAmps;
1066         const long long int chunkSize=multiQubit.numAmps;
1067         const long long int chunkId=multiQubit.chunkId;
1068 
1069         int controlBit;
1070 
1071         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
1072         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
1073         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1074         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1075         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1076 
1077 # ifdef _OPENMP
1078 # pragma omp parallel \
1079         default  (none) \
1080         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1081                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
1082         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
1083 # endif
1084         {
1085 # ifdef _OPENMP
1086                 # pragma omp for schedule (static)
1087 # endif
1088                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1089                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
1090                         if (controlBit){
1091                                 // store current state vector values in temp vari
      ables
1092                                 stateRealUp = stateVecRealUp[thisTask];
1093                                 stateImagUp = stateVecImagUp[thisTask];
1094 
1095                                 stateRealLo = stateVecRealLo[thisTask];
1096                                 stateImagLo = stateVecImagLo[thisTask];
1097 
1098                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
1099                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
1100                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
1101                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
1102                         }
1103                 }
1104         }
1105 }
\end{DoxyCode}
\hypertarget{qubits_8c_a8a4afcff70195a306c082b8ed8d4e09a}{
\index{qubits.c@{qubits.c}!controlledUnitaryLocal@{controlledUnitaryLocal}}
\index{controlledUnitaryLocal@{controlledUnitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{controlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8c_a8a4afcff70195a306c082b8ed8d4e09a}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. Only perform the rotation for elements where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform rotation if this qubit is 1 \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 914 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledUnitary().


\begin{DoxyCode}
916 {
917         long long int sizeBlock, sizeHalfBlock;
918         long long int thisBlock, // current block
919              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
920 
921         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
922         long long int thisTask;         
923         const long long int numTasks=multiQubit.numAmps>>1;
924         const long long int chunkSize=multiQubit.numAmps;
925         const long long int chunkId=multiQubit.chunkId;
926 
927         int controlBit;
928 
929     // set dimensions
930         sizeHalfBlock = 1LL << targetQubit;  
931         sizeBlock     = 2LL * sizeHalfBlock; 
932 
933         // Can't use multiQubit.stateVec as a private OMP var
934         REAL *stateVecReal = multiQubit.stateVec.real;
935         REAL *stateVecImag = multiQubit.stateVec.imag;
936 
937 # ifdef _OPENMP
938 # pragma omp parallel \
939         default  (none) \
940         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
941         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
942 # endif
943         {
944 # ifdef _OPENMP
945                 # pragma omp for schedule (static)
946 # endif
947                 for (thisTask=0; thisTask<numTasks; thisTask++) {
948 
949                         thisBlock   = thisTask / sizeHalfBlock;
950                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
951                         indexLo     = indexUp + sizeHalfBlock;
952 
953                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
954                         if (controlBit){
955                                 // store current state vector values in temp vari
      ables
956                                 stateRealUp = stateVecReal[indexUp];
957                                 stateImagUp = stateVecImag[indexUp];
958 
959                                 stateRealLo = stateVecReal[indexLo];
960                                 stateImagLo = stateVecImag[indexLo];
961 
962 
963                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
964                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
965                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
966                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
967                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
968 
969                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
970                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
971                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
972                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
973                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
974                         }
975                 } 
976         }
977 
978 }
\end{DoxyCode}
\hypertarget{qubits_8c_a9c02591bc64c2918503afa231d90d83f}{
\index{qubits.c@{qubits.c}!createMultiQubit@{createMultiQubit}}
\index{createMultiQubit@{createMultiQubit}!qubits.c@{qubits.c}}
\paragraph[{createMultiQubit}]{\setlength{\rightskip}{0pt plus 5cm}void createMultiQubit ({\bf MultiQubit} $\ast$ {\em multiQubit}, \/  int {\em numQubits}, \/  {\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8c_a9c02591bc64c2918503afa231d90d83f}


Create a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. Allocate space for state vector of probability amplitudes, including space for temporary values to be copied from one other chunk if running the distributed version. Define properties related to the size of the set of qubits. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em numQubits}]number of qubits in the system \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}


Definition at line 41 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, MultiQubit::numQubits, QuESTEnv::numRanks, MultiQubit::pairStateVec, QuESTAssert(), QuESTEnv::rank, ComplexArray::real, and MultiQubit::stateVec.

Referenced by main(), test\_\-collapseToOutcome(), test\_\-compactUnitary(), test\_\-controlledCompactUnitary(), test\_\-controlledNot(), test\_\-controlledPhaseGate(), test\_\-controlledUnitary(), test\_\-findProbabilityOfOutcome(), test\_\-hadamard(), test\_\-initStatePlus(), test\_\-initStateZero(), test\_\-measure(), test\_\-measureWithStats(), test\_\-multiControlledPhaseGate(), test\_\-multiControlledUnitary(), test\_\-sGate(), test\_\-sigmaX(), test\_\-sigmaY(), test\_\-sigmaZ(), test\_\-tGate(), and test\_\-unitary().


\begin{DoxyCode}
42 {
43     QuESTAssert(numQubits>0, 9, __func__);
44         long long int numAmps = 1L << numQubits;
45         long long int numAmpsPerRank = numAmps/env.numRanks;
46 
47         multiQubit->stateVec.real = malloc(numAmpsPerRank * sizeof(*(multiQubit->
      stateVec.real)));
48         multiQubit->stateVec.imag = malloc(numAmpsPerRank * sizeof(*(multiQubit->
      stateVec.imag)));
49         if (env.numRanks>1){
50                 multiQubit->pairStateVec.real = malloc(numAmpsPerRank * sizeof(*(
      multiQubit->pairStateVec.real)));
51                 multiQubit->pairStateVec.imag = malloc(numAmpsPerRank * sizeof(*(
      multiQubit->pairStateVec.imag)));
52         }
53 
54         if ( (!(multiQubit->stateVec.real) || !(multiQubit->stateVec.imag))
55                  && numAmpsPerRank ) {
56                 printf("Could not allocate memory!");
57                 exit (EXIT_FAILURE);
58         }
59 
60         if ( env.numRanks>1 && (!(multiQubit->pairStateVec.real) || !(multiQubit-
      >pairStateVec.imag))
61                  && numAmpsPerRank ) {
62                 printf("Could not allocate memory!");
63                 exit (EXIT_FAILURE);
64         }
65 
66         multiQubit->numQubits = numQubits;
67         multiQubit->numAmps = numAmpsPerRank;
68         multiQubit->chunkId = env.rank;
69         multiQubit->numChunks = env.numRanks;
70 
71 }
\end{DoxyCode}
\hypertarget{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}{
\index{qubits.c@{qubits.c}!destroyMultiQubit@{destroyMultiQubit}}
\index{destroyMultiQubit@{destroyMultiQubit}!qubits.c@{qubits.c}}
\paragraph[{destroyMultiQubit}]{\setlength{\rightskip}{0pt plus 5cm}void destroyMultiQubit ({\bf MultiQubit} {\em multiQubit}, \/  {\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}


Deallocate a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits Free memory allocated to state vector of probability amplitudes, including temporary vector for values copied from another chunk if running the distributed version. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object to be deallocated \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}


Definition at line 78 of file qubits.c.

References ComplexArray::imag, QuESTEnv::numRanks, MultiQubit::pairStateVec, ComplexArray::real, and MultiQubit::stateVec.

Referenced by main(), test\_\-collapseToOutcome(), test\_\-compactUnitary(), test\_\-controlledCompactUnitary(), test\_\-controlledNot(), test\_\-controlledPhaseGate(), test\_\-controlledUnitary(), test\_\-findProbabilityOfOutcome(), test\_\-hadamard(), test\_\-initStatePlus(), test\_\-initStateZero(), test\_\-measure(), test\_\-measureWithStats(), test\_\-multiControlledPhaseGate(), test\_\-multiControlledUnitary(), test\_\-sGate(), test\_\-sigmaX(), test\_\-sigmaY(), test\_\-sigmaZ(), test\_\-tGate(), and test\_\-unitary().


\begin{DoxyCode}
78                                                            {
79         free(multiQubit.stateVec.real);
80         free(multiQubit.stateVec.imag);
81         if (env.numRanks>1){
82                 free(multiQubit.pairStateVec.real);
83                 free(multiQubit.pairStateVec.imag);
84         }
85 }
\end{DoxyCode}
\hypertarget{qubits_8c_a100463f6ec212c76a5fad99579000505}{
\index{qubits.c@{qubits.c}!extractBit@{extractBit}}
\index{extractBit@{extractBit}!qubits.c@{qubits.c}}
\paragraph[{extractBit}]{\setlength{\rightskip}{0pt plus 5cm}static int extractBit (const int {\em locationOfBitFromRight}, \/  const long long int {\em theEncodedNumber})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits_8c_a100463f6ec212c76a5fad99579000505}


Get the value of the bit at a particular index in a number. SCB edit: new definition of extractBit is much faster $\ast$$\ast$$\ast$ 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em locationOfBitFromRight}]location of bit in theEncodedNumber \item[\mbox{$\leftarrow$} {\em theEncodedNumber}]number to search \end{DoxyParams}
\begin{DoxyReturn}{Returns}
the value of the bit in theEncodedNumber 
\end{DoxyReturn}


Definition at line 1887 of file qubits.c.

Referenced by controlledCompactUnitaryDistributed(), controlledCompactUnitaryLocal(), controlledNotDistributed(), controlledNotLocal(), controlledPhaseGate(), controlledUnitaryDistributed(), controlledUnitaryLocal(), and initStateOfSingleQubit().


\begin{DoxyCode}
1888 {
1889         return (theEncodedNumber & ( 1LL << locationOfBitFromRight )) >> location
      OfBitFromRight;
1890 }
\end{DoxyCode}
\hypertarget{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}{
\index{qubits.c@{qubits.c}!findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}}
\index{findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}!qubits.c@{qubits.c}}
\paragraph[{findProbabilityOfZeroDistributed}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}


Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. Size of regions to skip is a multiple of chunkSize.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1832 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1834 {
1835         // ----- measured probability
1836         REAL   totalProbability;                                    // probabilit
      y (returned) value
1837         // ----- temp variables
1838         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1839         long long int numTasks=multiQubit.numAmps;
1840 
1841         // ---------------------------------------------------------------- //
1842         //            find probability                                      //
1843         // ---------------------------------------------------------------- //
1844 
1845         // initialise returned value
1846         totalProbability = 0.0;
1847 
1848         REAL *stateVecReal = multiQubit.stateVec.real;
1849         REAL *stateVecImag = multiQubit.stateVec.imag;
1850 
1851 # ifdef _OPENMP
1852 # pragma omp parallel \
1853         shared    (numTasks,stateVecReal,stateVecImag) \
1854         private   (thisTask) \
1855         reduction ( +:totalProbability )
1856 # endif
1857         {
1858 # ifdef _OPENMP
1859                 # pragma omp for schedule  (static)
1860 # endif
1861                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1862                         // summation -- simple implementation
1863                         totalProbability += stateVecReal[thisTask]*stateVecReal[t
      hisTask]
1864                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
1865 
1866                         /*
1867                         // summation -- kahan correction
1868                         y = stateVecReal[thisTask]*stateVecReal[thisTask]
1869                         + stateVecImag[thisTask]*stateVecImag[thisTask] - c;
1870                         t = totalProbability + y;
1871                         c = (t - totalProbability) - y;
1872                         totalProbability = t;
1873                         */
1874 
1875                 }
1876         }
1877 
1878         return totalProbability;
1879 }
\end{DoxyCode}
\hypertarget{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}{
\index{qubits.c@{qubits.c}!findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}}
\index{findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}!qubits.c@{qubits.c}}
\paragraph[{findProbabilityOfZeroLocal}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}


Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1759 of file qubits.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1761 {
1762         // ----- sizes
1763         long long int sizeBlock,                                           // siz
      e of blocks
1764         sizeHalfBlock;                                       // size of blocks ha
      lved
1765         // ----- indices
1766         long long int thisBlock,                                           // cur
      rent block
1767              index;                                               // current inde
      x for first half block
1768         // ----- measured probability
1769         REAL   totalProbability;                                    // probabilit
      y (returned) value
1770         // ----- temp variables
1771         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1772         long long int numTasks=multiQubit.numAmps>>1;
1773 
1774         // ---------------------------------------------------------------- //
1775         //            dimensions                                            //
1776         // ---------------------------------------------------------------- //
1777         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1778         // and then the number to skip
1779         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1780 
1781         // initialise returned value
1782         totalProbability = 0.0;
1783 
1784         // initialise correction for kahan summation
1785         if (DEBUG) printf("sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\n",sizeHa
      lfBlock,sizeBlock,numTasks);
1786 
1787         REAL *stateVecReal = multiQubit.stateVec.real;
1788         REAL *stateVecImag = multiQubit.stateVec.imag;
1789 
1790 # ifdef _OPENMP
1791 # pragma omp parallel \
1792         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
      
1793         private   (thisTask,thisBlock,index) \
1794         reduction ( +:totalProbability )
1795 # endif 
1796         {
1797 # ifdef _OPENMP
1798                 # pragma omp for schedule  (static)
1799 # endif
1800                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1801                         thisBlock = thisTask / sizeHalfBlock;
1802                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
      
1803 
1804                         if (index<0){ printf("ABORTING as index=%Ld with thisBloc
      k = %Ld  thisTask=%Ld \n", index,thisBlock,thisTask); exit(1);}
1805 
1806                         // summation -- simple implementation
1807                         totalProbability += stateVecReal[index]*stateVecReal[inde
      x]
1808                                 + stateVecImag[index]*stateVecImag[index];
1809 
1810                         /*
1811                         // summation -- kahan correction
1812                         y = stateVecReal[index]*stateVecReal[index]
1813                         + stateVecImag[index]*stateVecImag[index] - c;
1814                         t = totalProbability + y;
1815                         c = (t - totalProbability) - y;
1816                         totalProbability = t;
1817                         */
1818 
1819                 }
1820         }
1821         return totalProbability;
1822 }
\end{DoxyCode}
\hypertarget{qubits_8c_a8f10aabf9f607f19093aee54630caa21}{
\index{qubits.c@{qubits.c}!getEnvironmentString@{getEnvironmentString}}
\index{getEnvironmentString@{getEnvironmentString}!qubits.c@{qubits.c}}
\paragraph[{getEnvironmentString}]{\setlength{\rightskip}{0pt plus 5cm}void getEnvironmentString ({\bf QuESTEnv} {\em env}, \/  {\bf MultiQubit} {\em multiQubit}, \/  char {\em str}\mbox{[}200\mbox{]})}\hfill}
\label{qubits_8c_a8f10aabf9f607f19093aee54630caa21}


Definition at line 164 of file qubits.c.

References MultiQubit::numQubits, and QuESTEnv::numRanks.


\begin{DoxyCode}
164                                                                              {
165         int numThreads=1;
166 # ifdef _OPENMP
167         numThreads=omp_get_max_threads(); 
168 # endif
169         sprintf(str, "%dqubits_CPU_%dranksx%dthreads", multiQubit.numQubits, env.
      numRanks, numThreads);
170 }
\end{DoxyCode}
\hypertarget{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}{
\index{qubits.c@{qubits.c}!getProbEl@{getProbEl}}
\index{getProbEl@{getProbEl}!qubits.c@{qubits.c}}
\paragraph[{getProbEl}]{\setlength{\rightskip}{0pt plus 5cm}REAL getProbEl ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})}\hfill}
\label{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}


Get probability of the state at an index in the state vector. Get the probability of the state at an index in the state vector.

For debugging purposes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \item[\mbox{$\leftarrow$} {\em index}]index in state vector of probability amplitudes \end{DoxyParams}
\begin{DoxyReturn}{Returns}
real component $\ast$ real component + imag component $\ast$ imag component 
\end{DoxyReturn}


Definition at line 2152 of file qubits.c.

References getImagAmpEl(), getRealAmpEl(), and REAL.


\begin{DoxyCode}
2152                                                           {
2153         REAL real;
2154         REAL imag;
2155         real = getRealAmpEl(multiQubit, index);
2156         imag = getImagAmpEl(multiQubit, index);
2157         return real*real + imag*imag;
2158 }
\end{DoxyCode}
\hypertarget{qubits_8c_ae6a897066979fc52d977007d959ca09d}{
\index{qubits.c@{qubits.c}!hadamardDistributed@{hadamardDistributed}}
\index{hadamardDistributed@{hadamardDistributed}!qubits.c@{qubits.c}}
\paragraph[{hadamardDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits_8c_ae6a897066979fc52d977007d959ca09d}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1546 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by hadamard().


\begin{DoxyCode}
1551 {
1552 
1553         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1554         long long int thisTask;  
1555         const long long int numTasks=multiQubit.numAmps;
1556 
1557         int sign;
1558         if (updateUpper) sign=1;
1559         else sign=-1;
1560 
1561         REAL recRoot2 = 1.0/sqrt(2);
1562 
1563         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1564         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1565         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1566 
1567 # ifdef _OPENMP
1568 # pragma omp parallel \
1569         default  (none) \
1570         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1571                         recRoot2, sign) \
1572         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1573 # endif
1574         {
1575 # ifdef _OPENMP
1576                 # pragma omp for schedule (static)
1577 # endif
1578                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1579                         // store current state vector values in temp variables
1580                         stateRealUp = stateVecRealUp[thisTask];
1581                         stateImagUp = stateVecImagUp[thisTask];
1582 
1583                         stateRealLo = stateVecRealLo[thisTask];
1584                         stateImagLo = stateVecImagLo[thisTask];
1585 
1586                         stateVecRealOut[thisTask] = recRoot2*(stateRealUp + sign*
      stateRealLo);
1587                         stateVecImagOut[thisTask] = recRoot2*(stateImagUp + sign*
      stateImagLo);
1588                 }
1589         }
1590 }
\end{DoxyCode}
\hypertarget{qubits_8c_aa9f0718b4dd794a3e1b143e3b153bfc5}{
\index{qubits.c@{qubits.c}!hadamardLocal@{hadamardLocal}}
\index{hadamardLocal@{hadamardLocal}!qubits.c@{qubits.c}}
\paragraph[{hadamardLocal}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_aa9f0718b4dd794a3e1b143e3b153bfc5}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \end{DoxyParams}


Definition at line 1484 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by hadamard().


\begin{DoxyCode}
1485 {
1486         long long int sizeBlock, sizeHalfBlock;
1487         long long int thisBlock, // current block
1488              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1489 
1490         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1491         long long int thisTask;         
1492         const long long int numTasks=multiQubit.numAmps>>1;
1493 
1494         // set dimensions
1495         sizeHalfBlock = 1LL << targetQubit;  
1496         sizeBlock     = 2LL * sizeHalfBlock; 
1497 
1498         // Can't use multiQubit.stateVec as a private OMP var
1499         REAL *stateVecReal = multiQubit.stateVec.real;
1500         REAL *stateVecImag = multiQubit.stateVec.imag;
1501 
1502         REAL recRoot2 = 1.0/sqrt(2);
1503 
1504 # ifdef _OPENMP
1505 # pragma omp parallel \
1506         default  (none) \
1507         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \
      
1508         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
1509 # endif
1510         {
1511 # ifdef _OPENMP
1512                 # pragma omp for schedule (static)
1513 # endif
1514                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1515                         thisBlock   = thisTask / sizeHalfBlock;
1516                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1517                         indexLo     = indexUp + sizeHalfBlock;
1518 
1519                         stateRealUp = stateVecReal[indexUp];
1520                         stateImagUp = stateVecImag[indexUp];
1521 
1522                         stateRealLo = stateVecReal[indexLo];
1523                         stateImagLo = stateVecImag[indexLo];
1524 
1525                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateReal
      Lo);
1526                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImag
      Lo);
1527 
1528                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateReal
      Lo);
1529                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImag
      Lo);
1530                 } 
1531         }
1532 }
\end{DoxyCode}
\hypertarget{qubits_8c_a433876ee9f3bcc54af346300f571fc3c}{
\index{qubits.c@{qubits.c}!initializeStateFromSingleFile@{initializeStateFromSingleFile}}
\index{initializeStateFromSingleFile@{initializeStateFromSingleFile}!qubits.c@{qubits.c}}
\paragraph[{initializeStateFromSingleFile}]{\setlength{\rightskip}{0pt plus 5cm}void initializeStateFromSingleFile ({\bf MultiQubit} $\ast$ {\em multiQubit}, \/  char {\em filename}\mbox{[}200\mbox{]}, \/  {\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8c_a433876ee9f3bcc54af346300f571fc3c}


fix -\/-\/ format needs to work for single precision values 

Definition at line 336 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, MultiQubit::stateVec, and syncQuESTEnv().

Referenced by test\_\-controlledCompactUnitary(), test\_\-controlledNot(), test\_\-controlledPhaseGate(), test\_\-hadamard(), test\_\-initStatePlus(), test\_\-initStateZero(), test\_\-multiControlledPhaseGate(), test\_\-multiControlledUnitary(), test\_\-sGate(), test\_\-sigmaX(), test\_\-sigmaY(), test\_\-sigmaZ(), and test\_\-tGate().


\begin{DoxyCode}
336                                                                                  
                 {
337         long long int chunkSize, stateVecSize;
338         long long int indexInChunk, totalIndex;
339 
340         chunkSize = multiQubit->numAmps;
341         stateVecSize = chunkSize*multiQubit->numChunks;
342 
343         REAL *stateVecReal = multiQubit->stateVec.real;
344         REAL *stateVecImag = multiQubit->stateVec.imag;
345         
346         FILE *fp;
347         char line[200];
348 
349         for (int rank=0; rank<(multiQubit->numChunks); rank++){
350                 if (rank==multiQubit->chunkId){
351                         fp = fopen(filename, "r");
352                         indexInChunk = 0; totalIndex = 0;
353                         while (fgets(line, sizeof(char)*200, fp) != NULL && total
      Index<stateVecSize){
354                                 if (line[0]!='#'){
355                                         int chunkId = totalIndex/chunkSize;
356                                         if (chunkId==multiQubit->chunkId){
358                                                 sscanf(line, "%lf, %lf", &(stateV
      ecReal[indexInChunk]), 
359                                                                 &(stateVecImag[in
      dexInChunk]));
360                                                 indexInChunk += 1;
361                                         }
362                                         totalIndex += 1;
363                                 }
364                         }       
365                         fclose(fp);
366                 }
367                 syncQuESTEnv(env);
368         }
369 }
\end{DoxyCode}
\hypertarget{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}{
\index{qubits.c@{qubits.c}!initStateDebug@{initStateDebug}}
\index{initStateDebug@{initStateDebug}!qubits.c@{qubits.c}}
\paragraph[{initStateDebug}]{\setlength{\rightskip}{0pt plus 5cm}void initStateDebug ({\bf MultiQubit} $\ast$ {\em multiQubit})}\hfill}
\label{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}


Initialise the state vector of probability amplitudes to an (unphysical) state with each component of each probability amplitude a unique floating point value. For debugging processes 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \end{DoxyParams}


Definition at line 304 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by test\_\-compactUnitary(), test\_\-controlledCompactUnitary(), test\_\-controlledNot(), test\_\-controlledPhaseGate(), test\_\-controlledUnitary(), test\_\-hadamard(), test\_\-multiControlledPhaseGate(), test\_\-multiControlledUnitary(), test\_\-sGate(), test\_\-sigmaX(), test\_\-sigmaY(), test\_\-sigmaZ(), test\_\-tGate(), and test\_\-unitary().


\begin{DoxyCode}
305 {
306         long long int chunkSize;
307         long long int index;
308 
309         // dimension of the state vector
310         chunkSize = multiQubit->numAmps;
311 
312         // Can't use multiQubit->stateVec as a private OMP var
313         REAL *stateVecReal = multiQubit->stateVec.real;
314         REAL *stateVecImag = multiQubit->stateVec.imag;
315 
316         REAL chunkOffset = (2.0*chunkSize*multiQubit->chunkId)/10.0;
317 
318         // initialise the state to |0000..0000>
319 # ifdef _OPENMP
320 # pragma omp parallel \
321         default  (none) \
322         shared   (chunkSize, stateVecReal, stateVecImag, chunkOffset) \
323         private  (index) 
324 # endif
325         {
326 # ifdef _OPENMP
327                 # pragma omp for schedule (static)
328 # endif
329                 for (index=0; index<chunkSize; index++) {
330                         stateVecReal[index] = chunkOffset + (index*2.0)/10.0;
331                         stateVecImag[index] = chunkOffset + (index*2.0+1.0)/10.0;
      
332                 }
333         }
334 }
\end{DoxyCode}
\hypertarget{qubits_8c_a7169fd0442cbc3418f3fac4d13363ca2}{
\index{qubits.c@{qubits.c}!initStateOfSingleQubit@{initStateOfSingleQubit}}
\index{initStateOfSingleQubit@{initStateOfSingleQubit}!qubits.c@{qubits.c}}
\paragraph[{initStateOfSingleQubit}]{\setlength{\rightskip}{0pt plus 5cm}void initStateOfSingleQubit ({\bf MultiQubit} $\ast$ {\em multiQubit}, \/  int {\em qubitId}, \/  int {\em outcome})}\hfill}
\label{qubits_8c_a7169fd0442cbc3418f3fac4d13363ca2}


Initialise the state vector of probability amplitudes such that one qubit is set to 'outcome' and all other qubits are in an equal superposition of zero and one. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \item[\mbox{$\leftarrow$} {\em qubitId}]id of qubit to set to state 'outcome' \item[\mbox{$\leftarrow$} {\em value}]of qubit 'qubitId' \end{DoxyParams}


Definition at line 257 of file qubits.c.

References MultiQubit::chunkId, DEBUG, extractBit(), ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by test\_\-collapseToOutcome(), test\_\-findProbabilityOfOutcome(), test\_\-measure(), and test\_\-measureWithStats().


\begin{DoxyCode}
258 {
259         long long int chunkSize, stateVecSize;
260         long long int index;
261         int bit;
262         const long long int chunkId=multiQubit->chunkId;
263 
264         // dimension of the state vector
265         chunkSize = multiQubit->numAmps;
266         stateVecSize = chunkSize*multiQubit->numChunks;
267         REAL normFactor = 1.0/sqrt(stateVecSize/2);
268 
269         // Can't use multiQubit->stateVec as a private OMP var
270         REAL *stateVecReal = multiQubit->stateVec.real;
271         REAL *stateVecImag = multiQubit->stateVec.imag;
272 
273         // initialise the state to |0000..0000>
274 # ifdef _OPENMP
275 # pragma omp parallel \
276         default  (none) \
277         shared   (chunkSize, stateVecReal, stateVecImag, normFactor, qubitId, out
      come) \
278         private  (index, bit) 
279 # endif
280         {
281 # ifdef _OPENMP
282                 # pragma omp for schedule (static)
283 # endif
284                 for (index=0; index<chunkSize; index++) {
285                         bit = extractBit(qubitId, index+chunkId*chunkSize);
286                         if (bit==outcome) {
287                                 stateVecReal[index] = normFactor;
288                                 stateVecImag[index] = 0.0;
289                         } else {
290                                 stateVecReal[index] = 0.0;
291                                 stateVecImag[index] = 0.0;
292                         }
293                 }
294         }
295         if (DEBUG) printf("COMPLETED INIT\n");
296 }
\end{DoxyCode}
\hypertarget{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}{
\index{qubits.c@{qubits.c}!initStatePlus@{initStatePlus}}
\index{initStatePlus@{initStatePlus}!qubits.c@{qubits.c}}
\paragraph[{initStatePlus}]{\setlength{\rightskip}{0pt plus 5cm}void initStatePlus ({\bf MultiQubit} $\ast$ {\em multiQubit})}\hfill}
\label{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}


Initialise the state vector of probability amplitudes for a set of qubits to an equal real superposition of all amplitudes: $|$+++. ..++$>$ 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \end{DoxyParams}


Definition at line 218 of file qubits.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by test\_\-collapseToOutcome(), test\_\-compactUnitary(), test\_\-findProbabilityOfOutcome(), test\_\-initStatePlus(), test\_\-measure(), test\_\-measureWithStats(), and test\_\-unitary().


\begin{DoxyCode}
219 {
220         long long int chunkSize, stateVecSize;
221         long long int index;
222 
223         // dimension of the state vector
224         chunkSize = multiQubit->numAmps;
225         stateVecSize = chunkSize*multiQubit->numChunks;
226         REAL normFactor = 1.0/sqrt(stateVecSize);
227 
228         // Can't use multiQubit->stateVec as a private OMP var
229         REAL *stateVecReal = multiQubit->stateVec.real;
230         REAL *stateVecImag = multiQubit->stateVec.imag;
231 
232         // initialise the state to |0000..0000>
233 # ifdef _OPENMP
234 # pragma omp parallel \
235         default  (none) \
236         shared   (chunkSize, stateVecReal, stateVecImag, normFactor) \
237         private  (index) 
238 # endif
239         {
240 # ifdef _OPENMP
241                 # pragma omp for schedule (static)
242 # endif
243                 for (index=0; index<chunkSize; index++) {
244                         stateVecReal[index] = normFactor;
245                         stateVecImag[index] = 0.0;
246                 }
247         }
248         if (DEBUG) printf("COMPLETED INIT\n");
249 }
\end{DoxyCode}
\hypertarget{qubits_8c_acb5b2eff794339090004d29f02a70d9a}{
\index{qubits.c@{qubits.c}!initStateZero@{initStateZero}}
\index{initStateZero@{initStateZero}!qubits.c@{qubits.c}}
\paragraph[{initStateZero}]{\setlength{\rightskip}{0pt plus 5cm}void initStateZero ({\bf MultiQubit} $\ast$ {\em multiQubit})}\hfill}
\label{qubits_8c_acb5b2eff794339090004d29f02a70d9a}


Initialise the state vector of probability amplitudes for a set of qubits to the zero state: $|$000...00$>$. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \end{DoxyParams}


Definition at line 176 of file qubits.c.

References MultiQubit::chunkId, DEBUG, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by main(), test\_\-collapseToOutcome(), test\_\-findProbabilityOfOutcome(), test\_\-initStateZero(), test\_\-measure(), and test\_\-measureWithStats().


\begin{DoxyCode}
177 {
178         long long int stateVecSize;
179         long long int index;
180 
181         // dimension of the state vector
182         stateVecSize = multiQubit->numAmps;
183 
184         // Can't use multiQubit->stateVec as a private OMP var
185         REAL *stateVecReal = multiQubit->stateVec.real;
186         REAL *stateVecImag = multiQubit->stateVec.imag;
187 
188         // initialise the state to |0000..0000>
189 # ifdef _OPENMP
190 # pragma omp parallel \
191         default  (none) \
192         shared   (stateVecSize, stateVecReal, stateVecImag) \
193         private  (index) 
194 # endif
195         {
196 # ifdef _OPENMP
197                 # pragma omp for schedule (static)
198 # endif
199                 for (index=0; index<stateVecSize; index++) {
200                         stateVecReal[index] = 0.0;
201                         stateVecImag[index] = 0.0;
202                 }
203         }
204 
205         if (multiQubit->chunkId==0){
206                 // zero state |0000..0000> has probability 1
207                 stateVecReal[0] = 1.0;
208                 stateVecImag[0] = 0.0;
209         }
210 
211         if (DEBUG) printf("COMPLETED INIT\n");
212 }
\end{DoxyCode}
\hypertarget{qubits_8c_afc1835c6b43b6e59ce7df7b13f274fc7}{
\index{qubits.c@{qubits.c}!multiControlledPhaseGate@{multiControlledPhaseGate}}
\index{multiControlledPhaseGate@{multiControlledPhaseGate}!qubits.c@{qubits.c}}
\paragraph[{multiControlledPhaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledPhaseGate ({\bf MultiQubit} {\em multiQubit}, \/  int $\ast$ {\em controlQubits}, \/  int {\em numControlQubits})}\hfill}
\label{qubits_8c_afc1835c6b43b6e59ce7df7b13f274fc7}


The multiple qubit control phase gate. For each state, if all input qubits are equal to one, multiply the amplitude of that state by -\/1. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em controlQubits}]array of input qubits \item[\mbox{$\leftarrow$} {\em numControlQubits}]number of input qubits \end{DoxyParams}


Definition at line 1939 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by test\_\-multiControlledPhaseGate().


\begin{DoxyCode}
1940 {
1941         long long int index;
1942         long long int stateVecSize;
1943         
1944         const long long int chunkSize=multiQubit.numAmps;
1945         const long long int chunkId=multiQubit.chunkId;
1946 
1947     QuESTAssert(numControlQubits > 0 && numControlQubits <= multiQubit.numQubits,
       4, __func__);
1948     long long int mask=0;
1949     for (int i=0; i<numControlQubits; i++) mask = mask | (1LL<<controlQubits[i]);
      
1950     QuESTAssert(mask >=0 && mask <= (1LL<<multiQubit.numQubits)-1, 2, __func__);
1951 
1952         stateVecSize = multiQubit.numAmps;
1953         REAL *stateVecReal = multiQubit.stateVec.real;
1954         REAL *stateVecImag = multiQubit.stateVec.imag;
1955 
1956 # ifdef _OPENMP
1957 # pragma omp parallel \
1958         default  (none)                      \
1959         shared   (stateVecSize, stateVecReal,stateVecImag, mask ) \
1960         private  (index)
1961 # endif
1962         {
1963 # ifdef _OPENMP
1964                 # pragma omp for schedule (static)
1965 # endif
1966                 for (index=0; index<stateVecSize; index++) {
1967                         if (mask == (mask & (index+chunkId*chunkSize)) ){
1968                                 stateVecReal [index] = - stateVecReal [index];
1969                                 stateVecImag [index] = - stateVecImag [index];
1970                         }
1971                 }
1972         }
1973 }
\end{DoxyCode}
\hypertarget{qubits_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{
\index{qubits.c@{qubits.c}!multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}}
\index{multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{multiControlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}


Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where all the control qubits are 1.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1120 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
1127 {
1128 
1129         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1130         long long int thisTask;  
1131         const long long int numTasks=multiQubit.numAmps;
1132         const long long int chunkSize=multiQubit.numAmps;
1133         const long long int chunkId=multiQubit.chunkId;
1134 
1135         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
1136         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
1137         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1138         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1139         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1140 
1141 # ifdef _OPENMP
1142 # pragma omp parallel \
1143         default  (none) \
1144         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1145                         rot1Real,rot1Imag, rot2Real,rot2Imag, mask) \
1146         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1147 # endif
1148         {
1149 # ifdef _OPENMP
1150                 # pragma omp for schedule (static)
1151 # endif
1152                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1153                         if (mask == (mask & (thisTask+chunkId*chunkSize)) ){
1154                                 // store current state vector values in temp vari
      ables
1155                                 stateRealUp = stateVecRealUp[thisTask];
1156                                 stateImagUp = stateVecImagUp[thisTask];
1157 
1158                                 stateRealLo = stateVecRealLo[thisTask];
1159                                 stateImagLo = stateVecImagLo[thisTask];
1160 
1161                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
1162                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
1163                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
1164                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
1165                         }
1166                 }
1167         }
1168 }
\end{DoxyCode}
\hypertarget{qubits_8c_a1309eabcba3cb97fbc3cd2e606d17766}{
\index{qubits.c@{qubits.c}!multiControlledUnitaryLocal@{multiControlledUnitaryLocal}}
\index{multiControlledUnitaryLocal@{multiControlledUnitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{multiControlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8c_a1309eabcba3cb97fbc3cd2e606d17766}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. Only perform the rotation for elements where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform rotation if this qubit is 1 \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 840 of file qubits.c.

References MultiQubit::chunkId, Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
842 {
843         long long int sizeBlock, sizeHalfBlock;
844         long long int thisBlock, // current block
845              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
846 
847         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
848         long long int thisTask;         
849         const long long int numTasks=multiQubit.numAmps>>1;
850         const long long int chunkSize=multiQubit.numAmps;
851         const long long int chunkId=multiQubit.chunkId;
852 
853         // set dimensions
854         sizeHalfBlock = 1LL << targetQubit;  
855         sizeBlock     = 2LL * sizeHalfBlock; 
856 
857         // Can't use multiQubit.stateVec as a private OMP var
858         REAL *stateVecReal = multiQubit.stateVec.real;
859         REAL *stateVecImag = multiQubit.stateVec.imag;
860 
861 # ifdef _OPENMP
862 # pragma omp parallel \
863         default  (none) \
864         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u, mask) \
865         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
866 # endif
867         {
868 # ifdef _OPENMP
869                 # pragma omp for schedule (static)
870 # endif
871                 for (thisTask=0; thisTask<numTasks; thisTask++) {
872 
873                         thisBlock   = thisTask / sizeHalfBlock;
874                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
875                         indexLo     = indexUp + sizeHalfBlock;
876 
877                         if (mask == (mask & (indexUp+chunkId*chunkSize)) ){
878                                 // store current state vector values in temp vari
      ables
879                                 stateRealUp = stateVecReal[indexUp];
880                                 stateImagUp = stateVecImag[indexUp];
881 
882                                 stateRealLo = stateVecReal[indexLo];
883                                 stateImagLo = stateVecImag[indexLo];
884 
885 
886                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
887                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
888                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
889                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
890                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
891 
892                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
893                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
894                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
895                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
896                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
897                         }
898                 } 
899         }
900 
901 }
\end{DoxyCode}
\hypertarget{qubits_8c_af832ed00b02a0597b7fe0b714032c54a}{
\index{qubits.c@{qubits.c}!phaseGateDistributed@{phaseGateDistributed}}
\index{phaseGateDistributed@{phaseGateDistributed}!qubits.c@{qubits.c}}
\paragraph[{phaseGateDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits_8c_af832ed00b02a0597b7fe0b714032c54a}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em type}]the type of phase gate to apply -\/-\/ one of \{SIGMA\_\-Z, S\_\-GATE, T\_\-GATE\} \end{DoxyParams}


Definition at line 1682 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1683 {
1684         REAL stateRealLo,stateImagLo;
1685         long long int thisTask;         
1686         const long long int numTasks=multiQubit.numAmps;
1687 
1688         // Can't use multiQubit.stateVec as a private OMP var
1689         REAL *stateVecReal = multiQubit.stateVec.real;
1690         REAL *stateVecImag = multiQubit.stateVec.imag;
1691 
1692         REAL recRoot2 = 1.0/sqrt(2);
1693 
1694 # ifdef _OPENMP
1695 # pragma omp parallel \
1696         default  (none) \
1697         shared   (stateVecReal,stateVecImag, recRoot2, type) \
1698         private  (thisTask,stateRealLo,stateImagLo) 
1699 # endif
1700         {
1701                 if (type==SIGMA_Z){
1702 # ifdef _OPENMP
1703                         # pragma omp for schedule (static)
1704 # endif
1705                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1706                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
      
1707                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
      
1708                         } 
1709                 } else if (type==S_GATE){
1710 # ifdef _OPENMP
1711                         # pragma omp for schedule (static)
1712 # endif
1713                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1714                                 stateRealLo = stateVecReal[thisTask];
1715                                 stateImagLo = stateVecImag[thisTask];
1716 
1717                                 stateVecReal[thisTask] = -stateImagLo;
1718                                 stateVecImag[thisTask] = stateRealLo;
1719                         } 
1720                 } else if (type==T_GATE){
1721 # ifdef _OPENMP
1722                         # pragma omp for schedule (static)
1723 # endif
1724                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1725                                 stateRealLo = stateVecReal[thisTask];
1726                                 stateImagLo = stateVecImag[thisTask];
1727 
1728                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo 
      - stateImagLo);
1729                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo 
      + stateImagLo);
1730                         } 
1731                 } else printf("Type %d is an invalid phase gate\n", type);
1732         }
1733 }
\end{DoxyCode}
\hypertarget{qubits_8c_a3a54566b73ac84c312d7da4f56ffbc3b}{
\index{qubits.c@{qubits.c}!phaseGateLocal@{phaseGateLocal}}
\index{phaseGateLocal@{phaseGateLocal}!qubits.c@{qubits.c}}
\paragraph[{phaseGateLocal}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits_8c_a3a54566b73ac84c312d7da4f56ffbc3b}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em type}]the type of phase gate to apply -\/-\/ one of \{SIGMA\_\-Z, S\_\-GATE, T\_\-GATE\} \end{DoxyParams}


fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod? 

Definition at line 1599 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1600 {
1601         long long int sizeBlock, sizeHalfBlock;
1602         long long int thisBlock, // current block
1603              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1604 
1605         REAL stateRealLo,stateImagLo;
1606         long long int thisTask;         
1607         const long long int numTasks=multiQubit.numAmps>>1;
1608 
1609         // set dimensions
1610         sizeHalfBlock = 1LL << targetQubit;  
1611         sizeBlock     = 2LL * sizeHalfBlock; 
1612 
1613         // Can't use multiQubit.stateVec as a private OMP var
1614         REAL *stateVecReal = multiQubit.stateVec.real;
1615         REAL *stateVecImag = multiQubit.stateVec.imag;
1616 
1617         REAL recRoot2 = 1.0/sqrt(2);
1618 
1619 # ifdef _OPENMP
1620 # pragma omp parallel \
1621         default  (none) \
1622         shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type
      ) \
1623         private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) 
1624 # endif
1625         {
1626                 if (type==SIGMA_Z){
1627 # ifdef _OPENMP
1628                         # pragma omp for schedule (static)
1629 # endif
1630                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1632                                 thisBlock   = thisTask / sizeHalfBlock;
1633                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1634                                 indexLo     = indexUp + sizeHalfBlock;
1635 
1636                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
1637                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
1638                         } 
1639                 } 
1640                 
1641                 else if (type==S_GATE){
1642 # ifdef _OPENMP
1643                         # pragma omp for schedule (static)
1644 # endif
1645                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1647                                 thisBlock   = thisTask / sizeHalfBlock;
1648                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1649                                 indexLo     = indexUp + sizeHalfBlock;
1650                                 stateRealLo = stateVecReal[indexLo];
1651                                 stateImagLo = stateVecImag[indexLo];
1652 
1653                                 stateVecReal[indexLo] = -stateImagLo;
1654                                 stateVecImag[indexLo] = stateRealLo;
1655                         } 
1656                 } else if (type==T_GATE){
1657 # ifdef _OPENMP
1658                         # pragma omp for schedule (static)
1659 # endif
1660                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1662                                 thisBlock   = thisTask / sizeHalfBlock;
1663                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1664                                 indexLo     = indexUp + sizeHalfBlock;
1665                                 stateRealLo = stateVecReal[indexLo];
1666                                 stateImagLo = stateVecImag[indexLo];
1667 
1668                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo -
       stateImagLo);
1669                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo +
       stateImagLo);
1670                         } 
1671                 } else printf("Type %d is an invalid phase gate\n", type);
1672         }
1673 }
\end{DoxyCode}
\hypertarget{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}{
\index{qubits.c@{qubits.c}!reportMultiQubitParams@{reportMultiQubitParams}}
\index{reportMultiQubitParams@{reportMultiQubitParams}!qubits.c@{qubits.c}}
\paragraph[{reportMultiQubitParams}]{\setlength{\rightskip}{0pt plus 5cm}void reportMultiQubitParams ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}


Report metainformation about a set of qubits: number of qubits, number of probability amplitudes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}


Definition at line 153 of file qubits.c.

References MultiQubit::chunkId, MultiQubit::numChunks, and MultiQubit::numQubits.

Referenced by main().


\begin{DoxyCode}
153                                                   {
154         long long int numAmps = 1L << multiQubit.numQubits;
155         long long int numAmpsPerRank = numAmps/multiQubit.numChunks;
156         if (multiQubit.chunkId==0){
157                 printf("QUBITS:\n");
158                 printf("Number of qubits is %d.\n", multiQubit.numQubits);
159                 printf("Number of amps is %lld.\n", numAmps);
160                 printf("Number of amps per rank is %lld.\n", numAmpsPerRank);
161         }
162 }
\end{DoxyCode}
\hypertarget{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}{
\index{qubits.c@{qubits.c}!reportState@{reportState}}
\index{reportState@{reportState}!qubits.c@{qubits.c}}
\paragraph[{reportState}]{\setlength{\rightskip}{0pt plus 5cm}void reportState ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}


Print the current state vector of probability amplitudes for a set of qubits to file. File format: \begin{DoxyVerb}
real, imag
realComponent1, imagComponent1
realComponent2, imagComponent2
...
realComponentN, imagComponentN
\end{DoxyVerb}


File naming convention:

For each node that the program runs on, a file 'state\_\-rank\_\-\mbox{[}node\_\-rank\mbox{]}.csv' is generated. If there is more than one node, ranks after the first do not include the header \begin{DoxyVerb}
real, imag
\end{DoxyVerb}
 so that files are easier to combine. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \end{DoxyParams}


Definition at line 107 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL\_\-STRING\_\-FORMAT, and MultiQubit::stateVec.


\begin{DoxyCode}
107                                        {
108         FILE *state;
109         char filename[100];
110         long long int index;
111         sprintf(filename, "state_rank_%d.csv", multiQubit.chunkId);
112         state = fopen(filename, "w");
113         if (multiQubit.chunkId==0) fprintf(state, "real, imag\n");
114 
115         for(index=0; index<multiQubit.numAmps; index++){
116                 fprintf(state, REAL_STRING_FORMAT "," REAL_STRING_FORMAT "\n", mu
      ltiQubit.stateVec.real[index], multiQubit.stateVec.imag[index]);
117         }
118         fclose(state);
119 }
\end{DoxyCode}
\hypertarget{qubits_8c_a842d6884e063a5865a2232cba56b65ac}{
\index{qubits.c@{qubits.c}!reportStateToScreen@{reportStateToScreen}}
\index{reportStateToScreen@{reportStateToScreen}!qubits.c@{qubits.c}}
\paragraph[{reportStateToScreen}]{\setlength{\rightskip}{0pt plus 5cm}void reportStateToScreen ({\bf MultiQubit} {\em multiQubit}, \/  {\bf QuESTEnv} {\em env}, \/  int {\em reportRank})}\hfill}
\label{qubits_8c_a842d6884e063a5865a2232cba56b65ac}


Print the current state vector of probability amplitudes for a set of qubits to standard out. For debugging purposes. Each rank should print output serially. Only print output for systems $<$= 5 qubits 

Definition at line 124 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, MultiQubit::numQubits, ComplexArray::real, REAL\_\-STRING\_\-FORMAT, MultiQubit::stateVec, and syncQuESTEnv().

Referenced by reportTest().


\begin{DoxyCode}
124                                                                              {
125         long long int index;
126         int rank;
127         if (multiQubit.numQubits<=5){
128                 for (rank=0; rank<multiQubit.numChunks; rank++){
129                         if (multiQubit.chunkId==rank){
130                                 if (reportRank) {
131                                         printf("Reporting state from rank %d [\n"
      , multiQubit.chunkId);
132                                         //printf("\trank, index, real, imag\n");
133                                         printf("real, imag\n");
134                                 } else if (rank==0) {
135                                         printf("Reporting state [\n");
136                                         printf("real, imag\n");
137                                 }
138 
139                                 for(index=0; index<multiQubit.numAmps; index++){
140                                         printf(REAL_STRING_FORMAT ", " 
      REAL_STRING_FORMAT "\n", multiQubit.stateVec.real[index], multiQubit.stateVec.
      imag[index]);
141                                 }
142                                 if (reportRank || rank==multiQubit.numChunks-1) p
      rintf("]\n");
143                         }
144                         syncQuESTEnv(env);
145                 }
146         } else printf("Error: reportStateToScreen will not print output for syste
      ms of more than 5 qubits.\n");
147 }
\end{DoxyCode}
\hypertarget{qubits_8c_a7fadb225fc385db789e844c87fcba9e1}{
\index{qubits.c@{qubits.c}!rotateAroundAxis@{rotateAroundAxis}}
\index{rotateAroundAxis@{rotateAroundAxis}!qubits.c@{qubits.c}}
\paragraph[{rotateAroundAxis}]{\setlength{\rightskip}{0pt plus 5cm}void rotateAroundAxis ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle}, \/  {\bf Vector} {\em unitAxis})}\hfill}
\label{qubits_8c_a7fadb225fc385db789e844c87fcba9e1}


Rotate a single qubit a certain angle about an axis. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \item[\mbox{$\leftarrow$} {\em unitAxis}]unit vector pointing along the axis about which to rotate. Does not need to be normalised \end{DoxyParams}


Definition at line 434 of file qubits.c.

References compactUnitary(), Complex::imag, Complex::real, Vector::x, Vector::y, and Vector::z.


\begin{DoxyCode}
434                                                                                  
                  {
435         Complex alpha, beta;
436         alpha.real = cos(angle/2.0);
437         alpha.imag = -sin(angle/2.0)*unitAxis.z;        
438         beta.real = 0;
439         beta.imag = -sin(angle/2.0)*(unitAxis.x + unitAxis.y);
440         compactUnitary(multiQubit, rotQubit, alpha, beta);
441 }
\end{DoxyCode}
\hypertarget{qubits_8c_a6cc7fa705a2f2e6b486b49c5589d5df5}{
\index{qubits.c@{qubits.c}!rotateX@{rotateX}}
\index{rotateX@{rotateX}!qubits.c@{qubits.c}}
\paragraph[{rotateX}]{\setlength{\rightskip}{0pt plus 5cm}void rotateX ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8c_a6cc7fa705a2f2e6b486b49c5589d5df5}


Rotate a single qubit a certain angle about the x-\/axis. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}


Definition at line 452 of file qubits.c.

References compactUnitary(), Complex::imag, Complex::real, Vector::x, Vector::y, and Vector::z.


\begin{DoxyCode}
452                                                                    {
453         Complex alpha, beta;
454     Vector unitAxis = {1, 0, 0};
455         alpha.real = cos(angle/2.0);
456         alpha.imag = -sin(angle/2.0)*unitAxis.z;        
457         beta.real = 0;
458         beta.imag = -sin(angle/2.0)*(unitAxis.x + unitAxis.y);
459         compactUnitary(multiQubit, rotQubit, alpha, beta);
460 }
\end{DoxyCode}
\hypertarget{qubits_8c_ace0d3592d38a990e81a434c4e9681500}{
\index{qubits.c@{qubits.c}!rotateY@{rotateY}}
\index{rotateY@{rotateY}!qubits.c@{qubits.c}}
\paragraph[{rotateY}]{\setlength{\rightskip}{0pt plus 5cm}void rotateY ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8c_ace0d3592d38a990e81a434c4e9681500}


Rotate a single qubit a certain angle about the y-\/axis. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}


Definition at line 471 of file qubits.c.

References compactUnitary(), Complex::imag, Complex::real, Vector::x, Vector::y, and Vector::z.


\begin{DoxyCode}
471                                                                    {
472         Complex alpha, beta;
473     Vector unitAxis = {0, 1, 0};
474         alpha.real = cos(angle/2.0);
475         alpha.imag = -sin(angle/2.0)*unitAxis.z;        
476         beta.real = 0;
477         beta.imag = -sin(angle/2.0)*(unitAxis.x + unitAxis.y);
478         compactUnitary(multiQubit, rotQubit, alpha, beta);
479 }
\end{DoxyCode}
\hypertarget{qubits_8c_abd621412ad30c1b034f4ce153c4afe10}{
\index{qubits.c@{qubits.c}!rotateZ@{rotateZ}}
\index{rotateZ@{rotateZ}!qubits.c@{qubits.c}}
\paragraph[{rotateZ}]{\setlength{\rightskip}{0pt plus 5cm}void rotateZ ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8c_abd621412ad30c1b034f4ce153c4afe10}


Rotate a single qubit a certain angle about the z-\/axis. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}


Definition at line 490 of file qubits.c.

References compactUnitary(), Complex::imag, Complex::real, Vector::x, Vector::y, and Vector::z.


\begin{DoxyCode}
490                                                                    {
491         Complex alpha, beta;
492     Vector unitAxis = {0, 0, 1};
493         alpha.real = cos(angle/2.0);
494         alpha.imag = -sin(angle/2.0)*unitAxis.z;        
495         beta.real = 0;
496         beta.imag = -sin(angle/2.0)*(unitAxis.x + unitAxis.y);
497         compactUnitary(multiQubit, rotQubit, alpha, beta);
498 }
\end{DoxyCode}
\hypertarget{qubits_8c_adda6c47876a7676488ed0565a19eaa65}{
\index{qubits.c@{qubits.c}!sGate@{sGate}}
\index{sGate@{sGate}!qubits.c@{qubits.c}}
\paragraph[{sGate}]{\setlength{\rightskip}{0pt plus 5cm}void sGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_adda6c47876a7676488ed0565a19eaa65}


Definition at line 1740 of file qubits.c.

References phaseGate(), and S\_\-GATE.

Referenced by test\_\-sGate().


\begin{DoxyCode}
1741 {
1742                 phaseGate(multiQubit, targetQubit, S_GATE);
1743 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a2275fff50824fe47485890ff5a857785}{
\index{qubits.c@{qubits.c}!sigmaXDistributed@{sigmaXDistributed}}
\index{sigmaXDistributed@{sigmaXDistributed}!qubits.c@{qubits.c}}
\paragraph[{sigmaXDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a2275fff50824fe47485890ff5a857785}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1237 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaX().


\begin{DoxyCode}
1240 {
1241 
1242         long long int thisTask;  
1243         const long long int numTasks=multiQubit.numAmps;
1244 
1245         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1246         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1247 
1248 # ifdef _OPENMP
1249 # pragma omp parallel \
1250         default  (none) \
1251         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1252         private  (thisTask)
1253 # endif
1254         {
1255 # ifdef _OPENMP
1256                 # pragma omp for schedule (static)
1257 # endif
1258                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1259                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
1260                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
1261                 }
1262         }
1263 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a74822fd86bb5d81766e6e8dbdcd62df1}{
\index{qubits.c@{qubits.c}!sigmaXLocal@{sigmaXLocal}}
\index{sigmaXLocal@{sigmaXLocal}!qubits.c@{qubits.c}}
\paragraph[{sigmaXLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_a74822fd86bb5d81766e6e8dbdcd62df1}


Rotate a single qubit by \{\{0,1\},\{1,0\}. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \end{DoxyParams}


Definition at line 1177 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaX().


\begin{DoxyCode}
1178 {
1179         long long int sizeBlock, sizeHalfBlock;
1180         long long int thisBlock, // current block
1181              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1182 
1183         REAL stateRealUp,stateImagUp;
1184         long long int thisTask;         
1185         const long long int numTasks=multiQubit.numAmps>>1;
1186 
1187         // set dimensions
1188         sizeHalfBlock = 1LL << targetQubit;  
1189         sizeBlock     = 2LL * sizeHalfBlock; 
1190 
1191         // Can't use multiQubit.stateVec as a private OMP var
1192         REAL *stateVecReal = multiQubit.stateVec.real;
1193         REAL *stateVecImag = multiQubit.stateVec.imag;
1194 
1195 # ifdef _OPENMP
1196 # pragma omp parallel \
1197         default  (none) \
1198         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1199         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1200 # endif
1201         {
1202 # ifdef _OPENMP
1203                 # pragma omp for schedule (static)
1204 # endif
1205                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1206                         thisBlock   = thisTask / sizeHalfBlock;
1207                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1208                         indexLo     = indexUp + sizeHalfBlock;
1209 
1210                         stateRealUp = stateVecReal[indexUp];
1211                         stateImagUp = stateVecImag[indexUp];
1212 
1213                         stateVecReal[indexUp] = stateVecReal[indexLo];
1214                         stateVecImag[indexUp] = stateVecImag[indexLo];
1215 
1216                         stateVecReal[indexLo] = stateRealUp;
1217                         stateVecImag[indexLo] = stateImagUp;
1218                 } 
1219         }
1220 
1221 }
\end{DoxyCode}
\hypertarget{qubits_8c_af5ef5166f00c0572354b4ac53dcf40cf}{
\index{qubits.c@{qubits.c}!sigmaYDistributed@{sigmaYDistributed}}
\index{sigmaYDistributed@{sigmaYDistributed}!qubits.c@{qubits.c}}
\paragraph[{sigmaYDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits_8c_af5ef5166f00c0572354b4ac53dcf40cf}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1444 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaY().


\begin{DoxyCode}
1448 {
1449 
1450         long long int thisTask;  
1451         const long long int numTasks=multiQubit.numAmps;
1452 
1453         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1454         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1455 
1456         int realSign=1, imagSign=1;
1457         if (updateUpper) imagSign=-1;
1458         else realSign = -1;
1459 
1460 # ifdef _OPENMP
1461 # pragma omp parallel \
1462         default  (none) \
1463         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,r
      ealSign,imagSign) \
1464         private  (thisTask)
1465 # endif
1466         {
1467 # ifdef _OPENMP
1468                 # pragma omp for schedule (static)
1469 # endif
1470                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1471                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisT
      ask];
1472                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisT
      ask];
1473                 }
1474         }
1475 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a81fbfaed65a742a7dfd622e17652245e}{
\index{qubits.c@{qubits.c}!sigmaYLocal@{sigmaYLocal}}
\index{sigmaYLocal@{sigmaYLocal}!qubits.c@{qubits.c}}
\paragraph[{sigmaYLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_a81fbfaed65a742a7dfd622e17652245e}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \end{DoxyParams}


Definition at line 1384 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaY().


\begin{DoxyCode}
1385 {
1386         long long int sizeBlock, sizeHalfBlock;
1387         long long int thisBlock, // current block
1388              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1389 
1390         REAL stateRealUp,stateImagUp;
1391         long long int thisTask;         
1392         const long long int numTasks=multiQubit.numAmps>>1;
1393 
1394         // set dimensions
1395         sizeHalfBlock = 1LL << targetQubit;  
1396         sizeBlock     = 2LL * sizeHalfBlock; 
1397 
1398         // Can't use multiQubit.stateVec as a private OMP var
1399         REAL *stateVecReal = multiQubit.stateVec.real;
1400         REAL *stateVecImag = multiQubit.stateVec.imag;
1401 
1402 # ifdef _OPENMP
1403 # pragma omp parallel \
1404         default  (none) \
1405         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1406         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1407 # endif
1408         {
1409 # ifdef _OPENMP
1410                 # pragma omp for schedule (static)
1411 # endif
1412                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1413                         thisBlock   = thisTask / sizeHalfBlock;
1414                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1415                         indexLo     = indexUp + sizeHalfBlock;
1416 
1417                         stateRealUp = stateVecReal[indexUp];
1418                         stateImagUp = stateVecImag[indexUp];
1419 
1420                         stateVecReal[indexUp] = stateVecImag[indexLo];
1421                         stateVecImag[indexUp] = -stateVecReal[indexLo];
1422 
1423                         stateVecReal[indexLo] = -stateImagUp;
1424                         stateVecImag[indexLo] = stateRealUp;
1425                 } 
1426         }
1427 }
\end{DoxyCode}
\hypertarget{qubits_8c_aebaab86326779de55d335cfea3efde8f}{
\index{qubits.c@{qubits.c}!sigmaZ@{sigmaZ}}
\index{sigmaZ@{sigmaZ}!qubits.c@{qubits.c}}
\paragraph[{sigmaZ}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaZ ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_aebaab86326779de55d335cfea3efde8f}


Rotate a single qubit by \{\{1,0\},\{\{0,-\/1\}\} -\/-\/ apply a phase of -\/1 to $|$1$>$. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \end{DoxyParams}


Definition at line 1735 of file qubits.c.

References phaseGate(), and SIGMA\_\-Z.

Referenced by test\_\-sigmaZ().


\begin{DoxyCode}
1736 {
1737                 phaseGate(multiQubit, targetQubit, SIGMA_Z);
1738 }
\end{DoxyCode}
\hypertarget{qubits_8c_af764ea63a2e870098f4e1ce08562942e}{
\index{qubits.c@{qubits.c}!tGate@{tGate}}
\index{tGate@{tGate}!qubits.c@{qubits.c}}
\paragraph[{tGate}]{\setlength{\rightskip}{0pt plus 5cm}void tGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_af764ea63a2e870098f4e1ce08562942e}


Definition at line 1745 of file qubits.c.

References phaseGate(), and T\_\-GATE.

Referenced by test\_\-tGate().


\begin{DoxyCode}
1746 {
1747                 phaseGate(multiQubit, targetQubit, T_GATE);
1748 }
\end{DoxyCode}
\hypertarget{qubits_8c_a2343b7240118e89aa615e2c9140b770b}{
\index{qubits.c@{qubits.c}!unitaryDistributed@{unitaryDistributed}}
\index{unitaryDistributed@{unitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{unitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a2343b7240118e89aa615e2c9140b770b}


Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em u}]unitary matrix to apply \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 706 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by unitary().


\begin{DoxyCode}
711 {
712 
713         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
714         long long int thisTask;  
715         const long long int numTasks=multiQubit.numAmps;
716 
717         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
718         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
719         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
720         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
721         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
722 
723 
724 # ifdef _OPENMP
725 # pragma omp parallel \
726         default  (none) \
727         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
728                         rot1Real, rot1Imag, rot2Real, rot2Imag) \
729         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
730 # endif
731         {
732 # ifdef _OPENMP
733                 # pragma omp for schedule (static)
734 # endif
735                 for (thisTask=0; thisTask<numTasks; thisTask++) {
736                         // store current state vector values in temp variables
737                         stateRealUp = stateVecRealUp[thisTask];
738                         stateImagUp = stateVecImagUp[thisTask];
739 
740                         stateRealLo = stateVecRealLo[thisTask];
741                         stateImagLo = stateVecImagLo[thisTask];
742 
743                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp 
744                                 + rot2Real*stateRealLo - rot2Imag*stateImagLo;
745                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp 
746                                 + rot2Real*stateImagLo + rot2Imag*stateRealLo;
747                 }
748         }
749 }
\end{DoxyCode}
\hypertarget{qubits_8c_ac134fb45b0a7248c5d15e16eb7139a35}{
\index{qubits.c@{qubits.c}!unitaryLocal@{unitaryLocal}}
\index{unitaryLocal@{unitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{unitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8c_ac134fb45b0a7248c5d15e16eb7139a35}


Definition at line 577 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by unitary().


\begin{DoxyCode}
578 {
579         long long int sizeBlock, sizeHalfBlock;
580         long long int thisBlock, // current block
581              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
582 
583         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
584         long long int thisTask;         
585         const long long int numTasks=multiQubit.numAmps>>1;
586 
587         // set dimensions
588         sizeHalfBlock = 1LL << targetQubit;  
589         sizeBlock     = 2LL * sizeHalfBlock; 
590 
591         // Can't use multiQubit.stateVec as a private OMP var
592         REAL *stateVecReal = multiQubit.stateVec.real;
593         REAL *stateVecImag = multiQubit.stateVec.imag;
594 
595 # ifdef _OPENMP
596 # pragma omp parallel \
597         default  (none) \
598         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
599         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
600 # endif
601         {
602 # ifdef _OPENMP
603                 # pragma omp for schedule (static)
604 # endif
605                 for (thisTask=0; thisTask<numTasks; thisTask++) {
606 
607                         thisBlock   = thisTask / sizeHalfBlock;
608                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
609                         indexLo     = indexUp + sizeHalfBlock;
610 
611                         // store current state vector values in temp variables
612                         stateRealUp = stateVecReal[indexUp];
613                         stateImagUp = stateVecImag[indexUp];
614 
615                         stateRealLo = stateVecReal[indexLo];
616                         stateImagLo = stateVecImag[indexLo];
617 
618 
619                         // state[indexUp] = u00 * state[indexUp] + u01 * state[in
      dexLo]
620                         stateVecReal[indexUp] = u.r0c0.real*stateRealUp - u.r0c0.
      imag*stateImagUp 
621                                 + u.r0c1.real*stateRealLo - u.r0c1.imag*stateImag
      Lo;
622                         stateVecImag[indexUp] = u.r0c0.real*stateImagUp + u.r0c0.
      imag*stateRealUp 
623                                 + u.r0c1.real*stateImagLo + u.r0c1.imag*stateReal
      Lo;
624 
625                         // state[indexLo] = u10  * state[indexUp] + u11 * state[i
      ndexLo]
626                         stateVecReal[indexLo] = u.r1c0.real*stateRealUp  - u.
      r1c0.imag*stateImagUp 
627                                 + u.r1c1.real*stateRealLo  -  u.r1c1.imag*stateIm
      agLo;
628                         stateVecImag[indexLo] = u.r1c0.real*stateImagUp + u.r1c0.
      imag*stateRealUp 
629                                 + u.r1c1.real*stateImagLo + u.r1c1.imag*stateReal
      Lo;
630 
631                 } 
632         }
633 } 
\end{DoxyCode}
\hypertarget{qubits_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}{
\index{qubits.c@{qubits.c}!validateAlphaBeta@{validateAlphaBeta}}
\index{validateAlphaBeta@{validateAlphaBeta}!qubits.c@{qubits.c}}
\paragraph[{validateAlphaBeta}]{\setlength{\rightskip}{0pt plus 5cm}int validateAlphaBeta ({\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}


Definition at line 410 of file qubits.c.

References Complex::imag, Complex::real, and REAL\_\-EPS.

Referenced by compactUnitary(), and controlledCompactUnitary().


\begin{DoxyCode}
410                                                   {
411         if ( fabs(alpha.real*alpha.real 
412                 + alpha.imag*alpha.imag
413                 + beta.real*beta.real 
414                 + beta.imag*beta.imag - 1) > REAL_EPS ) return 0;
415         else return 1;
416 }
\end{DoxyCode}
\hypertarget{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}{
\index{qubits.c@{qubits.c}!validateMatrixIsUnitary@{validateMatrixIsUnitary}}
\index{validateMatrixIsUnitary@{validateMatrixIsUnitary}!qubits.c@{qubits.c}}
\paragraph[{validateMatrixIsUnitary}]{\setlength{\rightskip}{0pt plus 5cm}int validateMatrixIsUnitary ({\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}


Definition at line 385 of file qubits.c.

References Complex::imag, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, and REAL\_\-EPS.

Referenced by controlledUnitary(), multiControlledUnitary(), and unitary().


\begin{DoxyCode}
385                                              {
386 
387         if ( fabs(u.r0c0.real*u.r0c0.real 
388                 + u.r0c0.imag*u.r0c0.imag
389                 + u.r1c0.real*u.r1c0.real
390                 + u.r1c0.imag*u.r1c0.imag - 1) > REAL_EPS ) return 0;
391     // check
392         if ( fabs(u.r0c1.real*u.r0c1.real 
393                 + u.r0c1.imag*u.r0c1.imag
394                 + u.r1c1.real*u.r1c1.real
395                 + u.r1c1.imag*u.r1c1.imag - 1) > REAL_EPS ) return 0;
396 
397         if ( fabs(u.r0c0.real*u.r0c1.real 
398                 + u.r0c0.imag*u.r0c1.imag
399                 + u.r1c0.real*u.r1c1.real
400                 + u.r1c0.imag*u.r1c1.imag) > REAL_EPS ) return 0;
401 
402         if ( fabs(u.r0c1.real*u.r0c0.imag
403                 - u.r0c0.real*u.r0c1.imag
404                 + u.r1c1.real*u.r1c0.imag
405                 - u.r1c0.real*u.r1c1.imag) > REAL_EPS ) return 0;
406 
407         return 1;
408 }
\end{DoxyCode}
\hypertarget{qubits_8c_a71c14976f63cfcda70026fa20ee531fe}{
\index{qubits.c@{qubits.c}!validateUnitVector@{validateUnitVector}}
\index{validateUnitVector@{validateUnitVector}!qubits.c@{qubits.c}}
\paragraph[{validateUnitVector}]{\setlength{\rightskip}{0pt plus 5cm}int validateUnitVector (REAL {\em ux}, \/  REAL {\em uy}, \/  REAL {\em uz})}\hfill}
\label{qubits_8c_a71c14976f63cfcda70026fa20ee531fe}


Definition at line 418 of file qubits.c.

References REAL\_\-EPS.


\begin{DoxyCode}
418                                                  {
419         if ( fabs(sqrt(ux*ux + uy*uy + uz*uz) - 1) > REAL_EPS ) return 0;
420         else return 1;
421 }
\end{DoxyCode}


\subsubsection{Variable Documentation}
\hypertarget{qubits_8c_aac1637696885c75b73a1ecf381cea713}{
\index{qubits.c@{qubits.c}!errorCodes@{errorCodes}}
\index{errorCodes@{errorCodes}!qubits.c@{qubits.c}}
\paragraph[{errorCodes}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ {\bf errorCodes}\mbox{[}$\,$\mbox{]}}\hfill}
\label{qubits_8c_aac1637696885c75b73a1ecf381cea713}
{\bfseries Initial value:}
\begin{DoxyCode}
 {
    "Success",                                              
    "Invalid target qubit. Note qubits are zero indexed.",  
    "Invalid control qubit. Note qubits are zero indexed.", 
    "Control qubit cannot equal target qubit.",             
    "Invalid number of control qubits",                     
    "Invalid unitary matrix.",                              
    "Invalid rotation arguments.",                          
    "Invalid system size. Cannot print output for systems greater than 5 qubits."
      , 
    "Can't collapse to state with zero probability." 
    "Invalid number of qubits." 
}
\end{DoxyCode}


Definition at line 17 of file qubits.c.

Referenced by exitWithError().