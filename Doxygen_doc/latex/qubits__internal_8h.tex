\hypertarget{qubits__internal_8h}{
\subsection{qubits\_\-internal.h File Reference}
\label{qubits__internal_8h}\index{qubits\_\-internal.h@{qubits\_\-internal.h}}
}


Internal functions used to implement the public facing API in \hyperlink{qubits_8h}{qubits.h}.  
{\ttfamily \#include \char`\"{}precision.h\char`\"{}}\par
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}{compactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}{compactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}{unitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}{unitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}{controlledCompactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}{controlledCompactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}{controlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}{controlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}{multiControlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{multiControlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}{sigmaXLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}{sigmaXDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}{sigmaYLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}{sigmaYDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}{hadamardLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}{hadamardDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}{phaseGateLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}{phaseGateDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}{controlledNotLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit)
\item 
void \hyperlink{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}{controlledNotDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{findProbabilityOfZeroLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{findProbabilityOfZeroDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}{collapseToOutcomeLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int measureQubit, REAL totalProbability, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, const REAL totalProbability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Set all amplitudes in one chunk to 0. \item\end{DoxyCompactList}\item 
int \hyperlink{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}{validateMatrixIsUnitary} (\hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
int \hyperlink{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}{validateAlphaBeta} (\hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
int \hyperlink{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}{validateUnitVector} (REAL ux, REAL uy, REAL uz)
\item 
void \hyperlink{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}{phaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}{exitWithError} (int errorCode, const char $\ast$func)
\item 
void \hyperlink{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert} (int isValid, int errorCode, const char $\ast$func)
\end{DoxyCompactItemize}
\subsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \hyperlink{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}{errorCodes} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
Internal functions used to implement the public facing API in \hyperlink{qubits_8h}{qubits.h}. Do not call these functions directly. In general, \hyperlink{qubits__env__local_8c}{qubits\_\-env\_\-local.c} and \hyperlink{qubits__env__mpi_8c}{qubits\_\-env\_\-mpi.c} will implement the public API by choosing the correct function or combination of functions to use from those included here. 

Definition in file \hyperlink{qubits__internal_8h_source}{qubits\_\-internal.h}.

\subsubsection{Function Documentation}
\hypertarget{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}}
\index{collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeDistributedRenorm}]{\setlength{\rightskip}{0pt plus 5cm}REAL collapseToOutcomeDistributedRenorm ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  const REAL {\em totalProbability})}\hfill}
\label{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}


Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that the value 'outcome' has been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being zero \end{DoxyParams}


Definition at line 1872 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1873 {
1874         // ----- temp variables
1875         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1876         long long int numTasks=multiQubit.numAmps;
1877         // (good for shared memory parallelism)
1878 
1879         REAL renorm=1/sqrt(totalProbability);
1880         
1881         REAL *stateVecReal = multiQubit.stateVec.real;
1882         REAL *stateVecImag = multiQubit.stateVec.imag;
1883 
1884 # ifdef _OPENMP
1885 # pragma omp parallel \
1886         shared    (numTasks,stateVecReal,stateVecImag) \
1887         private   (thisTask)
1888 # endif
1889         {
1890 # ifdef _OPENMP
1891                 # pragma omp for schedule  (static)
1892 # endif
1893                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1894                         // summation -- simple implementation
1895                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
1896                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
1897                 }
1898         }
1899         return totalProbability;
1900 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}}
\index{collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeDistributedSetZero}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeDistributedSetZero ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}


Set all amplitudes in one chunk to 0. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that a zero have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}


Definition at line 1914 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1915 {
1916         // ----- temp variables
1917         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1918         long long int numTasks=multiQubit.numAmps;
1919         // (good for shared memory parallelism)
1920 
1921         // ---------------------------------------------------------------- //
1922         //            find probability                                      //
1923         // ---------------------------------------------------------------- //
1924 
1925         REAL *stateVecReal = multiQubit.stateVec.real;
1926         REAL *stateVecImag = multiQubit.stateVec.imag;
1927 
1928 # ifdef _OPENMP
1929 # pragma omp parallel \
1930         shared    (numTasks,stateVecReal,stateVecImag) \
1931         private   (thisTask)
1932 # endif
1933         {
1934 # ifdef _OPENMP
1935                 # pragma omp for schedule  (static)
1936 # endif
1937                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1938                         // summation -- simple implementation
1939                         stateVecReal[thisTask] = 0;
1940                         stateVecImag[thisTask] = 0;
1941                 }
1942         }
1943 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeLocal@{collapseToOutcomeLocal}}
\index{collapseToOutcomeLocal@{collapseToOutcomeLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeLocal}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeLocal ({\bf MultiQubit} {\em multiQubit}, \/  int {\em measureQubit}, \/  REAL {\em totalProbability}, \/  int {\em outcome})}\hfill}
\label{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}


Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. Performs an irreversible change to the state vector: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being either zero or one \item[\mbox{$\leftarrow$} {\em outcome}]to measure the probability of and set the state to -\/-\/ either zero or one \end{DoxyParams}


Definition at line 1790 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1791 {
1792         // ----- sizes
1793         long long int sizeBlock,                                           // siz
      e of blocks
1794         sizeHalfBlock;                                       // size of blocks ha
      lved
1795         // ----- indices
1796         long long int thisBlock,                                           // cur
      rent block
1797              index;                                               // current inde
      x for first half block
1798         // ----- measured probability
1799         REAL   renorm;                                    // probability (returne
      d) value
1800         // ----- temp variables
1801         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1802         // (good for shared memory parallelism)
1803         long long int numTasks=multiQubit.numAmps>>1;
1804 
1805         // ---------------------------------------------------------------- //
1806         //            dimensions                                            //
1807         // ---------------------------------------------------------------- //
1808         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1809         // and then the number to skip
1810         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1811         
1812         renorm=1/sqrt(totalProbability);
1813         REAL *stateVecReal = multiQubit.stateVec.real;
1814         REAL *stateVecImag = multiQubit.stateVec.imag;
1815 
1816 
1817 # ifdef _OPENMP
1818 # pragma omp parallel \
1819         default (none) \
1820         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,re
      norm,outcome) \
1821         private   (thisTask,thisBlock,index)
1822 # endif
1823         {
1824                 if (outcome==0){
1825                         // measure qubit is 0
1826 # ifdef _OPENMP
1827                         # pragma omp for schedule  (static)
1828 # endif
1829                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1830                                 thisBlock = thisTask / sizeHalfBlock;
1831                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
1832                                 stateVecReal[index]=stateVecReal[index]*renorm;
1833                                 stateVecImag[index]=stateVecImag[index]*renorm;
1834 
1835                                 stateVecReal[index+sizeHalfBlock]=0;
1836                                 stateVecImag[index+sizeHalfBlock]=0;
1837                         }
1838                 } else {
1839                         // measure qubit is 1
1840 # ifdef _OPENMP
1841                         # pragma omp for schedule  (static)
1842 # endif
1843                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1844                                 thisBlock = thisTask / sizeHalfBlock;
1845                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
1846                                 stateVecReal[index]=0;
1847                                 stateVecImag[index]=0;
1848 
1849                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[in
      dex+sizeHalfBlock]*renorm;
1850                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[in
      dex+sizeHalfBlock]*renorm;
1851                         }
1852                 }
1853         }
1854 
1855 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!compactUnitaryDistributed@{compactUnitaryDistributed}}
\index{compactUnitaryDistributed@{compactUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{compactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a20ee1878a63ae6112e8845f4a8787592}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 547 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by compactUnitary().


\begin{DoxyCode}
552 {
553 
554         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
555         long long int thisTask;  
556         const long long int numTasks=multiQubit.numAmps;
557 
558         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
559         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
560         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
561         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
562         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
563 
564 # ifdef _OPENMP
565 # pragma omp parallel \
566         default  (none) \
567         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
568                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
569         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
570 # endif
571         {
572 # ifdef _OPENMP
573                 # pragma omp for schedule (static)
574 # endif
575                 for (thisTask=0; thisTask<numTasks; thisTask++) {
576                         // store current state vector values in temp variables
577                         stateRealUp = stateVecRealUp[thisTask];
578                         stateImagUp = stateVecImagUp[thisTask];
579 
580                         stateRealLo = stateVecRealLo[thisTask];
581                         stateImagLo = stateVecImagLo[thisTask];
582 
583                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
584                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
585                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
586                 }
587         }
588 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!compactUnitaryLocal@{compactUnitaryLocal}}
\index{compactUnitaryLocal@{compactUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{compactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_a9cee2d8716667a3318420a3b672f5b92}


Definition at line 418 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by compactUnitary().


\begin{DoxyCode}
419 {
420         long long int sizeBlock, sizeHalfBlock;
421         long long int thisBlock, // current block
422              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
423 
424         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
425         long long int thisTask;         
426         const long long int numTasks=multiQubit.numAmps>>1;
427 
428         // set dimensions
429         sizeHalfBlock = 1LL << targetQubit;  
430         sizeBlock     = 2LL * sizeHalfBlock; 
431 
432         // Can't use multiQubit.stateVec as a private OMP var
433         REAL *stateVecReal = multiQubit.stateVec.real;
434         REAL *stateVecImag = multiQubit.stateVec.imag;
435         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
436         REAL betaImag=beta.imag, betaReal=beta.real;
437 
438 # ifdef _OPENMP
439 # pragma omp parallel \
440         default  (none) \
441         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
442         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
443 # endif
444         {
445 # ifdef _OPENMP
446                 # pragma omp for schedule (static)
447 # endif
448                 for (thisTask=0; thisTask<numTasks; thisTask++) {
449 
450                         thisBlock   = thisTask / sizeHalfBlock;
451                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
452                         indexLo     = indexUp + sizeHalfBlock;
453 
454                         // store current state vector values in temp variables
455                         stateRealUp = stateVecReal[indexUp];
456                         stateImagUp = stateVecImag[indexUp];
457 
458                         stateRealLo = stateVecReal[indexLo];
459                         stateImagLo = stateVecImag[indexLo];
460 
461                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
462                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag
      *stateImagUp 
463                                 - betaReal*stateRealLo - betaImag*stateImagLo;
464                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag
      *stateRealUp 
465                                 - betaReal*stateImagLo + betaImag*stateRealLo;
466 
467                         // state[indexLo] = beta  * state[indexUp] + conj(alpha) 
      * state[indexLo]
468                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*s
      tateImagUp 
469                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
470                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*s
      tateRealUp 
471                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
472                 } 
473         }
474 
475 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}}
\index{controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledCompactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a717855e835e3161e08c18cdc15325d27}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 857 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
862 {
863 
864         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
865         long long int thisTask;  
866         const long long int numTasks=multiQubit.numAmps;
867         const long long int chunkSize=multiQubit.numAmps;
868         const long long int chunkId=multiQubit.chunkId;
869 
870         int controlBit;
871 
872     REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
873         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
874         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
875         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
876         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
877 
878 # ifdef _OPENMP
879 # pragma omp parallel \
880         default  (none) \
881         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
882                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
883         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
884 # endif
885         {
886 # ifdef _OPENMP
887                 # pragma omp for schedule (static)
888 # endif
889                 for (thisTask=0; thisTask<numTasks; thisTask++) {
890                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
891                         if (controlBit){
892                                 // store current state vector values in temp vari
      ables
893                                 stateRealUp = stateVecRealUp[thisTask];
894                                 stateImagUp = stateVecImagUp[thisTask];
895 
896                                 stateRealLo = stateVecRealLo[thisTask];
897                                 stateImagLo = stateVecImagLo[thisTask];
898 
899                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
900                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp 
      - rot1Imag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
901                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp 
      + rot1Imag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
902                         }
903                 }
904         }
905 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}}
\index{controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledCompactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_afc77657651d52c47403b44b923a098a8}


Definition at line 648 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
650 {
651         long long int sizeBlock, sizeHalfBlock;
652         long long int thisBlock, // current block
653              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
654 
655         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
656         long long int thisTask;         
657         const long long int numTasks=multiQubit.numAmps>>1;
658         const long long int chunkSize=multiQubit.numAmps;
659         const long long int chunkId=multiQubit.chunkId;
660 
661         int controlBit;
662 
663     // set dimensions
664         sizeHalfBlock = 1LL << targetQubit;  
665         sizeBlock     = 2LL * sizeHalfBlock; 
666 
667         // Can't use multiQubit.stateVec as a private OMP var
668         REAL *stateVecReal = multiQubit.stateVec.real;
669         REAL *stateVecImag = multiQubit.stateVec.imag;
670         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
671         REAL betaImag=beta.imag, betaReal=beta.real;
672 
673 # ifdef _OPENMP
674 # pragma omp parallel \
675         default  (none) \
676         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
677         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
678 # endif
679         {
680 # ifdef _OPENMP
681                 # pragma omp for schedule (static)
682 # endif
683                 for (thisTask=0; thisTask<numTasks; thisTask++) {
684 
685                         thisBlock   = thisTask / sizeHalfBlock;
686                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
687                         indexLo     = indexUp + sizeHalfBlock;
688 
689                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
690                         if (controlBit){
691                                 // store current state vector values in temp vari
      ables
692                                 stateRealUp = stateVecReal[indexUp];
693                                 stateImagUp = stateVecImag[indexUp];
694 
695                                 stateRealLo = stateVecReal[indexLo];
696                                 stateImagLo = stateVecImag[indexLo];
697 
698                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
699                                 stateVecReal[indexUp] = alphaReal*stateRealUp - a
      lphaImag*stateImagUp 
700                                         - betaReal*stateRealLo - betaImag*stateIm
      agLo;
701                                 stateVecImag[indexUp] = alphaReal*stateImagUp + a
      lphaImag*stateRealUp 
702                                         - betaReal*stateImagLo + betaImag*stateRe
      alLo;
703 
704                                 // state[indexLo] = beta  * state[indexUp] + conj
      (alpha) * state[indexLo]
705                                 stateVecReal[indexLo] = betaReal*stateRealUp - be
      taImag*stateImagUp 
706                                         + alphaReal*stateRealLo + alphaImag*state
      ImagLo;
707                                 stateVecImag[indexLo] = betaReal*stateImagUp + be
      taImag*stateRealUp 
708                                         + alphaReal*stateImagLo - alphaImag*state
      RealLo;
709                         }
710                 } 
711         }
712 
713 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledNotDistributed@{controlledNotDistributed}}
\index{controlledNotDistributed@{controlledNotDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledNotDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk. Only perform the rotation for elements where controlQubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1186 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by controlledNot().


\begin{DoxyCode}
1189 {
1190 
1191         long long int thisTask;  
1192         const long long int numTasks=multiQubit.numAmps;
1193         const long long int chunkSize=multiQubit.numAmps;
1194         const long long int chunkId=multiQubit.chunkId;
1195 
1196         int controlBit;
1197 
1198         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1199         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1200 
1201 # ifdef _OPENMP
1202 # pragma omp parallel \
1203         default  (none) \
1204         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1205         private  (thisTask,controlBit)
1206 # endif
1207         {
1208 # ifdef _OPENMP
1209                 # pragma omp for schedule (static)
1210 # endif
1211                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1212                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
1213                         if (controlBit){
1214                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTa
      sk];
1215                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTa
      sk];
1216                         }
1217                 }
1218         }
1219 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledNotLocal@{controlledNotLocal}}
\index{controlledNotLocal@{controlledNotLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledNotLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}


Definition at line 1121 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledNot().


\begin{DoxyCode}
1122 {
1123         long long int sizeBlock, sizeHalfBlock;
1124         long long int thisBlock, // current block
1125              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1126 
1127         REAL stateRealUp,stateImagUp;
1128         long long int thisTask;         
1129         const long long int numTasks=multiQubit.numAmps>>1;
1130         const long long int chunkSize=multiQubit.numAmps;
1131         const long long int chunkId=multiQubit.chunkId;
1132 
1133         int controlBit;
1134 
1135         // set dimensions
1136         sizeHalfBlock = 1LL << targetQubit;  
1137         sizeBlock     = 2LL * sizeHalfBlock; 
1138 
1139 
1140         // Can't use multiQubit.stateVec as a private OMP var
1141         REAL *stateVecReal = multiQubit.stateVec.real;
1142         REAL *stateVecImag = multiQubit.stateVec.imag;
1143 
1144 # ifdef _OPENMP
1145 # pragma omp parallel \
1146         default  (none) \
1147         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1148         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,co
      ntrolBit) 
1149 # endif
1150         {
1151 # ifdef _OPENMP
1152                 # pragma omp for schedule (static)
1153 # endif
1154                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1155                         thisBlock   = thisTask / sizeHalfBlock;
1156                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1157                         indexLo     = indexUp + sizeHalfBlock;
1158 
1159                         controlBit = extractBit(controlQubit, indexUp+chunkId*chu
      nkSize);
1160                         if (controlBit){
1161                                 stateRealUp = stateVecReal[indexUp];
1162                                 stateImagUp = stateVecImag[indexUp];
1163 
1164                                 stateVecReal[indexUp] = stateVecReal[indexLo];
1165                                 stateVecImag[indexUp] = stateVecImag[indexLo];
1166 
1167                                 stateVecReal[indexLo] = stateRealUp;
1168                                 stateVecImag[indexLo] = stateImagUp;
1169                         }
1170                 } 
1171         }
1172 
1173 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledUnitaryDistributed@{controlledUnitaryDistributed}}
\index{controlledUnitaryDistributed@{controlledUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a642093063a1f889f61a1311f6d6f2d3f}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 920 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledUnitary().


\begin{DoxyCode}
925 {
926 
927         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
928         long long int thisTask;  
929         const long long int numTasks=multiQubit.numAmps;
930         const long long int chunkSize=multiQubit.numAmps;
931         const long long int chunkId=multiQubit.chunkId;
932 
933         int controlBit;
934 
935         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
936         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
937         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
938         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
939         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
940 
941 # ifdef _OPENMP
942 # pragma omp parallel \
943         default  (none) \
944         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
945                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
946         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
947 # endif
948         {
949 # ifdef _OPENMP
950                 # pragma omp for schedule (static)
951 # endif
952                 for (thisTask=0; thisTask<numTasks; thisTask++) {
953                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
954                         if (controlBit){
955                                 // store current state vector values in temp vari
      ables
956                                 stateRealUp = stateVecRealUp[thisTask];
957                                 stateImagUp = stateVecImagUp[thisTask];
958 
959                                 stateRealLo = stateVecRealLo[thisTask];
960                                 stateImagLo = stateVecImagLo[thisTask];
961 
962                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
963                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
964                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
965                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
966                         }
967                 }
968         }
969 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledUnitaryLocal@{controlledUnitaryLocal}}
\index{controlledUnitaryLocal@{controlledUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_a8a4afcff70195a306c082b8ed8d4e09a}


Definition at line 778 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledUnitary().


\begin{DoxyCode}
780 {
781         long long int sizeBlock, sizeHalfBlock;
782         long long int thisBlock, // current block
783              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
784 
785         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
786         long long int thisTask;         
787         const long long int numTasks=multiQubit.numAmps>>1;
788         const long long int chunkSize=multiQubit.numAmps;
789         const long long int chunkId=multiQubit.chunkId;
790 
791         int controlBit;
792 
793     // set dimensions
794         sizeHalfBlock = 1LL << targetQubit;  
795         sizeBlock     = 2LL * sizeHalfBlock; 
796 
797         // Can't use multiQubit.stateVec as a private OMP var
798         REAL *stateVecReal = multiQubit.stateVec.real;
799         REAL *stateVecImag = multiQubit.stateVec.imag;
800 
801 # ifdef _OPENMP
802 # pragma omp parallel \
803         default  (none) \
804         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
805         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
806 # endif
807         {
808 # ifdef _OPENMP
809                 # pragma omp for schedule (static)
810 # endif
811                 for (thisTask=0; thisTask<numTasks; thisTask++) {
812 
813                         thisBlock   = thisTask / sizeHalfBlock;
814                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
815                         indexLo     = indexUp + sizeHalfBlock;
816 
817                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
818                         if (controlBit){
819                                 // store current state vector values in temp vari
      ables
820                                 stateRealUp = stateVecReal[indexUp];
821                                 stateImagUp = stateVecImag[indexUp];
822 
823                                 stateRealLo = stateVecReal[indexLo];
824                                 stateImagLo = stateVecImag[indexLo];
825 
826 
827                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
828                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
829                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
830                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
831                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
832 
833                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
834                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
835                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
836                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
837                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
838                         }
839                 } 
840         }
841 
842 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!exitWithError@{exitWithError}}
\index{exitWithError@{exitWithError}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{exitWithError}]{\setlength{\rightskip}{0pt plus 5cm}void exitWithError (int {\em errorCode}, \/  const char $\ast$ {\em func})}\hfill}
\label{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}


Definition at line 235 of file qubits\_\-env\_\-local.c.

References errorCodes.

Referenced by QuESTAssert().


\begin{DoxyCode}
235                                                    {
236     printf("!!!\n");
237     printf("QuEST Error in function %s: %s\n", func, errorCodes[errorCode]);
238     printf("!!!\n");
239     printf("exiting..\n");
240     exit(errorCode);
241 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}}
\index{findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{findProbabilityOfZeroDistributed}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}


Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. Size of regions to skip is a multiple of chunkSize.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1643 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1645 {
1646         // ----- measured probability
1647         REAL   totalProbability;                                    // probabilit
      y (returned) value
1648         // ----- temp variables
1649         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1650         long long int numTasks=multiQubit.numAmps;
1651 
1652         // ---------------------------------------------------------------- //
1653         //            find probability                                      //
1654         // ---------------------------------------------------------------- //
1655 
1656         // initialise returned value
1657         totalProbability = 0.0;
1658 
1659         REAL *stateVecReal = multiQubit.stateVec.real;
1660         REAL *stateVecImag = multiQubit.stateVec.imag;
1661 
1662 # ifdef _OPENMP
1663 # pragma omp parallel \
1664         shared    (numTasks,stateVecReal,stateVecImag) \
1665         private   (thisTask) \
1666         reduction ( +:totalProbability )
1667 # endif
1668         {
1669 # ifdef _OPENMP
1670                 # pragma omp for schedule  (static)
1671 # endif
1672                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1673                         // summation -- simple implementation
1674                         totalProbability += stateVecReal[thisTask]*stateVecReal[t
      hisTask]
1675                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
1676 
1677                         /*
1678                         // summation -- kahan correction
1679                         y = stateVecReal[thisTask]*stateVecReal[thisTask]
1680                         + stateVecImag[thisTask]*stateVecImag[thisTask] - c;
1681                         t = totalProbability + y;
1682                         c = (t - totalProbability) - y;
1683                         totalProbability = t;
1684                         */
1685 
1686                 }
1687         }
1688 
1689         return totalProbability;
1690 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}}
\index{findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{findProbabilityOfZeroLocal}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}


Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1571 of file qubits.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1573 {
1574         // ----- sizes
1575         long long int sizeBlock,                                           // siz
      e of blocks
1576         sizeHalfBlock;                                       // size of blocks ha
      lved
1577         // ----- indices
1578         long long int thisBlock,                                           // cur
      rent block
1579              index;                                               // current inde
      x for first half block
1580         // ----- measured probability
1581         REAL   totalProbability;                                    // probabilit
      y (returned) value
1582         // ----- temp variables
1583         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1584         long long int numTasks=multiQubit.numAmps>>1;
1585 
1586         // ---------------------------------------------------------------- //
1587         //            dimensions                                            //
1588         // ---------------------------------------------------------------- //
1589         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1590         // and then the number to skip
1591         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1592 
1593         // initialise returned value
1594         totalProbability = 0.0;
1595 
1596         // initialise correction for kahan summation
1597         if (DEBUG) printf("sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\n",sizeHa
      lfBlock,sizeBlock,numTasks);
1598 
1599         REAL *stateVecReal = multiQubit.stateVec.real;
1600         REAL *stateVecImag = multiQubit.stateVec.imag;
1601 
1602 # ifdef _OPENMP
1603 # pragma omp parallel \
1604         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
      
1605         private   (thisTask,thisBlock,index) \
1606         reduction ( +:totalProbability )
1607 # endif 
1608         {
1609 # ifdef _OPENMP
1610                 # pragma omp for schedule  (static)
1611 # endif
1612                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1613                         thisBlock = thisTask / sizeHalfBlock;
1614                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
      
1615 
1616                         if (index<0){ printf("ABORTING as index=%Ld with thisBloc
      k = %Ld  thisTask=%Ld \n", index,thisBlock,thisTask); exit(1);}
1617 
1618                         // summation -- simple implementation
1619                         totalProbability += stateVecReal[index]*stateVecReal[inde
      x]
1620                                 + stateVecImag[index]*stateVecImag[index];
1621 
1622                         /*
1623                         // summation -- kahan correction
1624                         y = stateVecReal[index]*stateVecReal[index]
1625                         + stateVecImag[index]*stateVecImag[index] - c;
1626                         t = totalProbability + y;
1627                         c = (t - totalProbability) - y;
1628                         totalProbability = t;
1629                         */
1630 
1631                 }
1632         }
1633         return totalProbability;
1634 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!hadamardDistributed@{hadamardDistributed}}
\index{hadamardDistributed@{hadamardDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{hadamardDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits__internal_8h_ae6a897066979fc52d977007d959ca09d}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1374 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by hadamard().


\begin{DoxyCode}
1379 {
1380 
1381         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1382         long long int thisTask;  
1383         const long long int numTasks=multiQubit.numAmps;
1384 
1385         int sign;
1386         if (updateUpper) sign=1;
1387         else sign=-1;
1388 
1389         REAL recRoot2 = 1.0/sqrt(2);
1390 
1391         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1392         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1393         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1394 
1395 # ifdef _OPENMP
1396 # pragma omp parallel \
1397         default  (none) \
1398         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1399                         recRoot2, sign) \
1400         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1401 # endif
1402         {
1403 # ifdef _OPENMP
1404                 # pragma omp for schedule (static)
1405 # endif
1406                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1407                         // store current state vector values in temp variables
1408                         stateRealUp = stateVecRealUp[thisTask];
1409                         stateImagUp = stateVecImagUp[thisTask];
1410 
1411                         stateRealLo = stateVecRealLo[thisTask];
1412                         stateImagLo = stateVecImagLo[thisTask];
1413 
1414                         stateVecRealOut[thisTask] = recRoot2*(stateRealUp + sign*
      stateRealLo);
1415                         stateVecImagOut[thisTask] = recRoot2*(stateImagUp + sign*
      stateImagLo);
1416                 }
1417         }
1418 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!hadamardLocal@{hadamardLocal}}
\index{hadamardLocal@{hadamardLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{hadamardLocal}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_aa9f0718b4dd794a3e1b143e3b153bfc5}


Definition at line 1313 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by hadamard().


\begin{DoxyCode}
1314 {
1315         long long int sizeBlock, sizeHalfBlock;
1316         long long int thisBlock, // current block
1317              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1318 
1319         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1320         long long int thisTask;         
1321         const long long int numTasks=multiQubit.numAmps>>1;
1322 
1323         // set dimensions
1324         sizeHalfBlock = 1LL << targetQubit;  
1325         sizeBlock     = 2LL * sizeHalfBlock; 
1326 
1327         // Can't use multiQubit.stateVec as a private OMP var
1328         REAL *stateVecReal = multiQubit.stateVec.real;
1329         REAL *stateVecImag = multiQubit.stateVec.imag;
1330 
1331         REAL recRoot2 = 1.0/sqrt(2);
1332 
1333 # ifdef _OPENMP
1334 # pragma omp parallel \
1335         default  (none) \
1336         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \
      
1337         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
1338 # endif
1339         {
1340 # ifdef _OPENMP
1341                 # pragma omp for schedule (static)
1342 # endif
1343                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1344                         thisBlock   = thisTask / sizeHalfBlock;
1345                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1346                         indexLo     = indexUp + sizeHalfBlock;
1347 
1348                         stateRealUp = stateVecReal[indexUp];
1349                         stateImagUp = stateVecImag[indexUp];
1350 
1351                         stateRealLo = stateVecReal[indexLo];
1352                         stateImagLo = stateVecImag[indexLo];
1353 
1354                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateReal
      Lo);
1355                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImag
      Lo);
1356 
1357                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateReal
      Lo);
1358                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImag
      Lo);
1359                 } 
1360         }
1361 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}}
\index{multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{multiControlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a9dbf856ebeea0cf0a3ee5aae6782f2d2}


Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where all the control qubits are 1.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 984 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
991 {
992 
993         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
994         long long int thisTask;  
995         const long long int numTasks=multiQubit.numAmps;
996         const long long int chunkSize=multiQubit.numAmps;
997         const long long int chunkId=multiQubit.chunkId;
998 
999         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
1000         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
1001         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1002         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1003         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1004 
1005 # ifdef _OPENMP
1006 # pragma omp parallel \
1007         default  (none) \
1008         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1009                         rot1Real,rot1Imag, rot2Real,rot2Imag, mask) \
1010         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1011 # endif
1012         {
1013 # ifdef _OPENMP
1014                 # pragma omp for schedule (static)
1015 # endif
1016                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1017                         if (mask == (mask & (thisTask+chunkId*chunkSize)) ){
1018                                 // store current state vector values in temp vari
      ables
1019                                 stateRealUp = stateVecRealUp[thisTask];
1020                                 stateImagUp = stateVecImagUp[thisTask];
1021 
1022                                 stateRealLo = stateVecRealLo[thisTask];
1023                                 stateImagLo = stateVecImagLo[thisTask];
1024 
1025                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
1026                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
1027                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
1028                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
1029                         }
1030                 }
1031         }
1032 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!multiControlledUnitaryLocal@{multiControlledUnitaryLocal}}
\index{multiControlledUnitaryLocal@{multiControlledUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{multiControlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_a1309eabcba3cb97fbc3cd2e606d17766}


Definition at line 715 of file qubits.c.

References MultiQubit::chunkId, Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
717 {
718         long long int sizeBlock, sizeHalfBlock;
719         long long int thisBlock, // current block
720              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
721 
722         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
723         long long int thisTask;         
724         const long long int numTasks=multiQubit.numAmps>>1;
725         const long long int chunkSize=multiQubit.numAmps;
726         const long long int chunkId=multiQubit.chunkId;
727 
728         // set dimensions
729         sizeHalfBlock = 1LL << targetQubit;  
730         sizeBlock     = 2LL * sizeHalfBlock; 
731 
732         // Can't use multiQubit.stateVec as a private OMP var
733         REAL *stateVecReal = multiQubit.stateVec.real;
734         REAL *stateVecImag = multiQubit.stateVec.imag;
735 
736 # ifdef _OPENMP
737 # pragma omp parallel \
738         default  (none) \
739         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u, mask) \
740         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
741 # endif
742         {
743 # ifdef _OPENMP
744                 # pragma omp for schedule (static)
745 # endif
746                 for (thisTask=0; thisTask<numTasks; thisTask++) {
747 
748                         thisBlock   = thisTask / sizeHalfBlock;
749                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
750                         indexLo     = indexUp + sizeHalfBlock;
751 
752                         if (mask == (mask & (indexUp+chunkId*chunkSize)) ){
753                                 // store current state vector values in temp vari
      ables
754                                 stateRealUp = stateVecReal[indexUp];
755                                 stateImagUp = stateVecImag[indexUp];
756 
757                                 stateRealLo = stateVecReal[indexLo];
758                                 stateImagLo = stateVecImag[indexLo];
759 
760 
761                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
762                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
763                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
764                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
765                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
766 
767                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
768                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
769                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
770                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
771                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
772                         }
773                 } 
774         }
775 
776 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGate@{phaseGate}}
\index{phaseGate@{phaseGate}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_aae7a8a7f1ccbddb7f76b6c52b746bb43}


Definition at line 166 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, phaseGateDistributed(), phaseGateLocal(), and QuESTAssert().

Referenced by sGate(), sigmaZ(), and tGate().


\begin{DoxyCode}
167 {
168     QuESTAssert(targetQubit >= 0 && targetQubit < multiQubit.numQubits, 1, __func
      __);
169         phaseGateLocal(multiQubit, targetQubit, type);
170 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGateDistributed@{phaseGateDistributed}}
\index{phaseGateDistributed@{phaseGateDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGateDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_af832ed00b02a0597b7fe0b714032c54a}


Definition at line 1496 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1497 {
1498         REAL stateRealLo,stateImagLo;
1499         long long int thisTask;         
1500         const long long int numTasks=multiQubit.numAmps;
1501 
1502         // Can't use multiQubit.stateVec as a private OMP var
1503         REAL *stateVecReal = multiQubit.stateVec.real;
1504         REAL *stateVecImag = multiQubit.stateVec.imag;
1505 
1506         REAL recRoot2 = 1.0/sqrt(2);
1507 
1508 # ifdef _OPENMP
1509 # pragma omp parallel \
1510         default  (none) \
1511         shared   (stateVecReal,stateVecImag, recRoot2, type) \
1512         private  (thisTask,stateRealLo,stateImagLo) 
1513 # endif
1514         {
1515                 if (type==SIGMA_Z){
1516 # ifdef _OPENMP
1517                         # pragma omp for schedule (static)
1518 # endif
1519                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1520                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
      
1521                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
      
1522                         } 
1523                 } else if (type==S_GATE){
1524 # ifdef _OPENMP
1525                         # pragma omp for schedule (static)
1526 # endif
1527                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1528                                 stateRealLo = stateVecReal[thisTask];
1529                                 stateImagLo = stateVecImag[thisTask];
1530 
1531                                 stateVecReal[thisTask] = -stateImagLo;
1532                                 stateVecImag[thisTask] = stateRealLo;
1533                         } 
1534                 } else if (type==T_GATE){
1535 # ifdef _OPENMP
1536                         # pragma omp for schedule (static)
1537 # endif
1538                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1539                                 stateRealLo = stateVecReal[thisTask];
1540                                 stateImagLo = stateVecImag[thisTask];
1541 
1542                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo 
      - stateImagLo);
1543                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo 
      + stateImagLo);
1544                         } 
1545                 } else printf("Type %d is an invalid phase gate\n", type);
1546         }
1547 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGateLocal@{phaseGateLocal}}
\index{phaseGateLocal@{phaseGateLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGateLocal}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_a3a54566b73ac84c312d7da4f56ffbc3b}


fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod? 

Definition at line 1420 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1421 {
1422         long long int sizeBlock, sizeHalfBlock;
1423         long long int thisBlock, // current block
1424              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1425 
1426         REAL stateRealLo,stateImagLo;
1427         long long int thisTask;         
1428         const long long int numTasks=multiQubit.numAmps>>1;
1429 
1430         // set dimensions
1431         sizeHalfBlock = 1LL << targetQubit;  
1432         sizeBlock     = 2LL * sizeHalfBlock; 
1433 
1434         // Can't use multiQubit.stateVec as a private OMP var
1435         REAL *stateVecReal = multiQubit.stateVec.real;
1436         REAL *stateVecImag = multiQubit.stateVec.imag;
1437 
1438         REAL recRoot2 = 1.0/sqrt(2);
1439 
1440 # ifdef _OPENMP
1441 # pragma omp parallel \
1442         default  (none) \
1443         shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type
      ) \
1444         private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) 
1445 # endif
1446         {
1447                 if (type==SIGMA_Z){
1448 # ifdef _OPENMP
1449                         # pragma omp for schedule (static)
1450 # endif
1451                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1453                                 thisBlock   = thisTask / sizeHalfBlock;
1454                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1455                                 indexLo     = indexUp + sizeHalfBlock;
1456 
1457                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
1458                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
1459                         } 
1460                 } 
1461                 
1462                 else if (type==S_GATE){
1463 # ifdef _OPENMP
1464                         # pragma omp for schedule (static)
1465 # endif
1466                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1468                                 thisBlock   = thisTask / sizeHalfBlock;
1469                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1470                                 indexLo     = indexUp + sizeHalfBlock;
1471                                 stateRealLo = stateVecReal[indexLo];
1472                                 stateImagLo = stateVecImag[indexLo];
1473 
1474                                 stateVecReal[indexLo] = -stateImagLo;
1475                                 stateVecImag[indexLo] = stateRealLo;
1476                         } 
1477                 } else if (type==T_GATE){
1478 # ifdef _OPENMP
1479                         # pragma omp for schedule (static)
1480 # endif
1481                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1483                                 thisBlock   = thisTask / sizeHalfBlock;
1484                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1485                                 indexLo     = indexUp + sizeHalfBlock;
1486                                 stateRealLo = stateVecReal[indexLo];
1487                                 stateImagLo = stateVecImag[indexLo];
1488 
1489                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo -
       stateImagLo);
1490                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo +
       stateImagLo);
1491                         } 
1492                 } else printf("Type %d is an invalid phase gate\n", type);
1493         }
1494 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!QuESTAssert@{QuESTAssert}}
\index{QuESTAssert@{QuESTAssert}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{QuESTAssert}]{\setlength{\rightskip}{0pt plus 5cm}void QuESTAssert (int {\em isValid}, \/  int {\em errorCode}, \/  const char $\ast$ {\em func})}\hfill}
\label{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}


Definition at line 243 of file qubits\_\-env\_\-local.c.

References exitWithError().

Referenced by collapseToOutcome(), compactUnitary(), controlledCompactUnitary(), controlledNot(), controlledPhaseGate(), controlledUnitary(), createMultiQubit(), findProbabilityOfOutcome(), hadamard(), measure(), measureWithStats(), multiControlledPhaseGate(), multiControlledUnitary(), phaseGate(), sigmaX(), sigmaY(), and unitary().


\begin{DoxyCode}
243                                                               {
244     if (!isValid) exitWithError(errorCode, func);
245 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaXDistributed@{sigmaXDistributed}}
\index{sigmaXDistributed@{sigmaXDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaXDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a2275fff50824fe47485890ff5a857785}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1093 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaX().


\begin{DoxyCode}
1096 {
1097 
1098         long long int thisTask;  
1099         const long long int numTasks=multiQubit.numAmps;
1100 
1101         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1102         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1103 
1104 # ifdef _OPENMP
1105 # pragma omp parallel \
1106         default  (none) \
1107         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1108         private  (thisTask)
1109 # endif
1110         {
1111 # ifdef _OPENMP
1112                 # pragma omp for schedule (static)
1113 # endif
1114                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1115                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
1116                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
1117                 }
1118         }
1119 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaXLocal@{sigmaXLocal}}
\index{sigmaXLocal@{sigmaXLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaXLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_a74822fd86bb5d81766e6e8dbdcd62df1}


Definition at line 1034 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaX().


\begin{DoxyCode}
1035 {
1036         long long int sizeBlock, sizeHalfBlock;
1037         long long int thisBlock, // current block
1038              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1039 
1040         REAL stateRealUp,stateImagUp;
1041         long long int thisTask;         
1042         const long long int numTasks=multiQubit.numAmps>>1;
1043 
1044         // set dimensions
1045         sizeHalfBlock = 1LL << targetQubit;  
1046         sizeBlock     = 2LL * sizeHalfBlock; 
1047 
1048         // Can't use multiQubit.stateVec as a private OMP var
1049         REAL *stateVecReal = multiQubit.stateVec.real;
1050         REAL *stateVecImag = multiQubit.stateVec.imag;
1051 
1052 # ifdef _OPENMP
1053 # pragma omp parallel \
1054         default  (none) \
1055         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1056         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1057 # endif
1058         {
1059 # ifdef _OPENMP
1060                 # pragma omp for schedule (static)
1061 # endif
1062                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1063                         thisBlock   = thisTask / sizeHalfBlock;
1064                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1065                         indexLo     = indexUp + sizeHalfBlock;
1066 
1067                         stateRealUp = stateVecReal[indexUp];
1068                         stateImagUp = stateVecImag[indexUp];
1069 
1070                         stateVecReal[indexUp] = stateVecReal[indexLo];
1071                         stateVecImag[indexUp] = stateVecImag[indexLo];
1072 
1073                         stateVecReal[indexLo] = stateRealUp;
1074                         stateVecImag[indexLo] = stateImagUp;
1075                 } 
1076         }
1077 
1078 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaYDistributed@{sigmaYDistributed}}
\index{sigmaYDistributed@{sigmaYDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaYDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits__internal_8h_af5ef5166f00c0572354b4ac53dcf40cf}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1280 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaY().


\begin{DoxyCode}
1284 {
1285 
1286         long long int thisTask;  
1287         const long long int numTasks=multiQubit.numAmps;
1288 
1289         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1290         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1291 
1292         int realSign=1, imagSign=1;
1293         if (updateUpper) imagSign=-1;
1294         else realSign = -1;
1295 
1296 # ifdef _OPENMP
1297 # pragma omp parallel \
1298         default  (none) \
1299         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,r
      ealSign,imagSign) \
1300         private  (thisTask)
1301 # endif
1302         {
1303 # ifdef _OPENMP
1304                 # pragma omp for schedule (static)
1305 # endif
1306                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1307                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisT
      ask];
1308                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisT
      ask];
1309                 }
1310         }
1311 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaYLocal@{sigmaYLocal}}
\index{sigmaYLocal@{sigmaYLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaYLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_a81fbfaed65a742a7dfd622e17652245e}


Definition at line 1221 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaY().


\begin{DoxyCode}
1222 {
1223         long long int sizeBlock, sizeHalfBlock;
1224         long long int thisBlock, // current block
1225              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1226 
1227         REAL stateRealUp,stateImagUp;
1228         long long int thisTask;         
1229         const long long int numTasks=multiQubit.numAmps>>1;
1230 
1231         // set dimensions
1232         sizeHalfBlock = 1LL << targetQubit;  
1233         sizeBlock     = 2LL * sizeHalfBlock; 
1234 
1235         // Can't use multiQubit.stateVec as a private OMP var
1236         REAL *stateVecReal = multiQubit.stateVec.real;
1237         REAL *stateVecImag = multiQubit.stateVec.imag;
1238 
1239 # ifdef _OPENMP
1240 # pragma omp parallel \
1241         default  (none) \
1242         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1243         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1244 # endif
1245         {
1246 # ifdef _OPENMP
1247                 # pragma omp for schedule (static)
1248 # endif
1249                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1250                         thisBlock   = thisTask / sizeHalfBlock;
1251                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1252                         indexLo     = indexUp + sizeHalfBlock;
1253 
1254                         stateRealUp = stateVecReal[indexUp];
1255                         stateImagUp = stateVecImag[indexUp];
1256 
1257                         stateVecReal[indexUp] = stateVecImag[indexLo];
1258                         stateVecImag[indexUp] = -stateVecReal[indexLo];
1259 
1260                         stateVecReal[indexLo] = -stateImagUp;
1261                         stateVecImag[indexLo] = stateRealUp;
1262                 } 
1263         }
1264 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!unitaryDistributed@{unitaryDistributed}}
\index{unitaryDistributed@{unitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{unitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a2343b7240118e89aa615e2c9140b770b}


Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em u}]unitary matrix to apply \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 603 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by unitary().


\begin{DoxyCode}
608 {
609 
610         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
611         long long int thisTask;  
612         const long long int numTasks=multiQubit.numAmps;
613 
614         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
615         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
616         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
617         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
618         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
619 
620 
621 # ifdef _OPENMP
622 # pragma omp parallel \
623         default  (none) \
624         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
625                         rot1Real, rot1Imag, rot2Real, rot2Imag) \
626         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
627 # endif
628         {
629 # ifdef _OPENMP
630                 # pragma omp for schedule (static)
631 # endif
632                 for (thisTask=0; thisTask<numTasks; thisTask++) {
633                         // store current state vector values in temp variables
634                         stateRealUp = stateVecRealUp[thisTask];
635                         stateImagUp = stateVecImagUp[thisTask];
636 
637                         stateRealLo = stateVecRealLo[thisTask];
638                         stateImagLo = stateVecImagLo[thisTask];
639 
640                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp 
641                                 + rot2Real*stateRealLo - rot2Imag*stateImagLo;
642                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp 
643                                 + rot2Real*stateImagLo + rot2Imag*stateRealLo;
644                 }
645         }
646 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!unitaryLocal@{unitaryLocal}}
\index{unitaryLocal@{unitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{unitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_ac134fb45b0a7248c5d15e16eb7139a35}


Definition at line 477 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by unitary().


\begin{DoxyCode}
478 {
479         long long int sizeBlock, sizeHalfBlock;
480         long long int thisBlock, // current block
481              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
482 
483         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
484         long long int thisTask;         
485         const long long int numTasks=multiQubit.numAmps>>1;
486 
487         // set dimensions
488         sizeHalfBlock = 1LL << targetQubit;  
489         sizeBlock     = 2LL * sizeHalfBlock; 
490 
491         // Can't use multiQubit.stateVec as a private OMP var
492         REAL *stateVecReal = multiQubit.stateVec.real;
493         REAL *stateVecImag = multiQubit.stateVec.imag;
494 
495 # ifdef _OPENMP
496 # pragma omp parallel \
497         default  (none) \
498         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
499         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
500 # endif
501         {
502 # ifdef _OPENMP
503                 # pragma omp for schedule (static)
504 # endif
505                 for (thisTask=0; thisTask<numTasks; thisTask++) {
506 
507                         thisBlock   = thisTask / sizeHalfBlock;
508                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
509                         indexLo     = indexUp + sizeHalfBlock;
510 
511                         // store current state vector values in temp variables
512                         stateRealUp = stateVecReal[indexUp];
513                         stateImagUp = stateVecImag[indexUp];
514 
515                         stateRealLo = stateVecReal[indexLo];
516                         stateImagLo = stateVecImag[indexLo];
517 
518 
519                         // state[indexUp] = u00 * state[indexUp] + u01 * state[in
      dexLo]
520                         stateVecReal[indexUp] = u.r0c0.real*stateRealUp - u.r0c0.
      imag*stateImagUp 
521                                 + u.r0c1.real*stateRealLo - u.r0c1.imag*stateImag
      Lo;
522                         stateVecImag[indexUp] = u.r0c0.real*stateImagUp + u.r0c0.
      imag*stateRealUp 
523                                 + u.r0c1.real*stateImagLo + u.r0c1.imag*stateReal
      Lo;
524 
525                         // state[indexLo] = u10  * state[indexUp] + u11 * state[i
      ndexLo]
526                         stateVecReal[indexLo] = u.r1c0.real*stateRealUp  - u.
      r1c0.imag*stateImagUp 
527                                 + u.r1c1.real*stateRealLo  -  u.r1c1.imag*stateIm
      agLo;
528                         stateVecImag[indexLo] = u.r1c0.real*stateImagUp + u.r1c0.
      imag*stateRealUp 
529                                 + u.r1c1.real*stateImagLo + u.r1c1.imag*stateReal
      Lo;
530 
531                 } 
532         }
533 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateAlphaBeta@{validateAlphaBeta}}
\index{validateAlphaBeta@{validateAlphaBeta}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateAlphaBeta}]{\setlength{\rightskip}{0pt plus 5cm}int validateAlphaBeta ({\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}


Definition at line 366 of file qubits.c.

References Complex::imag, Complex::real, and REAL\_\-EPS.

Referenced by compactUnitary(), and controlledCompactUnitary().


\begin{DoxyCode}
366                                                   {
367         if ( fabs(alpha.real*alpha.real 
368                 + alpha.imag*alpha.imag
369                 + beta.real*beta.real 
370                 + beta.imag*beta.imag - 1) > REAL_EPS ) return 0;
371         else return 1;
372 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateMatrixIsUnitary@{validateMatrixIsUnitary}}
\index{validateMatrixIsUnitary@{validateMatrixIsUnitary}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateMatrixIsUnitary}]{\setlength{\rightskip}{0pt plus 5cm}int validateMatrixIsUnitary ({\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}


Definition at line 341 of file qubits.c.

References Complex::imag, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, and REAL\_\-EPS.

Referenced by controlledUnitary(), multiControlledUnitary(), and unitary().


\begin{DoxyCode}
341                                              {
342 
343         if ( fabs(u.r0c0.real*u.r0c0.real 
344                 + u.r0c0.imag*u.r0c0.imag
345                 + u.r1c0.real*u.r1c0.real
346                 + u.r1c0.imag*u.r1c0.imag - 1) > REAL_EPS ) return 0;
347     // check
348         if ( fabs(u.r0c1.real*u.r0c1.real 
349                 + u.r0c1.imag*u.r0c1.imag
350                 + u.r1c1.real*u.r1c1.real
351                 + u.r1c1.imag*u.r1c1.imag - 1) > REAL_EPS ) return 0;
352 
353         if ( fabs(u.r0c0.real*u.r0c1.real 
354                 + u.r0c0.imag*u.r0c1.imag
355                 + u.r1c0.real*u.r1c1.real
356                 + u.r1c0.imag*u.r1c1.imag) > REAL_EPS ) return 0;
357 
358         if ( fabs(u.r0c1.real*u.r0c0.imag
359                 - u.r0c0.real*u.r0c1.imag
360                 + u.r1c1.real*u.r1c0.imag
361                 - u.r1c0.real*u.r1c1.imag) > REAL_EPS ) return 0;
362 
363         return 1;
364 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateUnitVector@{validateUnitVector}}
\index{validateUnitVector@{validateUnitVector}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateUnitVector}]{\setlength{\rightskip}{0pt plus 5cm}int validateUnitVector (REAL {\em ux}, \/  REAL {\em uy}, \/  REAL {\em uz})}\hfill}
\label{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}


Definition at line 374 of file qubits.c.

References REAL\_\-EPS.


\begin{DoxyCode}
374                                                  {
375         if ( fabs(sqrt(ux*ux + uy*uy + uz*uz) - 1) > REAL_EPS ) return 0;
376         else return 1;
377 }
\end{DoxyCode}


\subsubsection{Variable Documentation}
\hypertarget{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!errorCodes@{errorCodes}}
\index{errorCodes@{errorCodes}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{errorCodes}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ {\bf errorCodes}\mbox{[}$\,$\mbox{]}}\hfill}
\label{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}


Definition at line 17 of file qubits.c.

Referenced by exitWithError().