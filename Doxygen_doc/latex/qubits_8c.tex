\hypertarget{qubits_8c}{}\subsection{qubits.\+c File Reference}
\label{qubits_8c}\index{qubits.\+c@{qubits.\+c}}


The core of the Q\+U\+E\+ST Library.  


{\ttfamily \#include $<$math.\+h$>$}\newline
{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$assert.\+h$>$}\newline
{\ttfamily \#include \char`\"{}qubits.\+h\char`\"{}}\newline
\subsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{D\+E\+B\+UG}~0
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extract\+Bit} (const int location\+Of\+Bit\+From\+Right, const long long int the\+Encoded\+Number)
\begin{DoxyCompactList}\small\item\em Get the value of the bit at a particular index in a number. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ae729f311efd2a426ce5161df3e017a16}{create\+Multi\+Qubit} (\hyperlink{structMultiQubit}{Multi\+Qubit} $\ast$multi\+Qubit, int num\+Qubits, \hyperlink{structQUESTEnv}{Q\+U\+E\+S\+T\+Env} env)
\begin{DoxyCompactList}\small\item\em Create a \hyperlink{structMultiQubit}{Multi\+Qubit} object representing a set of qubits. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ab796aea79288b974f63474db650be878}{destroy\+Multi\+Qubit} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, \hyperlink{structQUESTEnv}{Q\+U\+E\+S\+T\+Env} env)
\begin{DoxyCompactList}\small\item\em Deallocate a \hyperlink{structMultiQubit}{Multi\+Qubit} object representing a set of qubits Free memory allocated to state vector of probability amplitudes, including temporary vector for values copied from another chunk if running the distributed version. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}{report\+State} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Print the current state vector of probability amplitudes for a set of qubits to file. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}{report\+Multi\+Qubit\+Params} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Report metainformation about a set of qubits\+: number of qubits, number of probability amplitudes. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a492d10377278f685c7a1fabc3ee60623}{init\+State\+Vec} (\hyperlink{structMultiQubit}{Multi\+Qubit} $\ast$multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes for a set of qubits to the zero state\+: $\vert$000...00$>$ \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_acb059cbcb8c7910a5fc43d21da4f5dea}{rotate\+Qubit\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a6ff67d25363f39fd57a4e76621a4bfd5}{rotate\+Qubit\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
double \hyperlink{qubits_8c_a1c0a25823add0bd9f925a9164dc21870}{find\+Probability\+Of\+Zero\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \end{DoxyCompactList}\item 
double \hyperlink{qubits_8c_a2d302738d123129a388edf81b845fd89}{find\+Probability\+Of\+Zero\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a0ad4584e44f567c140b653ed36d26ccf}{control\+Phase\+Gate} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2)
\begin{DoxyCompactList}\small\item\em The control phase (the two qubit phase gate). \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_aca7765bd500718f98700a172351748cc}{quad\+C\+Phase\+Gate} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3, const int id\+Qubit4)
\begin{DoxyCompactList}\small\item\em The control phase (the four qubit phase gate). \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_af77bdfeac8c0f5311e46fb523cbade7e}{measure\+In\+Zero\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, int measure\+Qubit, double total\+Probability)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measure\+Qubit=0. \end{DoxyCompactList}\item 
double \hyperlink{qubits_8c_a7ca30c5cfa104241549514f607371859}{measure\+In\+Zero\+Distributed\+Renorm} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit, const double total\+Probability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measure\+Qubit=0, based on the total probability of that qubit being in state 0. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a5b6e47e9a9b9324c9412b13d1e4a4f9b}{measure\+In\+Zero\+Distributed\+Set\+Zero} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Set parts of the state vector where measure\+Qubit=1 to have amplitude 0. \end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a035d5fa11bf9c4d7d4aea56fd3ba1153}{filter\+Out111\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3, const double prob\+Of\+Filter)
\begin{DoxyCompactList}\small\item\em Updates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \end{DoxyCompactList}\item 
double \hyperlink{qubits_8c_a9a91a155770436fcf14487cd1a45585d}{prob\+Of\+Filter\+Out111\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3)
\begin{DoxyCompactList}\small\item\em Evaluates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
The core of the Q\+U\+E\+ST Library. 



\subsubsection{Macro Definition Documentation}
\mbox{\Hypertarget{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}\label{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}} 
\index{qubits.\+c@{qubits.\+c}!D\+E\+B\+UG@{D\+E\+B\+UG}}
\index{D\+E\+B\+UG@{D\+E\+B\+UG}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{D\+E\+B\+UG}{DEBUG}}
{\footnotesize\ttfamily \#define D\+E\+B\+UG~0}



Definition at line 11 of file qubits.\+c.



Referenced by find\+Probability\+Of\+Zero\+Local(), and init\+State\+Vec().



\subsubsection{Function Documentation}
\mbox{\Hypertarget{qubits_8c_a0ad4584e44f567c140b653ed36d26ccf}\label{qubits_8c_a0ad4584e44f567c140b653ed36d26ccf}} 
\index{qubits.\+c@{qubits.\+c}!control\+Phase\+Gate@{control\+Phase\+Gate}}
\index{control\+Phase\+Gate@{control\+Phase\+Gate}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{control\+Phase\+Gate()}{controlPhaseGate()}}
{\footnotesize\ttfamily void control\+Phase\+Gate (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{id\+Qubit1,  }\item[{const int}]{id\+Qubit2 }\end{DoxyParamCaption})}



The control phase (the two qubit phase gate). 

For each state, if both input qubits are equal to zero, multiply the amplitude of that state by -\/1. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2} & specified qubits \\
\hline
\end{DoxyParams}


Definition at line 505 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by main().


\begin{DoxyCode}
506 \{
507         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
508         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
509         \textcolor{keywordtype}{int} bit1, bit2;
510 
511         \textcolor{comment}{// ---------------------------------------------------------------- //}
512         \textcolor{comment}{//            tests                                                 //}
513         \textcolor{comment}{// ---------------------------------------------------------------- //}
514 
515         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} && idQubit2 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
516 
517 
518         \textcolor{comment}{// ---------------------------------------------------------------- //}
519         \textcolor{comment}{//            initialise the state to |0000..0>                     //}
520         \textcolor{comment}{// ---------------------------------------------------------------- //}
521 
522         \textcolor{comment}{// dimension of the state vector}
523         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
524         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
525         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
526 
527 \textcolor{preprocessor}{# ifdef \_OPENMP}
528 \textcolor{preprocessor}{# pragma omp parallel for \(\backslash\)}
529 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
530 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag ) \(\backslash\)}
531 \textcolor{preprocessor}{        private  (index,bit1,bit2)                     \(\backslash\)}
532 \textcolor{preprocessor}{        schedule (static)}
533 \textcolor{preprocessor}{# endif}
534         \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
535                 bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
536                 bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
537                 \textcolor{keywordflow}{if} (bit1 && bit2) \{
538                         stateVecReal [index] = - stateVecReal [index];
539                         stateVecImag [index] = - stateVecImag [index];
540                 \}
541         \}
542 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits_8c_ae729f311efd2a426ce5161df3e017a16}\label{qubits_8c_ae729f311efd2a426ce5161df3e017a16}} 
\index{qubits.\+c@{qubits.\+c}!create\+Multi\+Qubit@{create\+Multi\+Qubit}}
\index{create\+Multi\+Qubit@{create\+Multi\+Qubit}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{create\+Multi\+Qubit()}{createMultiQubit()}}
{\footnotesize\ttfamily void create\+Multi\+Qubit (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit} $\ast$}]{multi\+Qubit,  }\item[{int}]{num\+Qubits,  }\item[{\hyperlink{structQUESTEnv}{Q\+U\+E\+S\+T\+Env}}]{env }\end{DoxyParamCaption})}



Create a \hyperlink{structMultiQubit}{Multi\+Qubit} object representing a set of qubits. 

Allocate space for state vector of probability amplitudes, including space for temporary values to be copied from one other chunk if running the distributed version. Define properties related to the size of the set of qubits. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em num\+Qubits} & number of qubits in the system \\
\hline
\mbox{\tt in}  & {\em env} & object representing the execution environment (local, multinode etc) \\
\hline
\end{DoxyParams}


Definition at line 24 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Chunks, Multi\+Qubit\+::num\+Qubits, Q\+U\+E\+S\+T\+Env\+::num\+Ranks, Multi\+Qubit\+::pair\+State\+Vec, Q\+U\+E\+S\+T\+Env\+::rank, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by main().


\begin{DoxyCode}
25 \{
26         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numAmps = 1L << numQubits;
27         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numAmpsPerRank = numAmps/env.\hyperlink{structQUESTEnv_ab9d9ce82e2d5f1b39aa9efc3accb3742}{numRanks};
28 
29         multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real} = malloc(numAmpsPerRank * \textcolor{keyword}{sizeof}(multiQubit->
      \hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}));
30         multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag} = malloc(numAmpsPerRank * \textcolor{keyword}{sizeof}(multiQubit->
      \hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag}));
31         \textcolor{keywordflow}{if} (env.\hyperlink{structQUESTEnv_ab9d9ce82e2d5f1b39aa9efc3accb3742}{numRanks}>1)\{
32                 multiQubit->\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real} = malloc(numAmpsPerRank * \textcolor{keyword}{sizeof}(multiQubit->
      \hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}));
33                 multiQubit->\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag} = malloc(numAmpsPerRank * \textcolor{keyword}{sizeof}(multiQubit->
      \hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag}));
34         \}
35 
36         \textcolor{keywordflow}{if} ( (!(multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}) || !(multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.
      \hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag}))
37                  && numAmpsPerRank ) \{
38                 printf(\textcolor{stringliteral}{"Could not allocate memory!"});
39                 exit (EXIT\_FAILURE);
40         \}
41 
42         \textcolor{keywordflow}{if} ( env.\hyperlink{structQUESTEnv_ab9d9ce82e2d5f1b39aa9efc3accb3742}{numRanks}>1 && (!(multiQubit->\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.
      \hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}) || !(multiQubit->\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag}))
43                  && numAmpsPerRank ) \{
44                 printf(\textcolor{stringliteral}{"Could not allocate memory!"});
45                 exit (EXIT\_FAILURE);
46         \}
47 
48         multiQubit->\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} = numQubits;
49         multiQubit->\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps} = numAmpsPerRank;
50         multiQubit->\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId} = env.\hyperlink{structQUESTEnv_a1bdb6d425a2ce6a468f93929c0b26d73}{rank};
51         multiQubit->\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks} = env.\hyperlink{structQUESTEnv_ab9d9ce82e2d5f1b39aa9efc3accb3742}{numRanks};
52 
53 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits_8c_ab796aea79288b974f63474db650be878}\label{qubits_8c_ab796aea79288b974f63474db650be878}} 
\index{qubits.\+c@{qubits.\+c}!destroy\+Multi\+Qubit@{destroy\+Multi\+Qubit}}
\index{destroy\+Multi\+Qubit@{destroy\+Multi\+Qubit}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{destroy\+Multi\+Qubit()}{destroyMultiQubit()}}
{\footnotesize\ttfamily void destroy\+Multi\+Qubit (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{\hyperlink{structQUESTEnv}{Q\+U\+E\+S\+T\+Env}}]{env }\end{DoxyParamCaption})}



Deallocate a \hyperlink{structMultiQubit}{Multi\+Qubit} object representing a set of qubits Free memory allocated to state vector of probability amplitudes, including temporary vector for values copied from another chunk if running the distributed version. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object to be deallocated \\
\hline
\mbox{\tt in}  & {\em env} & object representing the execution environment (local, multinode etc) \\
\hline
\end{DoxyParams}


Definition at line 60 of file qubits.\+c.



References Complex\+Array\+::imag, Q\+U\+E\+S\+T\+Env\+::num\+Ranks, Multi\+Qubit\+::pair\+State\+Vec, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by main().


\begin{DoxyCode}
60                                                            \{
61         free(multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real});
62         free(multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag});
63         \textcolor{keywordflow}{if} (env.\hyperlink{structQUESTEnv_ab9d9ce82e2d5f1b39aa9efc3accb3742}{numRanks}>1)\{
64                 free(multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real});
65                 free(multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag});
66         \}
67 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits_8c_a100463f6ec212c76a5fad99579000505}\label{qubits_8c_a100463f6ec212c76a5fad99579000505}} 
\index{qubits.\+c@{qubits.\+c}!extract\+Bit@{extract\+Bit}}
\index{extract\+Bit@{extract\+Bit}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{extract\+Bit()}{extractBit()}}
{\footnotesize\ttfamily static int extract\+Bit (\begin{DoxyParamCaption}\item[{const int}]{location\+Of\+Bit\+From\+Right,  }\item[{const long long int}]{the\+Encoded\+Number }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Get the value of the bit at a particular index in a number. 

S\+CB edit\+: new definition of extract\+Bit is much faster $\ast$$\ast$$\ast$ 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em location\+Of\+Bit\+From\+Right} & location of bit in the\+Encoded\+Number \\
\hline
\mbox{\tt in}  & {\em the\+Encoded\+Number} & number to search \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the value of the bit in the\+Encoded\+Number 
\end{DoxyReturn}


Definition at line 494 of file qubits.\+c.



Referenced by control\+Phase\+Gate(), filter\+Out111\+Local(), prob\+Of\+Filter\+Out111\+Local(), and quad\+C\+Phase\+Gate().


\begin{DoxyCode}
495 \{
496         \textcolor{keywordflow}{return} (theEncodedNumber & ( 1LL << locationOfBitFromRight )) >> locationOfBitFromRight;
497 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits_8c_a035d5fa11bf9c4d7d4aea56fd3ba1153}\label{qubits_8c_a035d5fa11bf9c4d7d4aea56fd3ba1153}} 
\index{qubits.\+c@{qubits.\+c}!filter\+Out111\+Local@{filter\+Out111\+Local}}
\index{filter\+Out111\+Local@{filter\+Out111\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{filter\+Out111\+Local()}{filterOut111Local()}}
{\footnotesize\ttfamily void filter\+Out111\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{id\+Qubit1,  }\item[{const int}]{id\+Qubit2,  }\item[{const int}]{id\+Qubit3,  }\item[{const double}]{prob\+Of\+Filter }\end{DoxyParamCaption})}



Updates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3} & specified qubits \\
\hline
\mbox{\tt in}  & {\em prob\+Of\+Filter} & Total probability that the 3 qubits are not all in the 1 state. \\
\hline
\end{DoxyParams}


Definition at line 788 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by filter\+Out111().


\begin{DoxyCode}
790 \{
791         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
792         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
793         \textcolor{keywordtype}{int} bit1, bit2, bit3;
794 
795         \textcolor{comment}{// ---------------------------------------------------------------- //}
796         \textcolor{comment}{//            tests                                                 //}
797         \textcolor{comment}{// ---------------------------------------------------------------- //}
798         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} && idQubit2 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
799 
800         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
801 
802         \textcolor{keywordflow}{if} ( probOfFilter<1e-16 )\{ printf(\textcolor{stringliteral}{"Extremely small or negative profOfFilter=%.8e; aborting! \(\backslash\)n"},
      probOfFilter); exit(1);\}
803         \textcolor{keywordtype}{double} myNorm=1/sqrt(probOfFilter);
804         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
805         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
806 
807 \textcolor{preprocessor}{# ifdef \_OPENMP}
808 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
809 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
810 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag, myNorm) \(\backslash\)}
811 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3)                }
812 \textcolor{preprocessor}{# endif }
813         \{
814 \textcolor{preprocessor}{# ifdef \_OPENMP}
815 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
816 \textcolor{preprocessor}{# endif}
817                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
818                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
819                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
820                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index);
821                         \textcolor{keywordflow}{if} ((bit1 && bit2 && bit3)) \{
822                                 stateVecReal[index]=0;
823                                 stateVecImag [index]=0;
824                         \}\textcolor{keywordflow}{else}\{
825                                 stateVecReal[index] *= myNorm;
826                                 stateVecImag[index] *= myNorm;
827                         \}
828                 \}
829         \}
830 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits_8c_a2d302738d123129a388edf81b845fd89}\label{qubits_8c_a2d302738d123129a388edf81b845fd89}} 
\index{qubits.\+c@{qubits.\+c}!find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}}
\index{find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{find\+Probability\+Of\+Zero\+Distributed()}{findProbabilityOfZeroDistributed()}}
{\footnotesize\ttfamily double find\+Probability\+Of\+Zero\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit }\end{DoxyParamCaption})}



Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. 

Size of regions to skip is a multiple of chunk\+Size.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 427 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Zero().


\begin{DoxyCode}
429 \{
430         \textcolor{comment}{// ----- measured probability}
431         \textcolor{keywordtype}{double}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
432         \textcolor{comment}{// ----- temp variables}
433         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
434         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
435         \textcolor{comment}{// (good for shared memory parallelism)}
436 
437         \textcolor{comment}{// ---------------------------------------------------------------- //}
438         \textcolor{comment}{//            tests                                                 //}
439         \textcolor{comment}{// ---------------------------------------------------------------- //}
440         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
441 
442         \textcolor{comment}{// ---------------------------------------------------------------- //}
443         \textcolor{comment}{//            find probability                                      //}
444         \textcolor{comment}{// ---------------------------------------------------------------- //}
445 
446         \textcolor{comment}{// initialise returned value}
447         totalProbability = 0.0;
448 
449         \textcolor{comment}{// initialise correction for kahan summation}
450 
451         \textcolor{comment}{//}
452         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
453         \textcolor{comment}{//}
454         
455         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
456         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
457 
458 \textcolor{preprocessor}{# ifdef \_OPENMP}
459 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
460 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
461 \textcolor{preprocessor}{        private   (thisTask) \(\backslash\)}
462 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
463 \textcolor{preprocessor}{# endif}
464         \{
465 \textcolor{preprocessor}{# ifdef \_OPENMP}
466 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
467 \textcolor{preprocessor}{# endif}
468                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
469                         \textcolor{comment}{// summation -- simple implementation}
470                         totalProbability += stateVecReal[thisTask]*stateVecReal[thisTask]
471                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
472 
473                         \textcolor{comment}{/*}
474 \textcolor{comment}{                        // summation -- kahan correction}
475 \textcolor{comment}{                        y = stateVecReal[thisTask]*stateVecReal[thisTask]}
476 \textcolor{comment}{                        + stateVecImag[thisTask]*stateVecImag[thisTask] - c;}
477 \textcolor{comment}{                        t = totalProbability + y;}
478 \textcolor{comment}{                        c = (t - totalProbability) - y;}
479 \textcolor{comment}{                        totalProbability = t;}
480 \textcolor{comment}{                        */}
481 
482                 \}
483         \}
484 
485         \textcolor{keywordflow}{return} totalProbability;
486 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits_8c_a1c0a25823add0bd9f925a9164dc21870}\label{qubits_8c_a1c0a25823add0bd9f925a9164dc21870}} 
\index{qubits.\+c@{qubits.\+c}!find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}}
\index{find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{find\+Probability\+Of\+Zero\+Local()}{findProbabilityOfZeroLocal()}}
{\footnotesize\ttfamily double find\+Probability\+Of\+Zero\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit }\end{DoxyParamCaption})}



Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. 

Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 339 of file qubits.\+c.



References D\+E\+B\+UG, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Zero().


\begin{DoxyCode}
341 \{
342         \textcolor{comment}{// ----- sizes}
343         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
344         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
345         \textcolor{comment}{// ----- indices}
346         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
347              index;                                               \textcolor{comment}{// current index for first half block}
348         \textcolor{comment}{// ----- measured probability}
349         \textcolor{keywordtype}{double}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
350         \textcolor{comment}{// ----- temp variables}
351         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
352         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
353         \textcolor{comment}{// (good for shared memory parallelism)}
354 
355         \textcolor{comment}{// ---------------------------------------------------------------- //}
356         \textcolor{comment}{//            tests                                                 //}
357         \textcolor{comment}{// ---------------------------------------------------------------- //}
358         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
359 
360 
361         \textcolor{comment}{// ---------------------------------------------------------------- //}
362         \textcolor{comment}{//            dimensions                                            //}
363         \textcolor{comment}{// ---------------------------------------------------------------- //}
364         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
365         \textcolor{comment}{// and then the number to skip}
366         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
367 
368         \textcolor{comment}{// ---------------------------------------------------------------- //}
369         \textcolor{comment}{//            find probability                                      //}
370         \textcolor{comment}{// ---------------------------------------------------------------- //}
371 
372         \textcolor{comment}{// initialise returned value}
373         totalProbability = 0.0;
374 
375         \textcolor{comment}{// initialise correction for kahan summation}
376         \textcolor{keywordflow}{if} (\hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\(\backslash\)n"},sizeHalfBlock,sizeBlock,
      numTasks);
377 
378         \textcolor{comment}{//}
379         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
380         \textcolor{comment}{//}
381         
382         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
383         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
384 
385 \textcolor{preprocessor}{# ifdef \_OPENMP}
386 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
387 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
388 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index) \(\backslash\)}
389 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
390 \textcolor{preprocessor}{# endif }
391         \{
392 \textcolor{preprocessor}{# ifdef \_OPENMP}
393 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
394 \textcolor{preprocessor}{# endif}
395                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
396                         thisBlock = thisTask / sizeHalfBlock;
397                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
398 
399                         \textcolor{keywordflow}{if} (index<0)\{ printf(\textcolor{stringliteral}{"ABORTING as index=%Ld with thisBlock = %Ld  thisTask=%Ld \(\backslash\)n"},
       index,thisBlock,thisTask); exit(1);\}
400 
401                         \textcolor{comment}{// summation -- simple implementation}
402                         totalProbability += stateVecReal[index]*stateVecReal[index]
403                                 + stateVecImag[index]*stateVecImag[index];
404 
405                         \textcolor{comment}{/*}
406 \textcolor{comment}{                        // summation -- kahan correction}
407 \textcolor{comment}{                        y = stateVecReal[index]*stateVecReal[index]}
408 \textcolor{comment}{                        + stateVecImag[index]*stateVecImag[index] - c;}
409 \textcolor{comment}{                        t = totalProbability + y;}
410 \textcolor{comment}{                        c = (t - totalProbability) - y;}
411 \textcolor{comment}{                        totalProbability = t;}
412 \textcolor{comment}{                        */}
413 
414                 \}
415         \}
416         \textcolor{keywordflow}{return} totalProbability;
417 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits_8c_a492d10377278f685c7a1fabc3ee60623}\label{qubits_8c_a492d10377278f685c7a1fabc3ee60623}} 
\index{qubits.\+c@{qubits.\+c}!init\+State\+Vec@{init\+State\+Vec}}
\index{init\+State\+Vec@{init\+State\+Vec}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{init\+State\+Vec()}{initStateVec()}}
{\footnotesize\ttfamily void init\+State\+Vec (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit} $\ast$}]{multi\+Qubit }\end{DoxyParamCaption})}



Initialise the state vector of probability amplitudes for a set of qubits to the zero state\+: $\vert$000...00$>$ 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits to be initialised \\
\hline
\end{DoxyParams}


Definition at line 122 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, D\+E\+B\+UG, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by main().


\begin{DoxyCode}
123 \{
124         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
125         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
126 
127         \textcolor{comment}{// dimension of the state vector}
128         stateVecSize = multiQubit->\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
129 
130         \textcolor{comment}{// Can't use multiQubit->stateVec as a private OMP var}
131         \textcolor{keywordtype}{double} *stateVecReal = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
132         \textcolor{keywordtype}{double} *stateVecImag = multiQubit->\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
133 
134         \textcolor{comment}{// initialise the state to |0000..0000>}
135 \textcolor{preprocessor}{# ifdef \_OPENMP}
136 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
137 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
138 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal, stateVecImag) \(\backslash\)}
139 \textcolor{preprocessor}{        private  (index) }
140 \textcolor{preprocessor}{# endif}
141         \{
142 \textcolor{preprocessor}{# ifdef \_OPENMP}
143 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
144 \textcolor{preprocessor}{# endif}
145                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
146                         stateVecReal[index] = 0.0;
147                         stateVecImag[index] = 0.0;
148                 \}
149         \}
150 
151         \textcolor{keywordflow}{if} (multiQubit->\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}==0)\{
152                 \textcolor{comment}{// zero state |0000..0000> has probability 1}
153                 stateVecReal[0] = 1.0;
154                 stateVecImag[0] = 0.0;
155         \}
156 
157         \textcolor{keywordflow}{if} (\hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"COMPLETED INIT\(\backslash\)n"});
158 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits_8c_a7ca30c5cfa104241549514f607371859}\label{qubits_8c_a7ca30c5cfa104241549514f607371859}} 
\index{qubits.\+c@{qubits.\+c}!measure\+In\+Zero\+Distributed\+Renorm@{measure\+In\+Zero\+Distributed\+Renorm}}
\index{measure\+In\+Zero\+Distributed\+Renorm@{measure\+In\+Zero\+Distributed\+Renorm}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{measure\+In\+Zero\+Distributed\+Renorm()}{measureInZeroDistributedRenorm()}}
{\footnotesize\ttfamily double measure\+In\+Zero\+Distributed\+Renorm (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit,  }\item[{const double}]{total\+Probability }\end{DoxyParamCaption})}



Renormalise parts of the state vector where measure\+Qubit=0, based on the total probability of that qubit being in state 0. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that a zero have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0. In the distributed version, one block (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em total\+Probability} & probability of qubit measure\+Qubit being zero \\
\hline
\end{DoxyParams}


Definition at line 683 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+Zero().


\begin{DoxyCode}
684 \{
685         \textcolor{comment}{// ----- temp variables}
686         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
687         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
688         \textcolor{comment}{// (good for shared memory parallelism)}
689 
690         \textcolor{comment}{// ---------------------------------------------------------------- //}
691         \textcolor{comment}{//            tests                                                 //}
692         \textcolor{comment}{// ---------------------------------------------------------------- //}
693         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
694 
695         \textcolor{comment}{// ---------------------------------------------------------------- //}
696         \textcolor{comment}{//            find probability                                      //}
697         \textcolor{comment}{// ---------------------------------------------------------------- //}
698 
699         \textcolor{comment}{// initialise correction for kahan summation}
700 
701         \textcolor{comment}{//}
702         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
703         \textcolor{comment}{//}
704         
705         \textcolor{keywordtype}{double} renorm=1/sqrt(totalProbability);
706         
707         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
708         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
709 
710 \textcolor{preprocessor}{# ifdef \_OPENMP}
711 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
712 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
713 \textcolor{preprocessor}{        private   (thisTask)}
714 \textcolor{preprocessor}{# endif}
715         \{
716 \textcolor{preprocessor}{# ifdef \_OPENMP}
717 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
718 \textcolor{preprocessor}{# endif}
719                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
720                         \textcolor{comment}{// summation -- simple implementation}
721                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
722                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
723                 \}
724         \}
725         \textcolor{keywordflow}{return} totalProbability;
726 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits_8c_a5b6e47e9a9b9324c9412b13d1e4a4f9b}\label{qubits_8c_a5b6e47e9a9b9324c9412b13d1e4a4f9b}} 
\index{qubits.\+c@{qubits.\+c}!measure\+In\+Zero\+Distributed\+Set\+Zero@{measure\+In\+Zero\+Distributed\+Set\+Zero}}
\index{measure\+In\+Zero\+Distributed\+Set\+Zero@{measure\+In\+Zero\+Distributed\+Set\+Zero}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{measure\+In\+Zero\+Distributed\+Set\+Zero()}{measureInZeroDistributedSetZero()}}
{\footnotesize\ttfamily void measure\+In\+Zero\+Distributed\+Set\+Zero (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit }\end{DoxyParamCaption})}



Set parts of the state vector where measure\+Qubit=1 to have amplitude 0. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that a zero have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0. In the distributed version, one block (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}


Definition at line 741 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+Zero().


\begin{DoxyCode}
742 \{
743         \textcolor{comment}{// ----- temp variables}
744         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
745         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
746         \textcolor{comment}{// (good for shared memory parallelism)}
747 
748         \textcolor{comment}{// ---------------------------------------------------------------- //}
749         \textcolor{comment}{//            tests                                                 //}
750         \textcolor{comment}{// ---------------------------------------------------------------- //}
751         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
752 
753         \textcolor{comment}{// ---------------------------------------------------------------- //}
754         \textcolor{comment}{//            find probability                                      //}
755         \textcolor{comment}{// ---------------------------------------------------------------- //}
756 
757         \textcolor{comment}{// initialise correction for kahan summation}
758 
759         \textcolor{comment}{//}
760         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
761         \textcolor{comment}{//}
762         
763         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
764         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
765 
766 \textcolor{preprocessor}{# ifdef \_OPENMP}
767 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
768 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
769 \textcolor{preprocessor}{        private   (thisTask)}
770 \textcolor{preprocessor}{# endif}
771         \{
772 \textcolor{preprocessor}{# ifdef \_OPENMP}
773 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
774 \textcolor{preprocessor}{# endif}
775                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
776                         \textcolor{comment}{// summation -- simple implementation}
777                         stateVecReal[thisTask] = 0;
778                         stateVecImag[thisTask] = 0;
779                 \}
780         \}
781 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits_8c_af77bdfeac8c0f5311e46fb523cbade7e}\label{qubits_8c_af77bdfeac8c0f5311e46fb523cbade7e}} 
\index{qubits.\+c@{qubits.\+c}!measure\+In\+Zero\+Local@{measure\+In\+Zero\+Local}}
\index{measure\+In\+Zero\+Local@{measure\+In\+Zero\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{measure\+In\+Zero\+Local()}{measureInZeroLocal()}}
{\footnotesize\ttfamily void measure\+In\+Zero\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{int}]{measure\+Qubit,  }\item[{double}]{total\+Probability }\end{DoxyParamCaption})}



Update the state vector to be consistent with measuring measure\+Qubit=0. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that a zero have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0. In the local version, one or more blocks (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em total\+Probability} & probability of qubit measure\+Qubit being zero \\
\hline
\end{DoxyParams}


Definition at line 600 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+Zero().


\begin{DoxyCode}
601 \{
602         \textcolor{comment}{// ----- sizes}
603         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
604         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
605         \textcolor{comment}{// ----- indices}
606         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
607              index;                                               \textcolor{comment}{// current index for first half block}
608         \textcolor{comment}{// ----- measured probability}
609         \textcolor{keywordtype}{double}   renorm;                                    \textcolor{comment}{// probability (returned) value}
610         \textcolor{comment}{// ----- temp variables}
611         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
612         \textcolor{comment}{// (good for shared memory parallelism)}
613         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
614 
615         \textcolor{comment}{// ---------------------------------------------------------------- //}
616         \textcolor{comment}{//            tests                                                 //}
617         \textcolor{comment}{// ---------------------------------------------------------------- //}
618         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
619 
620         \textcolor{comment}{// ---------------------------------------------------------------- //}
621         \textcolor{comment}{//            dimensions                                            //}
622         \textcolor{comment}{// ---------------------------------------------------------------- //}
623         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
624         \textcolor{comment}{// and then the number to skip}
625         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
626 
627         \textcolor{comment}{// ---------------------------------------------------------------- //}
628         \textcolor{comment}{//            find probability                                      //}
629         \textcolor{comment}{// ---------------------------------------------------------------- //}
630 
631         \textcolor{comment}{//}
632         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
633         \textcolor{comment}{//}
634         renorm=1/sqrt(totalProbability);
635         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
636         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
637 
638 
639 \textcolor{preprocessor}{# ifdef \_OPENMP}
640 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
641 \textcolor{preprocessor}{        default (none) \(\backslash\)}
642 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,renorm) \(\backslash\)}
643 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index)}
644 \textcolor{preprocessor}{# endif}
645         \{
646 \textcolor{preprocessor}{# ifdef \_OPENMP}
647 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
648 \textcolor{preprocessor}{# endif}
649                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
650                         thisBlock = thisTask / sizeHalfBlock;
651                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
652                         stateVecReal[index]=stateVecReal[index]*renorm;
653                         stateVecImag[index]=stateVecImag[index]*renorm;
654 
655                         stateVecReal[index+sizeHalfBlock]=0;
656                         stateVecImag[index+sizeHalfBlock]=0;
657                 \}
658         \}
659 
660         \textcolor{comment}{//SCB this is a debugging style check. It is probably useful to leave in, but it could be
       parallelised I guess}
661         \textcolor{comment}{//  double checkTotal=1.;}
662         \textcolor{comment}{//  for (index=0; index<2*numTasks; index++) \{}
663         \textcolor{comment}{//      checkTotal=checkTotal-(stateVecReal[index]*stateVecReal[index] +
       stateVecImag[index]*stateVecImag[index]);}
664         \textcolor{comment}{//  \}}
665         \textcolor{comment}{//  if (checkTotal>0.00001)\{printf("Deviation of sum squared amps from unity is
       %.16f\(\backslash\)n",checkTotal); exit(1);\}}
666 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits_8c_a9a91a155770436fcf14487cd1a45585d}\label{qubits_8c_a9a91a155770436fcf14487cd1a45585d}} 
\index{qubits.\+c@{qubits.\+c}!prob\+Of\+Filter\+Out111\+Local@{prob\+Of\+Filter\+Out111\+Local}}
\index{prob\+Of\+Filter\+Out111\+Local@{prob\+Of\+Filter\+Out111\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{prob\+Of\+Filter\+Out111\+Local()}{probOfFilterOut111Local()}}
{\footnotesize\ttfamily double prob\+Of\+Filter\+Out111\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{id\+Qubit1,  }\item[{const int}]{id\+Qubit2,  }\item[{const int}]{id\+Qubit3 }\end{DoxyParamCaption})}



Evaluates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. 

The function returns the probability of this outcome across all amplitudes in this chunk (if zero, it will exit with error) 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3} & specified qubits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Total probability that the 3 qubits are not all in the 1 state. 
\end{DoxyReturn}


Definition at line 838 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by prob\+Of\+Filter\+Out111().


\begin{DoxyCode}
839 \{
840         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
841         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
842         \textcolor{keywordtype}{int} bit1, bit2, bit3;
843 
844         \textcolor{comment}{// ---------------------------------------------------------------- //}
845         \textcolor{comment}{//            tests                                                 //}
846         \textcolor{comment}{// ---------------------------------------------------------------- //}
847         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} && idQubit2 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
848 
849         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
850         \textcolor{keywordtype}{double} probOfFilter=0;
851         
852         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
853         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
854 
855 \textcolor{preprocessor}{# ifdef \_OPENMP}
856 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
857 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
858 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag) \(\backslash\)}
859 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3)                \(\backslash\)}
860 \textcolor{preprocessor}{        reduction ( +:probOfFilter )}
861 \textcolor{preprocessor}{# endif}
862         \{
863 \textcolor{preprocessor}{# ifdef \_OPENMP}
864 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
865 \textcolor{preprocessor}{# endif}
866                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
867                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
868                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
869                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index);
870                         \textcolor{keywordflow}{if} (!(bit1 && bit2 && bit3)) \{
871                                 probOfFilter+= stateVecReal[index]*stateVecReal[index] + stateVecImag[index
      ]* stateVecImag [index];
872                         \}
873                 \}
874         \}
875         \textcolor{keywordflow}{return} probOfFilter;
876 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits_8c_aca7765bd500718f98700a172351748cc}\label{qubits_8c_aca7765bd500718f98700a172351748cc}} 
\index{qubits.\+c@{qubits.\+c}!quad\+C\+Phase\+Gate@{quad\+C\+Phase\+Gate}}
\index{quad\+C\+Phase\+Gate@{quad\+C\+Phase\+Gate}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{quad\+C\+Phase\+Gate()}{quadCPhaseGate()}}
{\footnotesize\ttfamily void quad\+C\+Phase\+Gate (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{id\+Qubit1,  }\item[{const int}]{id\+Qubit2,  }\item[{const int}]{id\+Qubit3,  }\item[{const int}]{id\+Qubit4 }\end{DoxyParamCaption})}



The control phase (the four qubit phase gate). 

For each state, if all four input qubits are equal to zero, multiply the amplitude of that state by -\/1. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3,id\+Qubit4} & specified qubits \\
\hline
\end{DoxyParams}


Definition at line 549 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by main().


\begin{DoxyCode}
551 \{
552         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
553         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
554         \textcolor{keywordtype}{int} bit1, bit2, bit3, bit4;
555 
556         \textcolor{comment}{// ---------------------------------------------------------------- //}
557         \textcolor{comment}{//            tests                                                 //}
558         \textcolor{comment}{// ---------------------------------------------------------------- //}
559         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} && idQubit2 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
560 
561         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
562         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
563         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
564 
565 \textcolor{preprocessor}{# ifdef \_OPENMP}
566 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
567 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
568 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag ) \(\backslash\)}
569 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3,bit4)}
570 \textcolor{preprocessor}{# endif}
571         \{
572 \textcolor{preprocessor}{# ifdef \_OPENMP}
573 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
574 \textcolor{preprocessor}{# endif}
575                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
576                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
577                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
578                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index);
579                         bit4 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit4, index);
580                         \textcolor{keywordflow}{if} (bit1 && bit2 && bit3 && bit4) \{
581                                 stateVecReal [index] = - stateVecReal [index];
582                                 stateVecImag [index] = - stateVecImag [index];
583                         \}
584                 \}
585         \}
586 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}\label{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}} 
\index{qubits.\+c@{qubits.\+c}!report\+Multi\+Qubit\+Params@{report\+Multi\+Qubit\+Params}}
\index{report\+Multi\+Qubit\+Params@{report\+Multi\+Qubit\+Params}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{report\+Multi\+Qubit\+Params()}{reportMultiQubitParams()}}
{\footnotesize\ttfamily void report\+Multi\+Qubit\+Params (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit }\end{DoxyParamCaption})}



Report metainformation about a set of qubits\+: number of qubits, number of probability amplitudes. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em env} & object representing the execution environment (local, multinode etc) \\
\hline
\end{DoxyParams}


Definition at line 107 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Multi\+Qubit\+::num\+Chunks, and Multi\+Qubit\+::num\+Qubits.



Referenced by main().


\begin{DoxyCode}
107                                                   \{
108         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numAmps = 1L << multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits};
109         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numAmpsPerRank = numAmps/multiQubit.\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks};
110         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}==0)\{
111                 printf(\textcolor{stringliteral}{"QUBITS:\(\backslash\)n"});
112                 printf(\textcolor{stringliteral}{"Number of qubits is %d.\(\backslash\)n"}, multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
113                 printf(\textcolor{stringliteral}{"Number of amps is %lld.\(\backslash\)n"}, numAmps);
114                 printf(\textcolor{stringliteral}{"Number of amps per rank is %lld.\(\backslash\)n"}, numAmpsPerRank);
115         \}
116 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}\label{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}} 
\index{qubits.\+c@{qubits.\+c}!report\+State@{report\+State}}
\index{report\+State@{report\+State}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{report\+State()}{reportState()}}
{\footnotesize\ttfamily void report\+State (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit }\end{DoxyParamCaption})}



Print the current state vector of probability amplitudes for a set of qubits to file. 

File format\+: \begin{DoxyVerb}real, imag
realComponent1, imagComponent1
realComponent2, imagComponent2
...
realComponentN, imagComponentN
\end{DoxyVerb}


File naming convention\+:

For each node that the program runs on, a file \textquotesingle{}state\+\_\+rank\+\_\+\mbox{[}node\+\_\+rank\mbox{]}.csv\textquotesingle{} is generated. If there is more than one node, ranks after the first do not include the header \begin{DoxyVerb}real, imag
\end{DoxyVerb}
 so that files are easier to combine. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\end{DoxyParams}


Definition at line 89 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by main().


\begin{DoxyCode}
89                                        \{
90         FILE *state;
91         \textcolor{keywordtype}{char} filename[100];
92         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
93         sprintf(filename, \textcolor{stringliteral}{"state\_rank\_%d.csv"}, multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId});
94         state = fopen(filename, \textcolor{stringliteral}{"w"});
95         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}==0) fprintf(state, \textcolor{stringliteral}{"real, imag\(\backslash\)n"});
96 
97         \textcolor{keywordflow}{for}(index=0; index<multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}; index++)\{
98                 fprintf(state, \textcolor{stringliteral}{"%.12f, %.12f\(\backslash\)n"}, multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.
      \hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}[index], multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag}[index]);
99         \}
100         fclose(state);
101 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits_8c_a6ff67d25363f39fd57a4e76621a4bfd5}\label{qubits_8c_a6ff67d25363f39fd57a4e76621a4bfd5}} 
\index{qubits.\+c@{qubits.\+c}!rotate\+Qubit\+Distributed@{rotate\+Qubit\+Distributed}}
\index{rotate\+Qubit\+Distributed@{rotate\+Qubit\+Distributed}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{rotate\+Qubit\+Distributed()}{rotateQubitDistributed()}}
{\footnotesize\ttfamily void rotate\+Qubit\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{\hyperlink{structComplex}{Complex}}]{rot1,  }\item[{\hyperlink{structComplex}{Complex}}]{rot2,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Up,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Lo,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Out }\end{DoxyParamCaption})}



Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 271 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Complex\+::real.



Referenced by rotate\+Qubit().


\begin{DoxyCode}
276 \{
277         \textcolor{comment}{// ----- temp variables}
278         \textcolor{keywordtype}{double}   stateRealUp,stateRealLo,                             \textcolor{comment}{// storage for previous state values}
279         stateImagUp,stateImagLo;                             \textcolor{comment}{// (used in updates)}
280         \textcolor{comment}{// ----- temp variables}
281         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
282         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
283 
284         \textcolor{comment}{// (good for shared memory parallelism)}
285 
286         \textcolor{comment}{// ---------------------------------------------------------------- //}
287         \textcolor{comment}{//            tests                                                 //}
288         \textcolor{comment}{// ---------------------------------------------------------------- //}
289         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
290 
291         \textcolor{comment}{// ---------------------------------------------------------------- //}
292         \textcolor{comment}{//            rotate                                                //}
293         \textcolor{comment}{// ---------------------------------------------------------------- //}
294 
295         \textcolor{comment}{//}
296         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
297         \textcolor{comment}{//}
298         \textcolor{keywordtype}{double} rot1Real=rot1.\hyperlink{structComplex_a0138f5fe2b2c6180b8fcda77a7aa51c5}{real}, rot1Imag=rot1.\hyperlink{structComplex_a2bb90cc563599c3c8bdec9acf9ea40a6}{imag};
299         \textcolor{keywordtype}{double} rot2Real=rot2.\hyperlink{structComplex_a0138f5fe2b2c6180b8fcda77a7aa51c5}{real}, rot2Imag=rot2.\hyperlink{structComplex_a2bb90cc563599c3c8bdec9acf9ea40a6}{imag};
300         \textcolor{keywordtype}{double} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
301         \textcolor{keywordtype}{double} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
302         \textcolor{keywordtype}{double} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
303 
304 \textcolor{preprocessor}{# ifdef \_OPENMP}
305 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
306 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
307 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
308 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag) \(\backslash\)}
309 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
310 \textcolor{preprocessor}{# endif}
311         \{
312 \textcolor{preprocessor}{# ifdef \_OPENMP}
313 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
314 \textcolor{preprocessor}{# endif}
315                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
316                         \textcolor{comment}{// store current state vector values in temp variables}
317                         stateRealUp = stateVecRealUp[thisTask];
318                         stateImagUp = stateVecImagUp[thisTask];
319 
320                         stateRealLo = stateVecRealLo[thisTask];
321                         stateImagLo = stateVecImagLo[thisTask];
322 
323                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
324                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp + rot2Real*
      stateRealLo + rot2Imag*stateImagLo;
325                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp + rot2Real*
      stateImagLo - rot2Imag*stateRealLo;
326                 \} \textcolor{comment}{// end for loop}
327         \}
328 \} \textcolor{comment}{// end of function definition}
\end{DoxyCode}
\mbox{\Hypertarget{qubits_8c_acb059cbcb8c7910a5fc43d21da4f5dea}\label{qubits_8c_acb059cbcb8c7910a5fc43d21da4f5dea}} 
\index{qubits.\+c@{qubits.\+c}!rotate\+Qubit\+Local@{rotate\+Qubit\+Local}}
\index{rotate\+Qubit\+Local@{rotate\+Qubit\+Local}!qubits.\+c@{qubits.\+c}}
\paragraph{\texorpdfstring{rotate\+Qubit\+Local()}{rotateQubitLocal()}}
{\footnotesize\ttfamily void rotate\+Qubit\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{\hyperlink{structComplex}{Complex}}]{alpha,  }\item[{\hyperlink{structComplex}{Complex}}]{beta }\end{DoxyParamCaption})}



Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. 

alpha\+Re = cos(angle1) $\ast$ cos(angle2) ~\newline
alpha\+Im = cos(angle1) $\ast$ sin(angle2) ~\newline
 beta\+Re = sin(angle1) $\ast$ cos(angle3) ~\newline
 beta\+Im = sin(angle1) $\ast$ sin(angle3) ~\newline


\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em alpha} & rotation angle \\
\hline
\mbox{\tt in}  & {\em beta} & rotation angle \\
\hline
\end{DoxyParams}


Definition at line 174 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, Complex\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by rotate\+Qubit().


\begin{DoxyCode}
175 \{
176         \textcolor{comment}{// ----- sizes}
177         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
178         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
179         \textcolor{comment}{// ----- indices}
180         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
181              indexUp,indexLo;                                     \textcolor{comment}{// current index and corresponding index
       in lower half block}
182 
183         \textcolor{comment}{// ----- temp variables}
184         \textcolor{keywordtype}{double}   stateRealUp,stateRealLo,                             \textcolor{comment}{// storage for previous state values}
185                  stateImagUp,stateImagLo;                             \textcolor{comment}{// (used in updates)}
186         \textcolor{comment}{// ----- temp variables}
187         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
188         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
189         \textcolor{comment}{// (good for shared memory parallelism)}
190 
191 
192         \textcolor{comment}{// ---------------------------------------------------------------- //}
193         \textcolor{comment}{//            tests                                                 //}
194         \textcolor{comment}{// ---------------------------------------------------------------- //}
195         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
196 
197 
198         \textcolor{comment}{// ---------------------------------------------------------------- //}
199         \textcolor{comment}{//            dimensions                                            //}
200         \textcolor{comment}{// ---------------------------------------------------------------- //}
201         sizeHalfBlock = 1LL << rotQubit;                               \textcolor{comment}{// size of blocks halved}
202         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks}
203 
204 
205         \textcolor{comment}{// ---------------------------------------------------------------- //}
206         \textcolor{comment}{//            rotate                                                //}
207         \textcolor{comment}{// ---------------------------------------------------------------- //}
208 
209         \textcolor{comment}{//}
210         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
211         \textcolor{comment}{//}
212         
213         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
214         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
215         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
216         \textcolor{keywordtype}{double} alphaImag=alpha.\hyperlink{structComplex_a2bb90cc563599c3c8bdec9acf9ea40a6}{imag}, alphaReal=alpha.\hyperlink{structComplex_a0138f5fe2b2c6180b8fcda77a7aa51c5}{real};
217         \textcolor{keywordtype}{double} betaImag=beta.\hyperlink{structComplex_a2bb90cc563599c3c8bdec9acf9ea40a6}{imag}, betaReal=beta.\hyperlink{structComplex_a0138f5fe2b2c6180b8fcda77a7aa51c5}{real};
218 
219 \textcolor{preprocessor}{# ifdef \_OPENMP}
220 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
221 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
222 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,alphaImag,
       betaReal,betaImag) \(\backslash\)}
223 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
224 \textcolor{preprocessor}{# endif}
225         \{
226 \textcolor{preprocessor}{# ifdef \_OPENMP}
227 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
228 \textcolor{preprocessor}{# endif}
229                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
230 
231                         thisBlock   = thisTask / sizeHalfBlock;
232                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
233                         indexLo     = indexUp + sizeHalfBlock;
234 
235                         \textcolor{comment}{// store current state vector values in temp variables}
236                         stateRealUp = stateVecReal[indexUp];
237                         stateImagUp = stateVecImag[indexUp];
238 
239                         stateRealLo = stateVecReal[indexLo];
240                         stateImagLo = stateVecImag[indexLo];
241 
242                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
243                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag*stateImagUp - betaReal*
      stateRealLo - betaImag*stateImagLo;
244                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag*stateRealUp - betaReal*
      stateImagLo + betaImag*stateRealLo;
245 
246                         \textcolor{comment}{// state[indexLo] = beta  * state[indexUp] + conj(alpha) * state[indexLo]}
247                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*stateImagUp + alphaReal*
      stateRealLo + alphaImag*stateImagLo;
248                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*stateRealUp + alphaReal*
      stateImagLo - alphaImag*stateRealLo;
249                 \} \textcolor{comment}{// end for loop}
250         \}
251 
252 \} \textcolor{comment}{// end of function definition}
\end{DoxyCode}
