\hypertarget{qubits__internal_8h}{}\subsection{qubits\+\_\+internal.\+h File Reference}
\label{qubits__internal_8h}\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}


Internal functions used to implement the public facing A\+PI in \hyperlink{qubits_8h}{qubits.\+h}.  


\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}{rotate\+Qubit\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}{rotate\+Qubit\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
double \hyperlink{qubits__internal_8h_a1c0a25823add0bd9f925a9164dc21870}{find\+Probability\+Of\+Zero\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \end{DoxyCompactList}\item 
double \hyperlink{qubits__internal_8h_a2d302738d123129a388edf81b845fd89}{find\+Probability\+Of\+Zero\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_af77bdfeac8c0f5311e46fb523cbade7e}{measure\+In\+Zero\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, int measure\+Qubit, double total\+Probability)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measure\+Qubit=0. \end{DoxyCompactList}\item 
double \hyperlink{qubits__internal_8h_a7ca30c5cfa104241549514f607371859}{measure\+In\+Zero\+Distributed\+Renorm} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit, const double total\+Probability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measure\+Qubit=0, based on the total probability of that qubit being in state 0. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a5b6e47e9a9b9324c9412b13d1e4a4f9b}{measure\+In\+Zero\+Distributed\+Set\+Zero} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Set parts of the state vector where measure\+Qubit=1 to have amplitude 0. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a035d5fa11bf9c4d7d4aea56fd3ba1153}{filter\+Out111\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3, const double prob\+Of\+Filter)
\begin{DoxyCompactList}\small\item\em Updates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \end{DoxyCompactList}\item 
double \hyperlink{qubits__internal_8h_a9a91a155770436fcf14487cd1a45585d}{prob\+Of\+Filter\+Out111\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3)
\begin{DoxyCompactList}\small\item\em Evaluates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
Internal functions used to implement the public facing A\+PI in \hyperlink{qubits_8h}{qubits.\+h}. 

Do not call these functions directly. In general, \hyperlink{qubits__env__local_8c}{qubits\+\_\+env\+\_\+local.\+c} and \hyperlink{qubits__env__mpi_8c}{qubits\+\_\+env\+\_\+mpi.\+c} will implement the public A\+PI by choosing the correct function or combination of functions to use from those included here. 

\subsubsection{Function Documentation}
\mbox{\Hypertarget{qubits__internal_8h_a035d5fa11bf9c4d7d4aea56fd3ba1153}\label{qubits__internal_8h_a035d5fa11bf9c4d7d4aea56fd3ba1153}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!filter\+Out111\+Local@{filter\+Out111\+Local}}
\index{filter\+Out111\+Local@{filter\+Out111\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{filter\+Out111\+Local()}{filterOut111Local()}}
{\footnotesize\ttfamily void filter\+Out111\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{id\+Qubit1,  }\item[{const int}]{id\+Qubit2,  }\item[{const int}]{id\+Qubit3,  }\item[{const double}]{prob\+Of\+Filter }\end{DoxyParamCaption})}



Updates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3} & specified qubits \\
\hline
\mbox{\tt in}  & {\em prob\+Of\+Filter} & Total probability that the 3 qubits are not all in the 1 state. \\
\hline
\end{DoxyParams}


Definition at line 788 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by filter\+Out111().


\begin{DoxyCode}
790 \{
791         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
792         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
793         \textcolor{keywordtype}{int} bit1, bit2, bit3;
794 
795         \textcolor{comment}{// ---------------------------------------------------------------- //}
796         \textcolor{comment}{//            tests                                                 //}
797         \textcolor{comment}{// ---------------------------------------------------------------- //}
798         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} && idQubit2 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
799 
800         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
801 
802         \textcolor{keywordflow}{if} ( probOfFilter<1e-16 )\{ printf(\textcolor{stringliteral}{"Extremely small or negative profOfFilter=%.8e; aborting! \(\backslash\)n"},
      probOfFilter); exit(1);\}
803         \textcolor{keywordtype}{double} myNorm=1/sqrt(probOfFilter);
804         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
805         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
806 
807 \textcolor{preprocessor}{# ifdef \_OPENMP}
808 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
809 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
810 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag, myNorm) \(\backslash\)}
811 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3)                }
812 \textcolor{preprocessor}{# endif }
813         \{
814 \textcolor{preprocessor}{# ifdef \_OPENMP}
815 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
816 \textcolor{preprocessor}{# endif}
817                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
818                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
819                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
820                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index);
821                         \textcolor{keywordflow}{if} ((bit1 && bit2 && bit3)) \{
822                                 stateVecReal[index]=0;
823                                 stateVecImag [index]=0;
824                         \}\textcolor{keywordflow}{else}\{
825                                 stateVecReal[index] *= myNorm;
826                                 stateVecImag[index] *= myNorm;
827                         \}
828                 \}
829         \}
830 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a2d302738d123129a388edf81b845fd89}\label{qubits__internal_8h_a2d302738d123129a388edf81b845fd89}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}}
\index{find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{find\+Probability\+Of\+Zero\+Distributed()}{findProbabilityOfZeroDistributed()}}
{\footnotesize\ttfamily double find\+Probability\+Of\+Zero\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit }\end{DoxyParamCaption})}



Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. 

Size of regions to skip is a multiple of chunk\+Size.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 427 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Zero().


\begin{DoxyCode}
429 \{
430         \textcolor{comment}{// ----- measured probability}
431         \textcolor{keywordtype}{double}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
432         \textcolor{comment}{// ----- temp variables}
433         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
434         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
435         \textcolor{comment}{// (good for shared memory parallelism)}
436 
437         \textcolor{comment}{// ---------------------------------------------------------------- //}
438         \textcolor{comment}{//            tests                                                 //}
439         \textcolor{comment}{// ---------------------------------------------------------------- //}
440         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
441 
442         \textcolor{comment}{// ---------------------------------------------------------------- //}
443         \textcolor{comment}{//            find probability                                      //}
444         \textcolor{comment}{// ---------------------------------------------------------------- //}
445 
446         \textcolor{comment}{// initialise returned value}
447         totalProbability = 0.0;
448 
449         \textcolor{comment}{// initialise correction for kahan summation}
450 
451         \textcolor{comment}{//}
452         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
453         \textcolor{comment}{//}
454         
455         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
456         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
457 
458 \textcolor{preprocessor}{# ifdef \_OPENMP}
459 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
460 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
461 \textcolor{preprocessor}{        private   (thisTask) \(\backslash\)}
462 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
463 \textcolor{preprocessor}{# endif}
464         \{
465 \textcolor{preprocessor}{# ifdef \_OPENMP}
466 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
467 \textcolor{preprocessor}{# endif}
468                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
469                         \textcolor{comment}{// summation -- simple implementation}
470                         totalProbability += stateVecReal[thisTask]*stateVecReal[thisTask]
471                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
472 
473                         \textcolor{comment}{/*}
474 \textcolor{comment}{                        // summation -- kahan correction}
475 \textcolor{comment}{                        y = stateVecReal[thisTask]*stateVecReal[thisTask]}
476 \textcolor{comment}{                        + stateVecImag[thisTask]*stateVecImag[thisTask] - c;}
477 \textcolor{comment}{                        t = totalProbability + y;}
478 \textcolor{comment}{                        c = (t - totalProbability) - y;}
479 \textcolor{comment}{                        totalProbability = t;}
480 \textcolor{comment}{                        */}
481 
482                 \}
483         \}
484 
485         \textcolor{keywordflow}{return} totalProbability;
486 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a1c0a25823add0bd9f925a9164dc21870}\label{qubits__internal_8h_a1c0a25823add0bd9f925a9164dc21870}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}}
\index{find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{find\+Probability\+Of\+Zero\+Local()}{findProbabilityOfZeroLocal()}}
{\footnotesize\ttfamily double find\+Probability\+Of\+Zero\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit }\end{DoxyParamCaption})}



Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. 

Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 339 of file qubits.\+c.



References D\+E\+B\+UG, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Zero().


\begin{DoxyCode}
341 \{
342         \textcolor{comment}{// ----- sizes}
343         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
344         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
345         \textcolor{comment}{// ----- indices}
346         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
347              index;                                               \textcolor{comment}{// current index for first half block}
348         \textcolor{comment}{// ----- measured probability}
349         \textcolor{keywordtype}{double}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
350         \textcolor{comment}{// ----- temp variables}
351         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
352         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
353         \textcolor{comment}{// (good for shared memory parallelism)}
354 
355         \textcolor{comment}{// ---------------------------------------------------------------- //}
356         \textcolor{comment}{//            tests                                                 //}
357         \textcolor{comment}{// ---------------------------------------------------------------- //}
358         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
359 
360 
361         \textcolor{comment}{// ---------------------------------------------------------------- //}
362         \textcolor{comment}{//            dimensions                                            //}
363         \textcolor{comment}{// ---------------------------------------------------------------- //}
364         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
365         \textcolor{comment}{// and then the number to skip}
366         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
367 
368         \textcolor{comment}{// ---------------------------------------------------------------- //}
369         \textcolor{comment}{//            find probability                                      //}
370         \textcolor{comment}{// ---------------------------------------------------------------- //}
371 
372         \textcolor{comment}{// initialise returned value}
373         totalProbability = 0.0;
374 
375         \textcolor{comment}{// initialise correction for kahan summation}
376         \textcolor{keywordflow}{if} (\hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\(\backslash\)n"},sizeHalfBlock,sizeBlock,
      numTasks);
377 
378         \textcolor{comment}{//}
379         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
380         \textcolor{comment}{//}
381         
382         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
383         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
384 
385 \textcolor{preprocessor}{# ifdef \_OPENMP}
386 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
387 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
388 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index) \(\backslash\)}
389 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
390 \textcolor{preprocessor}{# endif }
391         \{
392 \textcolor{preprocessor}{# ifdef \_OPENMP}
393 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
394 \textcolor{preprocessor}{# endif}
395                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
396                         thisBlock = thisTask / sizeHalfBlock;
397                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
398 
399                         \textcolor{keywordflow}{if} (index<0)\{ printf(\textcolor{stringliteral}{"ABORTING as index=%Ld with thisBlock = %Ld  thisTask=%Ld \(\backslash\)n"},
       index,thisBlock,thisTask); exit(1);\}
400 
401                         \textcolor{comment}{// summation -- simple implementation}
402                         totalProbability += stateVecReal[index]*stateVecReal[index]
403                                 + stateVecImag[index]*stateVecImag[index];
404 
405                         \textcolor{comment}{/*}
406 \textcolor{comment}{                        // summation -- kahan correction}
407 \textcolor{comment}{                        y = stateVecReal[index]*stateVecReal[index]}
408 \textcolor{comment}{                        + stateVecImag[index]*stateVecImag[index] - c;}
409 \textcolor{comment}{                        t = totalProbability + y;}
410 \textcolor{comment}{                        c = (t - totalProbability) - y;}
411 \textcolor{comment}{                        totalProbability = t;}
412 \textcolor{comment}{                        */}
413 
414                 \}
415         \}
416         \textcolor{keywordflow}{return} totalProbability;
417 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a7ca30c5cfa104241549514f607371859}\label{qubits__internal_8h_a7ca30c5cfa104241549514f607371859}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!measure\+In\+Zero\+Distributed\+Renorm@{measure\+In\+Zero\+Distributed\+Renorm}}
\index{measure\+In\+Zero\+Distributed\+Renorm@{measure\+In\+Zero\+Distributed\+Renorm}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{measure\+In\+Zero\+Distributed\+Renorm()}{measureInZeroDistributedRenorm()}}
{\footnotesize\ttfamily double measure\+In\+Zero\+Distributed\+Renorm (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit,  }\item[{const double}]{total\+Probability }\end{DoxyParamCaption})}



Renormalise parts of the state vector where measure\+Qubit=0, based on the total probability of that qubit being in state 0. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that a zero have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0. In the distributed version, one block (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em total\+Probability} & probability of qubit measure\+Qubit being zero \\
\hline
\end{DoxyParams}


Definition at line 683 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+Zero().


\begin{DoxyCode}
684 \{
685         \textcolor{comment}{// ----- temp variables}
686         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
687         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
688         \textcolor{comment}{// (good for shared memory parallelism)}
689 
690         \textcolor{comment}{// ---------------------------------------------------------------- //}
691         \textcolor{comment}{//            tests                                                 //}
692         \textcolor{comment}{// ---------------------------------------------------------------- //}
693         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
694 
695         \textcolor{comment}{// ---------------------------------------------------------------- //}
696         \textcolor{comment}{//            find probability                                      //}
697         \textcolor{comment}{// ---------------------------------------------------------------- //}
698 
699         \textcolor{comment}{// initialise correction for kahan summation}
700 
701         \textcolor{comment}{//}
702         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
703         \textcolor{comment}{//}
704         
705         \textcolor{keywordtype}{double} renorm=1/sqrt(totalProbability);
706         
707         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
708         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
709 
710 \textcolor{preprocessor}{# ifdef \_OPENMP}
711 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
712 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
713 \textcolor{preprocessor}{        private   (thisTask)}
714 \textcolor{preprocessor}{# endif}
715         \{
716 \textcolor{preprocessor}{# ifdef \_OPENMP}
717 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
718 \textcolor{preprocessor}{# endif}
719                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
720                         \textcolor{comment}{// summation -- simple implementation}
721                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
722                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
723                 \}
724         \}
725         \textcolor{keywordflow}{return} totalProbability;
726 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a5b6e47e9a9b9324c9412b13d1e4a4f9b}\label{qubits__internal_8h_a5b6e47e9a9b9324c9412b13d1e4a4f9b}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!measure\+In\+Zero\+Distributed\+Set\+Zero@{measure\+In\+Zero\+Distributed\+Set\+Zero}}
\index{measure\+In\+Zero\+Distributed\+Set\+Zero@{measure\+In\+Zero\+Distributed\+Set\+Zero}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{measure\+In\+Zero\+Distributed\+Set\+Zero()}{measureInZeroDistributedSetZero()}}
{\footnotesize\ttfamily void measure\+In\+Zero\+Distributed\+Set\+Zero (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit }\end{DoxyParamCaption})}



Set parts of the state vector where measure\+Qubit=1 to have amplitude 0. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that a zero have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0. In the distributed version, one block (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}


Definition at line 741 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+Zero().


\begin{DoxyCode}
742 \{
743         \textcolor{comment}{// ----- temp variables}
744         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
745         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
746         \textcolor{comment}{// (good for shared memory parallelism)}
747 
748         \textcolor{comment}{// ---------------------------------------------------------------- //}
749         \textcolor{comment}{//            tests                                                 //}
750         \textcolor{comment}{// ---------------------------------------------------------------- //}
751         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
752 
753         \textcolor{comment}{// ---------------------------------------------------------------- //}
754         \textcolor{comment}{//            find probability                                      //}
755         \textcolor{comment}{// ---------------------------------------------------------------- //}
756 
757         \textcolor{comment}{// initialise correction for kahan summation}
758 
759         \textcolor{comment}{//}
760         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
761         \textcolor{comment}{//}
762         
763         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
764         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
765 
766 \textcolor{preprocessor}{# ifdef \_OPENMP}
767 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
768 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
769 \textcolor{preprocessor}{        private   (thisTask)}
770 \textcolor{preprocessor}{# endif}
771         \{
772 \textcolor{preprocessor}{# ifdef \_OPENMP}
773 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
774 \textcolor{preprocessor}{# endif}
775                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
776                         \textcolor{comment}{// summation -- simple implementation}
777                         stateVecReal[thisTask] = 0;
778                         stateVecImag[thisTask] = 0;
779                 \}
780         \}
781 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_af77bdfeac8c0f5311e46fb523cbade7e}\label{qubits__internal_8h_af77bdfeac8c0f5311e46fb523cbade7e}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!measure\+In\+Zero\+Local@{measure\+In\+Zero\+Local}}
\index{measure\+In\+Zero\+Local@{measure\+In\+Zero\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{measure\+In\+Zero\+Local()}{measureInZeroLocal()}}
{\footnotesize\ttfamily void measure\+In\+Zero\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{int}]{measure\+Qubit,  }\item[{double}]{total\+Probability }\end{DoxyParamCaption})}



Update the state vector to be consistent with measuring measure\+Qubit=0. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that a zero have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0. In the local version, one or more blocks (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em total\+Probability} & probability of qubit measure\+Qubit being zero \\
\hline
\end{DoxyParams}


Definition at line 600 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+Zero().


\begin{DoxyCode}
601 \{
602         \textcolor{comment}{// ----- sizes}
603         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
604         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
605         \textcolor{comment}{// ----- indices}
606         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
607              index;                                               \textcolor{comment}{// current index for first half block}
608         \textcolor{comment}{// ----- measured probability}
609         \textcolor{keywordtype}{double}   renorm;                                    \textcolor{comment}{// probability (returned) value}
610         \textcolor{comment}{// ----- temp variables}
611         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
612         \textcolor{comment}{// (good for shared memory parallelism)}
613         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
614 
615         \textcolor{comment}{// ---------------------------------------------------------------- //}
616         \textcolor{comment}{//            tests                                                 //}
617         \textcolor{comment}{// ---------------------------------------------------------------- //}
618         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
619 
620         \textcolor{comment}{// ---------------------------------------------------------------- //}
621         \textcolor{comment}{//            dimensions                                            //}
622         \textcolor{comment}{// ---------------------------------------------------------------- //}
623         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
624         \textcolor{comment}{// and then the number to skip}
625         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
626 
627         \textcolor{comment}{// ---------------------------------------------------------------- //}
628         \textcolor{comment}{//            find probability                                      //}
629         \textcolor{comment}{// ---------------------------------------------------------------- //}
630 
631         \textcolor{comment}{//}
632         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
633         \textcolor{comment}{//}
634         renorm=1/sqrt(totalProbability);
635         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
636         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
637 
638 
639 \textcolor{preprocessor}{# ifdef \_OPENMP}
640 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
641 \textcolor{preprocessor}{        default (none) \(\backslash\)}
642 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,renorm) \(\backslash\)}
643 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index)}
644 \textcolor{preprocessor}{# endif}
645         \{
646 \textcolor{preprocessor}{# ifdef \_OPENMP}
647 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
648 \textcolor{preprocessor}{# endif}
649                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
650                         thisBlock = thisTask / sizeHalfBlock;
651                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
652                         stateVecReal[index]=stateVecReal[index]*renorm;
653                         stateVecImag[index]=stateVecImag[index]*renorm;
654 
655                         stateVecReal[index+sizeHalfBlock]=0;
656                         stateVecImag[index+sizeHalfBlock]=0;
657                 \}
658         \}
659 
660         \textcolor{comment}{//SCB this is a debugging style check. It is probably useful to leave in, but it could be
       parallelised I guess}
661         \textcolor{comment}{//  double checkTotal=1.;}
662         \textcolor{comment}{//  for (index=0; index<2*numTasks; index++) \{}
663         \textcolor{comment}{//      checkTotal=checkTotal-(stateVecReal[index]*stateVecReal[index] +
       stateVecImag[index]*stateVecImag[index]);}
664         \textcolor{comment}{//  \}}
665         \textcolor{comment}{//  if (checkTotal>0.00001)\{printf("Deviation of sum squared amps from unity is
       %.16f\(\backslash\)n",checkTotal); exit(1);\}}
666 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a9a91a155770436fcf14487cd1a45585d}\label{qubits__internal_8h_a9a91a155770436fcf14487cd1a45585d}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!prob\+Of\+Filter\+Out111\+Local@{prob\+Of\+Filter\+Out111\+Local}}
\index{prob\+Of\+Filter\+Out111\+Local@{prob\+Of\+Filter\+Out111\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{prob\+Of\+Filter\+Out111\+Local()}{probOfFilterOut111Local()}}
{\footnotesize\ttfamily double prob\+Of\+Filter\+Out111\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{id\+Qubit1,  }\item[{const int}]{id\+Qubit2,  }\item[{const int}]{id\+Qubit3 }\end{DoxyParamCaption})}



Evaluates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. 

The function returns the probability of this outcome across all amplitudes in this chunk (if zero, it will exit with error) 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3} & specified qubits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Total probability that the 3 qubits are not all in the 1 state. 
\end{DoxyReturn}


Definition at line 838 of file qubits.\+c.



References extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by prob\+Of\+Filter\+Out111().


\begin{DoxyCode}
839 \{
840         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
841         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
842         \textcolor{keywordtype}{int} bit1, bit2, bit3;
843 
844         \textcolor{comment}{// ---------------------------------------------------------------- //}
845         \textcolor{comment}{//            tests                                                 //}
846         \textcolor{comment}{// ---------------------------------------------------------------- //}
847         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} && idQubit2 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
848 
849         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
850         \textcolor{keywordtype}{double} probOfFilter=0;
851         
852         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
853         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
854 
855 \textcolor{preprocessor}{# ifdef \_OPENMP}
856 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
857 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
858 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag) \(\backslash\)}
859 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3)                \(\backslash\)}
860 \textcolor{preprocessor}{        reduction ( +:probOfFilter )}
861 \textcolor{preprocessor}{# endif}
862         \{
863 \textcolor{preprocessor}{# ifdef \_OPENMP}
864 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
865 \textcolor{preprocessor}{# endif}
866                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
867                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index);
868                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index);
869                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index);
870                         \textcolor{keywordflow}{if} (!(bit1 && bit2 && bit3)) \{
871                                 probOfFilter+= stateVecReal[index]*stateVecReal[index] + stateVecImag[index
      ]* stateVecImag [index];
872                         \}
873                 \}
874         \}
875         \textcolor{keywordflow}{return} probOfFilter;
876 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}\label{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!rotate\+Qubit\+Distributed@{rotate\+Qubit\+Distributed}}
\index{rotate\+Qubit\+Distributed@{rotate\+Qubit\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{rotate\+Qubit\+Distributed()}{rotateQubitDistributed()}}
{\footnotesize\ttfamily void rotate\+Qubit\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{\hyperlink{structComplex}{Complex}}]{rot1,  }\item[{\hyperlink{structComplex}{Complex}}]{rot2,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Up,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Lo,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Out }\end{DoxyParamCaption})}



Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments, and a subset of the state vector with upper and lower block values stored seperately. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 271 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and Complex\+::real.



Referenced by rotate\+Qubit().


\begin{DoxyCode}
276 \{
277         \textcolor{comment}{// ----- temp variables}
278         \textcolor{keywordtype}{double}   stateRealUp,stateRealLo,                             \textcolor{comment}{// storage for previous state values}
279         stateImagUp,stateImagLo;                             \textcolor{comment}{// (used in updates)}
280         \textcolor{comment}{// ----- temp variables}
281         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
282         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
283 
284         \textcolor{comment}{// (good for shared memory parallelism)}
285 
286         \textcolor{comment}{// ---------------------------------------------------------------- //}
287         \textcolor{comment}{//            tests                                                 //}
288         \textcolor{comment}{// ---------------------------------------------------------------- //}
289         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
290 
291         \textcolor{comment}{// ---------------------------------------------------------------- //}
292         \textcolor{comment}{//            rotate                                                //}
293         \textcolor{comment}{// ---------------------------------------------------------------- //}
294 
295         \textcolor{comment}{//}
296         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
297         \textcolor{comment}{//}
298         \textcolor{keywordtype}{double} rot1Real=rot1.\hyperlink{structComplex_a0138f5fe2b2c6180b8fcda77a7aa51c5}{real}, rot1Imag=rot1.\hyperlink{structComplex_a2bb90cc563599c3c8bdec9acf9ea40a6}{imag};
299         \textcolor{keywordtype}{double} rot2Real=rot2.\hyperlink{structComplex_a0138f5fe2b2c6180b8fcda77a7aa51c5}{real}, rot2Imag=rot2.\hyperlink{structComplex_a2bb90cc563599c3c8bdec9acf9ea40a6}{imag};
300         \textcolor{keywordtype}{double} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
301         \textcolor{keywordtype}{double} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
302         \textcolor{keywordtype}{double} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
303 
304 \textcolor{preprocessor}{# ifdef \_OPENMP}
305 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
306 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
307 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
308 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag) \(\backslash\)}
309 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
310 \textcolor{preprocessor}{# endif}
311         \{
312 \textcolor{preprocessor}{# ifdef \_OPENMP}
313 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
314 \textcolor{preprocessor}{# endif}
315                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
316                         \textcolor{comment}{// store current state vector values in temp variables}
317                         stateRealUp = stateVecRealUp[thisTask];
318                         stateImagUp = stateVecImagUp[thisTask];
319 
320                         stateRealLo = stateVecRealLo[thisTask];
321                         stateImagLo = stateVecImagLo[thisTask];
322 
323                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
324                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp + rot2Real*
      stateRealLo + rot2Imag*stateImagLo;
325                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp + rot2Real*
      stateImagLo - rot2Imag*stateRealLo;
326                 \} \textcolor{comment}{// end for loop}
327         \}
328 \} \textcolor{comment}{// end of function definition}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}\label{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!rotate\+Qubit\+Local@{rotate\+Qubit\+Local}}
\index{rotate\+Qubit\+Local@{rotate\+Qubit\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{rotate\+Qubit\+Local()}{rotateQubitLocal()}}
{\footnotesize\ttfamily void rotate\+Qubit\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{\hyperlink{structComplex}{Complex}}]{alpha,  }\item[{\hyperlink{structComplex}{Complex}}]{beta }\end{DoxyParamCaption})}



Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. 

alpha\+Re = cos(angle1) $\ast$ cos(angle2) ~\newline
alpha\+Im = cos(angle1) $\ast$ sin(angle2) ~\newline
 beta\+Re = sin(angle1) $\ast$ cos(angle3) ~\newline
 beta\+Im = sin(angle1) $\ast$ sin(angle3) ~\newline


\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em alpha} & rotation angle \\
\hline
\mbox{\tt in}  & {\em beta} & rotation angle \\
\hline
\end{DoxyParams}


Definition at line 174 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, Complex\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by rotate\+Qubit().


\begin{DoxyCode}
175 \{
176         \textcolor{comment}{// ----- sizes}
177         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
178         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
179         \textcolor{comment}{// ----- indices}
180         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
181              indexUp,indexLo;                                     \textcolor{comment}{// current index and corresponding index
       in lower half block}
182 
183         \textcolor{comment}{// ----- temp variables}
184         \textcolor{keywordtype}{double}   stateRealUp,stateRealLo,                             \textcolor{comment}{// storage for previous state values}
185                  stateImagUp,stateImagLo;                             \textcolor{comment}{// (used in updates)}
186         \textcolor{comment}{// ----- temp variables}
187         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
188         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
189         \textcolor{comment}{// (good for shared memory parallelism)}
190 
191 
192         \textcolor{comment}{// ---------------------------------------------------------------- //}
193         \textcolor{comment}{//            tests                                                 //}
194         \textcolor{comment}{// ---------------------------------------------------------------- //}
195         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
196 
197 
198         \textcolor{comment}{// ---------------------------------------------------------------- //}
199         \textcolor{comment}{//            dimensions                                            //}
200         \textcolor{comment}{// ---------------------------------------------------------------- //}
201         sizeHalfBlock = 1LL << rotQubit;                               \textcolor{comment}{// size of blocks halved}
202         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks}
203 
204 
205         \textcolor{comment}{// ---------------------------------------------------------------- //}
206         \textcolor{comment}{//            rotate                                                //}
207         \textcolor{comment}{// ---------------------------------------------------------------- //}
208 
209         \textcolor{comment}{//}
210         \textcolor{comment}{// --- task-based shared-memory parallel implementation}
211         \textcolor{comment}{//}
212         
213         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
214         \textcolor{keywordtype}{double} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a1cf9fd31d6dce5ef618d2bcf3e4f8b69}{real};
215         \textcolor{keywordtype}{double} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_aa409fd14e1ff3e1fdcc53cc4eb77a7a8}{imag};
216         \textcolor{keywordtype}{double} alphaImag=alpha.\hyperlink{structComplex_a2bb90cc563599c3c8bdec9acf9ea40a6}{imag}, alphaReal=alpha.\hyperlink{structComplex_a0138f5fe2b2c6180b8fcda77a7aa51c5}{real};
217         \textcolor{keywordtype}{double} betaImag=beta.\hyperlink{structComplex_a2bb90cc563599c3c8bdec9acf9ea40a6}{imag}, betaReal=beta.\hyperlink{structComplex_a0138f5fe2b2c6180b8fcda77a7aa51c5}{real};
218 
219 \textcolor{preprocessor}{# ifdef \_OPENMP}
220 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
221 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
222 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,alphaImag,
       betaReal,betaImag) \(\backslash\)}
223 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
224 \textcolor{preprocessor}{# endif}
225         \{
226 \textcolor{preprocessor}{# ifdef \_OPENMP}
227 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
228 \textcolor{preprocessor}{# endif}
229                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
230 
231                         thisBlock   = thisTask / sizeHalfBlock;
232                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
233                         indexLo     = indexUp + sizeHalfBlock;
234 
235                         \textcolor{comment}{// store current state vector values in temp variables}
236                         stateRealUp = stateVecReal[indexUp];
237                         stateImagUp = stateVecImag[indexUp];
238 
239                         stateRealLo = stateVecReal[indexLo];
240                         stateImagLo = stateVecImag[indexLo];
241 
242                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
243                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag*stateImagUp - betaReal*
      stateRealLo - betaImag*stateImagLo;
244                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag*stateRealUp - betaReal*
      stateImagLo + betaImag*stateRealLo;
245 
246                         \textcolor{comment}{// state[indexLo] = beta  * state[indexUp] + conj(alpha) * state[indexLo]}
247                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*stateImagUp + alphaReal*
      stateRealLo + alphaImag*stateImagLo;
248                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*stateRealUp + alphaReal*
      stateImagLo - alphaImag*stateRealLo;
249                 \} \textcolor{comment}{// end for loop}
250         \}
251 
252 \} \textcolor{comment}{// end of function definition}
\end{DoxyCode}
