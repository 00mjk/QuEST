<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Distributed QuEST: qubits_internal.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>qubits_internal.h File Reference</h1>
<p>Internal functions used to implement the public facing API in <a class="el" href="qubits_8h.html" title="The QuEST library API and objects.">qubits.h</a>.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="precision_8h_source.html">precision.h</a>&quot;</code><br/>

<p><a href="qubits__internal_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#acb059cbcb8c7910a5fc43d21da4f5dea">rotateQubitLocal</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int rotQubit, <a class="el" href="structComplex.html">Complex</a> alpha, <a class="el" href="structComplex.html">Complex</a> beta)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a single qubit in the state vector of probability amplitudes.  <a href="#acb059cbcb8c7910a5fc43d21da4f5dea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#a6ff67d25363f39fd57a4e76621a4bfd5">rotateQubitDistributed</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int rotQubit, <a class="el" href="structComplex.html">Complex</a> rot1, <a class="el" href="structComplex.html">Complex</a> rot2, <a class="el" href="structComplexArray.html">ComplexArray</a> stateVecUp, <a class="el" href="structComplexArray.html">ComplexArray</a> stateVecLo, <a class="el" href="structComplexArray.html">ComplexArray</a> stateVecOut)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately.  <a href="#a6ff67d25363f39fd57a4e76621a4bfd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#a824d71bae93236d8a3cd43589044eaee">controlRotateQubitLocal</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int rotQubit, const int controlQubit, <a class="el" href="structComplex.html">Complex</a> alpha, <a class="el" href="structComplex.html">Complex</a> beta)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit.  <a href="#a824d71bae93236d8a3cd43589044eaee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#ab22d031e2507f1d859292103a99e2378">controlRotateQubitDistributed</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int rotQubit, const int controlQubit, <a class="el" href="structComplex.html">Complex</a> rot1, <a class="el" href="structComplex.html">Complex</a> rot2, <a class="el" href="structComplexArray.html">ComplexArray</a> stateVecUp, <a class="el" href="structComplexArray.html">ComplexArray</a> stateVecLo, <a class="el" href="structComplexArray.html">ComplexArray</a> stateVecOut)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately.  <a href="#ab22d031e2507f1d859292103a99e2378"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#aa9e640bb2d0458c937c6a87dfeca0f23">sigmaXLocal</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int rotQubit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a single qubit by {{0,1},{1,0}.  <a href="#aa9e640bb2d0458c937c6a87dfeca0f23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#a5958808b2f2f05937921ba7dabe5a171">sigmaXDistributed</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int rotQubit, <a class="el" href="structComplexArray.html">ComplexArray</a> stateVecIn, <a class="el" href="structComplexArray.html">ComplexArray</a> stateVecOut)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a single qubit by {{0,1},{1,0}.  <a href="#a5958808b2f2f05937921ba7dabe5a171"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#afcbb1dcbe070ad0ed1a72a23251b6a83">sigmaYLocal</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int rotQubit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a single qubit by {{0,-i},{i,0}.  <a href="#afcbb1dcbe070ad0ed1a72a23251b6a83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#a0471f6b547ce8270ef85170b7f4f0214">sigmaYDistributed</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int rotQubit, <a class="el" href="structComplexArray.html">ComplexArray</a> stateVecIn, <a class="el" href="structComplexArray.html">ComplexArray</a> stateVecOut, int updateUpper)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a single qubit by {{0,-i},{i,0}.  <a href="#a0471f6b547ce8270ef85170b7f4f0214"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#a0711416fceaf63c67b496e123e845c69">hadamardLocal</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int rotQubit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a single qubit by {{1,1},{1,-1}}/sqrt2.  <a href="#a0711416fceaf63c67b496e123e845c69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#ac835c194bd547240a35f0b028db1d658">hadamardDistributed</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int rotQubit, <a class="el" href="structComplexArray.html">ComplexArray</a> stateVecUp, <a class="el" href="structComplexArray.html">ComplexArray</a> stateVecLo, <a class="el" href="structComplexArray.html">ComplexArray</a> stateVecOut, int updateUpper)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a single qubit by {{1,1},{1,-1}}/sqrt2.  <a href="#ac835c194bd547240a35f0b028db1d658"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#a6a736aeb3532898019fe7c27010edc6a">phaseGateLocal</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int rotQubit, enum <a class="el" href="qubits_8h.html#a5739021c733cecc49647956b2f7338ea">phaseGateType</a> type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a single qubit by {{1,0},{0,p}} where p is a phase term determined by the type argument.  <a href="#a6a736aeb3532898019fe7c27010edc6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#a38a05c7e749e806b182ef3b89878bfc4">phaseGateDistributed</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int rotQubit, enum <a class="el" href="qubits_8h.html#a5739021c733cecc49647956b2f7338ea">phaseGateType</a> type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a single qubit by {{1,0},{0,p}} where p is a phase term determined by the type argument.  <a href="#a38a05c7e749e806b182ef3b89878bfc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#a2901e2e5531cb77f87ea54b3fc28f51a">controlNotLocal</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int targetQubit, const int controlQubit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a single qubit by {{0,1},{1,0} for elements where controlQubit is one.  <a href="#a2901e2e5531cb77f87ea54b3fc28f51a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#a774dd1217fcc3591a74a74d5667afa29">controlNotDistributed</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int targetQubit, const int controlQubit, <a class="el" href="structComplexArray.html">ComplexArray</a> stateVecIn, <a class="el" href="structComplexArray.html">ComplexArray</a> stateVecOut)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a single qubit by {{0,1},{1,0}.  <a href="#a774dd1217fcc3591a74a74d5667afa29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#a7c02cd0e1b4eac19771a0525f023249e">findProbabilityOfZeroLocal</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int measureQubit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk.  <a href="#a7c02cd0e1b4eac19771a0525f023249e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#a9ac9bb717a889f09d307eda9f0b65957">findProbabilityOfZeroDistributed</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int measureQubit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk.  <a href="#a9ac9bb717a889f09d307eda9f0b65957"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#a53614ce19e0a4f2c41b400cf05dc5bd1">measureInStateLocal</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, int measureQubit, REAL totalProbability, int outcome)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1.  <a href="#a53614ce19e0a4f2c41b400cf05dc5bd1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#a35e5ac30c8427c482a97b33a4e295535">measureInStateDistributedRenorm</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int measureQubit, const REAL totalProbability)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1.  <a href="#a35e5ac30c8427c482a97b33a4e295535"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#ac39efc9ed939382276ebd0c15dd6a0fa">measureInStateDistributedSetZero</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int measureQubit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set all amplitudes in one chunk to 0.  <a href="#ac39efc9ed939382276ebd0c15dd6a0fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#a2d73fd11c1d154640dbf114da8f34c64">filterOut111Local</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int idQubit1, const int idQubit2, const int idQubit3, const REAL probOfFilter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Updates the state according to this scenario: we ask "are these 3 qubits in 111" and the answer is "no".  <a href="#a2d73fd11c1d154640dbf114da8f34c64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#a096cddbac961f0651a084d2ceb905d1b">probOfFilterOut111Local</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int idQubit1, const int idQubit2, const int idQubit3)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluates the state according to this scenario: we ask "are these 3 qubits in 111" and the answer is "no".  <a href="#a096cddbac961f0651a084d2ceb905d1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qubits__internal_8h.html#ae275b94c1a483dda43bf4ec947635605">phaseGate</a> (<a class="el" href="structMultiQubit.html">MultiQubit</a> multiQubit, const int rotQubit, enum <a class="el" href="qubits_8h.html#a5739021c733cecc49647956b2f7338ea">phaseGateType</a> type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a single qubit by {{1,0},{0,p}} where p is a phase term determined by the type argument.  <a href="#ae275b94c1a483dda43bf4ec947635605"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Internal functions used to implement the public facing API in <a class="el" href="qubits_8h.html" title="The QuEST library API and objects.">qubits.h</a>. </p>
<p>Do not call these functions directly. In general, <a class="el" href="qubits__env__local_8c.html" title="An implementation of the API in qubits.h for a local (non-MPI) environment.">qubits_env_local.c</a> and <a class="el" href="qubits__env__mpi_8c.html" title="An implementation of the API in qubits.h for an MPI environment.">qubits_env_mpi.c</a> will implement the public API by choosing the correct function or combination of functions to use from those included here. </p>

<p>Definition in file <a class="el" href="qubits__internal_8h_source.html">qubits_internal.h</a>.</p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a774dd1217fcc3591a74a74d5667afa29"></a><!-- doxytag: member="qubits_internal.h::controlNotDistributed" ref="a774dd1217fcc3591a74a74d5667afa29" args="(MultiQubit multiQubit, const int targetQubit, const int controlQubit, ComplexArray stateVecIn, ComplexArray stateVecOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void controlNotDistributed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>targetQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>controlQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplexArray.html">ComplexArray</a>&nbsp;</td>
          <td class="paramname"> <em>stateVecIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplexArray.html">ComplexArray</a>&nbsp;</td>
          <td class="paramname"> <em>stateVecOut</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a single qubit by {{0,1},{1,0}. </p>
<p>Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk. Only perform the rotation for elements where controlQubit is one.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotQubit</em>&nbsp;</td><td>qubit to rotate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stateVecIn</em>&nbsp;</td><td>probability amplitudes in lower or upper half of a block depending on chunkId </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stateVecOut</em>&nbsp;</td><td>array section to update (will correspond to either the lower or upper half of a block) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l00865">865</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00040">MultiQubit::chunkId</a>, <a class="el" href="qubits_8c_source.html#l01450">extractBit()</a>, <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, and <a class="el" href="precision_8h_source.html#l00021">REAL</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__mpi_8c_source.html#l00347">controlNot()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00868"></a>00868 {
<a name="l00869"></a>00869 
<a name="l00870"></a>00870         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;  
<a name="l00871"></a>00871         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l00872"></a>00872         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> chunkSize=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l00873"></a>00873         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> chunkId=multiQubit.<a class="code" href="structMultiQubit.html#ab10c88249fa3825d6227ceec01d37e37" title="The position of the chunk of the state vector held by this process in the full state...">chunkId</a>;
<a name="l00874"></a>00874         
<a name="l00875"></a>00875         <span class="comment">// if targetQubit==controlQubit, it is guaranteed that controlQubit==1 when</span>
<a name="l00876"></a>00876         <span class="comment">// targetQubit==1. As rotations are symmetric, we can instead apply the rotation</span>
<a name="l00877"></a>00877         <span class="comment">// on all amplitudes where targetQubit==0 as we do here.</span>
<a name="l00878"></a>00878         <span class="keywordtype">int</span> rotateAll=(targetQubit==controlQubit);
<a name="l00879"></a>00879 
<a name="l00880"></a>00880         <span class="keywordtype">int</span> controlBit;
<a name="l00881"></a>00881 
<a name="l00882"></a>00882         <span class="comment">// test qubit valid</span>
<a name="l00883"></a>00883         assert (targetQubit &gt;= 0 &amp;&amp; targetQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l00884"></a>00884 
<a name="l00885"></a>00885         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecRealIn=stateVecIn.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>, *stateVecImagIn=stateVecIn.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l00886"></a>00886         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecRealOut=stateVecOut.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>, *stateVecImagOut=stateVecOut.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l00887"></a>00887 
<a name="l00888"></a>00888 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00889"></a>00889 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l00890"></a>00890 <span class="preprocessor">        default  (none) \</span>
<a name="l00891"></a>00891 <span class="preprocessor">        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,rotateAll) \</span>
<a name="l00892"></a>00892 <span class="preprocessor">        private  (thisTask,controlBit)</span>
<a name="l00893"></a>00893 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00894"></a>00894 <span class="preprocessor"></span>        {
<a name="l00895"></a>00895 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00896"></a>00896 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule (static)</span>
<a name="l00897"></a>00897 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00898"></a>00898 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l00899"></a>00899                         controlBit = <a class="code" href="qubits_8c.html#a100463f6ec212c76a5fad99579000505" title="Get the value of the bit at a particular index in a number.">extractBit</a> (controlQubit, thisTask+chunkId*chunkSize);
<a name="l00900"></a>00900                         <span class="keywordflow">if</span> (rotateAll || controlBit){
<a name="l00901"></a>00901                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
<a name="l00902"></a>00902                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
<a name="l00903"></a>00903                         }
<a name="l00904"></a>00904                 }
<a name="l00905"></a>00905         }
<a name="l00906"></a>00906 } 
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2901e2e5531cb77f87ea54b3fc28f51a"></a><!-- doxytag: member="qubits_internal.h::controlNotLocal" ref="a2901e2e5531cb77f87ea54b3fc28f51a" args="(MultiQubit multiQubit, const int targetQubit, const int controlQubit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void controlNotLocal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>targetQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>controlQubit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a single qubit by {{0,1},{1,0} for elements where controlQubit is one. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Qubits are zero-based and the the first qubit is the rightmost</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>targetQubit</em>&nbsp;</td><td>qubit to rotate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>controlQubit</em>&nbsp;</td><td>qubit to determine whether or not to perform a rotation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l00791">791</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00040">MultiQubit::chunkId</a>, <a class="el" href="qubits_8c_source.html#l01450">extractBit()</a>, <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, <a class="el" href="precision_8h_source.html#l00021">REAL</a>, and <a class="el" href="qubits_8h_source.html#l00031">MultiQubit::stateVec</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__local_8c_source.html#l00118">controlNot()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00792"></a>00792 {
<a name="l00793"></a>00793         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> sizeBlock, sizeHalfBlock;
<a name="l00794"></a>00794         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisBlock, <span class="comment">// current block</span>
<a name="l00795"></a>00795              indexUp,indexLo;    <span class="comment">// current index and corresponding index in lower half block</span>
<a name="l00796"></a>00796 
<a name="l00797"></a>00797         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> stateRealUp,stateImagUp;
<a name="l00798"></a>00798         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;         
<a name="l00799"></a>00799         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>&gt;&gt;1;
<a name="l00800"></a>00800         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> chunkSize=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l00801"></a>00801         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> chunkId=multiQubit.<a class="code" href="structMultiQubit.html#ab10c88249fa3825d6227ceec01d37e37" title="The position of the chunk of the state vector held by this process in the full state...">chunkId</a>;
<a name="l00802"></a>00802 
<a name="l00803"></a>00803         <span class="keywordtype">int</span> controlBit;
<a name="l00804"></a>00804 
<a name="l00805"></a>00805         <span class="comment">// if targetQubit==controlQubit, it is guaranteed that controlQubit==1 when</span>
<a name="l00806"></a>00806         <span class="comment">// targetQubit==1. As rotations are symmetric, we can instead apply the rotation</span>
<a name="l00807"></a>00807         <span class="comment">// on all amplitudes where targetQubit==0 as we do here.</span>
<a name="l00808"></a>00808         <span class="keywordtype">int</span> rotateAll=(targetQubit==controlQubit);
<a name="l00809"></a>00809 
<a name="l00810"></a>00810         <span class="comment">// test qubit valid</span>
<a name="l00811"></a>00811         assert (targetQubit &gt;= 0 &amp;&amp; targetQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l00812"></a>00812 
<a name="l00813"></a>00813         <span class="comment">// set dimensions</span>
<a name="l00814"></a>00814         sizeHalfBlock = 1LL &lt;&lt; targetQubit;  
<a name="l00815"></a>00815         sizeBlock     = 2LL * sizeHalfBlock; 
<a name="l00816"></a>00816 
<a name="l00817"></a>00817 
<a name="l00818"></a>00818         <span class="comment">// Can&apos;t use multiQubit.stateVec as a private OMP var</span>
<a name="l00819"></a>00819         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecReal = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>;
<a name="l00820"></a>00820         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecImag = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l00821"></a>00821 
<a name="l00822"></a>00822 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00823"></a>00823 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l00824"></a>00824 <span class="preprocessor">        default  (none) \</span>
<a name="l00825"></a>00825 <span class="preprocessor">        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,rotateAll) \</span>
<a name="l00826"></a>00826 <span class="preprocessor">        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,controlBit) </span>
<a name="l00827"></a>00827 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00828"></a>00828 <span class="preprocessor"></span>        {
<a name="l00829"></a>00829 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00830"></a>00830 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule (static)</span>
<a name="l00831"></a>00831 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00832"></a>00832 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l00833"></a>00833                         thisBlock   = thisTask / sizeHalfBlock;
<a name="l00834"></a>00834                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
<a name="l00835"></a>00835                         indexLo     = indexUp + sizeHalfBlock;
<a name="l00836"></a>00836 
<a name="l00837"></a>00837                         controlBit = <a class="code" href="qubits_8c.html#a100463f6ec212c76a5fad99579000505" title="Get the value of the bit at a particular index in a number.">extractBit</a>(controlQubit, indexUp+chunkId*chunkSize);
<a name="l00838"></a>00838                         <span class="keywordflow">if</span> (rotateAll || controlBit){
<a name="l00839"></a>00839                                 stateRealUp = stateVecReal[indexUp];
<a name="l00840"></a>00840                                 stateImagUp = stateVecImag[indexUp];
<a name="l00841"></a>00841 
<a name="l00842"></a>00842                                 stateVecReal[indexUp] = stateVecReal[indexLo];
<a name="l00843"></a>00843                                 stateVecImag[indexUp] = stateVecImag[indexLo];
<a name="l00844"></a>00844 
<a name="l00845"></a>00845                                 stateVecReal[indexLo] = stateRealUp;
<a name="l00846"></a>00846                                 stateVecImag[indexLo] = stateImagUp;
<a name="l00847"></a>00847                         }
<a name="l00848"></a>00848                 } 
<a name="l00849"></a>00849         }
<a name="l00850"></a>00850 
<a name="l00851"></a>00851 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab22d031e2507f1d859292103a99e2378"></a><!-- doxytag: member="qubits_internal.h::controlRotateQubitDistributed" ref="ab22d031e2507f1d859292103a99e2378" args="(MultiQubit multiQubit, const int rotQubit, const int controlQubit, Complex rot1, Complex rot2, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void controlRotateQubitDistributed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rotQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>controlQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplex.html">Complex</a>&nbsp;</td>
          <td class="paramname"> <em>rot1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplex.html">Complex</a>&nbsp;</td>
          <td class="paramname"> <em>rot2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplexArray.html">ComplexArray</a>&nbsp;</td>
          <td class="paramname"> <em>stateVecUp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplexArray.html">ComplexArray</a>&nbsp;</td>
          <td class="paramname"> <em>stateVecLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplexArray.html">ComplexArray</a>&nbsp;</td>
          <td class="paramname"> <em>stateVecOut</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. </p>
<p>Only perform the rotation where the control qubit is one.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotQubit</em>&nbsp;</td><td>qubit to rotate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>controlQubit</em>&nbsp;</td><td>qubit to determine whether or not to perform a rotation </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rot1</em>&nbsp;</td><td>rotation angle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rot2</em>&nbsp;</td><td>rotation angle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stateVecUp</em>&nbsp;</td><td>probability amplitudes in upper half of a block </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stateVecLo</em>&nbsp;</td><td>probability amplitudes in lower half of a block </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stateVecOut</em>&nbsp;</td><td>array section to update (will correspond to either the lower or upper half of a block) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l00620">620</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00040">MultiQubit::chunkId</a>, <a class="el" href="qubits_8c_source.html#l01450">extractBit()</a>, <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00022">Complex::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, <a class="el" href="qubits_8h_source.html#l00021">Complex::real</a>, and <a class="el" href="precision_8h_source.html#l00021">REAL</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__mpi_8c_source.html#l00282">controlRotateQubit()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00625"></a>00625 {
<a name="l00626"></a>00626 
<a name="l00627"></a>00627         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a>   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
<a name="l00628"></a>00628         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;  
<a name="l00629"></a>00629         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l00630"></a>00630         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> chunkSize=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l00631"></a>00631         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> chunkId=multiQubit.<a class="code" href="structMultiQubit.html#ab10c88249fa3825d6227ceec01d37e37" title="The position of the chunk of the state vector held by this process in the full state...">chunkId</a>;
<a name="l00632"></a>00632 
<a name="l00633"></a>00633         <span class="keywordtype">int</span> controlBit;
<a name="l00634"></a>00634 
<a name="l00635"></a>00635         <span class="comment">// As rotations are symmetric, we can apply rotations for all elements where</span>
<a name="l00636"></a>00636         <span class="comment">// targetQubit==0 and controlQubit==1.  </span>
<a name="l00637"></a>00637         <span class="comment">// However, this means we will skip the case where targetQubit==controlQubit. </span>
<a name="l00638"></a>00638         <span class="comment">// We check for that here. </span>
<a name="l00639"></a>00639         <span class="comment">// We could also choose to rotate on targetQubit==1, but are doing it this way </span>
<a name="l00640"></a>00640         <span class="comment">// to match the regular rotate implementation. </span>
<a name="l00641"></a>00641         <span class="keywordtype">int</span> rotateAll=(rotQubit==controlQubit);
<a name="l00642"></a>00642 
<a name="l00643"></a>00643         <span class="comment">// test qubit valid</span>
<a name="l00644"></a>00644         assert (rotQubit &gt;= 0 &amp;&amp; rotQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l00645"></a>00645 
<a name="l00646"></a>00646         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> rot1Real=rot1.<a class="code" href="structComplex.html#a479ad939835457595fcca3ca55c06283">real</a>, rot1Imag=rot1.<a class="code" href="structComplex.html#a1151948284b21c0052f203f23ab931d9">imag</a>;
<a name="l00647"></a>00647         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> rot2Real=rot2.<a class="code" href="structComplex.html#a479ad939835457595fcca3ca55c06283">real</a>, rot2Imag=rot2.<a class="code" href="structComplex.html#a1151948284b21c0052f203f23ab931d9">imag</a>;
<a name="l00648"></a>00648         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecRealUp=stateVecUp.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>, *stateVecImagUp=stateVecUp.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l00649"></a>00649         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecRealLo=stateVecLo.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>, *stateVecImagLo=stateVecLo.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l00650"></a>00650         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecRealOut=stateVecOut.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>, *stateVecImagOut=stateVecOut.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l00651"></a>00651 
<a name="l00652"></a>00652 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00653"></a>00653 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l00654"></a>00654 <span class="preprocessor">        default  (none) \</span>
<a name="l00655"></a>00655 <span class="preprocessor">        shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \</span>
<a name="l00656"></a>00656 <span class="preprocessor">                        rot1Real,rot1Imag, rot2Real,rot2Imag,rotateAll) \</span>
<a name="l00657"></a>00657 <span class="preprocessor">        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit)</span>
<a name="l00658"></a>00658 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00659"></a>00659 <span class="preprocessor"></span>        {
<a name="l00660"></a>00660 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00661"></a>00661 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule (static)</span>
<a name="l00662"></a>00662 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00663"></a>00663 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l00664"></a>00664                         controlBit = <a class="code" href="qubits_8c.html#a100463f6ec212c76a5fad99579000505" title="Get the value of the bit at a particular index in a number.">extractBit</a> (controlQubit, thisTask+chunkId*chunkSize);
<a name="l00665"></a>00665                         <span class="keywordflow">if</span> (rotateAll || controlBit){
<a name="l00666"></a>00666                                 <span class="comment">// store current state vector values in temp variables</span>
<a name="l00667"></a>00667                                 stateRealUp = stateVecRealUp[thisTask];
<a name="l00668"></a>00668                                 stateImagUp = stateVecImagUp[thisTask];
<a name="l00669"></a>00669 
<a name="l00670"></a>00670                                 stateRealLo = stateVecRealLo[thisTask];
<a name="l00671"></a>00671                                 stateImagLo = stateVecImagLo[thisTask];
<a name="l00672"></a>00672 
<a name="l00673"></a>00673                                 <span class="comment">// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]</span>
<a name="l00674"></a>00674                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
<a name="l00675"></a>00675                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
<a name="l00676"></a>00676                         }
<a name="l00677"></a>00677                 }
<a name="l00678"></a>00678         }
<a name="l00679"></a>00679 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a824d71bae93236d8a3cd43589044eaee"></a><!-- doxytag: member="qubits_internal.h::controlRotateQubitLocal" ref="a824d71bae93236d8a3cd43589044eaee" args="(MultiQubit multiQubit, const int rotQubit, const int controlQubit, Complex alpha, Complex beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void controlRotateQubitLocal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rotQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>controlQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplex.html">Complex</a>&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplex.html">Complex</a>&nbsp;</td>
          <td class="paramname"> <em>beta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. </p>
<p>Only perform the rotation for elements where the control qubit is one.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotQubit</em>&nbsp;</td><td>qubit to rotate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>controlQubit</em>&nbsp;</td><td>perform rotation if this qubit is 1 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>alpha</em>&nbsp;</td><td>rotation angle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>beta</em>&nbsp;</td><td>rotation angle </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l00528">528</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00040">MultiQubit::chunkId</a>, <a class="el" href="qubits_8c_source.html#l01450">extractBit()</a>, <a class="el" href="qubits_8h_source.html#l00022">Complex::imag</a>, <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00021">Complex::real</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, <a class="el" href="precision_8h_source.html#l00021">REAL</a>, and <a class="el" href="qubits_8h_source.html#l00031">MultiQubit::stateVec</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__local_8c_source.html#l00093">controlRotateQubit()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00530"></a>00530 {
<a name="l00531"></a>00531         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> sizeBlock, sizeHalfBlock;
<a name="l00532"></a>00532         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisBlock, <span class="comment">// current block</span>
<a name="l00533"></a>00533              indexUp,indexLo;    <span class="comment">// current index and corresponding index in lower half block</span>
<a name="l00534"></a>00534 
<a name="l00535"></a>00535         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> stateRealUp,stateRealLo,stateImagUp,stateImagLo;
<a name="l00536"></a>00536         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;         
<a name="l00537"></a>00537         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>&gt;&gt;1;
<a name="l00538"></a>00538         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> chunkSize=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l00539"></a>00539         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> chunkId=multiQubit.<a class="code" href="structMultiQubit.html#ab10c88249fa3825d6227ceec01d37e37" title="The position of the chunk of the state vector held by this process in the full state...">chunkId</a>;
<a name="l00540"></a>00540 
<a name="l00541"></a>00541         <span class="keywordtype">int</span> controlBit;
<a name="l00542"></a>00542 
<a name="l00543"></a>00543         <span class="comment">// As rotations are symmetric, we can apply rotations for all elements where</span>
<a name="l00544"></a>00544         <span class="comment">// targetQubit==0 and controlQubit==1.  </span>
<a name="l00545"></a>00545         <span class="comment">// However, this means we will skip the case where targetQubit==controlQubit. </span>
<a name="l00546"></a>00546         <span class="comment">// We check for that here. </span>
<a name="l00547"></a>00547         <span class="comment">// We could also choose to rotate on targetQubit==1, but are doing it this way </span>
<a name="l00548"></a>00548         <span class="comment">// to match the regular rotate implementation. </span>
<a name="l00549"></a>00549         <span class="keywordtype">int</span> rotateAll=(rotQubit==controlQubit);
<a name="l00550"></a>00550 
<a name="l00551"></a>00551         <span class="comment">// test qubit valid</span>
<a name="l00552"></a>00552         assert (rotQubit &gt;= 0 &amp;&amp; rotQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l00553"></a>00553 
<a name="l00554"></a>00554         <span class="comment">// set dimensions</span>
<a name="l00555"></a>00555         sizeHalfBlock = 1LL &lt;&lt; rotQubit;  
<a name="l00556"></a>00556         sizeBlock     = 2LL * sizeHalfBlock; 
<a name="l00557"></a>00557 
<a name="l00558"></a>00558         <span class="comment">// Can&apos;t use multiQubit.stateVec as a private OMP var</span>
<a name="l00559"></a>00559         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecReal = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>;
<a name="l00560"></a>00560         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecImag = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l00561"></a>00561         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> alphaImag=alpha.<a class="code" href="structComplex.html#a1151948284b21c0052f203f23ab931d9">imag</a>, alphaReal=alpha.<a class="code" href="structComplex.html#a479ad939835457595fcca3ca55c06283">real</a>;
<a name="l00562"></a>00562         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> betaImag=beta.<a class="code" href="structComplex.html#a1151948284b21c0052f203f23ab931d9">imag</a>, betaReal=beta.<a class="code" href="structComplex.html#a479ad939835457595fcca3ca55c06283">real</a>;
<a name="l00563"></a>00563 
<a name="l00564"></a>00564 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00565"></a>00565 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l00566"></a>00566 <span class="preprocessor">        default  (none) \</span>
<a name="l00567"></a>00567 <span class="preprocessor">        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,alphaImag, betaReal,betaImag,\</span>
<a name="l00568"></a>00568 <span class="preprocessor">                        rotateAll) \</span>
<a name="l00569"></a>00569 <span class="preprocessor">        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit) </span>
<a name="l00570"></a>00570 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00571"></a>00571 <span class="preprocessor"></span>        {
<a name="l00572"></a>00572 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00573"></a>00573 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule (static)</span>
<a name="l00574"></a>00574 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00575"></a>00575 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l00576"></a>00576 
<a name="l00577"></a>00577                         thisBlock   = thisTask / sizeHalfBlock;
<a name="l00578"></a>00578                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
<a name="l00579"></a>00579                         indexLo     = indexUp + sizeHalfBlock;
<a name="l00580"></a>00580 
<a name="l00581"></a>00581                         controlBit = <a class="code" href="qubits_8c.html#a100463f6ec212c76a5fad99579000505" title="Get the value of the bit at a particular index in a number.">extractBit</a> (controlQubit, indexUp+chunkId*chunkSize);
<a name="l00582"></a>00582                         <span class="keywordflow">if</span> (rotateAll || controlBit){
<a name="l00583"></a>00583                                 <span class="comment">// store current state vector values in temp variables</span>
<a name="l00584"></a>00584                                 stateRealUp = stateVecReal[indexUp];
<a name="l00585"></a>00585                                 stateImagUp = stateVecImag[indexUp];
<a name="l00586"></a>00586 
<a name="l00587"></a>00587                                 stateRealLo = stateVecReal[indexLo];
<a name="l00588"></a>00588                                 stateImagLo = stateVecImag[indexLo];
<a name="l00589"></a>00589 
<a name="l00590"></a>00590                                 <span class="comment">// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]</span>
<a name="l00591"></a>00591                                 stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag*stateImagUp 
<a name="l00592"></a>00592                                         - betaReal*stateRealLo - betaImag*stateImagLo;
<a name="l00593"></a>00593                                 stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag*stateRealUp 
<a name="l00594"></a>00594                                         - betaReal*stateImagLo + betaImag*stateRealLo;
<a name="l00595"></a>00595 
<a name="l00596"></a>00596                                 <span class="comment">// state[indexLo] = beta  * state[indexUp] + conj(alpha) * state[indexLo]</span>
<a name="l00597"></a>00597                                 stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*stateImagUp 
<a name="l00598"></a>00598                                         + alphaReal*stateRealLo + alphaImag*stateImagLo;
<a name="l00599"></a>00599                                 stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*stateRealUp 
<a name="l00600"></a>00600                                         + alphaReal*stateImagLo - alphaImag*stateRealLo;
<a name="l00601"></a>00601                         }
<a name="l00602"></a>00602                 } 
<a name="l00603"></a>00603         }
<a name="l00604"></a>00604 
<a name="l00605"></a>00605 } 
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2d73fd11c1d154640dbf114da8f34c64"></a><!-- doxytag: member="qubits_internal.h::filterOut111Local" ref="a2d73fd11c1d154640dbf114da8f34c64" args="(MultiQubit multiQubit, const int idQubit1, const int idQubit2, const int idQubit3, const REAL probOfFilter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filterOut111Local </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>idQubit1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>idQubit2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>idQubit3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&nbsp;</td>
          <td class="paramname"> <em>probOfFilter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the state according to this scenario: we ask "are these 3 qubits in 111" and the answer is "no". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idQubit1,idQubit2,idQubit3</em>&nbsp;</td><td>specified qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>probOfFilter</em>&nbsp;</td><td>Total probability that the 3 qubits are not all in the 1 state. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l01786">1786</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00040">MultiQubit::chunkId</a>, <a class="el" href="qubits_8c_source.html#l01450">extractBit()</a>, <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, <a class="el" href="precision_8h_source.html#l00021">REAL</a>, <a class="el" href="precision_8h_source.html#l00023">REAL_STRING_FORMAT</a>, and <a class="el" href="qubits_8h_source.html#l00031">MultiQubit::stateVec</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__local_8c_source.html#l00139">filterOut111()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01788"></a>01788 {
<a name="l01789"></a>01789         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> index;
<a name="l01790"></a>01790         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> stateVecSize;
<a name="l01791"></a>01791         <span class="keywordtype">int</span> bit1, bit2, bit3;
<a name="l01792"></a>01792         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> chunkSize=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l01793"></a>01793         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> chunkId=multiQubit.<a class="code" href="structMultiQubit.html#ab10c88249fa3825d6227ceec01d37e37" title="The position of the chunk of the state vector held by this process in the full state...">chunkId</a>;
<a name="l01794"></a>01794 
<a name="l01795"></a>01795         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01796"></a>01796         <span class="comment">//            tests                                                 //</span>
<a name="l01797"></a>01797         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01798"></a>01798         assert (idQubit1 &gt;= 0 &amp;&amp; idQubit2 &gt;= 0 &amp;&amp; idQubit1 &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a> &amp;&amp; idQubit2 &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l01799"></a>01799 
<a name="l01800"></a>01800         assert (probOfFilter != 0);
<a name="l01801"></a>01801         stateVecSize = multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l01802"></a>01802 
<a name="l01803"></a>01803         <span class="keywordflow">if</span> ( probOfFilter&lt;1e-16 ){ printf(<span class="stringliteral">&quot;Extremely small or negative profOfFilter=&quot;</span><a class="code" href="precision_8h.html#ad751ac7ddc8ec19f23fb33083c0da8da">REAL_STRING_FORMAT</a><span class="stringliteral">&quot;; aborting! \n&quot;</span>,probOfFilter); exit(1);}
<a name="l01804"></a>01804         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> myNorm=1/sqrt(probOfFilter);
<a name="l01805"></a>01805         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecReal = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>;
<a name="l01806"></a>01806         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecImag = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l01807"></a>01807 
<a name="l01808"></a>01808 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01809"></a>01809 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l01810"></a>01810 <span class="preprocessor">        default  (none)                      \</span>
<a name="l01811"></a>01811 <span class="preprocessor">        shared   (stateVecSize, stateVecReal,stateVecImag, myNorm) \</span>
<a name="l01812"></a>01812 <span class="preprocessor">        private  (index,bit1,bit2,bit3)                </span>
<a name="l01813"></a>01813 <span class="preprocessor"></span><span class="preprocessor"># endif </span>
<a name="l01814"></a>01814 <span class="preprocessor"></span>        {
<a name="l01815"></a>01815 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01816"></a>01816 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule (static)</span>
<a name="l01817"></a>01817 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01818"></a>01818 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (index=0; index&lt;stateVecSize; index++) {
<a name="l01819"></a>01819                         bit1 = <a class="code" href="qubits_8c.html#a100463f6ec212c76a5fad99579000505" title="Get the value of the bit at a particular index in a number.">extractBit</a> (idQubit1, index+chunkId*chunkSize);
<a name="l01820"></a>01820                         bit2 = <a class="code" href="qubits_8c.html#a100463f6ec212c76a5fad99579000505" title="Get the value of the bit at a particular index in a number.">extractBit</a> (idQubit2, index+chunkId*chunkSize);
<a name="l01821"></a>01821                         bit3 = <a class="code" href="qubits_8c.html#a100463f6ec212c76a5fad99579000505" title="Get the value of the bit at a particular index in a number.">extractBit</a> (idQubit3, index+chunkId*chunkSize);
<a name="l01822"></a>01822                         <span class="keywordflow">if</span> ((bit1 &amp;&amp; bit2 &amp;&amp; bit3)) {
<a name="l01823"></a>01823                                 stateVecReal[index]=0;
<a name="l01824"></a>01824                                 stateVecImag [index]=0;
<a name="l01825"></a>01825                         }<span class="keywordflow">else</span>{
<a name="l01826"></a>01826                                 stateVecReal[index] *= myNorm;
<a name="l01827"></a>01827                                 stateVecImag[index] *= myNorm;
<a name="l01828"></a>01828                         }
<a name="l01829"></a>01829                 }
<a name="l01830"></a>01830         }
<a name="l01831"></a>01831 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9ac9bb717a889f09d307eda9f0b65957"></a><!-- doxytag: member="qubits_internal.h::findProbabilityOfZeroDistributed" ref="a9ac9bb717a889f09d307eda9f0b65957" args="(MultiQubit multiQubit, const int measureQubit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL findProbabilityOfZeroDistributed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>measureQubit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. </p>
<p>Size of regions to skip is a multiple of chunkSize.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>measureQubit</em>&nbsp;</td><td>qubit to measure </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>probability of qubit measureQubit being zero </dd></dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l01389">1389</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, <a class="el" href="precision_8h_source.html#l00021">REAL</a>, and <a class="el" href="qubits_8h_source.html#l00031">MultiQubit::stateVec</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__mpi_8c_source.html#l00481">findProbabilityOfOutcome()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01391"></a>01391 {
<a name="l01392"></a>01392         <span class="comment">// ----- measured probability</span>
<a name="l01393"></a>01393         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a>   totalProbability;                                    <span class="comment">// probability (returned) value</span>
<a name="l01394"></a>01394         <span class="comment">// ----- temp variables</span>
<a name="l01395"></a>01395         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;                                   <span class="comment">// task based approach for expose loop with small granularity</span>
<a name="l01396"></a>01396         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l01397"></a>01397         <span class="comment">// (good for shared memory parallelism)</span>
<a name="l01398"></a>01398 
<a name="l01399"></a>01399         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01400"></a>01400         <span class="comment">//            tests                                                 //</span>
<a name="l01401"></a>01401         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01402"></a>01402         assert (measureQubit &gt;= 0 &amp;&amp; measureQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l01403"></a>01403 
<a name="l01404"></a>01404         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01405"></a>01405         <span class="comment">//            find probability                                      //</span>
<a name="l01406"></a>01406         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01407"></a>01407 
<a name="l01408"></a>01408         <span class="comment">// initialise returned value</span>
<a name="l01409"></a>01409         totalProbability = 0.0;
<a name="l01410"></a>01410 
<a name="l01411"></a>01411         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecReal = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>;
<a name="l01412"></a>01412         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecImag = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l01413"></a>01413 
<a name="l01414"></a>01414 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01415"></a>01415 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l01416"></a>01416 <span class="preprocessor">        shared    (numTasks,stateVecReal,stateVecImag) \</span>
<a name="l01417"></a>01417 <span class="preprocessor">        private   (thisTask) \</span>
<a name="l01418"></a>01418 <span class="preprocessor">        reduction ( +:totalProbability )</span>
<a name="l01419"></a>01419 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01420"></a>01420 <span class="preprocessor"></span>        {
<a name="l01421"></a>01421 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01422"></a>01422 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule  (static)</span>
<a name="l01423"></a>01423 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01424"></a>01424 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l01425"></a>01425                         <span class="comment">// summation -- simple implementation</span>
<a name="l01426"></a>01426                         totalProbability += stateVecReal[thisTask]*stateVecReal[thisTask]
<a name="l01427"></a>01427                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
<a name="l01428"></a>01428 
<a name="l01429"></a>01429                         <span class="comment">/*</span>
<a name="l01430"></a>01430 <span class="comment">                        // summation -- kahan correction</span>
<a name="l01431"></a>01431 <span class="comment">                        y = stateVecReal[thisTask]*stateVecReal[thisTask]</span>
<a name="l01432"></a>01432 <span class="comment">                        + stateVecImag[thisTask]*stateVecImag[thisTask] - c;</span>
<a name="l01433"></a>01433 <span class="comment">                        t = totalProbability + y;</span>
<a name="l01434"></a>01434 <span class="comment">                        c = (t - totalProbability) - y;</span>
<a name="l01435"></a>01435 <span class="comment">                        totalProbability = t;</span>
<a name="l01436"></a>01436 <span class="comment">                        */</span>
<a name="l01437"></a>01437 
<a name="l01438"></a>01438                 }
<a name="l01439"></a>01439         }
<a name="l01440"></a>01440 
<a name="l01441"></a>01441         <span class="keywordflow">return</span> totalProbability;
<a name="l01442"></a>01442 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7c02cd0e1b4eac19771a0525f023249e"></a><!-- doxytag: member="qubits_internal.h::findProbabilityOfZeroLocal" ref="a7c02cd0e1b4eac19771a0525f023249e" args="(MultiQubit multiQubit, const int measureQubit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL findProbabilityOfZeroLocal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>measureQubit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. </p>
<p>Size of regions to skip is less than the size of one chunk.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>measureQubit</em>&nbsp;</td><td>qubit to measure </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>probability of qubit measureQubit being zero </dd></dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l01310">1310</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8c_source.html#l00015">DEBUG</a>, <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, <a class="el" href="precision_8h_source.html#l00021">REAL</a>, and <a class="el" href="qubits_8h_source.html#l00031">MultiQubit::stateVec</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__local_8c_source.html#l00123">findProbabilityOfOutcome()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01312"></a>01312 {
<a name="l01313"></a>01313         <span class="comment">// ----- sizes</span>
<a name="l01314"></a>01314         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> sizeBlock,                                           <span class="comment">// size of blocks</span>
<a name="l01315"></a>01315         sizeHalfBlock;                                       <span class="comment">// size of blocks halved</span>
<a name="l01316"></a>01316         <span class="comment">// ----- indices</span>
<a name="l01317"></a>01317         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisBlock,                                           <span class="comment">// current block</span>
<a name="l01318"></a>01318              index;                                               <span class="comment">// current index for first half block</span>
<a name="l01319"></a>01319         <span class="comment">// ----- measured probability</span>
<a name="l01320"></a>01320         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a>   totalProbability;                                    <span class="comment">// probability (returned) value</span>
<a name="l01321"></a>01321         <span class="comment">// ----- temp variables</span>
<a name="l01322"></a>01322         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;                                   <span class="comment">// task based approach for expose loop with small granularity</span>
<a name="l01323"></a>01323         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>&gt;&gt;1;
<a name="l01324"></a>01324 
<a name="l01325"></a>01325         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01326"></a>01326         <span class="comment">//            tests                                                 //</span>
<a name="l01327"></a>01327         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01328"></a>01328         assert (measureQubit &gt;= 0 &amp;&amp; measureQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l01329"></a>01329 
<a name="l01330"></a>01330 
<a name="l01331"></a>01331         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01332"></a>01332         <span class="comment">//            dimensions                                            //</span>
<a name="l01333"></a>01333         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01334"></a>01334         sizeHalfBlock = 1LL &lt;&lt; (measureQubit);                       <span class="comment">// number of state vector elements to sum,</span>
<a name="l01335"></a>01335         <span class="comment">// and then the number to skip</span>
<a name="l01336"></a>01336         sizeBlock     = 2LL * sizeHalfBlock;                           <span class="comment">// size of blocks (pairs of measure and skip entries)</span>
<a name="l01337"></a>01337 
<a name="l01338"></a>01338         <span class="comment">// initialise returned value</span>
<a name="l01339"></a>01339         totalProbability = 0.0;
<a name="l01340"></a>01340 
<a name="l01341"></a>01341         <span class="comment">// initialise correction for kahan summation</span>
<a name="l01342"></a>01342         <span class="keywordflow">if</span> (<a class="code" href="qubits_8c.html#ad72dbcf6d0153db1b8d8a58001feed83">DEBUG</a>) printf(<span class="stringliteral">&quot;sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\n&quot;</span>,sizeHalfBlock,sizeBlock,numTasks);
<a name="l01343"></a>01343 
<a name="l01344"></a>01344         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecReal = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>;
<a name="l01345"></a>01345         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecImag = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l01346"></a>01346 
<a name="l01347"></a>01347 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01348"></a>01348 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l01349"></a>01349 <span class="preprocessor">        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \</span>
<a name="l01350"></a>01350 <span class="preprocessor">        private   (thisTask,thisBlock,index) \</span>
<a name="l01351"></a>01351 <span class="preprocessor">        reduction ( +:totalProbability )</span>
<a name="l01352"></a>01352 <span class="preprocessor"></span><span class="preprocessor"># endif </span>
<a name="l01353"></a>01353 <span class="preprocessor"></span>        {
<a name="l01354"></a>01354 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01355"></a>01355 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule  (static)</span>
<a name="l01356"></a>01356 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01357"></a>01357 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l01358"></a>01358                         thisBlock = thisTask / sizeHalfBlock;
<a name="l01359"></a>01359                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
<a name="l01360"></a>01360 
<a name="l01361"></a>01361                         <span class="keywordflow">if</span> (index&lt;0){ printf(<span class="stringliteral">&quot;ABORTING as index=%Ld with thisBlock = %Ld  thisTask=%Ld \n&quot;</span>, index,thisBlock,thisTask); exit(1);}
<a name="l01362"></a>01362 
<a name="l01363"></a>01363                         <span class="comment">// summation -- simple implementation</span>
<a name="l01364"></a>01364                         totalProbability += stateVecReal[index]*stateVecReal[index]
<a name="l01365"></a>01365                                 + stateVecImag[index]*stateVecImag[index];
<a name="l01366"></a>01366 
<a name="l01367"></a>01367                         <span class="comment">/*</span>
<a name="l01368"></a>01368 <span class="comment">                        // summation -- kahan correction</span>
<a name="l01369"></a>01369 <span class="comment">                        y = stateVecReal[index]*stateVecReal[index]</span>
<a name="l01370"></a>01370 <span class="comment">                        + stateVecImag[index]*stateVecImag[index] - c;</span>
<a name="l01371"></a>01371 <span class="comment">                        t = totalProbability + y;</span>
<a name="l01372"></a>01372 <span class="comment">                        c = (t - totalProbability) - y;</span>
<a name="l01373"></a>01373 <span class="comment">                        totalProbability = t;</span>
<a name="l01374"></a>01374 <span class="comment">                        */</span>
<a name="l01375"></a>01375 
<a name="l01376"></a>01376                 }
<a name="l01377"></a>01377         }
<a name="l01378"></a>01378         <span class="keywordflow">return</span> totalProbability;
<a name="l01379"></a>01379 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac835c194bd547240a35f0b028db1d658"></a><!-- doxytag: member="qubits_internal.h::hadamardDistributed" ref="ac835c194bd547240a35f0b028db1d658" args="(MultiQubit multiQubit, const int rotQubit, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut, int updateUpper)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hadamardDistributed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rotQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplexArray.html">ComplexArray</a>&nbsp;</td>
          <td class="paramname"> <em>stateVecUp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplexArray.html">ComplexArray</a>&nbsp;</td>
          <td class="paramname"> <em>stateVecLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplexArray.html">ComplexArray</a>&nbsp;</td>
          <td class="paramname"> <em>stateVecOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>updateUpper</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a single qubit by {{1,1},{1,-1}}/sqrt2. </p>
<p>Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotQubit</em>&nbsp;</td><td>qubit to rotate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stateVecIn</em>&nbsp;</td><td>probability amplitudes in lower or upper half of a block depending on chunkId </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>updateUpper</em>&nbsp;</td><td>flag, 1: updating upper values, 0: updating lower values in block </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stateVecOut</em>&nbsp;</td><td>array section to update (will correspond to either the lower or upper half of a block) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l01088">1088</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, and <a class="el" href="precision_8h_source.html#l00021">REAL</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__mpi_8c_source.html#l00425">hadamard()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01093"></a>01093 {
<a name="l01094"></a>01094 
<a name="l01095"></a>01095         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a>   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
<a name="l01096"></a>01096         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;  
<a name="l01097"></a>01097         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l01098"></a>01098 
<a name="l01099"></a>01099         <span class="comment">// test qubit valid</span>
<a name="l01100"></a>01100         assert (rotQubit &gt;= 0 &amp;&amp; rotQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l01101"></a>01101 
<a name="l01102"></a>01102         <span class="keywordtype">int</span> sign;
<a name="l01103"></a>01103         <span class="keywordflow">if</span> (updateUpper) sign=1;
<a name="l01104"></a>01104         <span class="keywordflow">else</span> sign=-1;
<a name="l01105"></a>01105 
<a name="l01106"></a>01106         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> recRoot2 = 1.0/sqrt(2);
<a name="l01107"></a>01107 
<a name="l01108"></a>01108         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecRealUp=stateVecUp.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>, *stateVecImagUp=stateVecUp.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l01109"></a>01109         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecRealLo=stateVecLo.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>, *stateVecImagLo=stateVecLo.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l01110"></a>01110         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecRealOut=stateVecOut.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>, *stateVecImagOut=stateVecOut.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l01111"></a>01111 
<a name="l01112"></a>01112 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01113"></a>01113 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l01114"></a>01114 <span class="preprocessor">        default  (none) \</span>
<a name="l01115"></a>01115 <span class="preprocessor">        shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \</span>
<a name="l01116"></a>01116 <span class="preprocessor">                        recRoot2, sign) \</span>
<a name="l01117"></a>01117 <span class="preprocessor">        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)</span>
<a name="l01118"></a>01118 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01119"></a>01119 <span class="preprocessor"></span>        {
<a name="l01120"></a>01120 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01121"></a>01121 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule (static)</span>
<a name="l01122"></a>01122 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01123"></a>01123 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l01124"></a>01124                         <span class="comment">// store current state vector values in temp variables</span>
<a name="l01125"></a>01125                         stateRealUp = stateVecRealUp[thisTask];
<a name="l01126"></a>01126                         stateImagUp = stateVecImagUp[thisTask];
<a name="l01127"></a>01127 
<a name="l01128"></a>01128                         stateRealLo = stateVecRealLo[thisTask];
<a name="l01129"></a>01129                         stateImagLo = stateVecImagLo[thisTask];
<a name="l01130"></a>01130 
<a name="l01131"></a>01131                         stateVecRealOut[thisTask] = recRoot2*(stateRealUp + sign*stateRealLo);
<a name="l01132"></a>01132                         stateVecImagOut[thisTask] = recRoot2*(stateImagUp + sign*stateImagLo);
<a name="l01133"></a>01133                 }
<a name="l01134"></a>01134         }
<a name="l01135"></a>01135 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0711416fceaf63c67b496e123e845c69"></a><!-- doxytag: member="qubits_internal.h::hadamardLocal" ref="a0711416fceaf63c67b496e123e845c69" args="(MultiQubit multiQubit, const int rotQubit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hadamardLocal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rotQubit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a single qubit by {{1,1},{1,-1}}/sqrt2. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Qubits are zero-based and the the first qubit is the rightmost</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotQubit</em>&nbsp;</td><td>qubit to rotate </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l01023">1023</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, <a class="el" href="precision_8h_source.html#l00021">REAL</a>, and <a class="el" href="qubits_8h_source.html#l00031">MultiQubit::stateVec</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__local_8c_source.html#l00113">hadamard()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01024"></a>01024 {
<a name="l01025"></a>01025         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> sizeBlock, sizeHalfBlock;
<a name="l01026"></a>01026         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisBlock, <span class="comment">// current block</span>
<a name="l01027"></a>01027              indexUp,indexLo;    <span class="comment">// current index and corresponding index in lower half block</span>
<a name="l01028"></a>01028 
<a name="l01029"></a>01029         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> stateRealUp,stateRealLo,stateImagUp,stateImagLo;
<a name="l01030"></a>01030         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;         
<a name="l01031"></a>01031         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>&gt;&gt;1;
<a name="l01032"></a>01032 
<a name="l01033"></a>01033         <span class="comment">// test qubit valid</span>
<a name="l01034"></a>01034         assert (rotQubit &gt;= 0 &amp;&amp; rotQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l01035"></a>01035 
<a name="l01036"></a>01036         <span class="comment">// set dimensions</span>
<a name="l01037"></a>01037         sizeHalfBlock = 1LL &lt;&lt; rotQubit;  
<a name="l01038"></a>01038         sizeBlock     = 2LL * sizeHalfBlock; 
<a name="l01039"></a>01039 
<a name="l01040"></a>01040         <span class="comment">// Can&apos;t use multiQubit.stateVec as a private OMP var</span>
<a name="l01041"></a>01041         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecReal = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>;
<a name="l01042"></a>01042         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecImag = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l01043"></a>01043 
<a name="l01044"></a>01044         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> recRoot2 = 1.0/sqrt(2);
<a name="l01045"></a>01045 
<a name="l01046"></a>01046 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01047"></a>01047 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l01048"></a>01048 <span class="preprocessor">        default  (none) \</span>
<a name="l01049"></a>01049 <span class="preprocessor">        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \</span>
<a name="l01050"></a>01050 <span class="preprocessor">        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) </span>
<a name="l01051"></a>01051 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01052"></a>01052 <span class="preprocessor"></span>        {
<a name="l01053"></a>01053 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01054"></a>01054 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule (static)</span>
<a name="l01055"></a>01055 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01056"></a>01056 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l01057"></a>01057                         thisBlock   = thisTask / sizeHalfBlock;
<a name="l01058"></a>01058                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
<a name="l01059"></a>01059                         indexLo     = indexUp + sizeHalfBlock;
<a name="l01060"></a>01060 
<a name="l01061"></a>01061                         stateRealUp = stateVecReal[indexUp];
<a name="l01062"></a>01062                         stateImagUp = stateVecImag[indexUp];
<a name="l01063"></a>01063 
<a name="l01064"></a>01064                         stateRealLo = stateVecReal[indexLo];
<a name="l01065"></a>01065                         stateImagLo = stateVecImag[indexLo];
<a name="l01066"></a>01066 
<a name="l01067"></a>01067                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateRealLo);
<a name="l01068"></a>01068                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImagLo);
<a name="l01069"></a>01069 
<a name="l01070"></a>01070                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateRealLo);
<a name="l01071"></a>01071                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImagLo);
<a name="l01072"></a>01072                 } 
<a name="l01073"></a>01073         }
<a name="l01074"></a>01074 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a35e5ac30c8427c482a97b33a4e295535"></a><!-- doxytag: member="qubits_internal.h::measureInStateDistributedRenorm" ref="a35e5ac30c8427c482a97b33a4e295535" args="(MultiQubit multiQubit, const int measureQubit, const REAL totalProbability)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL measureInStateDistributedRenorm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>measureQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const REAL&nbsp;</td>
          <td class="paramname"> <em>totalProbability</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. </p>
<p>Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that the value 'outcome' has been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>measureQubit</em>&nbsp;</td><td>qubit to measure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>totalProbability</em>&nbsp;</td><td>probability of qubit measureQubit being zero </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l01696">1696</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, <a class="el" href="precision_8h_source.html#l00021">REAL</a>, and <a class="el" href="qubits_8h_source.html#l00031">MultiQubit::stateVec</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__mpi_8c_source.html#l00498">measureInState()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01697"></a>01697 {
<a name="l01698"></a>01698         <span class="comment">// ----- temp variables</span>
<a name="l01699"></a>01699         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;                                   <span class="comment">// task based approach for expose loop with small granularity</span>
<a name="l01700"></a>01700         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l01701"></a>01701         <span class="comment">// (good for shared memory parallelism)</span>
<a name="l01702"></a>01702 
<a name="l01703"></a>01703         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01704"></a>01704         <span class="comment">//            tests                                                 //</span>
<a name="l01705"></a>01705         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01706"></a>01706         assert (measureQubit &gt;= 0 &amp;&amp; measureQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l01707"></a>01707         assert (totalProbability != 0);
<a name="l01708"></a>01708 
<a name="l01709"></a>01709         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> renorm=1/sqrt(totalProbability);
<a name="l01710"></a>01710         
<a name="l01711"></a>01711         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecReal = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>;
<a name="l01712"></a>01712         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecImag = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l01713"></a>01713 
<a name="l01714"></a>01714 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01715"></a>01715 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l01716"></a>01716 <span class="preprocessor">        shared    (numTasks,stateVecReal,stateVecImag) \</span>
<a name="l01717"></a>01717 <span class="preprocessor">        private   (thisTask)</span>
<a name="l01718"></a>01718 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01719"></a>01719 <span class="preprocessor"></span>        {
<a name="l01720"></a>01720 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01721"></a>01721 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule  (static)</span>
<a name="l01722"></a>01722 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01723"></a>01723 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l01724"></a>01724                         <span class="comment">// summation -- simple implementation</span>
<a name="l01725"></a>01725                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
<a name="l01726"></a>01726                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
<a name="l01727"></a>01727                 }
<a name="l01728"></a>01728         }
<a name="l01729"></a>01729         <span class="keywordflow">return</span> totalProbability;
<a name="l01730"></a>01730 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac39efc9ed939382276ebd0c15dd6a0fa"></a><!-- doxytag: member="qubits_internal.h::measureInStateDistributedSetZero" ref="ac39efc9ed939382276ebd0c15dd6a0fa" args="(MultiQubit multiQubit, const int measureQubit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void measureInStateDistributedSetZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>measureQubit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set all amplitudes in one chunk to 0. </p>
<p>Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that a zero have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>measureQubit</em>&nbsp;</td><td>qubit to measure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l01745">1745</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, <a class="el" href="precision_8h_source.html#l00021">REAL</a>, and <a class="el" href="qubits_8h_source.html#l00031">MultiQubit::stateVec</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__mpi_8c_source.html#l00498">measureInState()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01746"></a>01746 {
<a name="l01747"></a>01747         <span class="comment">// ----- temp variables</span>
<a name="l01748"></a>01748         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;                                   <span class="comment">// task based approach for expose loop with small granularity</span>
<a name="l01749"></a>01749         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l01750"></a>01750         <span class="comment">// (good for shared memory parallelism)</span>
<a name="l01751"></a>01751 
<a name="l01752"></a>01752         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01753"></a>01753         <span class="comment">//            tests                                                 //</span>
<a name="l01754"></a>01754         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01755"></a>01755         assert (measureQubit &gt;= 0 &amp;&amp; measureQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l01756"></a>01756 
<a name="l01757"></a>01757         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01758"></a>01758         <span class="comment">//            find probability                                      //</span>
<a name="l01759"></a>01759         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01760"></a>01760 
<a name="l01761"></a>01761         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecReal = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>;
<a name="l01762"></a>01762         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecImag = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l01763"></a>01763 
<a name="l01764"></a>01764 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01765"></a>01765 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l01766"></a>01766 <span class="preprocessor">        shared    (numTasks,stateVecReal,stateVecImag) \</span>
<a name="l01767"></a>01767 <span class="preprocessor">        private   (thisTask)</span>
<a name="l01768"></a>01768 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01769"></a>01769 <span class="preprocessor"></span>        {
<a name="l01770"></a>01770 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01771"></a>01771 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule  (static)</span>
<a name="l01772"></a>01772 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01773"></a>01773 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l01774"></a>01774                         <span class="comment">// summation -- simple implementation</span>
<a name="l01775"></a>01775                         stateVecReal[thisTask] = 0;
<a name="l01776"></a>01776                         stateVecImag[thisTask] = 0;
<a name="l01777"></a>01777                 }
<a name="l01778"></a>01778         }
<a name="l01779"></a>01779 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a53614ce19e0a4f2c41b400cf05dc5bd1"></a><!-- doxytag: member="qubits_internal.h::measureInStateLocal" ref="a53614ce19e0a4f2c41b400cf05dc5bd1" args="(MultiQubit multiQubit, int measureQubit, REAL totalProbability, int outcome)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void measureInStateLocal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>measureQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&nbsp;</td>
          <td class="paramname"> <em>totalProbability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>outcome</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. </p>
<p>Performs an irreversible change to the state vector: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) fit entirely into one chunk.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>measureQubit</em>&nbsp;</td><td>qubit to measure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>totalProbability</em>&nbsp;</td><td>probability of qubit measureQubit being either zero or one </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outcome</em>&nbsp;</td><td>to measure the probability of and set the state to -- either zero or one </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l01607">1607</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, <a class="el" href="precision_8h_source.html#l00021">REAL</a>, and <a class="el" href="qubits_8h_source.html#l00031">MultiQubit::stateVec</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__local_8c_source.html#l00131">measureInState()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01608"></a>01608 {
<a name="l01609"></a>01609         <span class="comment">// ----- sizes</span>
<a name="l01610"></a>01610         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> sizeBlock,                                           <span class="comment">// size of blocks</span>
<a name="l01611"></a>01611         sizeHalfBlock;                                       <span class="comment">// size of blocks halved</span>
<a name="l01612"></a>01612         <span class="comment">// ----- indices</span>
<a name="l01613"></a>01613         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisBlock,                                           <span class="comment">// current block</span>
<a name="l01614"></a>01614              index;                                               <span class="comment">// current index for first half block</span>
<a name="l01615"></a>01615         <span class="comment">// ----- measured probability</span>
<a name="l01616"></a>01616         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a>   renorm;                                    <span class="comment">// probability (returned) value</span>
<a name="l01617"></a>01617         <span class="comment">// ----- temp variables</span>
<a name="l01618"></a>01618         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;                                   <span class="comment">// task based approach for expose loop with small granularity</span>
<a name="l01619"></a>01619         <span class="comment">// (good for shared memory parallelism)</span>
<a name="l01620"></a>01620         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>&gt;&gt;1;
<a name="l01621"></a>01621 
<a name="l01622"></a>01622         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01623"></a>01623         <span class="comment">//            tests                                                 //</span>
<a name="l01624"></a>01624         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01625"></a>01625         assert (measureQubit &gt;= 0 &amp;&amp; measureQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l01626"></a>01626         assert (totalProbability != 0);
<a name="l01627"></a>01627 
<a name="l01628"></a>01628         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01629"></a>01629         <span class="comment">//            dimensions                                            //</span>
<a name="l01630"></a>01630         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01631"></a>01631         sizeHalfBlock = 1LL &lt;&lt; (measureQubit);                       <span class="comment">// number of state vector elements to sum,</span>
<a name="l01632"></a>01632         <span class="comment">// and then the number to skip</span>
<a name="l01633"></a>01633         sizeBlock     = 2LL * sizeHalfBlock;                           <span class="comment">// size of blocks (pairs of measure and skip entries)</span>
<a name="l01634"></a>01634         
<a name="l01635"></a>01635         renorm=1/sqrt(totalProbability);
<a name="l01636"></a>01636         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecReal = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>;
<a name="l01637"></a>01637         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecImag = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l01638"></a>01638 
<a name="l01639"></a>01639 
<a name="l01640"></a>01640 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01641"></a>01641 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l01642"></a>01642 <span class="preprocessor">        default (none) \</span>
<a name="l01643"></a>01643 <span class="preprocessor">        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,renorm,outcome) \</span>
<a name="l01644"></a>01644 <span class="preprocessor">        private   (thisTask,thisBlock,index)</span>
<a name="l01645"></a>01645 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01646"></a>01646 <span class="preprocessor"></span>        {
<a name="l01647"></a>01647                 <span class="keywordflow">if</span> (outcome==0){
<a name="l01648"></a>01648                         <span class="comment">// measure qubit is 0</span>
<a name="l01649"></a>01649 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01650"></a>01650 <span class="preprocessor"></span><span class="preprocessor">                        # pragma omp for schedule  (static)</span>
<a name="l01651"></a>01651 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01652"></a>01652 <span class="preprocessor"></span>                        <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l01653"></a>01653                                 thisBlock = thisTask / sizeHalfBlock;
<a name="l01654"></a>01654                                 index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
<a name="l01655"></a>01655                                 stateVecReal[index]=stateVecReal[index]*renorm;
<a name="l01656"></a>01656                                 stateVecImag[index]=stateVecImag[index]*renorm;
<a name="l01657"></a>01657 
<a name="l01658"></a>01658                                 stateVecReal[index+sizeHalfBlock]=0;
<a name="l01659"></a>01659                                 stateVecImag[index+sizeHalfBlock]=0;
<a name="l01660"></a>01660                         }
<a name="l01661"></a>01661                 } <span class="keywordflow">else</span> {
<a name="l01662"></a>01662                         <span class="comment">// measure qubit is 1</span>
<a name="l01663"></a>01663 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01664"></a>01664 <span class="preprocessor"></span><span class="preprocessor">                        # pragma omp for schedule  (static)</span>
<a name="l01665"></a>01665 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01666"></a>01666 <span class="preprocessor"></span>                        <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l01667"></a>01667                                 thisBlock = thisTask / sizeHalfBlock;
<a name="l01668"></a>01668                                 index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
<a name="l01669"></a>01669                                 stateVecReal[index]=0;
<a name="l01670"></a>01670                                 stateVecImag[index]=0;
<a name="l01671"></a>01671 
<a name="l01672"></a>01672                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[index+sizeHalfBlock]*renorm;
<a name="l01673"></a>01673                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[index+sizeHalfBlock]*renorm;
<a name="l01674"></a>01674                         }
<a name="l01675"></a>01675                 }
<a name="l01676"></a>01676         }
<a name="l01677"></a>01677 
<a name="l01678"></a>01678 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae275b94c1a483dda43bf4ec947635605"></a><!-- doxytag: member="qubits_internal.h::phaseGate" ref="ae275b94c1a483dda43bf4ec947635605" args="(MultiQubit multiQubit, const int rotQubit, enum phaseGateType type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void phaseGate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rotQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="qubits_8h.html#a5739021c733cecc49647956b2f7338ea">phaseGateType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a single qubit by {{1,0},{0,p}} where p is a phase term determined by the type argument. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotQubit</em>&nbsp;</td><td>qubit to rotate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>the type of phase gate to apply -- one of {SIGMA_Z, S_GATE, T_GATE} </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits__env__local_8c_source.html#l00108">108</a> of file <a class="el" href="qubits__env__local_8c_source.html">qubits_env_local.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00040">MultiQubit::chunkId</a>, <a class="el" href="qubits__env__mpi_8c_source.html#l00145">chunkIsUpper()</a>, <a class="el" href="qubits__env__mpi_8c_source.html#l00206">halfMatrixBlockFitsInChunk()</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8c_source.html#l01230">phaseGateDistributed()</a>, and <a class="el" href="qubits_8c_source.html#l01144">phaseGateLocal()</a>.</p>

<p>Referenced by <a class="el" href="qubits_8c_source.html#l01291">sGate()</a>, <a class="el" href="qubits_8c_source.html#l01286">sigmaZ()</a>, and <a class="el" href="qubits_8c_source.html#l01296">tGate()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00109"></a>00109 {
<a name="l00110"></a>00110         <a class="code" href="qubits_8c.html#a6a736aeb3532898019fe7c27010edc6a" title="Rotate a single qubit by {{1,0},{0,p}} where p is a phase term determined by the...">phaseGateLocal</a>(multiQubit, rotQubit, type);
<a name="l00111"></a>00111 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a38a05c7e749e806b182ef3b89878bfc4"></a><!-- doxytag: member="qubits_internal.h::phaseGateDistributed" ref="a38a05c7e749e806b182ef3b89878bfc4" args="(MultiQubit multiQubit, const int rotQubit, enum phaseGateType type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void phaseGateDistributed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rotQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="qubits_8h.html#a5739021c733cecc49647956b2f7338ea">phaseGateType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a single qubit by {{1,0},{0,p}} where p is a phase term determined by the type argument. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotQubit</em>&nbsp;</td><td>qubit to rotate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>the type of phase gate to apply -- one of {SIGMA_Z, S_GATE, T_GATE} </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l01230">1230</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, <a class="el" href="precision_8h_source.html#l00021">REAL</a>, <a class="el" href="qubits_8h_source.html#l00055">S_GATE</a>, <a class="el" href="qubits_8h_source.html#l00055">SIGMA_Z</a>, <a class="el" href="qubits_8h_source.html#l00031">MultiQubit::stateVec</a>, and <a class="el" href="qubits_8h_source.html#l00055">T_GATE</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__mpi_8c_source.html#l00409">phaseGate()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01231"></a>01231 {
<a name="l01232"></a>01232         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> stateRealLo,stateImagLo;
<a name="l01233"></a>01233         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;         
<a name="l01234"></a>01234         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l01235"></a>01235 
<a name="l01236"></a>01236         <span class="comment">// test qubit valid</span>
<a name="l01237"></a>01237         assert (rotQubit &gt;= 0 &amp;&amp; rotQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l01238"></a>01238 
<a name="l01239"></a>01239         <span class="comment">// Can&apos;t use multiQubit.stateVec as a private OMP var</span>
<a name="l01240"></a>01240         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecReal = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>;
<a name="l01241"></a>01241         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecImag = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l01242"></a>01242 
<a name="l01243"></a>01243         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> recRoot2 = 1.0/sqrt(2);
<a name="l01244"></a>01244 
<a name="l01245"></a>01245 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01246"></a>01246 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l01247"></a>01247 <span class="preprocessor">        default  (none) \</span>
<a name="l01248"></a>01248 <span class="preprocessor">        shared   (stateVecReal,stateVecImag, recRoot2, type) \</span>
<a name="l01249"></a>01249 <span class="preprocessor">        private  (thisTask,stateRealLo,stateImagLo) </span>
<a name="l01250"></a>01250 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01251"></a>01251 <span class="preprocessor"></span>        {
<a name="l01252"></a>01252                 <span class="keywordflow">if</span> (type==<a class="code" href="qubits_8h.html#a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac">SIGMA_Z</a>){
<a name="l01253"></a>01253 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01254"></a>01254 <span class="preprocessor"></span><span class="preprocessor">                        # pragma omp for schedule (static)</span>
<a name="l01255"></a>01255 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01256"></a>01256 <span class="preprocessor"></span>                        <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l01257"></a>01257                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
<a name="l01258"></a>01258                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
<a name="l01259"></a>01259                         } 
<a name="l01260"></a>01260                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type==<a class="code" href="qubits_8h.html#a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f">S_GATE</a>){
<a name="l01261"></a>01261 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01262"></a>01262 <span class="preprocessor"></span><span class="preprocessor">                        # pragma omp for schedule (static)</span>
<a name="l01263"></a>01263 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01264"></a>01264 <span class="preprocessor"></span>                        <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l01265"></a>01265                                 stateRealLo = stateVecReal[thisTask];
<a name="l01266"></a>01266                                 stateImagLo = stateVecImag[thisTask];
<a name="l01267"></a>01267 
<a name="l01268"></a>01268                                 stateVecReal[thisTask] = -stateImagLo;
<a name="l01269"></a>01269                                 stateVecImag[thisTask] = stateRealLo;
<a name="l01270"></a>01270                         } 
<a name="l01271"></a>01271                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type==<a class="code" href="qubits_8h.html#a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab">T_GATE</a>){
<a name="l01272"></a>01272 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01273"></a>01273 <span class="preprocessor"></span><span class="preprocessor">                        # pragma omp for schedule (static)</span>
<a name="l01274"></a>01274 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01275"></a>01275 <span class="preprocessor"></span>                        <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l01276"></a>01276                                 stateRealLo = stateVecReal[thisTask];
<a name="l01277"></a>01277                                 stateImagLo = stateVecImag[thisTask];
<a name="l01278"></a>01278 
<a name="l01279"></a>01279                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo - stateImagLo);
<a name="l01280"></a>01280                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo + stateImagLo);
<a name="l01281"></a>01281                         } 
<a name="l01282"></a>01282                 } <span class="keywordflow">else</span> printf(<span class="stringliteral">&quot;Type %d is an invalid phase gate\n&quot;</span>, type);
<a name="l01283"></a>01283         }
<a name="l01284"></a>01284 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6a736aeb3532898019fe7c27010edc6a"></a><!-- doxytag: member="qubits_internal.h::phaseGateLocal" ref="a6a736aeb3532898019fe7c27010edc6a" args="(MultiQubit multiQubit, const int rotQubit, enum phaseGateType type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void phaseGateLocal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rotQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="qubits_8h.html#a5739021c733cecc49647956b2f7338ea">phaseGateType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a single qubit by {{1,0},{0,p}} where p is a phase term determined by the type argument. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotQubit</em>&nbsp;</td><td>qubit to rotate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>the type of phase gate to apply -- one of {SIGMA_Z, S_GATE, T_GATE} </td></tr>
  </table>
  </dd>
</dl>

<p><p>fix -- can i rewrite this to not use mod?</p>
<p>fix -- can i rewrite this to not use mod?</p>
<p>fix -- can i rewrite this to not use mod? </p>
</p>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l01144">1144</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, <a class="el" href="precision_8h_source.html#l00021">REAL</a>, <a class="el" href="qubits_8h_source.html#l00055">S_GATE</a>, <a class="el" href="qubits_8h_source.html#l00055">SIGMA_Z</a>, <a class="el" href="qubits_8h_source.html#l00031">MultiQubit::stateVec</a>, and <a class="el" href="qubits_8h_source.html#l00055">T_GATE</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__local_8c_source.html#l00108">phaseGate()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01145"></a>01145 {
<a name="l01146"></a>01146         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> sizeBlock, sizeHalfBlock;
<a name="l01147"></a>01147         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisBlock, <span class="comment">// current block</span>
<a name="l01148"></a>01148              indexUp,indexLo;    <span class="comment">// current index and corresponding index in lower half block</span>
<a name="l01149"></a>01149 
<a name="l01150"></a>01150         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> stateRealLo,stateImagLo;
<a name="l01151"></a>01151         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;         
<a name="l01152"></a>01152         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>&gt;&gt;1;
<a name="l01153"></a>01153 
<a name="l01154"></a>01154         <span class="comment">// test qubit valid</span>
<a name="l01155"></a>01155         assert (rotQubit &gt;= 0 &amp;&amp; rotQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l01156"></a>01156 
<a name="l01157"></a>01157         <span class="comment">// set dimensions</span>
<a name="l01158"></a>01158         sizeHalfBlock = 1LL &lt;&lt; rotQubit;  
<a name="l01159"></a>01159         sizeBlock     = 2LL * sizeHalfBlock; 
<a name="l01160"></a>01160 
<a name="l01161"></a>01161         <span class="comment">// Can&apos;t use multiQubit.stateVec as a private OMP var</span>
<a name="l01162"></a>01162         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecReal = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>;
<a name="l01163"></a>01163         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecImag = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l01164"></a>01164 
<a name="l01165"></a>01165         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> recRoot2 = 1.0/sqrt(2);
<a name="l01166"></a>01166 
<a name="l01167"></a>01167 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01168"></a>01168 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l01169"></a>01169 <span class="preprocessor">        default  (none) \</span>
<a name="l01170"></a>01170 <span class="preprocessor">        shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type) \</span>
<a name="l01171"></a>01171 <span class="preprocessor">        private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) </span>
<a name="l01172"></a>01172 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01173"></a>01173 <span class="preprocessor"></span>        {
<a name="l01174"></a>01174                 <span class="keywordflow">if</span> (type==<a class="code" href="qubits_8h.html#a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac">SIGMA_Z</a>){
<a name="l01175"></a>01175 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01176"></a>01176 <span class="preprocessor"></span><span class="preprocessor">                        # pragma omp for schedule (static)</span>
<a name="l01177"></a>01177 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01178"></a>01178 <span class="preprocessor"></span>                        <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l01180"></a>01180                                 thisBlock   = thisTask / sizeHalfBlock;
<a name="l01181"></a>01181                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
<a name="l01182"></a>01182                                 indexLo     = indexUp + sizeHalfBlock;
<a name="l01183"></a>01183 
<a name="l01184"></a>01184                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
<a name="l01185"></a>01185                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
<a name="l01186"></a>01186                         } 
<a name="l01187"></a>01187                 } 
<a name="l01188"></a>01188                 
<a name="l01189"></a>01189                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type==<a class="code" href="qubits_8h.html#a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f">S_GATE</a>){
<a name="l01190"></a>01190 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01191"></a>01191 <span class="preprocessor"></span><span class="preprocessor">                        # pragma omp for schedule (static)</span>
<a name="l01192"></a>01192 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01193"></a>01193 <span class="preprocessor"></span>                        <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l01195"></a>01195                                 thisBlock   = thisTask / sizeHalfBlock;
<a name="l01196"></a>01196                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
<a name="l01197"></a>01197                                 indexLo     = indexUp + sizeHalfBlock;
<a name="l01198"></a>01198                                 stateRealLo = stateVecReal[indexLo];
<a name="l01199"></a>01199                                 stateImagLo = stateVecImag[indexLo];
<a name="l01200"></a>01200 
<a name="l01201"></a>01201                                 stateVecReal[indexLo] = -stateImagLo;
<a name="l01202"></a>01202                                 stateVecImag[indexLo] = stateRealLo;
<a name="l01203"></a>01203                         } 
<a name="l01204"></a>01204                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type==<a class="code" href="qubits_8h.html#a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab">T_GATE</a>){
<a name="l01205"></a>01205 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01206"></a>01206 <span class="preprocessor"></span><span class="preprocessor">                        # pragma omp for schedule (static)</span>
<a name="l01207"></a>01207 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01208"></a>01208 <span class="preprocessor"></span>                        <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l01210"></a>01210                                 thisBlock   = thisTask / sizeHalfBlock;
<a name="l01211"></a>01211                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
<a name="l01212"></a>01212                                 indexLo     = indexUp + sizeHalfBlock;
<a name="l01213"></a>01213                                 stateRealLo = stateVecReal[indexLo];
<a name="l01214"></a>01214                                 stateImagLo = stateVecImag[indexLo];
<a name="l01215"></a>01215 
<a name="l01216"></a>01216                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo - stateImagLo);
<a name="l01217"></a>01217                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo + stateImagLo);
<a name="l01218"></a>01218                         } 
<a name="l01219"></a>01219                 } <span class="keywordflow">else</span> printf(<span class="stringliteral">&quot;Type %d is an invalid phase gate\n&quot;</span>, type);
<a name="l01220"></a>01220         }
<a name="l01221"></a>01221 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a096cddbac961f0651a084d2ceb905d1b"></a><!-- doxytag: member="qubits_internal.h::probOfFilterOut111Local" ref="a096cddbac961f0651a084d2ceb905d1b" args="(MultiQubit multiQubit, const int idQubit1, const int idQubit2, const int idQubit3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL probOfFilterOut111Local </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>idQubit1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>idQubit2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>idQubit3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluates the state according to this scenario: we ask "are these 3 qubits in 111" and the answer is "no". </p>
<p>The function returns the probability of this outcome across all amplitudes in this chunk (if zero, it will exit with error) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idQubit1,idQubit2,idQubit3</em>&nbsp;</td><td>specified qubits </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Total probability that the 3 qubits are not all in the 1 state. </dd></dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l01839">1839</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00040">MultiQubit::chunkId</a>, <a class="el" href="qubits_8c_source.html#l01450">extractBit()</a>, <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, <a class="el" href="precision_8h_source.html#l00021">REAL</a>, and <a class="el" href="qubits_8h_source.html#l00031">MultiQubit::stateVec</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__local_8c_source.html#l00147">probOfFilterOut111()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01840"></a>01840 {
<a name="l01841"></a>01841         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> index;
<a name="l01842"></a>01842         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> stateVecSize;
<a name="l01843"></a>01843         <span class="keywordtype">int</span> bit1, bit2, bit3;
<a name="l01844"></a>01844         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> chunkSize=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l01845"></a>01845         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> chunkId=multiQubit.<a class="code" href="structMultiQubit.html#ab10c88249fa3825d6227ceec01d37e37" title="The position of the chunk of the state vector held by this process in the full state...">chunkId</a>;
<a name="l01846"></a>01846 
<a name="l01847"></a>01847         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01848"></a>01848         <span class="comment">//            tests                                                 //</span>
<a name="l01849"></a>01849         <span class="comment">// ---------------------------------------------------------------- //</span>
<a name="l01850"></a>01850         assert (idQubit1 &gt;= 0 &amp;&amp; idQubit2 &gt;= 0 &amp;&amp; idQubit1 &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a> &amp;&amp; idQubit2 &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l01851"></a>01851 
<a name="l01852"></a>01852         stateVecSize = multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l01853"></a>01853         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> probOfFilter=0;
<a name="l01854"></a>01854         
<a name="l01855"></a>01855         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecReal = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>;
<a name="l01856"></a>01856         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecImag = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l01857"></a>01857 
<a name="l01858"></a>01858 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01859"></a>01859 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l01860"></a>01860 <span class="preprocessor">        default  (none)                      \</span>
<a name="l01861"></a>01861 <span class="preprocessor">        shared   (stateVecSize, stateVecReal,stateVecImag) \</span>
<a name="l01862"></a>01862 <span class="preprocessor">        private  (index,bit1,bit2,bit3)                \</span>
<a name="l01863"></a>01863 <span class="preprocessor">        reduction ( +:probOfFilter )</span>
<a name="l01864"></a>01864 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01865"></a>01865 <span class="preprocessor"></span>        {
<a name="l01866"></a>01866 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01867"></a>01867 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule (static)</span>
<a name="l01868"></a>01868 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01869"></a>01869 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (index=0; index&lt;stateVecSize; index++) {
<a name="l01870"></a>01870                         bit1 = <a class="code" href="qubits_8c.html#a100463f6ec212c76a5fad99579000505" title="Get the value of the bit at a particular index in a number.">extractBit</a> (idQubit1, index+chunkId*chunkSize);
<a name="l01871"></a>01871                         bit2 = <a class="code" href="qubits_8c.html#a100463f6ec212c76a5fad99579000505" title="Get the value of the bit at a particular index in a number.">extractBit</a> (idQubit2, index+chunkId*chunkSize);
<a name="l01872"></a>01872                         bit3 = <a class="code" href="qubits_8c.html#a100463f6ec212c76a5fad99579000505" title="Get the value of the bit at a particular index in a number.">extractBit</a> (idQubit3, index+chunkId*chunkSize);
<a name="l01873"></a>01873                         <span class="keywordflow">if</span> (!(bit1 &amp;&amp; bit2 &amp;&amp; bit3)) {
<a name="l01874"></a>01874                                 probOfFilter+= stateVecReal[index]*stateVecReal[index] + stateVecImag[index]* stateVecImag [index];
<a name="l01875"></a>01875                         }
<a name="l01876"></a>01876                 }
<a name="l01877"></a>01877         }
<a name="l01878"></a>01878         <span class="keywordflow">return</span> probOfFilter;
<a name="l01879"></a>01879 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6ff67d25363f39fd57a4e76621a4bfd5"></a><!-- doxytag: member="qubits_internal.h::rotateQubitDistributed" ref="a6ff67d25363f39fd57a4e76621a4bfd5" args="(MultiQubit multiQubit, const int rotQubit, Complex rot1, Complex rot2, ComplexArray stateVecUp, ComplexArray stateVecLo, ComplexArray stateVecOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rotateQubitDistributed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rotQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplex.html">Complex</a>&nbsp;</td>
          <td class="paramname"> <em>rot1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplex.html">Complex</a>&nbsp;</td>
          <td class="paramname"> <em>rot2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplexArray.html">ComplexArray</a>&nbsp;</td>
          <td class="paramname"> <em>stateVecUp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplexArray.html">ComplexArray</a>&nbsp;</td>
          <td class="paramname"> <em>stateVecLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplexArray.html">ComplexArray</a>&nbsp;</td>
          <td class="paramname"> <em>stateVecOut</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotQubit</em>&nbsp;</td><td>qubit to rotate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rot1</em>&nbsp;</td><td>rotation angle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rot2</em>&nbsp;</td><td>rotation angle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stateVecUp</em>&nbsp;</td><td>probability amplitudes in upper half of a block </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stateVecLo</em>&nbsp;</td><td>probability amplitudes in lower half of a block </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stateVecOut</em>&nbsp;</td><td>array section to update (will correspond to either the lower or upper half of a block) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l00472">472</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00022">Complex::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, <a class="el" href="qubits_8h_source.html#l00021">Complex::real</a>, and <a class="el" href="precision_8h_source.html#l00021">REAL</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__mpi_8c_source.html#l00245">rotateQubit()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00477"></a>00477 {
<a name="l00478"></a>00478 
<a name="l00479"></a>00479         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a>   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
<a name="l00480"></a>00480         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;  
<a name="l00481"></a>00481         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l00482"></a>00482 
<a name="l00483"></a>00483         <span class="comment">// test qubit valid</span>
<a name="l00484"></a>00484         assert (rotQubit &gt;= 0 &amp;&amp; rotQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l00485"></a>00485 
<a name="l00486"></a>00486         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> rot1Real=rot1.<a class="code" href="structComplex.html#a479ad939835457595fcca3ca55c06283">real</a>, rot1Imag=rot1.<a class="code" href="structComplex.html#a1151948284b21c0052f203f23ab931d9">imag</a>;
<a name="l00487"></a>00487         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> rot2Real=rot2.<a class="code" href="structComplex.html#a479ad939835457595fcca3ca55c06283">real</a>, rot2Imag=rot2.<a class="code" href="structComplex.html#a1151948284b21c0052f203f23ab931d9">imag</a>;
<a name="l00488"></a>00488         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecRealUp=stateVecUp.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>, *stateVecImagUp=stateVecUp.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l00489"></a>00489         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecRealLo=stateVecLo.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>, *stateVecImagLo=stateVecLo.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l00490"></a>00490         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecRealOut=stateVecOut.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>, *stateVecImagOut=stateVecOut.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00493"></a>00493 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l00494"></a>00494 <span class="preprocessor">        default  (none) \</span>
<a name="l00495"></a>00495 <span class="preprocessor">        shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \</span>
<a name="l00496"></a>00496 <span class="preprocessor">                        rot1Real,rot1Imag, rot2Real,rot2Imag) \</span>
<a name="l00497"></a>00497 <span class="preprocessor">        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)</span>
<a name="l00498"></a>00498 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00499"></a>00499 <span class="preprocessor"></span>        {
<a name="l00500"></a>00500 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00501"></a>00501 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule (static)</span>
<a name="l00502"></a>00502 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00503"></a>00503 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l00504"></a>00504                         <span class="comment">// store current state vector values in temp variables</span>
<a name="l00505"></a>00505                         stateRealUp = stateVecRealUp[thisTask];
<a name="l00506"></a>00506                         stateImagUp = stateVecImagUp[thisTask];
<a name="l00507"></a>00507 
<a name="l00508"></a>00508                         stateRealLo = stateVecRealLo[thisTask];
<a name="l00509"></a>00509                         stateImagLo = stateVecImagLo[thisTask];
<a name="l00510"></a>00510 
<a name="l00511"></a>00511                         <span class="comment">// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]</span>
<a name="l00512"></a>00512                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
<a name="l00513"></a>00513                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
<a name="l00514"></a>00514                 }
<a name="l00515"></a>00515         }
<a name="l00516"></a>00516 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="acb059cbcb8c7910a5fc43d21da4f5dea"></a><!-- doxytag: member="qubits_internal.h::rotateQubitLocal" ref="acb059cbcb8c7910a5fc43d21da4f5dea" args="(MultiQubit multiQubit, const int rotQubit, Complex alpha, Complex beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rotateQubitLocal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rotQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplex.html">Complex</a>&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplex.html">Complex</a>&nbsp;</td>
          <td class="paramname"> <em>beta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a single qubit in the state vector of probability amplitudes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotQubit</em>&nbsp;</td><td>qubit to rotate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>alpha</em>&nbsp;</td><td>rotation angle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>beta</em>&nbsp;</td><td>rotation angle </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l00397">397</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00022">Complex::imag</a>, <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00021">Complex::real</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, <a class="el" href="precision_8h_source.html#l00021">REAL</a>, and <a class="el" href="qubits_8h_source.html#l00031">MultiQubit::stateVec</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__local_8c_source.html#l00087">rotateQubit()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00398"></a>00398 {
<a name="l00399"></a>00399         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> sizeBlock, sizeHalfBlock;
<a name="l00400"></a>00400         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisBlock, <span class="comment">// current block</span>
<a name="l00401"></a>00401              indexUp,indexLo;    <span class="comment">// current index and corresponding index in lower half block</span>
<a name="l00402"></a>00402 
<a name="l00403"></a>00403         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> stateRealUp,stateRealLo,stateImagUp,stateImagLo;
<a name="l00404"></a>00404         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;         
<a name="l00405"></a>00405         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>&gt;&gt;1;
<a name="l00406"></a>00406 
<a name="l00407"></a>00407         <span class="comment">// test qubit valid</span>
<a name="l00408"></a>00408         assert (rotQubit &gt;= 0 &amp;&amp; rotQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l00409"></a>00409 
<a name="l00410"></a>00410         <span class="comment">// set dimensions</span>
<a name="l00411"></a>00411         sizeHalfBlock = 1LL &lt;&lt; rotQubit;  
<a name="l00412"></a>00412         sizeBlock     = 2LL * sizeHalfBlock; 
<a name="l00413"></a>00413 
<a name="l00414"></a>00414         <span class="comment">// Can&apos;t use multiQubit.stateVec as a private OMP var</span>
<a name="l00415"></a>00415         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecReal = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>;
<a name="l00416"></a>00416         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecImag = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l00417"></a>00417         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> alphaImag=alpha.<a class="code" href="structComplex.html#a1151948284b21c0052f203f23ab931d9">imag</a>, alphaReal=alpha.<a class="code" href="structComplex.html#a479ad939835457595fcca3ca55c06283">real</a>;
<a name="l00418"></a>00418         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> betaImag=beta.<a class="code" href="structComplex.html#a1151948284b21c0052f203f23ab931d9">imag</a>, betaReal=beta.<a class="code" href="structComplex.html#a479ad939835457595fcca3ca55c06283">real</a>;
<a name="l00419"></a>00419 
<a name="l00420"></a>00420 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00421"></a>00421 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l00422"></a>00422 <span class="preprocessor">        default  (none) \</span>
<a name="l00423"></a>00423 <span class="preprocessor">        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,alphaImag, betaReal,betaImag) \</span>
<a name="l00424"></a>00424 <span class="preprocessor">        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) </span>
<a name="l00425"></a>00425 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00426"></a>00426 <span class="preprocessor"></span>        {
<a name="l00427"></a>00427 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00428"></a>00428 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule (static)</span>
<a name="l00429"></a>00429 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00430"></a>00430 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l00431"></a>00431 
<a name="l00432"></a>00432                         thisBlock   = thisTask / sizeHalfBlock;
<a name="l00433"></a>00433                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
<a name="l00434"></a>00434                         indexLo     = indexUp + sizeHalfBlock;
<a name="l00435"></a>00435 
<a name="l00436"></a>00436                         <span class="comment">// store current state vector values in temp variables</span>
<a name="l00437"></a>00437                         stateRealUp = stateVecReal[indexUp];
<a name="l00438"></a>00438                         stateImagUp = stateVecImag[indexUp];
<a name="l00439"></a>00439 
<a name="l00440"></a>00440                         stateRealLo = stateVecReal[indexLo];
<a name="l00441"></a>00441                         stateImagLo = stateVecImag[indexLo];
<a name="l00442"></a>00442 
<a name="l00443"></a>00443                         <span class="comment">// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]</span>
<a name="l00444"></a>00444                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag*stateImagUp 
<a name="l00445"></a>00445                                 - betaReal*stateRealLo - betaImag*stateImagLo;
<a name="l00446"></a>00446                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag*stateRealUp 
<a name="l00447"></a>00447                                 - betaReal*stateImagLo + betaImag*stateRealLo;
<a name="l00448"></a>00448 
<a name="l00449"></a>00449                         <span class="comment">// state[indexLo] = beta  * state[indexUp] + conj(alpha) * state[indexLo]</span>
<a name="l00450"></a>00450                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*stateImagUp 
<a name="l00451"></a>00451                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
<a name="l00452"></a>00452                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*stateRealUp 
<a name="l00453"></a>00453                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
<a name="l00454"></a>00454                 } 
<a name="l00455"></a>00455         }
<a name="l00456"></a>00456 
<a name="l00457"></a>00457 } 
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5958808b2f2f05937921ba7dabe5a171"></a><!-- doxytag: member="qubits_internal.h::sigmaXDistributed" ref="a5958808b2f2f05937921ba7dabe5a171" args="(MultiQubit multiQubit, const int rotQubit, ComplexArray stateVecIn, ComplexArray stateVecOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sigmaXDistributed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rotQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplexArray.html">ComplexArray</a>&nbsp;</td>
          <td class="paramname"> <em>stateVecIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplexArray.html">ComplexArray</a>&nbsp;</td>
          <td class="paramname"> <em>stateVecOut</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a single qubit by {{0,1},{1,0}. </p>
<p>Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Qubits are zero-based and the the first qubit is the rightmost</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotQubit</em>&nbsp;</td><td>qubit to rotate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stateVecIn</em>&nbsp;</td><td>probability amplitudes in lower or upper half of a block depending on chunkId </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stateVecOut</em>&nbsp;</td><td>array section to update (will correspond to either the lower or upper half of a block) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l00751">751</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, and <a class="el" href="precision_8h_source.html#l00021">REAL</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__mpi_8c_source.html#l00320">sigmaX()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00754"></a>00754 {
<a name="l00755"></a>00755 
<a name="l00756"></a>00756         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;  
<a name="l00757"></a>00757         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l00758"></a>00758 
<a name="l00759"></a>00759         <span class="comment">// test qubit valid</span>
<a name="l00760"></a>00760         assert (rotQubit &gt;= 0 &amp;&amp; rotQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l00761"></a>00761 
<a name="l00762"></a>00762         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecRealIn=stateVecIn.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>, *stateVecImagIn=stateVecIn.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l00763"></a>00763         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecRealOut=stateVecOut.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>, *stateVecImagOut=stateVecOut.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l00764"></a>00764 
<a name="l00765"></a>00765 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00766"></a>00766 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l00767"></a>00767 <span class="preprocessor">        default  (none) \</span>
<a name="l00768"></a>00768 <span class="preprocessor">        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) \</span>
<a name="l00769"></a>00769 <span class="preprocessor">        private  (thisTask)</span>
<a name="l00770"></a>00770 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00771"></a>00771 <span class="preprocessor"></span>        {
<a name="l00772"></a>00772 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00773"></a>00773 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule (static)</span>
<a name="l00774"></a>00774 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00775"></a>00775 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l00776"></a>00776                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
<a name="l00777"></a>00777                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
<a name="l00778"></a>00778                 }
<a name="l00779"></a>00779         }
<a name="l00780"></a>00780 } 
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa9e640bb2d0458c937c6a87dfeca0f23"></a><!-- doxytag: member="qubits_internal.h::sigmaXLocal" ref="aa9e640bb2d0458c937c6a87dfeca0f23" args="(MultiQubit multiQubit, const int rotQubit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sigmaXLocal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rotQubit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a single qubit by {{0,1},{1,0}. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Qubits are zero-based and the the first qubit is the rightmost</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotQubit</em>&nbsp;</td><td>qubit to rotate </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l00688">688</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, <a class="el" href="precision_8h_source.html#l00021">REAL</a>, and <a class="el" href="qubits_8h_source.html#l00031">MultiQubit::stateVec</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__local_8c_source.html#l00098">sigmaX()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00689"></a>00689 {
<a name="l00690"></a>00690         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> sizeBlock, sizeHalfBlock;
<a name="l00691"></a>00691         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisBlock, <span class="comment">// current block</span>
<a name="l00692"></a>00692              indexUp,indexLo;    <span class="comment">// current index and corresponding index in lower half block</span>
<a name="l00693"></a>00693 
<a name="l00694"></a>00694         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> stateRealUp,stateImagUp;
<a name="l00695"></a>00695         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;         
<a name="l00696"></a>00696         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>&gt;&gt;1;
<a name="l00697"></a>00697 
<a name="l00698"></a>00698         <span class="comment">// test qubit valid</span>
<a name="l00699"></a>00699         assert (rotQubit &gt;= 0 &amp;&amp; rotQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l00700"></a>00700 
<a name="l00701"></a>00701         <span class="comment">// set dimensions</span>
<a name="l00702"></a>00702         sizeHalfBlock = 1LL &lt;&lt; rotQubit;  
<a name="l00703"></a>00703         sizeBlock     = 2LL * sizeHalfBlock; 
<a name="l00704"></a>00704 
<a name="l00705"></a>00705         <span class="comment">// Can&apos;t use multiQubit.stateVec as a private OMP var</span>
<a name="l00706"></a>00706         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecReal = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>;
<a name="l00707"></a>00707         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecImag = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l00708"></a>00708 
<a name="l00709"></a>00709 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00710"></a>00710 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l00711"></a>00711 <span class="preprocessor">        default  (none) \</span>
<a name="l00712"></a>00712 <span class="preprocessor">        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \</span>
<a name="l00713"></a>00713 <span class="preprocessor">        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) </span>
<a name="l00714"></a>00714 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00715"></a>00715 <span class="preprocessor"></span>        {
<a name="l00716"></a>00716 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00717"></a>00717 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule (static)</span>
<a name="l00718"></a>00718 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00719"></a>00719 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l00720"></a>00720                         thisBlock   = thisTask / sizeHalfBlock;
<a name="l00721"></a>00721                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
<a name="l00722"></a>00722                         indexLo     = indexUp + sizeHalfBlock;
<a name="l00723"></a>00723 
<a name="l00724"></a>00724                         stateRealUp = stateVecReal[indexUp];
<a name="l00725"></a>00725                         stateImagUp = stateVecImag[indexUp];
<a name="l00726"></a>00726 
<a name="l00727"></a>00727                         stateVecReal[indexUp] = stateVecReal[indexLo];
<a name="l00728"></a>00728                         stateVecImag[indexUp] = stateVecImag[indexLo];
<a name="l00729"></a>00729 
<a name="l00730"></a>00730                         stateVecReal[indexLo] = stateRealUp;
<a name="l00731"></a>00731                         stateVecImag[indexLo] = stateImagUp;
<a name="l00732"></a>00732                 } 
<a name="l00733"></a>00733         }
<a name="l00734"></a>00734 
<a name="l00735"></a>00735 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0471f6b547ce8270ef85170b7f4f0214"></a><!-- doxytag: member="qubits_internal.h::sigmaYDistributed" ref="a0471f6b547ce8270ef85170b7f4f0214" args="(MultiQubit multiQubit, const int rotQubit, ComplexArray stateVecIn, ComplexArray stateVecOut, int updateUpper)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sigmaYDistributed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rotQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplexArray.html">ComplexArray</a>&nbsp;</td>
          <td class="paramname"> <em>stateVecIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structComplexArray.html">ComplexArray</a>&nbsp;</td>
          <td class="paramname"> <em>stateVecOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>updateUpper</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a single qubit by {{0,-i},{i,0}. </p>
<p>Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Qubits are zero-based and the the first qubit is the rightmost</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotQubit</em>&nbsp;</td><td>qubit to rotate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stateVecIn</em>&nbsp;</td><td>probability amplitudes in lower or upper half of a block depending on chunkId </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>updateUpper</em>&nbsp;</td><td>flag, 1: updating upper values, 0: updating lower values in block </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stateVecOut</em>&nbsp;</td><td>array section to update (will correspond to either the lower or upper half of a block) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l00980">980</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, and <a class="el" href="precision_8h_source.html#l00021">REAL</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__mpi_8c_source.html#l00380">sigmaY()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00984"></a>00984 {
<a name="l00985"></a>00985 
<a name="l00986"></a>00986         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;  
<a name="l00987"></a>00987         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>;
<a name="l00988"></a>00988 
<a name="l00989"></a>00989         <span class="comment">// test qubit valid</span>
<a name="l00990"></a>00990         assert (rotQubit &gt;= 0 &amp;&amp; rotQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l00991"></a>00991 
<a name="l00992"></a>00992         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecRealIn=stateVecIn.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>, *stateVecImagIn=stateVecIn.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l00993"></a>00993         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecRealOut=stateVecOut.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>, *stateVecImagOut=stateVecOut.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l00994"></a>00994 
<a name="l00995"></a>00995         <span class="keywordtype">int</span> realSign=1, imagSign=1;
<a name="l00996"></a>00996         <span class="keywordflow">if</span> (updateUpper) imagSign=-1;
<a name="l00997"></a>00997         <span class="keywordflow">else</span> realSign = -1;
<a name="l00998"></a>00998 
<a name="l00999"></a>00999 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01000"></a>01000 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l01001"></a>01001 <span class="preprocessor">        default  (none) \</span>
<a name="l01002"></a>01002 <span class="preprocessor">        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,realSign,imagSign) \</span>
<a name="l01003"></a>01003 <span class="preprocessor">        private  (thisTask)</span>
<a name="l01004"></a>01004 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01005"></a>01005 <span class="preprocessor"></span>        {
<a name="l01006"></a>01006 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l01007"></a>01007 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule (static)</span>
<a name="l01008"></a>01008 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01009"></a>01009 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l01010"></a>01010                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisTask];
<a name="l01011"></a>01011                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisTask];
<a name="l01012"></a>01012                 }
<a name="l01013"></a>01013         }
<a name="l01014"></a>01014 } 
</pre></div></p>

</div>
</div>
<a class="anchor" id="afcbb1dcbe070ad0ed1a72a23251b6a83"></a><!-- doxytag: member="qubits_internal.h::sigmaYLocal" ref="afcbb1dcbe070ad0ed1a72a23251b6a83" args="(MultiQubit multiQubit, const int rotQubit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sigmaYLocal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMultiQubit.html">MultiQubit</a>&nbsp;</td>
          <td class="paramname"> <em>multiQubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rotQubit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a single qubit by {{0,-i},{i,0}. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Qubits are zero-based and the the first qubit is the rightmost</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>multiQubit</em>&nbsp;</td><td>object representing the set of qubits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotQubit</em>&nbsp;</td><td>qubit to rotate </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qubits_8c_source.html#l00917">917</a> of file <a class="el" href="qubits_8c_source.html">qubits.c</a>.</p>

<p>References <a class="el" href="qubits_8h_source.html#l00014">ComplexArray::imag</a>, <a class="el" href="qubits_8h_source.html#l00038">MultiQubit::numAmps</a>, <a class="el" href="qubits_8h_source.html#l00035">MultiQubit::numQubits</a>, <a class="el" href="qubits_8h_source.html#l00013">ComplexArray::real</a>, <a class="el" href="precision_8h_source.html#l00021">REAL</a>, and <a class="el" href="qubits_8h_source.html#l00031">MultiQubit::stateVec</a>.</p>

<p>Referenced by <a class="el" href="qubits__env__local_8c_source.html#l00103">sigmaY()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00918"></a>00918 {
<a name="l00919"></a>00919         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> sizeBlock, sizeHalfBlock;
<a name="l00920"></a>00920         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisBlock, <span class="comment">// current block</span>
<a name="l00921"></a>00921              indexUp,indexLo;    <span class="comment">// current index and corresponding index in lower half block</span>
<a name="l00922"></a>00922 
<a name="l00923"></a>00923         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> stateRealUp,stateImagUp;
<a name="l00924"></a>00924         <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> thisTask;         
<a name="l00925"></a>00925         <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> numTasks=multiQubit.<a class="code" href="structMultiQubit.html#ae16f47d8b725c914fb7f66b6498d79db" title="Number of probability amplitudes held in stateVec by this process In the non-MPI...">numAmps</a>&gt;&gt;1;
<a name="l00926"></a>00926 
<a name="l00927"></a>00927         <span class="comment">// test qubit valid</span>
<a name="l00928"></a>00928         assert (rotQubit &gt;= 0 &amp;&amp; rotQubit &lt; multiQubit.<a class="code" href="structMultiQubit.html#ab5b9795bdc6fb5855e1974dcbbaeb36f" title="Number of qubits in the state.">numQubits</a>);
<a name="l00929"></a>00929 
<a name="l00930"></a>00930         <span class="comment">// set dimensions</span>
<a name="l00931"></a>00931         sizeHalfBlock = 1LL &lt;&lt; rotQubit;  
<a name="l00932"></a>00932         sizeBlock     = 2LL * sizeHalfBlock; 
<a name="l00933"></a>00933 
<a name="l00934"></a>00934         <span class="comment">// Can&apos;t use multiQubit.stateVec as a private OMP var</span>
<a name="l00935"></a>00935         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecReal = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a4195cac6c784ea1b6271f1c7dba1548a">real</a>;
<a name="l00936"></a>00936         <a class="code" href="precision_8h.html#a4b654506f18b8bfd61ad2a29a7e38c25">REAL</a> *stateVecImag = multiQubit.<a class="code" href="structMultiQubit.html#a45483190d6b01ef6b2f98f2bec9ab94f" title="Probablilty amplitudes for the multi qubit state.">stateVec</a>.<a class="code" href="structComplexArray.html#a79dde47c7ae530c79cebfdf57b225968">imag</a>;
<a name="l00937"></a>00937 
<a name="l00938"></a>00938 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00939"></a>00939 <span class="preprocessor"></span><span class="preprocessor"># pragma omp parallel \</span>
<a name="l00940"></a>00940 <span class="preprocessor">        default  (none) \</span>
<a name="l00941"></a>00941 <span class="preprocessor">        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \</span>
<a name="l00942"></a>00942 <span class="preprocessor">        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) </span>
<a name="l00943"></a>00943 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00944"></a>00944 <span class="preprocessor"></span>        {
<a name="l00945"></a>00945 <span class="preprocessor"># ifdef _OPENMP</span>
<a name="l00946"></a>00946 <span class="preprocessor"></span><span class="preprocessor">                # pragma omp for schedule (static)</span>
<a name="l00947"></a>00947 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00948"></a>00948 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (thisTask=0; thisTask&lt;numTasks; thisTask++) {
<a name="l00949"></a>00949                         thisBlock   = thisTask / sizeHalfBlock;
<a name="l00950"></a>00950                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
<a name="l00951"></a>00951                         indexLo     = indexUp + sizeHalfBlock;
<a name="l00952"></a>00952 
<a name="l00953"></a>00953                         stateRealUp = stateVecReal[indexUp];
<a name="l00954"></a>00954                         stateImagUp = stateVecImag[indexUp];
<a name="l00955"></a>00955 
<a name="l00956"></a>00956                         stateVecReal[indexUp] = stateVecImag[indexLo];
<a name="l00957"></a>00957                         stateVecImag[indexUp] = -stateVecReal[indexLo];
<a name="l00958"></a>00958 
<a name="l00959"></a>00959                         stateVecReal[indexLo] = -stateImagUp;
<a name="l00960"></a>00960                         stateVecImag[indexLo] = stateRealUp;
<a name="l00961"></a>00961                 } 
<a name="l00962"></a>00962         }
<a name="l00963"></a>00963 }
</pre></div></p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 14 Nov 2017 for Distributed QuEST by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
