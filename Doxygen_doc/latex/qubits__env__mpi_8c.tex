\hypertarget{qubits__env__mpi_8c}{}\subsection{qubits\+\_\+env\+\_\+mpi.\+c File Reference}
\label{qubits__env__mpi_8c}\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}


An implementation of the A\+PI in \hyperlink{qubits_8h}{qubits.\+h} for an M\+PI environment.  


{\ttfamily \#include $<$unistd.\+h$>$}\\*
{\ttfamily \#include $<$mpi.\+h$>$}\\*
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$omp.\+h$>$}\\*
{\ttfamily \#include \char`\"{}precision.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}qubits.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}qubits\+\_\+internal.\+h\char`\"{}}\\*
\subsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}
\item 
\#define \hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{D\+E\+B\+UG}~0
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero} (int chunk\+Id, long long int chunk\+Size, int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Find chunks to skip when calculating probability of qubit being zero. \end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunk\+Is\+Upper} (int chunk\+Id, long long int chunk\+Size, int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Returns whether a given chunk in position chunk\+Id is in the upper or lower half of a block. \end{DoxyCompactList}\item 
static void \hyperlink{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{get\+Rot\+Angle} (int \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunk\+Is\+Upper}, \hyperlink{structComplex}{Complex} $\ast$rot1, \hyperlink{structComplex}{Complex} $\ast$rot2, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Get rotation values for a given chunk. \end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{get\+Chunk\+Pair\+Id} (int \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunk\+Is\+Upper}, int chunk\+Id, long long int chunk\+Size, int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em get position of corresponding chunk, holding values required to update values in my chunk (with chunk\+Id) when rotating rot\+Qubit. \end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{half\+Matrix\+Block\+Fits\+In\+Chunk} (long long int chunk\+Size, int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em return whether the current qubit rotation will use blocks that fit within a single chunk. \end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{get\+Chunk\+Id\+From\+Index} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, long long int index)
\item 
void \hyperlink{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}{init\+Qu\+E\+S\+T\+Env} (\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} $\ast$\hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Initialize Qu\+E\+ST environment. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{sync\+Qu\+E\+S\+T\+Env} (\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Guarantees that all code up to the given point has been executed on all nodes. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}{close\+Qu\+E\+S\+T\+Env} (\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Close Qu\+E\+ST environment. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}{report\+Qu\+E\+S\+T\+Env} (\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Report information about the Qu\+E\+ST environment. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}{report\+Node\+List} (\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env} \hyperlink{runTests_8c_a5fd8ba97fcae3408ae6221dfc3cc1f93}{env})
\begin{DoxyCompactList}\small\item\em Report a list of C\+PU hostnames and the rank that is running on each if running with M\+PI enabled and an error message otherwise. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}{get\+Real\+Amp\+El} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the real component of the probability amplitude at an index in the state vector. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}{get\+Imag\+Amp\+El} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the imaginary component of the probability amplitude at an index in the state vector. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}{calc\+Total\+Probability} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Calculate the probability of being in any state by taking the norm of the entire state vector. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchange\+State\+Vectors} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, int pair\+Rank)
\item 
void \hyperlink{qubits__env__mpi_8c_a4ba468aa69f812efd1f964e10a45ca2f}{rotate\+Qubit} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_abac5189a14bc12e79580ba0d75de796e}{control\+Rotate\+Qubit} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, const int control\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments and a control qubit. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_acda82bebb0a62f419eec9c1e0575daad}{sigmaX} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}\} -- swap $\vert$0$>$ and $\vert$1$>$. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a41f33b4f5f2bf697821591eb224cabb9}{control\+Not} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, const int control\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -- swap $\vert$0$>$ and $\vert$1$>$ and apply a phase of -\/i or i, only for elements when control qubit is 1. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a7b022c75cef77be046bd5d61e38a581e}{sigmaY} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -- swap $\vert$0$>$ and $\vert$1$>$ and apply a phase of -\/i or i. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ae275b94c1a483dda43bf4ec947635605}{phase\+Gate} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ad247d084dc7150893e9051a438a5807e}{hadamard} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2 -- turn a $\vert$0$>$ into a $\vert$+$>$ and a $\vert$1$>$ into a $\vert$-\/$>$. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{find\+Probability\+Of\+Outcome} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit, int outcome)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero or one state. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_a88605f373c2401760aab0e08719e08dd}{measure\+In\+State} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measure\+Qubit=0 or measure\+Qubit=1 according to the value of outcome. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_ae8fcabd3f22c6c9a9104e1807fb78f80}{filter\+Out111} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3)
\begin{DoxyCompactList}\small\item\em Updates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__env__mpi_8c_a909ba48b5a82c9f5c3a94d17a72b1aa3}{prob\+Of\+Filter\+Out111} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3)
\begin{DoxyCompactList}\small\item\em Evaluates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
An implementation of the A\+PI in \hyperlink{qubits_8h}{qubits.\+h} for an M\+PI environment. 



\subsubsection{Macro Definition Documentation}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE@{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}}
\index{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE@{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}{_BSD_SOURCE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define \+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}\hypertarget{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}{}\label{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}


Definition at line 5 of file qubits\+\_\+env\+\_\+mpi.\+c.

\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!D\+E\+B\+UG@{D\+E\+B\+UG}}
\index{D\+E\+B\+UG@{D\+E\+B\+UG}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{D\+E\+B\+UG}{DEBUG}}]{\setlength{\rightskip}{0pt plus 5cm}\#define D\+E\+B\+UG~0}\hypertarget{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{}\label{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}


Definition at line 17 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by calc\+Total\+Probability(), exchange\+State\+Vectors(), and init\+Qu\+E\+S\+T\+Env().



\subsubsection{Function Documentation}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!calc\+Total\+Probability@{calc\+Total\+Probability}}
\index{calc\+Total\+Probability@{calc\+Total\+Probability}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{calc\+Total\+Probability(\+Multi\+Qubit multi\+Qubit)}{calcTotalProbability(MultiQubit multiQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} calc\+Total\+Probability (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}{}\label{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}


Calculate the probability of being in any state by taking the norm of the entire state vector. 

Should be equal to 1. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing a set of qubits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
total probability 
\end{DoxyReturn}


Definition at line 101 of file qubits\+\_\+env\+\_\+mpi.\+c.



References chunk\+Is\+Upper(), D\+E\+B\+UG, Complex\+Array\+::imag, M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Chunks, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by main().


\begin{DoxyCode}
101                                                 \{
102   \textcolor{comment}{/* IJB - implemented using Kahan summation for greater accuracy at a slight floating}
103 \textcolor{comment}{     point operation overhead. For more details see https://en.wikipedia.org/wiki/Kahan\_summation\_algorithm
       */}
104   \textcolor{comment}{/* Don't change the bracketing in this routine! */}
105   \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} pTotal=0; 
106   \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} y, t, c;
107   \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} allRankTotals=0;
108   \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
109   \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numAmpsPerRank = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
110   c = 0.0;
111   \textcolor{keywordflow}{for} (index=0; index<numAmpsPerRank; index++)\{ 
112     \textcolor{comment}{/* Perform pTotal+=multiQubit.stateVec.real[index]*multiQubit.stateVec.real[index]; by Kahan */}
113     y = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[index]*multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.
      \hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[index] - c;
114     t = pTotal + y;
115     c = ( t - pTotal ) - y;
116     pTotal = t;
117     \textcolor{comment}{/* Perform pTotal+=multiQubit.stateVec.imag[index]*multiQubit.stateVec.imag[index]; by Kahan */}
118     y = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[index]*multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[index] - c;
119     t = pTotal + y;
120     c = ( t - pTotal ) - y;
121     pTotal = t;
122   \} 
123   \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"before calc prob. %d\(\backslash\)n"}, multiQubit.\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks});
124   \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks}>1) MPI\_Allreduce(&pTotal, &allRankTotals, 1, 
      \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, MPI\_SUM, MPI\_COMM\_WORLD);
125   \textcolor{keywordflow}{else} allRankTotals=pTotal;
126   
127   \textcolor{keywordflow}{return} allRankTotals;
128 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!chunk\+Is\+Upper@{chunk\+Is\+Upper}}
\index{chunk\+Is\+Upper@{chunk\+Is\+Upper}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{chunk\+Is\+Upper(int chunk\+Id, long long int chunk\+Size, int rot\+Qubit)}{chunkIsUpper(int chunkId, long long int chunkSize, int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}static int chunk\+Is\+Upper (
\begin{DoxyParamCaption}
\item[{int}]{chunk\+Id, }
\item[{long long int}]{chunk\+Size, }
\item[{int}]{rot\+Qubit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{}\label{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}


Returns whether a given chunk in position chunk\+Id is in the upper or lower half of a block. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Id} & id of chunk in state vector \\
\hline
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit being rotated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1\+: chunk is in upper half of block, 0\+: chunk is in lower half of block fix -- is this the same as is\+Chunk\+To\+Skip? 
\end{DoxyReturn}


Definition at line 139 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by calc\+Total\+Probability(), control\+Not(), control\+Rotate\+Qubit(), hadamard(), phase\+Gate(), rotate\+Qubit(), sigma\+X(), and sigma\+Y().


\begin{DoxyCode}
140 \{       
141         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (rotQubit);
142         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock = sizeHalfBlock*2;
143         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} posInBlock = (chunkId*chunkSize) % sizeBlock;
144         \textcolor{keywordflow}{return} posInBlock<sizeHalfBlock;
145 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!close\+Qu\+E\+S\+T\+Env@{close\+Qu\+E\+S\+T\+Env}}
\index{close\+Qu\+E\+S\+T\+Env@{close\+Qu\+E\+S\+T\+Env}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{close\+Qu\+E\+S\+T\+Env(\+Qu\+E\+S\+T\+Env env)}{closeQuESTEnv(QuESTEnv env)}}]{\setlength{\rightskip}{0pt plus 5cm}void close\+Qu\+E\+S\+T\+Env (
\begin{DoxyParamCaption}
\item[{{\bf Qu\+E\+S\+T\+Env}}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}{}\label{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}


Close Qu\+E\+ST environment. 

If something needs to be done to clean up the execution environment, such as finalizing M\+PI when running in distributed mode, it is handled here 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 49 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by main().


\begin{DoxyCode}
49                                 \{
50         \textcolor{keywordtype}{int} finalized;
51         MPI\_Finalized(&finalized);
52         \textcolor{keywordflow}{if} (!finalized) MPI\_Finalize();
53         \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"ERROR: Trying to close QuESTEnv multiple times. Ignoring\(\backslash\)n"});
54 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!control\+Not@{control\+Not}}
\index{control\+Not@{control\+Not}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{control\+Not(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, const int control\+Qubit)}{controlNot(MultiQubit multiQubit, const int rotQubit, const int controlQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void control\+Not (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{target\+Qubit, }
\item[{const int}]{control\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a41f33b4f5f2bf697821591eb224cabb9}{}\label{qubits__env__mpi_8c_a41f33b4f5f2bf697821591eb224cabb9}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -- swap $\vert$0$>$ and $\vert$1$>$ and apply a phase of -\/i or i, only for elements when control qubit is 1. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & perform sigmaX rotation if this qubit is 1 \\
\hline
\end{DoxyParams}


Definition at line 341 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), control\+Not\+Distributed(), control\+Not\+Local(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::pair\+State\+Vec, and Multi\+Qubit\+::state\+Vec.



Referenced by main(), and test\+\_\+control\+Not().


\begin{DoxyCode}
342 \{
343         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
344         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
345 
346         \textcolor{comment}{// rank's chunk is in upper half of block }
347         \textcolor{keywordtype}{int} rankIsUpper;
348         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
349 
350         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
351                 \textcolor{comment}{// all values required to update state vector lie in this rank}
352                 \hyperlink{qubits_8c_a2901e2e5531cb77f87ea54b3fc28f51a}{controlNotLocal}(multiQubit, rotQubit, controlQubit);
353         \} \textcolor{keywordflow}{else} \{
354                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
355                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
356                 pairRank = \hyperlink{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
357                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
358                 \textcolor{comment}{// get corresponding values from my pair}
359                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
360                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. send values to
       rotateQubitDistributed}
361                 \textcolor{comment}{// in the correct order}
362                 \textcolor{keywordflow}{if} (rankIsUpper)\{
363                         \hyperlink{qubits_8c_a774dd1217fcc3591a74a74d5667afa29}{controlNotDistributed}(multiQubit,rotQubit,controlQubit,
364                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//in}
365                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//out}
366                 \} \textcolor{keywordflow}{else} \{
367                         \hyperlink{qubits_8c_a774dd1217fcc3591a74a74d5667afa29}{controlNotDistributed}(multiQubit,rotQubit,controlQubit,
368                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//in}
369                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//out}
370                 \}
371         \}
372 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!control\+Rotate\+Qubit@{control\+Rotate\+Qubit}}
\index{control\+Rotate\+Qubit@{control\+Rotate\+Qubit}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{control\+Rotate\+Qubit(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, const int control\+Qubit, Complex alpha, Complex beta)}{controlRotateQubit(MultiQubit multiQubit, const int rotQubit, const int controlQubit, Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}void control\+Rotate\+Qubit (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{const int}]{control\+Qubit, }
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_abac5189a14bc12e79580ba0d75de796e}{}\label{qubits__env__mpi_8c_abac5189a14bc12e79580ba0d75de796e}


Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments and a control qubit. 

Only perform the rotation for elements where the control qubit is 1. alpha\+Re = cos(angle1) $\ast$ cos(angle2) ~\newline
alpha\+Im = cos(angle1) $\ast$ sin(angle2) ~\newline
 beta\+Re = sin(angle1) $\ast$ cos(angle3) ~\newline
 beta\+Im = sin(angle1) $\ast$ sin(angle3) ~\newline


\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & perform rotation if this qubit is 1 \\
\hline
\mbox{\tt in}  & {\em alpha} & rotation angle \\
\hline
\mbox{\tt in}  & {\em beta} & rotation angle \\
\hline
\end{DoxyParams}


Definition at line 276 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), control\+Rotate\+Qubit\+Distributed(), control\+Rotate\+Qubit\+Local(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), get\+Rot\+Angle(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::pair\+State\+Vec, and Multi\+Qubit\+::state\+Vec.



Referenced by main().


\begin{DoxyCode}
277 \{
278         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
279         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
280         \hyperlink{structComplex}{Complex} rot1, rot2;
281 
282         \textcolor{comment}{// rank's chunk is in upper half of block }
283         \textcolor{keywordtype}{int} rankIsUpper;
284         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
285 
286         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
287                 \textcolor{comment}{// all values required to update state vector lie in this rank}
288                 \hyperlink{qubits_8c_a824d71bae93236d8a3cd43589044eaee}{controlRotateQubitLocal}(multiQubit, rotQubit, controlQubit, alpha, 
      beta);
289         \} \textcolor{keywordflow}{else} \{
290                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
291                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
292                 \hyperlink{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{getRotAngle}(rankIsUpper, &rot1, &rot2, alpha, beta);
293                 pairRank = \hyperlink{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
294                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
295                 \textcolor{comment}{// get corresponding values from my pair}
296                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
297                 
298                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. send values to
       rotateQubitDistributed}
299                 \textcolor{comment}{// in the correct order}
300                 \textcolor{keywordflow}{if} (rankIsUpper)\{
301                         \hyperlink{qubits_8c_ab22d031e2507f1d859292103a99e2378}{controlRotateQubitDistributed}(multiQubit,rotQubit,
      controlQubit,rot1,rot2,
302                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//upper}
303                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//lower}
304                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
305                 \} \textcolor{keywordflow}{else} \{
306                         \hyperlink{qubits_8c_ab22d031e2507f1d859292103a99e2378}{controlRotateQubitDistributed}(multiQubit,rotQubit,
      controlQubit,rot1,rot2,
307                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//upper}
308                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//lower}
309                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
310                 \}
311         \}
312 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!exchange\+State\+Vectors@{exchange\+State\+Vectors}}
\index{exchange\+State\+Vectors@{exchange\+State\+Vectors}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{exchange\+State\+Vectors(\+Multi\+Qubit multi\+Qubit, int pair\+Rank)}{exchangeStateVectors(MultiQubit multiQubit, int pairRank)}}]{\setlength{\rightskip}{0pt plus 5cm}void exchange\+State\+Vectors (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{int}]{pair\+Rank}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{}\label{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}


Definition at line 207 of file qubits\+\_\+env\+\_\+mpi.\+c.



References D\+E\+B\+UG, Complex\+Array\+::imag, M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::pair\+State\+Vec, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by control\+Not(), control\+Rotate\+Qubit(), hadamard(), rotate\+Qubit(), sigma\+X(), and sigma\+Y().


\begin{DoxyCode}
207                                                               \{
208         \textcolor{comment}{// MPI send/receive vars}
209         \textcolor{keywordtype}{int} TAG=100;
210         MPI\_Status status;
211 
212         \textcolor{comment}{// Multiple messages are required as MPI uses int rather than long long int for count}
213         \textcolor{comment}{// For openmpi, messages are further restricted to 2GB in size -- do this for all cases}
214         \textcolor{comment}{// to be safe}
215         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} maxMessageCount = 1LL<<29;
216         \textcolor{keywordflow}{if} (\textcolor{keyword}{sizeof}(\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL})==8) maxMessageCount = (1LL<<28);
217         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\textcolor{keyword}{sizeof}(\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL})==16) maxMessageCount = (1LL<<27);
218 
219         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}<maxMessageCount) maxMessageCount = multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
220         \textcolor{keywordtype}{int} numMessages = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}/maxMessageCount;
221         \textcolor{keywordtype}{int} i;
222         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} offset;
223         \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"numMessages %d maxMessageCount %lld\(\backslash\)n"}, numMessages, maxMessageCount);
224 
225         \textcolor{comment}{// send my state vector to pairRank's multiQubit.pairStateVec}
226         \textcolor{comment}{// receive pairRank's state vector into multiQubit.pairStateVec}
227         \textcolor{keywordflow}{for} (i=0; i<numMessages; i++)\{
228                 offset = i*maxMessageCount;
229                 MPI\_Sendrecv(&multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[offset], maxMessageCount, 
      \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, pairRank, TAG,
230                                  &multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[offset], maxMessageCount, 
      \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL},
231                                  pairRank, TAG, MPI\_COMM\_WORLD, &status);
232                 \textcolor{comment}{//printf("rank: %d err: %d\(\backslash\)n", multiQubit.rank, err);}
233                 MPI\_Sendrecv(&multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[offset], maxMessageCount, 
      \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, pairRank, TAG,
234                                 &multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[offset], maxMessageCount, 
      \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL},
235                                 pairRank, TAG, MPI\_COMM\_WORLD, &status);
236         \}
237 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!filter\+Out111@{filter\+Out111}}
\index{filter\+Out111@{filter\+Out111}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{filter\+Out111(\+Multi\+Qubit multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3)}{filterOut111(MultiQubit multiQubit, const int idQubit1, const int idQubit2, const int idQubit3)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} filter\+Out111 (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{id\+Qubit1, }
\item[{const int}]{id\+Qubit2, }
\item[{const int}]{id\+Qubit3}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_ae8fcabd3f22c6c9a9104e1807fb78f80}{}\label{qubits__env__mpi_8c_ae8fcabd3f22c6c9a9104e1807fb78f80}


Updates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. 

The function returns the probability of this outcome (if zero, it will exit with error) 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3} & specified qubits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Total probability that the 3 qubits are not all in the 1 state. 
\end{DoxyReturn}


Definition at line 513 of file qubits\+\_\+env\+\_\+mpi.\+c.



References filter\+Out111\+Local(), prob\+Of\+Filter\+Out111(), and R\+E\+AL.



Referenced by main().


\begin{DoxyCode}
514 \{
515         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateProb=0;
516         stateProb = \hyperlink{qubits__env__mpi_8c_a909ba48b5a82c9f5c3a94d17a72b1aa3}{probOfFilterOut111}(multiQubit, idQubit1, idQubit2, idQubit3);
517         \hyperlink{qubits_8c_a2d73fd11c1d154640dbf114da8f34c64}{filterOut111Local}(multiQubit, idQubit1, idQubit2, idQubit3, stateProb);
518         \textcolor{keywordflow}{return} stateProb;
519 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!find\+Probability\+Of\+Outcome@{find\+Probability\+Of\+Outcome}}
\index{find\+Probability\+Of\+Outcome@{find\+Probability\+Of\+Outcome}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{find\+Probability\+Of\+Outcome(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit, int outcome)}{findProbabilityOfOutcome(MultiQubit multiQubit, const int measureQubit, int outcome)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} find\+Probability\+Of\+Outcome (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit, }
\item[{int}]{outcome}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{}\label{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}


Measure the probability of a specified qubit being in the zero or one state. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em outcome} & to measure the probability of -- either zero or one \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being either zero or one 
\end{DoxyReturn}


Definition at line 476 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, find\+Probability\+Of\+Zero\+Distributed(), find\+Probability\+Of\+Zero\+Local(), half\+Matrix\+Block\+Fits\+In\+Chunk(), is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero(), M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps, and R\+E\+AL.



Referenced by main(), and measure\+In\+State().


\begin{DoxyCode}
477 \{
478         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateProb=0, totalStateProb=0;
479         \textcolor{keywordtype}{int} skipValuesWithinRank = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, measureQubit);
480         \textcolor{keywordflow}{if} (skipValuesWithinRank) \{
481                 stateProb = \hyperlink{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}{findProbabilityOfZeroLocal}(multiQubit, measureQubit);
482         \} \textcolor{keywordflow}{else} \{
483                 \textcolor{keywordflow}{if} (!\hyperlink{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{isChunkToSkipInFindPZero}(multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, measureQubit))\{
484                         stateProb = \hyperlink{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}{findProbabilityOfZeroDistributed}(
      multiQubit, measureQubit);
485                 \} \textcolor{keywordflow}{else} stateProb = 0;
486         \}
487         MPI\_Allreduce(&stateProb, &totalStateProb, 1, \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, MPI\_SUM, MPI\_COMM\_WORLD
      );
488         \textcolor{keywordflow}{if} (outcome==1) totalStateProb = 1.0 - totalStateProb;
489         \textcolor{keywordflow}{return} totalStateProb;
490 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Chunk\+Id\+From\+Index@{get\+Chunk\+Id\+From\+Index}}
\index{get\+Chunk\+Id\+From\+Index@{get\+Chunk\+Id\+From\+Index}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{get\+Chunk\+Id\+From\+Index(\+Multi\+Qubit multi\+Qubit, long long int index)}{getChunkIdFromIndex(MultiQubit multiQubit, long long int index)}}]{\setlength{\rightskip}{0pt plus 5cm}int get\+Chunk\+Id\+From\+Index (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{long long int}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{}\label{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}


Definition at line 77 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::num\+Amps.



Referenced by get\+Imag\+Amp\+El(), and get\+Real\+Amp\+El().


\begin{DoxyCode}
77                                                                    \{
78         \textcolor{keywordflow}{return} index/multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}; \textcolor{comment}{// this is numAmpsPerChunk}
79 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Chunk\+Pair\+Id@{get\+Chunk\+Pair\+Id}}
\index{get\+Chunk\+Pair\+Id@{get\+Chunk\+Pair\+Id}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{get\+Chunk\+Pair\+Id(int chunk\+Is\+Upper, int chunk\+Id, long long int chunk\+Size, int rot\+Qubit)}{getChunkPairId(int chunkIsUpper, int chunkId, long long int chunkSize, int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}static int get\+Chunk\+Pair\+Id (
\begin{DoxyParamCaption}
\item[{int}]{chunk\+Is\+Upper, }
\item[{int}]{chunk\+Id, }
\item[{long long int}]{chunk\+Size, }
\item[{int}]{rot\+Qubit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{}\label{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}


get position of corresponding chunk, holding values required to update values in my chunk (with chunk\+Id) when rotating rot\+Qubit. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Is\+Upper} & 1\+: chunk is in upper half of block, 0\+: chunk is in lower half \\
\hline
\mbox{\tt in}  & {\em chunk\+Id} & id of chunk in state vector \\
\hline
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit being rotated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
chunk\+Id of chunk required to rotate rot\+Qubit 
\end{DoxyReturn}


Definition at line 181 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by control\+Not(), control\+Rotate\+Qubit(), hadamard(), rotate\+Qubit(), sigma\+X(), and sigma\+Y().


\begin{DoxyCode}
182 \{
183         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (rotQubit);
184         \textcolor{keywordtype}{int} chunksPerHalfBlock = sizeHalfBlock/chunkSize;
185         \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper})\{
186                 \textcolor{keywordflow}{return} chunkId + chunksPerHalfBlock;
187         \} \textcolor{keywordflow}{else} \{
188                 \textcolor{keywordflow}{return} chunkId - chunksPerHalfBlock;
189         \}
190 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Imag\+Amp\+El@{get\+Imag\+Amp\+El}}
\index{get\+Imag\+Amp\+El@{get\+Imag\+Amp\+El}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{get\+Imag\+Amp\+El(\+Multi\+Qubit multi\+Qubit, long long int index)}{getImagAmpEl(MultiQubit multiQubit, long long int index)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} get\+Imag\+Amp\+El (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{long long int}]{index}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}{}\label{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}


Get the imaginary component of the probability amplitude at an index in the state vector. 

For debugging purposes. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing a set of qubits \\
\hline
\mbox{\tt in}  & {\em index} & index in state vector of probability amplitudes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
imaginary component at that index 
\end{DoxyReturn}


Definition at line 91 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, get\+Chunk\+Id\+From\+Index(), Complex\+Array\+::imag, M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by get\+Prob\+El().


\begin{DoxyCode}
91                                                              \{
92         \textcolor{keywordtype}{int} chunkId = \hyperlink{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{getChunkIdFromIndex}(multiQubit, index);
93         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} el; 
94         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}==chunkId)\{
95                 el = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}[index-chunkId*multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}];
96         \}
97         MPI\_Bcast(&el, 1, \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, chunkId, MPI\_COMM\_WORLD);
98         \textcolor{keywordflow}{return} el; 
99 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Real\+Amp\+El@{get\+Real\+Amp\+El}}
\index{get\+Real\+Amp\+El@{get\+Real\+Amp\+El}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{get\+Real\+Amp\+El(\+Multi\+Qubit multi\+Qubit, long long int index)}{getRealAmpEl(MultiQubit multiQubit, long long int index)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} get\+Real\+Amp\+El (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{long long int}]{index}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}{}\label{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}


Get the real component of the probability amplitude at an index in the state vector. 

For debugging purposes. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing a set of qubits \\
\hline
\mbox{\tt in}  & {\em index} & index in state vector of probability amplitudes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
real component at that index 
\end{DoxyReturn}


Definition at line 81 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, get\+Chunk\+Id\+From\+Index(), M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by get\+Prob\+El(), and main().


\begin{DoxyCode}
81                                                              \{
82         \textcolor{keywordtype}{int} chunkId = \hyperlink{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{getChunkIdFromIndex}(multiQubit, index);
83         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} el; 
84         \textcolor{keywordflow}{if} (multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}==chunkId)\{
85                 el = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}[index-chunkId*multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}];
86         \}
87         MPI\_Bcast(&el, 1, \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, chunkId, MPI\_COMM\_WORLD);
88         \textcolor{keywordflow}{return} el; 
89 \} 
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!get\+Rot\+Angle@{get\+Rot\+Angle}}
\index{get\+Rot\+Angle@{get\+Rot\+Angle}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{get\+Rot\+Angle(int chunk\+Is\+Upper, Complex $\ast$rot1, Complex $\ast$rot2, Complex alpha, Complex beta)}{getRotAngle(int chunkIsUpper, Complex *rot1, Complex *rot2, Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}static void get\+Rot\+Angle (
\begin{DoxyParamCaption}
\item[{int}]{chunk\+Is\+Upper, }
\item[{{\bf Complex} $\ast$}]{rot1, }
\item[{{\bf Complex} $\ast$}]{rot2, }
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{}\label{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}


Get rotation values for a given chunk. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Is\+Upper} & 1\+: chunk is in upper half of block, 0\+: chunk is in lower half\\
\hline
\mbox{\tt out}  & {\em rot1,rot2} & rotation values to use, allocated for upper/lower such that \begin{DoxyVerb}stateUpper = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 or \begin{DoxyVerb}stateLower = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 \\
\hline
\mbox{\tt in}  & {\em alpha,beta} & initial rotation values \\
\hline
\end{DoxyParams}


Definition at line 160 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Complex\+::imag, and Complex\+::real.



Referenced by control\+Rotate\+Qubit(), and rotate\+Qubit().


\begin{DoxyCode}
161 \{
162         \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper})\{
163                 *rot1=alpha;
164                 rot2->\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}=-beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
165                 rot2->\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}=-beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
166         \} \textcolor{keywordflow}{else} \{
167                 *rot1=beta;
168                 *rot2=alpha;
169         \}
170 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!hadamard@{hadamard}}
\index{hadamard@{hadamard}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{hadamard(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit)}{hadamard(MultiQubit multiQubit, const int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void hadamard (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_ad247d084dc7150893e9051a438a5807e}{}\label{qubits__env__mpi_8c_ad247d084dc7150893e9051a438a5807e}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2 -- turn a $\vert$0$>$ into a $\vert$+$>$ and a $\vert$1$>$ into a $\vert$-\/$>$. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}


Definition at line 420 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), hadamard\+Distributed(), hadamard\+Local(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::pair\+State\+Vec, and Multi\+Qubit\+::state\+Vec.



Referenced by main(), and test\+\_\+hadamard().


\begin{DoxyCode}
421 \{
422         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
423         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
424 
425         \textcolor{comment}{// rank's chunk is in upper half of block }
426         \textcolor{keywordtype}{int} rankIsUpper;
427         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
428 
429         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
430                 \textcolor{comment}{// all values required to update state vector lie in this rank}
431                 \hyperlink{qubits_8c_a0711416fceaf63c67b496e123e845c69}{hadamardLocal}(multiQubit, rotQubit);
432         \} \textcolor{keywordflow}{else} \{
433                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
434                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
435                 pairRank = \hyperlink{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
436                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
437                 \textcolor{comment}{// get corresponding values from my pair}
438                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
439                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. send values to
       rotateQubitDistributed}
440                 \textcolor{comment}{// in the correct order}
441                 \textcolor{keywordflow}{if} (rankIsUpper)\{
442                         \hyperlink{qubits_8c_ac835c194bd547240a35f0b028db1d658}{hadamardDistributed}(multiQubit,rotQubit,
443                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//upper}
444                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//lower}
445                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, rankIsUpper); \textcolor{comment}{//output}
446                 \} \textcolor{keywordflow}{else} \{
447                         \hyperlink{qubits_8c_ac835c194bd547240a35f0b028db1d658}{hadamardDistributed}(multiQubit,rotQubit,
448                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//upper}
449                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//lower}
450                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, rankIsUpper); \textcolor{comment}{//output}
451                 \}
452         \}
453 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!half\+Matrix\+Block\+Fits\+In\+Chunk@{half\+Matrix\+Block\+Fits\+In\+Chunk}}
\index{half\+Matrix\+Block\+Fits\+In\+Chunk@{half\+Matrix\+Block\+Fits\+In\+Chunk}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{half\+Matrix\+Block\+Fits\+In\+Chunk(long long int chunk\+Size, int rot\+Qubit)}{halfMatrixBlockFitsInChunk(long long int chunkSize, int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}static int half\+Matrix\+Block\+Fits\+In\+Chunk (
\begin{DoxyParamCaption}
\item[{long long int}]{chunk\+Size, }
\item[{int}]{rot\+Qubit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{}\label{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}


return whether the current qubit rotation will use blocks that fit within a single chunk. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit being rotated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1\+: one chunk fits in one block 0\+: chunk is larger than block 
\end{DoxyReturn}


Definition at line 200 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by control\+Not(), control\+Rotate\+Qubit(), find\+Probability\+Of\+Outcome(), hadamard(), measure\+In\+State(), phase\+Gate(), rotate\+Qubit(), sigma\+X(), and sigma\+Y().


\begin{DoxyCode}
201 \{
202         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (rotQubit);
203         \textcolor{keywordflow}{if} (chunkSize > sizeHalfBlock) \textcolor{keywordflow}{return} 1;
204         \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} 0;
205 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!init\+Qu\+E\+S\+T\+Env@{init\+Qu\+E\+S\+T\+Env}}
\index{init\+Qu\+E\+S\+T\+Env@{init\+Qu\+E\+S\+T\+Env}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{init\+Qu\+E\+S\+T\+Env(\+Qu\+E\+S\+T\+Env $\ast$env)}{initQuESTEnv(QuESTEnv *env)}}]{\setlength{\rightskip}{0pt plus 5cm}void init\+Qu\+E\+S\+T\+Env (
\begin{DoxyParamCaption}
\item[{{\bf Qu\+E\+S\+T\+Env} $\ast$}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}{}\label{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}


Initialize Qu\+E\+ST environment. 

If something needs to be done to set up the execution environment, such as initializing M\+PI when running in distributed mode, it is handled here 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 25 of file qubits\+\_\+env\+\_\+mpi.\+c.



References D\+E\+B\+UG, Qu\+E\+S\+T\+Env\+::num\+Ranks, and Qu\+E\+S\+T\+Env\+::rank.



Referenced by main().


\begin{DoxyCode}
25                                 \{
26         \textcolor{comment}{// init MPI environment}
27         \textcolor{keywordtype}{int} rank, numRanks, initialized;
28         MPI\_Initialized(&initialized);
29         \textcolor{keywordflow}{if} (!initialized)\{
30                 MPI\_Init(NULL, NULL);
31                 MPI\_Comm\_size(MPI\_COMM\_WORLD, &numRanks);
32                 MPI\_Comm\_rank(MPI\_COMM\_WORLD, &rank);
33 
34                 \textcolor{keywordflow}{if} (\hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) \{
35                         \textcolor{keywordtype}{char} hostName[256];
36                         \textcolor{keywordtype}{int} hostNameLen;
37                         MPI\_Get\_processor\_name(hostName, &hostNameLen);
38                         printf(\textcolor{stringliteral}{"rank %d on host %s\(\backslash\)n"}, rank, hostName);
39                 \}
40                 env->\hyperlink{structQuESTEnv_aa648bb336cf8598467cb62db00b9cee8}{rank}=rank;
41                 env->\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks}=numRanks;
42         \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"ERROR: Trying to initialize QuESTEnv multiple times. Ignoring\(\backslash\)n"});
43 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero@{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero}}
\index{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero@{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero(int chunk\+Id, long long int chunk\+Size, int measure\+Qubit)}{isChunkToSkipInFindPZero(int chunkId, long long int chunkSize, int measureQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}static int is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero (
\begin{DoxyParamCaption}
\item[{int}]{chunk\+Id, }
\item[{long long int}]{chunk\+Size, }
\item[{int}]{measure\+Qubit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{}\label{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}


Find chunks to skip when calculating probability of qubit being zero. 

When calculating probability of a bit q being zero, sum up 2$^\wedge$q values, then skip 2$^\wedge$q values, etc. This function finds if an entire chunk is in the range of values to be skipped


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Id} & id of chunk in state vector \\
\hline
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em measure\+Qubi} & qubit being measured \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int -- 1\+: skip, 0\+: don\textquotesingle{}t skip 
\end{DoxyReturn}


Definition at line 467 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by find\+Probability\+Of\+Outcome(), and measure\+In\+State().


\begin{DoxyCode}
468 \{
469         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (measureQubit);
470         \textcolor{keywordtype}{int} numChunksToSkip = sizeHalfBlock/chunkSize;
471         \textcolor{comment}{// calculate probability by summing over numChunksToSkip, then skipping numChunksToSkip, etc}
472         \textcolor{keywordtype}{int} bitToCheck = chunkId & numChunksToSkip;
473         \textcolor{keywordflow}{return} bitToCheck;
474 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!measure\+In\+State@{measure\+In\+State}}
\index{measure\+In\+State@{measure\+In\+State}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{measure\+In\+State(\+Multi\+Qubit multi\+Qubit, const int measure\+Qubit, int outcome)}{measureInState(MultiQubit multiQubit, const int measureQubit, int outcome)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} measure\+In\+State (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{measure\+Qubit, }
\item[{int}]{outcome}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a88605f373c2401760aab0e08719e08dd}{}\label{qubits__env__mpi_8c_a88605f373c2401760aab0e08719e08dd}


Update the state vector to be consistent with measuring measure\+Qubit=0 or measure\+Qubit=1 according to the value of outcome. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that an outcome has been measured on the qubit indicated by measure\+Qubit (where his label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 if outcome=0 or measure\+Qubit=1 if outcome=1. It then returns the probability of making this measurement.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em outcome} & to measure the probability of and set the state to -- either zero or one \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being either zero or one 
\end{DoxyReturn}


Definition at line 493 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, find\+Probability\+Of\+Outcome(), half\+Matrix\+Block\+Fits\+In\+Chunk(), is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero(), measure\+In\+State\+Distributed\+Renorm(), measure\+In\+State\+Distributed\+Set\+Zero(), measure\+In\+State\+Local(), Multi\+Qubit\+::num\+Amps, and R\+E\+AL.



Referenced by main().


\begin{DoxyCode}
494 \{
495         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} totalStateProb=\hyperlink{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{findProbabilityOfOutcome}(multiQubit, measureQubit, 
      outcome);
496         \textcolor{keywordtype}{int} skipValuesWithinRank = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, measureQubit);
497         \textcolor{keywordflow}{if} (skipValuesWithinRank) \{
498                 \hyperlink{qubits_8c_a53614ce19e0a4f2c41b400cf05dc5bd1}{measureInStateLocal}(multiQubit, measureQubit, totalStateProb, outcome);
499         \} \textcolor{keywordflow}{else} \{
500                 \textcolor{keywordflow}{if} (!\hyperlink{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{isChunkToSkipInFindPZero}(multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, measureQubit))\{
501                         \textcolor{comment}{// chunk has amps for q=0}
502                         \textcolor{keywordflow}{if} (outcome==0) \hyperlink{qubits_8c_a35e5ac30c8427c482a97b33a4e295535}{measureInStateDistributedRenorm}(
      multiQubit, measureQubit, totalStateProb);
503                         \textcolor{keywordflow}{else} \hyperlink{qubits_8c_ac39efc9ed939382276ebd0c15dd6a0fa}{measureInStateDistributedSetZero}(multiQubit, 
      measureQubit);
504                 \} \textcolor{keywordflow}{else} \{
505                         \textcolor{comment}{// chunk has amps for q=1}
506                         \textcolor{keywordflow}{if} (outcome==1) \hyperlink{qubits_8c_a35e5ac30c8427c482a97b33a4e295535}{measureInStateDistributedRenorm}(
      multiQubit, measureQubit, totalStateProb);
507                         \textcolor{keywordflow}{else} \hyperlink{qubits_8c_ac39efc9ed939382276ebd0c15dd6a0fa}{measureInStateDistributedSetZero}(multiQubit, 
      measureQubit);
508                 \}
509         \}
510         \textcolor{keywordflow}{return} totalStateProb;
511 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!phase\+Gate@{phase\+Gate}}
\index{phase\+Gate@{phase\+Gate}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{phase\+Gate(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, enum phase\+Gate\+Type type)}{phaseGate(MultiQubit multiQubit, const int rotQubit, enum phaseGateType type)}}]{\setlength{\rightskip}{0pt plus 5cm}void phase\+Gate (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{enum {\bf phase\+Gate\+Type}}]{type}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_ae275b94c1a483dda43bf4ec947635605}{}\label{qubits__env__mpi_8c_ae275b94c1a483dda43bf4ec947635605}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em type} & the type of phase gate to apply -- one of \{S\+I\+G\+M\+A\+\_\+Z, S\+\_\+\+G\+A\+TE, T\+\_\+\+G\+A\+TE\} \\
\hline
\end{DoxyParams}


Definition at line 403 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, phase\+Gate\+Distributed(), and phase\+Gate\+Local().



Referenced by s\+Gate(), sigma\+Z(), and t\+Gate().


\begin{DoxyCode}
404 \{
405         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
406         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
407 
408         \textcolor{comment}{// rank's chunk is in upper half of block }
409         \textcolor{keywordtype}{int} rankIsUpper;
410         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
411 
412         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
413                 \hyperlink{qubits_8c_a6a736aeb3532898019fe7c27010edc6a}{phaseGateLocal}(multiQubit, rotQubit, type);
414         \} \textcolor{keywordflow}{else} \{
415                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
416                 \textcolor{keywordflow}{if} (!rankIsUpper) \hyperlink{qubits_8c_a38a05c7e749e806b182ef3b89878bfc4}{phaseGateDistributed}(multiQubit, rotQubit, type);
417         \}
418 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!prob\+Of\+Filter\+Out111@{prob\+Of\+Filter\+Out111}}
\index{prob\+Of\+Filter\+Out111@{prob\+Of\+Filter\+Out111}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{prob\+Of\+Filter\+Out111(\+Multi\+Qubit multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3)}{probOfFilterOut111(MultiQubit multiQubit, const int idQubit1, const int idQubit2, const int idQubit3)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf R\+E\+AL} prob\+Of\+Filter\+Out111 (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{id\+Qubit1, }
\item[{const int}]{id\+Qubit2, }
\item[{const int}]{id\+Qubit3}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a909ba48b5a82c9f5c3a94d17a72b1aa3}{}\label{qubits__env__mpi_8c_a909ba48b5a82c9f5c3a94d17a72b1aa3}


Evaluates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. 

The function returns the probability of this outcome (if zero, it will exit with error) 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3} & specified qubits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Total probability that the 3 qubits are not all in the 1 state. 
\end{DoxyReturn}


Definition at line 521 of file qubits\+\_\+env\+\_\+mpi.\+c.



References M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, prob\+Of\+Filter\+Out111\+Local(), and R\+E\+AL.



Referenced by filter\+Out111(), and main().


\begin{DoxyCode}
522 \{
523         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateProb=0, totalStateProb=0;
524         stateProb = \hyperlink{qubits_8c_a096cddbac961f0651a084d2ceb905d1b}{probOfFilterOut111Local}(multiQubit, idQubit1, idQubit2, idQubit3
      );
525         MPI\_Allreduce(&stateProb, &totalStateProb, 1, \hyperlink{precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}, MPI\_SUM, MPI\_COMM\_WORLD
      );
526         \textcolor{keywordflow}{return} totalStateProb;
527 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!report\+Node\+List@{report\+Node\+List}}
\index{report\+Node\+List@{report\+Node\+List}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{report\+Node\+List(\+Qu\+E\+S\+T\+Env env)}{reportNodeList(QuESTEnv env)}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+Node\+List (
\begin{DoxyParamCaption}
\item[{{\bf Qu\+E\+S\+T\+Env}}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}{}\label{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}


Report a list of C\+PU hostnames and the rank that is running on each if running with M\+PI enabled and an error message otherwise. 

For debugging purposes. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 71 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Qu\+E\+S\+T\+Env\+::rank.


\begin{DoxyCode}
71                                  \{
72         \textcolor{keywordtype}{char} hostName[256];
73         gethostname(hostName, 255);
74         printf(\textcolor{stringliteral}{"hostname on rank %d: %s\(\backslash\)n"}, env.\hyperlink{structQuESTEnv_aa648bb336cf8598467cb62db00b9cee8}{rank}, hostName);
75 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!report\+Qu\+E\+S\+T\+Env@{report\+Qu\+E\+S\+T\+Env}}
\index{report\+Qu\+E\+S\+T\+Env@{report\+Qu\+E\+S\+T\+Env}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{report\+Qu\+E\+S\+T\+Env(\+Qu\+E\+S\+T\+Env env)}{reportQuESTEnv(QuESTEnv env)}}]{\setlength{\rightskip}{0pt plus 5cm}void report\+Qu\+E\+S\+T\+Env (
\begin{DoxyParamCaption}
\item[{{\bf Qu\+E\+S\+T\+Env}}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}{}\label{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}


Report information about the Qu\+E\+ST environment. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 56 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Qu\+E\+S\+T\+Env\+::num\+Ranks, Qu\+E\+S\+T\+Env\+::rank, and R\+E\+AL.



Referenced by main().


\begin{DoxyCode}
56                                  \{
57         \textcolor{keywordflow}{if} (env.\hyperlink{structQuESTEnv_aa648bb336cf8598467cb62db00b9cee8}{rank}==0)\{
58                 printf(\textcolor{stringliteral}{"EXECUTION ENVIRONMENT:\(\backslash\)n"}); 
59                 printf(\textcolor{stringliteral}{"Running distributed (MPI) version\(\backslash\)n"});
60                 printf(\textcolor{stringliteral}{"Number of ranks is %d\(\backslash\)n"}, env.\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks});
61 \textcolor{preprocessor}{# ifdef \_OPENMP}
62                 printf(\textcolor{stringliteral}{"OpenMP enabled\(\backslash\)n"});
63                 printf(\textcolor{stringliteral}{"Number of threads available is %d\(\backslash\)n"}, omp\_get\_max\_threads());
64 \textcolor{preprocessor}{# else}
65                 printf(\textcolor{stringliteral}{"OpenMP disabled\(\backslash\)n"});
66 \textcolor{preprocessor}{# endif }
67                 printf(\textcolor{stringliteral}{"Precision: size of REAL is %ld bytes\(\backslash\)n"}, \textcolor{keyword}{sizeof}(\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}));
68         \}
69 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!rotate\+Qubit@{rotate\+Qubit}}
\index{rotate\+Qubit@{rotate\+Qubit}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{rotate\+Qubit(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit, Complex alpha, Complex beta)}{rotateQubit(MultiQubit multiQubit, const int rotQubit, Complex alpha, Complex beta)}}]{\setlength{\rightskip}{0pt plus 5cm}void rotate\+Qubit (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit, }
\item[{{\bf Complex}}]{alpha, }
\item[{{\bf Complex}}]{beta}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a4ba468aa69f812efd1f964e10a45ca2f}{}\label{qubits__env__mpi_8c_a4ba468aa69f812efd1f964e10a45ca2f}


Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. 

alpha\+Re = cos(angle1) $\ast$ cos(angle2) ~\newline
alpha\+Im = cos(angle1) $\ast$ sin(angle2) ~\newline
 beta\+Re = sin(angle1) $\ast$ cos(angle3) ~\newline
 beta\+Im = sin(angle1) $\ast$ sin(angle3) ~\newline


\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em alpha} & rotation angle \\
\hline
\mbox{\tt in}  & {\em beta} & rotation angle \\
\hline
\end{DoxyParams}


Definition at line 239 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), get\+Rot\+Angle(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::pair\+State\+Vec, rotate\+Qubit\+Distributed(), rotate\+Qubit\+Local(), and Multi\+Qubit\+::state\+Vec.



Referenced by main(), test\+\_\+control\+Not(), test\+\_\+control\+Phase\+Gate(), test\+\_\+hadamard(), test\+\_\+s\+Gate(), test\+\_\+sigma\+X(), test\+\_\+sigma\+Y(), test\+\_\+sigma\+Z(), and test\+\_\+t\+Gate().


\begin{DoxyCode}
240 \{
241         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
242         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
243         \hyperlink{structComplex}{Complex} rot1, rot2;
244 
245         \textcolor{comment}{// rank's chunk is in upper half of block }
246         \textcolor{keywordtype}{int} rankIsUpper;
247         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
248 
249         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
250                 \textcolor{comment}{// all values required to update state vector lie in this rank}
251                 \hyperlink{qubits_8c_acb059cbcb8c7910a5fc43d21da4f5dea}{rotateQubitLocal}(multiQubit, rotQubit, alpha, beta);
252         \} \textcolor{keywordflow}{else} \{
253                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
254                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
255                 \hyperlink{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{getRotAngle}(rankIsUpper, &rot1, &rot2, alpha, beta);
256                 pairRank = \hyperlink{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
257                 \textcolor{comment}{// get corresponding values from my pair}
258                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
259 
260                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. }
261                 \textcolor{comment}{// send values to rotateQubitDistributed in the correct order}
262                 \textcolor{keywordflow}{if} (rankIsUpper)\{
263                         \hyperlink{qubits_8c_a6ff67d25363f39fd57a4e76621a4bfd5}{rotateQubitDistributed}(multiQubit,rotQubit,rot1,rot2,
264                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//upper}
265                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//lower}
266                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
267                 \} \textcolor{keywordflow}{else} \{
268                         \hyperlink{qubits_8c_a6ff67d25363f39fd57a4e76621a4bfd5}{rotateQubitDistributed}(multiQubit,rotQubit,rot1,rot2,
269                                 multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{//upper}
270                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{//lower}
271                                 multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{//output}
272                 \}
273         \}
274 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!sigmaX@{sigmaX}}
\index{sigmaX@{sigmaX}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{sigma\+X(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit)}{sigmaX(MultiQubit multiQubit, const int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaX (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_acda82bebb0a62f419eec9c1e0575daad}{}\label{qubits__env__mpi_8c_acda82bebb0a62f419eec9c1e0575daad}


Rotate a single qubit by \{\{0,1\},\{1,0\}\} -- swap $\vert$0$>$ and $\vert$1$>$. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}


Definition at line 314 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::pair\+State\+Vec, sigma\+X\+Distributed(), sigma\+X\+Local(), and Multi\+Qubit\+::state\+Vec.



Referenced by main(), and test\+\_\+sigma\+X().


\begin{DoxyCode}
315 \{
316         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
317         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
318 
319         \textcolor{comment}{// rank's chunk is in upper half of block }
320         \textcolor{keywordtype}{int} rankIsUpper;
321         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
322 
323         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
324                 \textcolor{comment}{// all values required to update state vector lie in this rank}
325                 \hyperlink{qubits_8c_aa9e640bb2d0458c937c6a87dfeca0f23}{sigmaXLocal}(multiQubit, rotQubit);
326         \} \textcolor{keywordflow}{else} \{
327                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
328                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
329                 pairRank = \hyperlink{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
330                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
331                 \textcolor{comment}{// get corresponding values from my pair}
332                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
333                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. sigmaX just
       replaces}
334                 \textcolor{comment}{// this rank's values with pair values}
335                 \hyperlink{qubits_8c_a5958808b2f2f05937921ba7dabe5a171}{sigmaXDistributed}(multiQubit, rotQubit,
336                         multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{// in}
337                         multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}); \textcolor{comment}{// out}
338         \}
339 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!sigmaY@{sigmaY}}
\index{sigmaY@{sigmaY}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{sigma\+Y(\+Multi\+Qubit multi\+Qubit, const int rot\+Qubit)}{sigmaY(MultiQubit multiQubit, const int rotQubit)}}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaY (
\begin{DoxyParamCaption}
\item[{{\bf Multi\+Qubit}}]{multi\+Qubit, }
\item[{const int}]{rot\+Qubit}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a7b022c75cef77be046bd5d61e38a581e}{}\label{qubits__env__mpi_8c_a7b022c75cef77be046bd5d61e38a581e}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -- swap $\vert$0$>$ and $\vert$1$>$ and apply a phase of -\/i or i. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}
fix -- put duplicate code (sigmaX, sigmaY) in seperate function 

Definition at line 374 of file qubits\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::pair\+State\+Vec, sigma\+Y\+Distributed(), sigma\+Y\+Local(), and Multi\+Qubit\+::state\+Vec.



Referenced by main(), and test\+\_\+sigma\+Y().


\begin{DoxyCode}
375 \{
376         \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block
       fits on one rank}
377         \textcolor{keywordtype}{int} useLocalDataOnly = \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk}(multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
378 
379         \textcolor{comment}{// rank's chunk is in upper half of block }
380         \textcolor{keywordtype}{int} rankIsUpper;
381         \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
382 
383         \textcolor{keywordflow}{if} (useLocalDataOnly)\{
384                 \textcolor{comment}{// all values required to update state vector lie in this rank}
385                 \hyperlink{qubits_8c_afcbb1dcbe070ad0ed1a72a23251b6a83}{sigmaYLocal}(multiQubit, rotQubit);
386         \} \textcolor{keywordflow}{else} \{
388                 \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
389                 rankIsUpper = \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper}(multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.
      \hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
390                 pairRank = \hyperlink{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{getChunkPairId}(rankIsUpper, multiQubit.
      \hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}, multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}, rotQubit);
391                 \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
392                 \textcolor{comment}{// get corresponding values from my pair}
393                 \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}(multiQubit, pairRank);
394                 \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. sigmaX just
       replaces}
395                 \textcolor{comment}{// this rank's values with pair values}
396                 \hyperlink{qubits_8c_a0471f6b547ce8270ef85170b7f4f0214}{sigmaYDistributed}(multiQubit,rotQubit,
397                         multiQubit.\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}, \textcolor{comment}{// in}
398                         multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}, \textcolor{comment}{// out}
399                         rankIsUpper);
400         \}
401 \}
\end{DoxyCode}
\index{qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}!sync\+Qu\+E\+S\+T\+Env@{sync\+Qu\+E\+S\+T\+Env}}
\index{sync\+Qu\+E\+S\+T\+Env@{sync\+Qu\+E\+S\+T\+Env}!qubits\+\_\+env\+\_\+mpi.\+c@{qubits\+\_\+env\+\_\+mpi.\+c}}
\paragraph[{\texorpdfstring{sync\+Qu\+E\+S\+T\+Env(\+Qu\+E\+S\+T\+Env env)}{syncQuESTEnv(QuESTEnv env)}}]{\setlength{\rightskip}{0pt plus 5cm}void sync\+Qu\+E\+S\+T\+Env (
\begin{DoxyParamCaption}
\item[{{\bf Qu\+E\+S\+T\+Env}}]{env}
\end{DoxyParamCaption}
)}\hypertarget{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{}\label{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}


Guarantees that all code up to the given point has been executed on all nodes. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 45 of file qubits\+\_\+env\+\_\+mpi.\+c.



Referenced by report\+State\+To\+Screen().


\begin{DoxyCode}
45                                \{
46         MPI\_Barrier(MPI\_COMM\_WORLD);
47 \}
\end{DoxyCode}
