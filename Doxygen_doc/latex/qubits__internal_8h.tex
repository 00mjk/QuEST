\hypertarget{qubits__internal_8h}{}\subsection{qubits\+\_\+internal.\+h File Reference}
\label{qubits__internal_8h}\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}


Internal functions used to implement the public facing A\+PI in \hyperlink{qubits_8h}{qubits.\+h}.  


{\ttfamily \#include \char`\"{}precision.\+h\char`\"{}}\newline
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}{rotate\+Qubit\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}{rotate\+Qubit\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a824d71bae93236d8a3cd43589044eaee}{control\+Rotate\+Qubit\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, const int control\+Qubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ab22d031e2507f1d859292103a99e2378}{control\+Rotate\+Qubit\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, const int control\+Qubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_aa9e640bb2d0458c937c6a87dfeca0f23}{sigma\+X\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a5958808b2f2f05937921ba7dabe5a171}{sigma\+X\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_afcbb1dcbe070ad0ed1a72a23251b6a83}{sigma\+Y\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a0471f6b547ce8270ef85170b7f4f0214}{sigma\+Y\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out, int update\+Upper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a0711416fceaf63c67b496e123e845c69}{hadamard\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ac835c194bd547240a35f0b028db1d658}{hadamard\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Up, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Lo, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out, int update\+Upper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a6a736aeb3532898019fe7c27010edc6a}{phase\+Gate\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a38a05c7e749e806b182ef3b89878bfc4}{phase\+Gate\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a2901e2e5531cb77f87ea54b3fc28f51a}{control\+Not\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, const int control\+Qubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\} for elements where control\+Qubit is one. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a774dd1217fcc3591a74a74d5667afa29}{control\+Not\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int target\+Qubit, const int control\+Qubit, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+In, \hyperlink{structComplexArray}{Complex\+Array} state\+Vec\+Out)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{find\+Probability\+Of\+Zero\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{find\+Probability\+Of\+Zero\+Distributed} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a53614ce19e0a4f2c41b400cf05dc5bd1}{measure\+In\+State\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, int measure\+Qubit, \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} total\+Probability, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__internal_8h_a35e5ac30c8427c482a97b33a4e295535}{measure\+In\+State\+Distributed\+Renorm} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit, const \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} total\+Probability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measure\+Qubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ac39efc9ed939382276ebd0c15dd6a0fa}{measure\+In\+State\+Distributed\+Set\+Zero} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Set all amplitudes in one chunk to 0. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a2d73fd11c1d154640dbf114da8f34c64}{filter\+Out111\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3, const \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} prob\+Of\+Filter)
\begin{DoxyCompactList}\small\item\em Updates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \end{DoxyCompactList}\item 
\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} \hyperlink{qubits__internal_8h_a096cddbac961f0651a084d2ceb905d1b}{prob\+Of\+Filter\+Out111\+Local} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int id\+Qubit1, const int id\+Qubit2, const int id\+Qubit3)
\begin{DoxyCompactList}\small\item\em Evaluates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ae275b94c1a483dda43bf4ec947635605}{phase\+Gate} (\hyperlink{structMultiQubit}{Multi\+Qubit} multi\+Qubit, const int rot\+Qubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
Internal functions used to implement the public facing A\+PI in \hyperlink{qubits_8h}{qubits.\+h}. 

Do not call these functions directly. In general, \hyperlink{qubits__env__local_8c}{qubits\+\_\+env\+\_\+local.\+c} and \hyperlink{qubits__env__mpi_8c}{qubits\+\_\+env\+\_\+mpi.\+c} will implement the public A\+PI by choosing the correct function or combination of functions to use from those included here. 

\subsubsection{Function Documentation}
\mbox{\Hypertarget{qubits__internal_8h_a774dd1217fcc3591a74a74d5667afa29}\label{qubits__internal_8h_a774dd1217fcc3591a74a74d5667afa29}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!control\+Not\+Distributed@{control\+Not\+Distributed}}
\index{control\+Not\+Distributed@{control\+Not\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{control\+Not\+Distributed()}{controlNotDistributed()}}
{\footnotesize\ttfamily void control\+Not\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{target\+Qubit,  }\item[{const int}]{control\+Qubit,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+In,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Out }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{0,1\},\{1,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk. Only perform the rotation for elements where control\+Qubit is one.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 865 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and R\+E\+AL.



Referenced by control\+Not().


\begin{DoxyCode}
868 \{
869 
870         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
871         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
872         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
873         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
874         
875         \textcolor{comment}{// if targetQubit==controlQubit, it is guaranteed that controlQubit==1 when}
876         \textcolor{comment}{// targetQubit==1. As rotations are symmetric, we can instead apply the rotation}
877         \textcolor{comment}{// on all amplitudes where targetQubit==0 as we do here.}
878         \textcolor{keywordtype}{int} rotateAll=(targetQubit==controlQubit);
879 
880         \textcolor{keywordtype}{int} controlBit;
881 
882         \textcolor{comment}{// test qubit valid}
883         assert (targetQubit >= 0 && targetQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
884 
885         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
886         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
887 
888 \textcolor{preprocessor}{# ifdef \_OPENMP}
889 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
890 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
891 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,rotateAll) \(\backslash\)}
892 \textcolor{preprocessor}{        private  (thisTask,controlBit)}
893 \textcolor{preprocessor}{# endif}
894         \{
895 \textcolor{preprocessor}{# ifdef \_OPENMP}
896 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
897 \textcolor{preprocessor}{# endif}
898                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
899                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, thisTask+chunkId*chunkSize);
900                         \textcolor{keywordflow}{if} (rotateAll || controlBit)\{
901                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
902                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
903                         \}
904                 \}
905         \}
906 \} 
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a2901e2e5531cb77f87ea54b3fc28f51a}\label{qubits__internal_8h_a2901e2e5531cb77f87ea54b3fc28f51a}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!control\+Not\+Local@{control\+Not\+Local}}
\index{control\+Not\+Local@{control\+Not\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{control\+Not\+Local()}{controlNotLocal()}}
{\footnotesize\ttfamily void control\+Not\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{target\+Qubit,  }\item[{const int}]{control\+Qubit }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{0,1\},\{1,0\} for elements where control\+Qubit is one. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & qubit to determine whether or not to perform a rotation \\
\hline
\end{DoxyParams}


Definition at line 791 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by control\+Not().


\begin{DoxyCode}
792 \{
793         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
794         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
795              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
796 
797         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
798         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
799         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
800         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
801         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
802 
803         \textcolor{keywordtype}{int} controlBit;
804 
805         \textcolor{comment}{// if targetQubit==controlQubit, it is guaranteed that controlQubit==1 when}
806         \textcolor{comment}{// targetQubit==1. As rotations are symmetric, we can instead apply the rotation}
807         \textcolor{comment}{// on all amplitudes where targetQubit==0 as we do here.}
808         \textcolor{keywordtype}{int} rotateAll=(targetQubit==controlQubit);
809 
810         \textcolor{comment}{// test qubit valid}
811         assert (targetQubit >= 0 && targetQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
812 
813         \textcolor{comment}{// set dimensions}
814         sizeHalfBlock = 1LL << targetQubit;  
815         sizeBlock     = 2LL * sizeHalfBlock; 
816 
817 
818         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
819         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
820         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
821 
822 \textcolor{preprocessor}{# ifdef \_OPENMP}
823 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
824 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
825 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,rotateAll) \(\backslash\)}
826 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,controlBit) }
827 \textcolor{preprocessor}{# endif}
828         \{
829 \textcolor{preprocessor}{# ifdef \_OPENMP}
830 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
831 \textcolor{preprocessor}{# endif}
832                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
833                         thisBlock   = thisTask / sizeHalfBlock;
834                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
835                         indexLo     = indexUp + sizeHalfBlock;
836 
837                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit}(controlQubit, indexUp+chunkId*chunkSize);
838                         \textcolor{keywordflow}{if} (rotateAll || controlBit)\{
839                                 stateRealUp = stateVecReal[indexUp];
840                                 stateImagUp = stateVecImag[indexUp];
841 
842                                 stateVecReal[indexUp] = stateVecReal[indexLo];
843                                 stateVecImag[indexUp] = stateVecImag[indexLo];
844 
845                                 stateVecReal[indexLo] = stateRealUp;
846                                 stateVecImag[indexLo] = stateImagUp;
847                         \}
848                 \} 
849         \}
850 
851 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_ab22d031e2507f1d859292103a99e2378}\label{qubits__internal_8h_ab22d031e2507f1d859292103a99e2378}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!control\+Rotate\+Qubit\+Distributed@{control\+Rotate\+Qubit\+Distributed}}
\index{control\+Rotate\+Qubit\+Distributed@{control\+Rotate\+Qubit\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{control\+Rotate\+Qubit\+Distributed()}{controlRotateQubitDistributed()}}
{\footnotesize\ttfamily void control\+Rotate\+Qubit\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{const int}]{control\+Qubit,  }\item[{\hyperlink{structComplex}{Complex}}]{rot1,  }\item[{\hyperlink{structComplex}{Complex}}]{rot2,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Up,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Lo,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Out }\end{DoxyParamCaption})}



Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. 

Only perform the rotation where the control qubit is one.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & qubit to determine whether or not to perform a rotation \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 620 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Complex\+::real.



Referenced by control\+Rotate\+Qubit().


\begin{DoxyCode}
625 \{
626 
627         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
628         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
629         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
630         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
631         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
632 
633         \textcolor{keywordtype}{int} controlBit;
634 
635         \textcolor{comment}{// As rotations are symmetric, we can apply rotations for all elements where}
636         \textcolor{comment}{// targetQubit==0 and controlQubit==1.  }
637         \textcolor{comment}{// However, this means we will skip the case where targetQubit==controlQubit. }
638         \textcolor{comment}{// We check for that here. }
639         \textcolor{comment}{// We could also choose to rotate on targetQubit==1, but are doing it this way }
640         \textcolor{comment}{// to match the regular rotate implementation. }
641         \textcolor{keywordtype}{int} rotateAll=(rotQubit==controlQubit);
642 
643         \textcolor{comment}{// test qubit valid}
644         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
645 
646         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
647         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
648         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
649         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
650         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
651 
652 \textcolor{preprocessor}{# ifdef \_OPENMP}
653 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
654 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
655 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
656 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag,rotateAll) \(\backslash\)}
657 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit)}
658 \textcolor{preprocessor}{# endif}
659         \{
660 \textcolor{preprocessor}{# ifdef \_OPENMP}
661 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
662 \textcolor{preprocessor}{# endif}
663                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
664                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, thisTask+chunkId*chunkSize);
665                         \textcolor{keywordflow}{if} (rotateAll || controlBit)\{
666                                 \textcolor{comment}{// store current state vector values in temp variables}
667                                 stateRealUp = stateVecRealUp[thisTask];
668                                 stateImagUp = stateVecImagUp[thisTask];
669 
670                                 stateRealLo = stateVecRealLo[thisTask];
671                                 stateImagLo = stateVecImagLo[thisTask];
672 
673                                 \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
674                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp + 
      rot2Real*stateRealLo + rot2Imag*stateImagLo;
675                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp + 
      rot2Real*stateImagLo - rot2Imag*stateRealLo;
676                         \}
677                 \}
678         \}
679 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a824d71bae93236d8a3cd43589044eaee}\label{qubits__internal_8h_a824d71bae93236d8a3cd43589044eaee}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!control\+Rotate\+Qubit\+Local@{control\+Rotate\+Qubit\+Local}}
\index{control\+Rotate\+Qubit\+Local@{control\+Rotate\+Qubit\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{control\+Rotate\+Qubit\+Local()}{controlRotateQubitLocal()}}
{\footnotesize\ttfamily void control\+Rotate\+Qubit\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{const int}]{control\+Qubit,  }\item[{\hyperlink{structComplex}{Complex}}]{alpha,  }\item[{\hyperlink{structComplex}{Complex}}]{beta }\end{DoxyParamCaption})}



Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. 

Only perform the rotation for elements where the control qubit is one.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & perform rotation if this qubit is 1 \\
\hline
\mbox{\tt in}  & {\em alpha} & rotation angle \\
\hline
\mbox{\tt in}  & {\em beta} & rotation angle \\
\hline
\end{DoxyParams}


Definition at line 528 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, Complex\+::real, and Multi\+Qubit\+::state\+Vec.



Referenced by control\+Rotate\+Qubit().


\begin{DoxyCode}
530 \{
531         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
532         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
533              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
534 
535         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
536         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
537         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
538         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
539         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
540 
541         \textcolor{keywordtype}{int} controlBit;
542 
543         \textcolor{comment}{// As rotations are symmetric, we can apply rotations for all elements where}
544         \textcolor{comment}{// targetQubit==0 and controlQubit==1.  }
545         \textcolor{comment}{// However, this means we will skip the case where targetQubit==controlQubit. }
546         \textcolor{comment}{// We check for that here. }
547         \textcolor{comment}{// We could also choose to rotate on targetQubit==1, but are doing it this way }
548         \textcolor{comment}{// to match the regular rotate implementation. }
549         \textcolor{keywordtype}{int} rotateAll=(rotQubit==controlQubit);
550 
551         \textcolor{comment}{// test qubit valid}
552         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
553 
554         \textcolor{comment}{// set dimensions}
555         sizeHalfBlock = 1LL << rotQubit;  
556         sizeBlock     = 2LL * sizeHalfBlock; 
557 
558         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
559         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
560         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
561         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} alphaImag=alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, alphaReal=alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
562         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} betaImag=beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, betaReal=beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
563 
564 \textcolor{preprocessor}{# ifdef \_OPENMP}
565 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
566 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
567 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,alphaImag,
       betaReal,betaImag,\(\backslash\)}
568 \textcolor{preprocessor}{                        rotateAll) \(\backslash\)}
569 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo,
       stateRealUp,stateImagUp,stateRealLo,stateImagLo,controlBit) }
570 \textcolor{preprocessor}{# endif}
571         \{
572 \textcolor{preprocessor}{# ifdef \_OPENMP}
573 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
574 \textcolor{preprocessor}{# endif}
575                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
576 
577                         thisBlock   = thisTask / sizeHalfBlock;
578                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
579                         indexLo     = indexUp + sizeHalfBlock;
580 
581                         controlBit = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (controlQubit, indexUp+chunkId*chunkSize);
582                         \textcolor{keywordflow}{if} (rotateAll || controlBit)\{
583                                 \textcolor{comment}{// store current state vector values in temp variables}
584                                 stateRealUp = stateVecReal[indexUp];
585                                 stateImagUp = stateVecImag[indexUp];
586 
587                                 stateRealLo = stateVecReal[indexLo];
588                                 stateImagLo = stateVecImag[indexLo];
589 
590                                 \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
591                                 stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag*stateImagUp 
592                                         - betaReal*stateRealLo - betaImag*stateImagLo;
593                                 stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag*stateRealUp 
594                                         - betaReal*stateImagLo + betaImag*stateRealLo;
595 
596                                 \textcolor{comment}{// state[indexLo] = beta  * state[indexUp] + conj(alpha) * state[indexLo]}
597                                 stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*stateImagUp 
598                                         + alphaReal*stateRealLo + alphaImag*stateImagLo;
599                                 stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*stateRealUp 
600                                         + alphaReal*stateImagLo - alphaImag*stateRealLo;
601                         \}
602                 \} 
603         \}
604 
605 \} 
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a2d73fd11c1d154640dbf114da8f34c64}\label{qubits__internal_8h_a2d73fd11c1d154640dbf114da8f34c64}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!filter\+Out111\+Local@{filter\+Out111\+Local}}
\index{filter\+Out111\+Local@{filter\+Out111\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{filter\+Out111\+Local()}{filterOut111Local()}}
{\footnotesize\ttfamily void filter\+Out111\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{id\+Qubit1,  }\item[{const int}]{id\+Qubit2,  }\item[{const int}]{id\+Qubit3,  }\item[{const \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}}]{prob\+Of\+Filter }\end{DoxyParamCaption})}



Updates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3} & specified qubits \\
\hline
\mbox{\tt in}  & {\em prob\+Of\+Filter} & Total probability that the 3 qubits are not all in the 1 state. \\
\hline
\end{DoxyParams}


Definition at line 1786 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, R\+E\+A\+L\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+F\+O\+R\+M\+AT, and Multi\+Qubit\+::state\+Vec.



Referenced by filter\+Out111().


\begin{DoxyCode}
1788 \{
1789         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
1790         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
1791         \textcolor{keywordtype}{int} bit1, bit2, bit3;
1792         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1793         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
1794 
1795         \textcolor{comment}{// ---------------------------------------------------------------- //}
1796         \textcolor{comment}{//            tests                                                 //}
1797         \textcolor{comment}{// ---------------------------------------------------------------- //}
1798         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} && idQubit2 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1799 
1800         assert (probOfFilter != 0);
1801         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1802 
1803         \textcolor{keywordflow}{if} ( probOfFilter<1e-16 )\{ printf(\textcolor{stringliteral}{"Extremely small or negative profOfFilter="}
      \hyperlink{precision_8h_ad751ac7ddc8ec19f23fb33083c0da8da}{REAL\_STRING\_FORMAT}\textcolor{stringliteral}{"; aborting! \(\backslash\)n"},probOfFilter); exit(1);\}
1804         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} myNorm=1/sqrt(probOfFilter);
1805         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1806         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1807 
1808 \textcolor{preprocessor}{# ifdef \_OPENMP}
1809 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1810 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
1811 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag, myNorm) \(\backslash\)}
1812 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3)                }
1813 \textcolor{preprocessor}{# endif }
1814         \{
1815 \textcolor{preprocessor}{# ifdef \_OPENMP}
1816 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1817 \textcolor{preprocessor}{# endif}
1818                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
1819                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index+chunkId*chunkSize);
1820                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index+chunkId*chunkSize);
1821                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index+chunkId*chunkSize);
1822                         \textcolor{keywordflow}{if} ((bit1 && bit2 && bit3)) \{
1823                                 stateVecReal[index]=0;
1824                                 stateVecImag [index]=0;
1825                         \}\textcolor{keywordflow}{else}\{
1826                                 stateVecReal[index] *= myNorm;
1827                                 stateVecImag[index] *= myNorm;
1828                         \}
1829                 \}
1830         \}
1831 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}\label{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}}
\index{find\+Probability\+Of\+Zero\+Distributed@{find\+Probability\+Of\+Zero\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{find\+Probability\+Of\+Zero\+Distributed()}{findProbabilityOfZeroDistributed()}}
{\footnotesize\ttfamily \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} find\+Probability\+Of\+Zero\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit }\end{DoxyParamCaption})}



Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. 

Size of regions to skip is a multiple of chunk\+Size.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 1389 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Outcome().


\begin{DoxyCode}
1391 \{
1392         \textcolor{comment}{// ----- measured probability}
1393         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
1394         \textcolor{comment}{// ----- temp variables}
1395         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1396         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1397         \textcolor{comment}{// (good for shared memory parallelism)}
1398 
1399         \textcolor{comment}{// ---------------------------------------------------------------- //}
1400         \textcolor{comment}{//            tests                                                 //}
1401         \textcolor{comment}{// ---------------------------------------------------------------- //}
1402         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1403 
1404         \textcolor{comment}{// ---------------------------------------------------------------- //}
1405         \textcolor{comment}{//            find probability                                      //}
1406         \textcolor{comment}{// ---------------------------------------------------------------- //}
1407 
1408         \textcolor{comment}{// initialise returned value}
1409         totalProbability = 0.0;
1410 
1411         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1412         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1413 
1414 \textcolor{preprocessor}{# ifdef \_OPENMP}
1415 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1416 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1417 \textcolor{preprocessor}{        private   (thisTask) \(\backslash\)}
1418 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
1419 \textcolor{preprocessor}{# endif}
1420         \{
1421 \textcolor{preprocessor}{# ifdef \_OPENMP}
1422 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1423 \textcolor{preprocessor}{# endif}
1424                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1425                         \textcolor{comment}{// summation -- simple implementation}
1426                         totalProbability += stateVecReal[thisTask]*stateVecReal[thisTask]
1427                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
1428 
1429                         \textcolor{comment}{/*}
1430 \textcolor{comment}{                        // summation -- kahan correction}
1431 \textcolor{comment}{                        y = stateVecReal[thisTask]*stateVecReal[thisTask]}
1432 \textcolor{comment}{                        + stateVecImag[thisTask]*stateVecImag[thisTask] - c;}
1433 \textcolor{comment}{                        t = totalProbability + y;}
1434 \textcolor{comment}{                        c = (t - totalProbability) - y;}
1435 \textcolor{comment}{                        totalProbability = t;}
1436 \textcolor{comment}{                        */}
1437 
1438                 \}
1439         \}
1440 
1441         \textcolor{keywordflow}{return} totalProbability;
1442 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}\label{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}}
\index{find\+Probability\+Of\+Zero\+Local@{find\+Probability\+Of\+Zero\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{find\+Probability\+Of\+Zero\+Local()}{findProbabilityOfZeroLocal()}}
{\footnotesize\ttfamily \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} find\+Probability\+Of\+Zero\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit }\end{DoxyParamCaption})}



Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. 

Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being zero 
\end{DoxyReturn}


Definition at line 1310 of file qubits.\+c.



References D\+E\+B\+UG, Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by find\+Probability\+Of\+Outcome().


\begin{DoxyCode}
1312 \{
1313         \textcolor{comment}{// ----- sizes}
1314         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
1315         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
1316         \textcolor{comment}{// ----- indices}
1317         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
1318              index;                                               \textcolor{comment}{// current index for first half block}
1319         \textcolor{comment}{// ----- measured probability}
1320         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   totalProbability;                                    \textcolor{comment}{// probability (returned) value}
1321         \textcolor{comment}{// ----- temp variables}
1322         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1323         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1324 
1325         \textcolor{comment}{// ---------------------------------------------------------------- //}
1326         \textcolor{comment}{//            tests                                                 //}
1327         \textcolor{comment}{// ---------------------------------------------------------------- //}
1328         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1329 
1330 
1331         \textcolor{comment}{// ---------------------------------------------------------------- //}
1332         \textcolor{comment}{//            dimensions                                            //}
1333         \textcolor{comment}{// ---------------------------------------------------------------- //}
1334         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
1335         \textcolor{comment}{// and then the number to skip}
1336         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
1337 
1338         \textcolor{comment}{// initialise returned value}
1339         totalProbability = 0.0;
1340 
1341         \textcolor{comment}{// initialise correction for kahan summation}
1342         \textcolor{keywordflow}{if} (\hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}) printf(\textcolor{stringliteral}{"sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\(\backslash\)n"},sizeHalfBlock,sizeBlock,
      numTasks);
1343 
1344         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1345         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1346 
1347 \textcolor{preprocessor}{# ifdef \_OPENMP}
1348 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1349 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
1350 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index) \(\backslash\)}
1351 \textcolor{preprocessor}{        reduction ( +:totalProbability )}
1352 \textcolor{preprocessor}{# endif }
1353         \{
1354 \textcolor{preprocessor}{# ifdef \_OPENMP}
1355 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1356 \textcolor{preprocessor}{# endif}
1357                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1358                         thisBlock = thisTask / sizeHalfBlock;
1359                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1360 
1361                         \textcolor{keywordflow}{if} (index<0)\{ printf(\textcolor{stringliteral}{"ABORTING as index=%Ld with thisBlock = %Ld  thisTask=%Ld \(\backslash\)n"},
       index,thisBlock,thisTask); exit(1);\}
1362 
1363                         \textcolor{comment}{// summation -- simple implementation}
1364                         totalProbability += stateVecReal[index]*stateVecReal[index]
1365                                 + stateVecImag[index]*stateVecImag[index];
1366 
1367                         \textcolor{comment}{/*}
1368 \textcolor{comment}{                        // summation -- kahan correction}
1369 \textcolor{comment}{                        y = stateVecReal[index]*stateVecReal[index]}
1370 \textcolor{comment}{                        + stateVecImag[index]*stateVecImag[index] - c;}
1371 \textcolor{comment}{                        t = totalProbability + y;}
1372 \textcolor{comment}{                        c = (t - totalProbability) - y;}
1373 \textcolor{comment}{                        totalProbability = t;}
1374 \textcolor{comment}{                        */}
1375 
1376                 \}
1377         \}
1378         \textcolor{keywordflow}{return} totalProbability;
1379 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_ac835c194bd547240a35f0b028db1d658}\label{qubits__internal_8h_ac835c194bd547240a35f0b028db1d658}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!hadamard\+Distributed@{hadamard\+Distributed}}
\index{hadamard\+Distributed@{hadamard\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{hadamard\+Distributed()}{hadamardDistributed()}}
{\footnotesize\ttfamily void hadamard\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Up,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Lo,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Out,  }\item[{int}]{update\+Upper }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt in}  & {\em update\+Upper} & flag, 1\+: updating upper values, 0\+: updating lower values in block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 1088 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and R\+E\+AL.



Referenced by hadamard().


\begin{DoxyCode}
1093 \{
1094 
1095         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1096         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
1097         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1098 
1099         \textcolor{comment}{// test qubit valid}
1100         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1101 
1102         \textcolor{keywordtype}{int} sign;
1103         \textcolor{keywordflow}{if} (updateUpper) sign=1;
1104         \textcolor{keywordflow}{else} sign=-1;
1105 
1106         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1107 
1108         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1109         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1110         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1111 
1112 \textcolor{preprocessor}{# ifdef \_OPENMP}
1113 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1114 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1115 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
1116 \textcolor{preprocessor}{                        recRoot2, sign) \(\backslash\)}
1117 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
1118 \textcolor{preprocessor}{# endif}
1119         \{
1120 \textcolor{preprocessor}{# ifdef \_OPENMP}
1121 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1122 \textcolor{preprocessor}{# endif}
1123                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1124                         \textcolor{comment}{// store current state vector values in temp variables}
1125                         stateRealUp = stateVecRealUp[thisTask];
1126                         stateImagUp = stateVecImagUp[thisTask];
1127 
1128                         stateRealLo = stateVecRealLo[thisTask];
1129                         stateImagLo = stateVecImagLo[thisTask];
1130 
1131                         stateVecRealOut[thisTask] = recRoot2*(stateRealUp + sign*stateRealLo);
1132                         stateVecImagOut[thisTask] = recRoot2*(stateImagUp + sign*stateImagLo);
1133                 \}
1134         \}
1135 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a0711416fceaf63c67b496e123e845c69}\label{qubits__internal_8h_a0711416fceaf63c67b496e123e845c69}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!hadamard\+Local@{hadamard\+Local}}
\index{hadamard\+Local@{hadamard\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{hadamard\+Local()}{hadamardLocal()}}
{\footnotesize\ttfamily void hadamard\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}


Definition at line 1023 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by hadamard().


\begin{DoxyCode}
1024 \{
1025         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
1026         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
1027              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
1028 
1029         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1030         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1031         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1032 
1033         \textcolor{comment}{// test qubit valid}
1034         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1035 
1036         \textcolor{comment}{// set dimensions}
1037         sizeHalfBlock = 1LL << rotQubit;  
1038         sizeBlock     = 2LL * sizeHalfBlock; 
1039 
1040         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1041         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1042         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1043 
1044         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1045 
1046 \textcolor{preprocessor}{# ifdef \_OPENMP}
1047 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1048 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1049 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \(\backslash\)}
1050 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
1051 \textcolor{preprocessor}{# endif}
1052         \{
1053 \textcolor{preprocessor}{# ifdef \_OPENMP}
1054 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1055 \textcolor{preprocessor}{# endif}
1056                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1057                         thisBlock   = thisTask / sizeHalfBlock;
1058                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1059                         indexLo     = indexUp + sizeHalfBlock;
1060 
1061                         stateRealUp = stateVecReal[indexUp];
1062                         stateImagUp = stateVecImag[indexUp];
1063 
1064                         stateRealLo = stateVecReal[indexLo];
1065                         stateImagLo = stateVecImag[indexLo];
1066 
1067                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateRealLo);
1068                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImagLo);
1069 
1070                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateRealLo);
1071                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImagLo);
1072                 \} 
1073         \}
1074 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a35e5ac30c8427c482a97b33a4e295535}\label{qubits__internal_8h_a35e5ac30c8427c482a97b33a4e295535}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!measure\+In\+State\+Distributed\+Renorm@{measure\+In\+State\+Distributed\+Renorm}}
\index{measure\+In\+State\+Distributed\+Renorm@{measure\+In\+State\+Distributed\+Renorm}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{measure\+In\+State\+Distributed\+Renorm()}{measureInStateDistributedRenorm()}}
{\footnotesize\ttfamily \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} measure\+In\+State\+Distributed\+Renorm (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit,  }\item[{const \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}}]{total\+Probability }\end{DoxyParamCaption})}



Renormalise parts of the state vector where measure\+Qubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that the value \textquotesingle{}outcome\textquotesingle{} has been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. In the distributed version, one block (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em total\+Probability} & probability of qubit measure\+Qubit being zero \\
\hline
\end{DoxyParams}


Definition at line 1696 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+State().


\begin{DoxyCode}
1697 \{
1698         \textcolor{comment}{// ----- temp variables}
1699         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1700         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1701         \textcolor{comment}{// (good for shared memory parallelism)}
1702 
1703         \textcolor{comment}{// ---------------------------------------------------------------- //}
1704         \textcolor{comment}{//            tests                                                 //}
1705         \textcolor{comment}{// ---------------------------------------------------------------- //}
1706         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1707         assert (totalProbability != 0);
1708 
1709         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} renorm=1/sqrt(totalProbability);
1710         
1711         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1712         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1713 
1714 \textcolor{preprocessor}{# ifdef \_OPENMP}
1715 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1716 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1717 \textcolor{preprocessor}{        private   (thisTask)}
1718 \textcolor{preprocessor}{# endif}
1719         \{
1720 \textcolor{preprocessor}{# ifdef \_OPENMP}
1721 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1722 \textcolor{preprocessor}{# endif}
1723                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1724                         \textcolor{comment}{// summation -- simple implementation}
1725                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
1726                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
1727                 \}
1728         \}
1729         \textcolor{keywordflow}{return} totalProbability;
1730 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_ac39efc9ed939382276ebd0c15dd6a0fa}\label{qubits__internal_8h_ac39efc9ed939382276ebd0c15dd6a0fa}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!measure\+In\+State\+Distributed\+Set\+Zero@{measure\+In\+State\+Distributed\+Set\+Zero}}
\index{measure\+In\+State\+Distributed\+Set\+Zero@{measure\+In\+State\+Distributed\+Set\+Zero}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{measure\+In\+State\+Distributed\+Set\+Zero()}{measureInStateDistributedSetZero()}}
{\footnotesize\ttfamily void measure\+In\+State\+Distributed\+Set\+Zero (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit }\end{DoxyParamCaption})}



Set all amplitudes in one chunk to 0. 

Measure in Zero performs an irreversible change to the state vector\+: it updates the vector according to the event that a zero have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 or 1. In the distributed version, one block (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}


Definition at line 1745 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+State().


\begin{DoxyCode}
1746 \{
1747         \textcolor{comment}{// ----- temp variables}
1748         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1749         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1750         \textcolor{comment}{// (good for shared memory parallelism)}
1751 
1752         \textcolor{comment}{// ---------------------------------------------------------------- //}
1753         \textcolor{comment}{//            tests                                                 //}
1754         \textcolor{comment}{// ---------------------------------------------------------------- //}
1755         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1756 
1757         \textcolor{comment}{// ---------------------------------------------------------------- //}
1758         \textcolor{comment}{//            find probability                                      //}
1759         \textcolor{comment}{// ---------------------------------------------------------------- //}
1760 
1761         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1762         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1763 
1764 \textcolor{preprocessor}{# ifdef \_OPENMP}
1765 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1766 \textcolor{preprocessor}{        shared    (numTasks,stateVecReal,stateVecImag) \(\backslash\)}
1767 \textcolor{preprocessor}{        private   (thisTask)}
1768 \textcolor{preprocessor}{# endif}
1769         \{
1770 \textcolor{preprocessor}{# ifdef \_OPENMP}
1771 \textcolor{preprocessor}{                # pragma omp for schedule  (static)}
1772 \textcolor{preprocessor}{# endif}
1773                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1774                         \textcolor{comment}{// summation -- simple implementation}
1775                         stateVecReal[thisTask] = 0;
1776                         stateVecImag[thisTask] = 0;
1777                 \}
1778         \}
1779 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a53614ce19e0a4f2c41b400cf05dc5bd1}\label{qubits__internal_8h_a53614ce19e0a4f2c41b400cf05dc5bd1}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!measure\+In\+State\+Local@{measure\+In\+State\+Local}}
\index{measure\+In\+State\+Local@{measure\+In\+State\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{measure\+In\+State\+Local()}{measureInStateLocal()}}
{\footnotesize\ttfamily void measure\+In\+State\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{int}]{measure\+Qubit,  }\item[{\hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}}]{total\+Probability,  }\item[{int}]{outcome }\end{DoxyParamCaption})}



Update the state vector to be consistent with measuring measure\+Qubit=0 if outcome=0 and measure\+Qubit=1 if outcome=1. 

Performs an irreversible change to the state vector\+: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measure\+Qubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measure\+Qubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measure\+Qubit=0 in the first half of the block and measure\+Qubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em total\+Probability} & probability of qubit measure\+Qubit being either zero or one \\
\hline
\mbox{\tt in}  & {\em outcome} & to measure the probability of and set the state to -- either zero or one \\
\hline
\end{DoxyParams}


Definition at line 1607 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by measure\+In\+State().


\begin{DoxyCode}
1608 \{
1609         \textcolor{comment}{// ----- sizes}
1610         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock,                                           \textcolor{comment}{// size of blocks}
1611         sizeHalfBlock;                                       \textcolor{comment}{// size of blocks halved}
1612         \textcolor{comment}{// ----- indices}
1613         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock,                                           \textcolor{comment}{// current block}
1614              index;                                               \textcolor{comment}{// current index for first half block}
1615         \textcolor{comment}{// ----- measured probability}
1616         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   renorm;                                    \textcolor{comment}{// probability (returned) value}
1617         \textcolor{comment}{// ----- temp variables}
1618         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;                                   \textcolor{comment}{// task based approach for expose loop
       with small granularity}
1619         \textcolor{comment}{// (good for shared memory parallelism)}
1620         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1621 
1622         \textcolor{comment}{// ---------------------------------------------------------------- //}
1623         \textcolor{comment}{//            tests                                                 //}
1624         \textcolor{comment}{// ---------------------------------------------------------------- //}
1625         assert (measureQubit >= 0 && measureQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1626         assert (totalProbability != 0);
1627 
1628         \textcolor{comment}{// ---------------------------------------------------------------- //}
1629         \textcolor{comment}{//            dimensions                                            //}
1630         \textcolor{comment}{// ---------------------------------------------------------------- //}
1631         sizeHalfBlock = 1LL << (measureQubit);                       \textcolor{comment}{// number of state vector elements to
       sum,}
1632         \textcolor{comment}{// and then the number to skip}
1633         sizeBlock     = 2LL * sizeHalfBlock;                           \textcolor{comment}{// size of blocks (pairs of measure
       and skip entries)}
1634         
1635         renorm=1/sqrt(totalProbability);
1636         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1637         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1638 
1639 
1640 \textcolor{preprocessor}{# ifdef \_OPENMP}
1641 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1642 \textcolor{preprocessor}{        default (none) \(\backslash\)}
1643 \textcolor{preprocessor}{        shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,renorm,outcome) \(\backslash\)}
1644 \textcolor{preprocessor}{        private   (thisTask,thisBlock,index)}
1645 \textcolor{preprocessor}{# endif}
1646         \{
1647                 \textcolor{keywordflow}{if} (outcome==0)\{
1648                         \textcolor{comment}{// measure qubit is 0}
1649 \textcolor{preprocessor}{# ifdef \_OPENMP}
1650 \textcolor{preprocessor}{                        # pragma omp for schedule  (static)}
1651 \textcolor{preprocessor}{# endif}
1652                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1653                                 thisBlock = thisTask / sizeHalfBlock;
1654                                 index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1655                                 stateVecReal[index]=stateVecReal[index]*renorm;
1656                                 stateVecImag[index]=stateVecImag[index]*renorm;
1657 
1658                                 stateVecReal[index+sizeHalfBlock]=0;
1659                                 stateVecImag[index+sizeHalfBlock]=0;
1660                         \}
1661                 \} \textcolor{keywordflow}{else} \{
1662                         \textcolor{comment}{// measure qubit is 1}
1663 \textcolor{preprocessor}{# ifdef \_OPENMP}
1664 \textcolor{preprocessor}{                        # pragma omp for schedule  (static)}
1665 \textcolor{preprocessor}{# endif}
1666                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1667                                 thisBlock = thisTask / sizeHalfBlock;
1668                                 index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1669                                 stateVecReal[index]=0;
1670                                 stateVecImag[index]=0;
1671 
1672                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[index+sizeHalfBlock]*renorm;
1673                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[index+sizeHalfBlock]*renorm;
1674                         \}
1675                 \}
1676         \}
1677 
1678 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_ae275b94c1a483dda43bf4ec947635605}\label{qubits__internal_8h_ae275b94c1a483dda43bf4ec947635605}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!phase\+Gate@{phase\+Gate}}
\index{phase\+Gate@{phase\+Gate}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{phase\+Gate()}{phaseGate()}}
{\footnotesize\ttfamily void phase\+Gate (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type}}]{type }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em type} & the type of phase gate to apply -- one of \{S\+I\+G\+M\+A\+\_\+Z, S\+\_\+\+G\+A\+TE, T\+\_\+\+G\+A\+TE\} \\
\hline
\end{DoxyParams}


Definition at line 108 of file qubits\+\_\+env\+\_\+local.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps, phase\+Gate\+Distributed(), and phase\+Gate\+Local().



Referenced by s\+Gate(), sigma\+Z(), and t\+Gate().


\begin{DoxyCode}
109 \{
110         \hyperlink{qubits_8c_a6a736aeb3532898019fe7c27010edc6a}{phaseGateLocal}(multiQubit, rotQubit, type);
111 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a38a05c7e749e806b182ef3b89878bfc4}\label{qubits__internal_8h_a38a05c7e749e806b182ef3b89878bfc4}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!phase\+Gate\+Distributed@{phase\+Gate\+Distributed}}
\index{phase\+Gate\+Distributed@{phase\+Gate\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{phase\+Gate\+Distributed()}{phaseGateDistributed()}}
{\footnotesize\ttfamily void phase\+Gate\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type}}]{type }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em type} & the type of phase gate to apply -- one of \{S\+I\+G\+M\+A\+\_\+Z, S\+\_\+\+G\+A\+TE, T\+\_\+\+G\+A\+TE\} \\
\hline
\end{DoxyParams}


Definition at line 1230 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, S\+\_\+\+G\+A\+TE, S\+I\+G\+M\+A\+\_\+Z, Multi\+Qubit\+::state\+Vec, and T\+\_\+\+G\+A\+TE.



Referenced by phase\+Gate().


\begin{DoxyCode}
1231 \{
1232         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealLo,stateImagLo;
1233         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1234         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1235 
1236         \textcolor{comment}{// test qubit valid}
1237         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1238 
1239         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1240         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1241         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1242 
1243         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1244 
1245 \textcolor{preprocessor}{# ifdef \_OPENMP}
1246 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1247 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1248 \textcolor{preprocessor}{        shared   (stateVecReal,stateVecImag, recRoot2, type) \(\backslash\)}
1249 \textcolor{preprocessor}{        private  (thisTask,stateRealLo,stateImagLo) }
1250 \textcolor{preprocessor}{# endif}
1251         \{
1252                 \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{SIGMA\_Z})\{
1253 \textcolor{preprocessor}{# ifdef \_OPENMP}
1254 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1255 \textcolor{preprocessor}{# endif}
1256                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1257                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
1258                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
1259                         \} 
1260                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{S\_GATE})\{
1261 \textcolor{preprocessor}{# ifdef \_OPENMP}
1262 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1263 \textcolor{preprocessor}{# endif}
1264                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1265                                 stateRealLo = stateVecReal[thisTask];
1266                                 stateImagLo = stateVecImag[thisTask];
1267 
1268                                 stateVecReal[thisTask] = -stateImagLo;
1269                                 stateVecImag[thisTask] = stateRealLo;
1270                         \} 
1271                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{T\_GATE})\{
1272 \textcolor{preprocessor}{# ifdef \_OPENMP}
1273 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1274 \textcolor{preprocessor}{# endif}
1275                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1276                                 stateRealLo = stateVecReal[thisTask];
1277                                 stateImagLo = stateVecImag[thisTask];
1278 
1279                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo - stateImagLo);
1280                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo + stateImagLo);
1281                         \} 
1282                 \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"Type %d is an invalid phase gate\(\backslash\)n"}, type);
1283         \}
1284 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a6a736aeb3532898019fe7c27010edc6a}\label{qubits__internal_8h_a6a736aeb3532898019fe7c27010edc6a}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!phase\+Gate\+Local@{phase\+Gate\+Local}}
\index{phase\+Gate\+Local@{phase\+Gate\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{phase\+Gate\+Local()}{phaseGateLocal()}}
{\footnotesize\ttfamily void phase\+Gate\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type}}]{type }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em type} & the type of phase gate to apply -- one of \{S\+I\+G\+M\+A\+\_\+Z, S\+\_\+\+G\+A\+TE, T\+\_\+\+G\+A\+TE\} \\
\hline
\end{DoxyParams}
fix -- can i rewrite this to not use mod?

fix -- can i rewrite this to not use mod?

fix -- can i rewrite this to not use mod? 

Definition at line 1144 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, S\+\_\+\+G\+A\+TE, S\+I\+G\+M\+A\+\_\+Z, Multi\+Qubit\+::state\+Vec, and T\+\_\+\+G\+A\+TE.



Referenced by phase\+Gate().


\begin{DoxyCode}
1145 \{
1146         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
1147         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
1148              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
1149 
1150         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealLo,stateImagLo;
1151         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
1152         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
1153 
1154         \textcolor{comment}{// test qubit valid}
1155         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1156 
1157         \textcolor{comment}{// set dimensions}
1158         sizeHalfBlock = 1LL << rotQubit;  
1159         sizeBlock     = 2LL * sizeHalfBlock; 
1160 
1161         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
1162         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1163         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1164 
1165         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} recRoot2 = 1.0/sqrt(2);
1166 
1167 \textcolor{preprocessor}{# ifdef \_OPENMP}
1168 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1169 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1170 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type) \(\backslash\)}
1171 \textcolor{preprocessor}{        private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) }
1172 \textcolor{preprocessor}{# endif}
1173         \{
1174                 \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa754922d1e1846a1961ff2bf163483dac}{SIGMA\_Z})\{
1175 \textcolor{preprocessor}{# ifdef \_OPENMP}
1176 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1177 \textcolor{preprocessor}{# endif}
1178                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1180                                 thisBlock   = thisTask / sizeHalfBlock;
1181                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1182                                 indexLo     = indexUp + sizeHalfBlock;
1183 
1184                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
1185                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
1186                         \} 
1187                 \} 
1188                 
1189                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa06e60f80fa80cce271793d6d31bcc21f}{S\_GATE})\{
1190 \textcolor{preprocessor}{# ifdef \_OPENMP}
1191 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1192 \textcolor{preprocessor}{# endif}
1193                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1195                                 thisBlock   = thisTask / sizeHalfBlock;
1196                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1197                                 indexLo     = indexUp + sizeHalfBlock;
1198                                 stateRealLo = stateVecReal[indexLo];
1199                                 stateImagLo = stateVecImag[indexLo];
1200 
1201                                 stateVecReal[indexLo] = -stateImagLo;
1202                                 stateVecImag[indexLo] = stateRealLo;
1203                         \} 
1204                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type==\hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338eaa614d07d597a8e320cc556bc0e652e4ab}{T\_GATE})\{
1205 \textcolor{preprocessor}{# ifdef \_OPENMP}
1206 \textcolor{preprocessor}{                        # pragma omp for schedule (static)}
1207 \textcolor{preprocessor}{# endif}
1208                         \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1210                                 thisBlock   = thisTask / sizeHalfBlock;
1211                                 indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
1212                                 indexLo     = indexUp + sizeHalfBlock;
1213                                 stateRealLo = stateVecReal[indexLo];
1214                                 stateImagLo = stateVecImag[indexLo];
1215 
1216                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo - stateImagLo);
1217                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo + stateImagLo);
1218                         \} 
1219                 \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"Type %d is an invalid phase gate\(\backslash\)n"}, type);
1220         \}
1221 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a096cddbac961f0651a084d2ceb905d1b}\label{qubits__internal_8h_a096cddbac961f0651a084d2ceb905d1b}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!prob\+Of\+Filter\+Out111\+Local@{prob\+Of\+Filter\+Out111\+Local}}
\index{prob\+Of\+Filter\+Out111\+Local@{prob\+Of\+Filter\+Out111\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{prob\+Of\+Filter\+Out111\+Local()}{probOfFilterOut111Local()}}
{\footnotesize\ttfamily \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL} prob\+Of\+Filter\+Out111\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{id\+Qubit1,  }\item[{const int}]{id\+Qubit2,  }\item[{const int}]{id\+Qubit3 }\end{DoxyParamCaption})}



Evaluates the state according to this scenario\+: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. 

The function returns the probability of this outcome across all amplitudes in this chunk (if zero, it will exit with error) 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em id\+Qubit1,id\+Qubit2,id\+Qubit3} & specified qubits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Total probability that the 3 qubits are not all in the 1 state. 
\end{DoxyReturn}


Definition at line 1839 of file qubits.\+c.



References Multi\+Qubit\+::chunk\+Id, extract\+Bit(), Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by prob\+Of\+Filter\+Out111().


\begin{DoxyCode}
1840 \{
1841         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
1842         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} stateVecSize;
1843         \textcolor{keywordtype}{int} bit1, bit2, bit3;
1844         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkSize=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1845         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} chunkId=multiQubit.\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId};
1846 
1847         \textcolor{comment}{// ---------------------------------------------------------------- //}
1848         \textcolor{comment}{//            tests                                                 //}
1849         \textcolor{comment}{// ---------------------------------------------------------------- //}
1850         assert (idQubit1 >= 0 && idQubit2 >= 0 && idQubit1 < multiQubit.
      \hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits} && idQubit2 < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
1851 
1852         stateVecSize = multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
1853         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} probOfFilter=0;
1854         
1855         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
1856         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
1857 
1858 \textcolor{preprocessor}{# ifdef \_OPENMP}
1859 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1860 \textcolor{preprocessor}{        default  (none)                      \(\backslash\)}
1861 \textcolor{preprocessor}{        shared   (stateVecSize, stateVecReal,stateVecImag) \(\backslash\)}
1862 \textcolor{preprocessor}{        private  (index,bit1,bit2,bit3)                \(\backslash\)}
1863 \textcolor{preprocessor}{        reduction ( +:probOfFilter )}
1864 \textcolor{preprocessor}{# endif}
1865         \{
1866 \textcolor{preprocessor}{# ifdef \_OPENMP}
1867 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1868 \textcolor{preprocessor}{# endif}
1869                 \textcolor{keywordflow}{for} (index=0; index<stateVecSize; index++) \{
1870                         bit1 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit1, index+chunkId*chunkSize);
1871                         bit2 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit2, index+chunkId*chunkSize);
1872                         bit3 = \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (idQubit3, index+chunkId*chunkSize);
1873                         \textcolor{keywordflow}{if} (!(bit1 && bit2 && bit3)) \{
1874                                 probOfFilter+= stateVecReal[index]*stateVecReal[index] + stateVecImag[index
      ]* stateVecImag [index];
1875                         \}
1876                 \}
1877         \}
1878         \textcolor{keywordflow}{return} probOfFilter;
1879 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}\label{qubits__internal_8h_a6ff67d25363f39fd57a4e76621a4bfd5}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!rotate\+Qubit\+Distributed@{rotate\+Qubit\+Distributed}}
\index{rotate\+Qubit\+Distributed@{rotate\+Qubit\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{rotate\+Qubit\+Distributed()}{rotateQubitDistributed()}}
{\footnotesize\ttfamily void rotate\+Qubit\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{\hyperlink{structComplex}{Complex}}]{rot1,  }\item[{\hyperlink{structComplex}{Complex}}]{rot2,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Up,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Lo,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Out }\end{DoxyParamCaption})}



Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em rot1} & rotation angle \\
\hline
\mbox{\tt in}  & {\em rot2} & rotation angle \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Up} & probability amplitudes in upper half of a block \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+Lo} & probability amplitudes in lower half of a block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 472 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Complex\+::real.



Referenced by rotate\+Qubit().


\begin{DoxyCode}
477 \{
478 
479         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
480         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
481         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
482 
483         \textcolor{comment}{// test qubit valid}
484         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
485 
486         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot1Real=rot1.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot1Imag=rot1.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
487         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} rot2Real=rot2.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}, rot2Imag=rot2.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag};
488         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealUp=stateVecUp.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagUp=stateVecUp.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
489         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealLo=stateVecLo.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagLo=stateVecLo.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
490         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
491 
492 \textcolor{preprocessor}{# ifdef \_OPENMP}
493 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
494 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
495 \textcolor{preprocessor}{        shared  
       (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,stateVecRealOut,stateVecImagOut, \(\backslash\)}
496 \textcolor{preprocessor}{                        rot1Real,rot1Imag, rot2Real,rot2Imag) \(\backslash\)}
497 \textcolor{preprocessor}{        private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)}
498 \textcolor{preprocessor}{# endif}
499         \{
500 \textcolor{preprocessor}{# ifdef \_OPENMP}
501 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
502 \textcolor{preprocessor}{# endif}
503                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
504                         \textcolor{comment}{// store current state vector values in temp variables}
505                         stateRealUp = stateVecRealUp[thisTask];
506                         stateImagUp = stateVecImagUp[thisTask];
507 
508                         stateRealLo = stateVecRealLo[thisTask];
509                         stateImagLo = stateVecImagLo[thisTask];
510 
511                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
512                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*stateImagUp + rot2Real*
      stateRealLo + rot2Imag*stateImagLo;
513                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*stateRealUp + rot2Real*
      stateImagLo - rot2Imag*stateRealLo;
514                 \}
515         \}
516 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}\label{qubits__internal_8h_acb059cbcb8c7910a5fc43d21da4f5dea}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!rotate\+Qubit\+Local@{rotate\+Qubit\+Local}}
\index{rotate\+Qubit\+Local@{rotate\+Qubit\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{rotate\+Qubit\+Local()}{rotateQubitLocal()}}
{\footnotesize\ttfamily void rotate\+Qubit\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{\hyperlink{structComplex}{Complex}}]{alpha,  }\item[{\hyperlink{structComplex}{Complex}}]{beta }\end{DoxyParamCaption})}



Rotate a single qubit in the state vector of probability amplitudes. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em alpha} & rotation angle \\
\hline
\mbox{\tt in}  & {\em beta} & rotation angle \\
\hline
\end{DoxyParams}


Definition at line 397 of file qubits.\+c.



References Complex\+Array\+::imag, Complex\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, Complex\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by rotate\+Qubit().


\begin{DoxyCode}
398 \{
399         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
400         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
401              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
402 
403         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateRealLo,stateImagUp,stateImagLo;
404         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
405         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
406 
407         \textcolor{comment}{// test qubit valid}
408         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
409 
410         \textcolor{comment}{// set dimensions}
411         sizeHalfBlock = 1LL << rotQubit;  
412         sizeBlock     = 2LL * sizeHalfBlock; 
413 
414         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
415         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
416         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
417         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} alphaImag=alpha.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, alphaReal=alpha.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
418         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} betaImag=beta.\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}, betaReal=beta.\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real};
419 
420 \textcolor{preprocessor}{# ifdef \_OPENMP}
421 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
422 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
423 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,alphaImag,
       betaReal,betaImag) \(\backslash\)}
424 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,stateRealLo,stateImagLo) }
425 \textcolor{preprocessor}{# endif}
426         \{
427 \textcolor{preprocessor}{# ifdef \_OPENMP}
428 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
429 \textcolor{preprocessor}{# endif}
430                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
431 
432                         thisBlock   = thisTask / sizeHalfBlock;
433                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
434                         indexLo     = indexUp + sizeHalfBlock;
435 
436                         \textcolor{comment}{// store current state vector values in temp variables}
437                         stateRealUp = stateVecReal[indexUp];
438                         stateImagUp = stateVecImag[indexUp];
439 
440                         stateRealLo = stateVecReal[indexLo];
441                         stateImagLo = stateVecImag[indexLo];
442 
443                         \textcolor{comment}{// state[indexUp] = alpha * state[indexUp] - conj(beta)  * state[indexLo]}
444                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag*stateImagUp 
445                                 - betaReal*stateRealLo - betaImag*stateImagLo;
446                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag*stateRealUp 
447                                 - betaReal*stateImagLo + betaImag*stateRealLo;
448 
449                         \textcolor{comment}{// state[indexLo] = beta  * state[indexUp] + conj(alpha) * state[indexLo]}
450                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*stateImagUp 
451                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
452                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*stateRealUp 
453                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
454                 \} 
455         \}
456 
457 \} 
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a5958808b2f2f05937921ba7dabe5a171}\label{qubits__internal_8h_a5958808b2f2f05937921ba7dabe5a171}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!sigma\+X\+Distributed@{sigma\+X\+Distributed}}
\index{sigma\+X\+Distributed@{sigma\+X\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{sigma\+X\+Distributed()}{sigmaXDistributed()}}
{\footnotesize\ttfamily void sigma\+X\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+In,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Out }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{0,1\},\{1,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 751 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and R\+E\+AL.



Referenced by sigma\+X().


\begin{DoxyCode}
754 \{
755 
756         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
757         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
758 
759         \textcolor{comment}{// test qubit valid}
760         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
761 
762         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
763         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
764 
765 \textcolor{preprocessor}{# ifdef \_OPENMP}
766 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
767 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
768 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) \(\backslash\)}
769 \textcolor{preprocessor}{        private  (thisTask)}
770 \textcolor{preprocessor}{# endif}
771         \{
772 \textcolor{preprocessor}{# ifdef \_OPENMP}
773 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
774 \textcolor{preprocessor}{# endif}
775                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
776                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
777                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
778                 \}
779         \}
780 \} 
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_aa9e640bb2d0458c937c6a87dfeca0f23}\label{qubits__internal_8h_aa9e640bb2d0458c937c6a87dfeca0f23}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!sigma\+X\+Local@{sigma\+X\+Local}}
\index{sigma\+X\+Local@{sigma\+X\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{sigma\+X\+Local()}{sigmaXLocal()}}
{\footnotesize\ttfamily void sigma\+X\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{0,1\},\{1,0\}. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}


Definition at line 688 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by sigma\+X().


\begin{DoxyCode}
689 \{
690         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
691         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
692              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
693 
694         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
695         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
696         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
697 
698         \textcolor{comment}{// test qubit valid}
699         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
700 
701         \textcolor{comment}{// set dimensions}
702         sizeHalfBlock = 1LL << rotQubit;  
703         sizeBlock     = 2LL * sizeHalfBlock; 
704 
705         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
706         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
707         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
708 
709 \textcolor{preprocessor}{# ifdef \_OPENMP}
710 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
711 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
712 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
713 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) }
714 \textcolor{preprocessor}{# endif}
715         \{
716 \textcolor{preprocessor}{# ifdef \_OPENMP}
717 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
718 \textcolor{preprocessor}{# endif}
719                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
720                         thisBlock   = thisTask / sizeHalfBlock;
721                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
722                         indexLo     = indexUp + sizeHalfBlock;
723 
724                         stateRealUp = stateVecReal[indexUp];
725                         stateImagUp = stateVecImag[indexUp];
726 
727                         stateVecReal[indexUp] = stateVecReal[indexLo];
728                         stateVecImag[indexUp] = stateVecImag[indexLo];
729 
730                         stateVecReal[indexLo] = stateRealUp;
731                         stateVecImag[indexLo] = stateImagUp;
732                 \} 
733         \}
734 
735 \}
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_a0471f6b547ce8270ef85170b7f4f0214}\label{qubits__internal_8h_a0471f6b547ce8270ef85170b7f4f0214}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!sigma\+Y\+Distributed@{sigma\+Y\+Distributed}}
\index{sigma\+Y\+Distributed@{sigma\+Y\+Distributed}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{sigma\+Y\+Distributed()}{sigmaYDistributed()}}
{\footnotesize\ttfamily void sigma\+Y\+Distributed (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+In,  }\item[{\hyperlink{structComplexArray}{Complex\+Array}}]{state\+Vec\+Out,  }\item[{int}]{update\+Upper }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. 

Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and state\+Vec\+In must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\mbox{\tt in}  & {\em state\+Vec\+In} & probability amplitudes in lower or upper half of a block depending on chunk\+Id \\
\hline
\mbox{\tt in}  & {\em update\+Upper} & flag, 1\+: updating upper values, 0\+: updating lower values in block \\
\hline
\mbox{\tt out}  & {\em state\+Vec\+Out} & array section to update (will correspond to either the lower or upper half of a block) \\
\hline
\end{DoxyParams}


Definition at line 980 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, and R\+E\+AL.



Referenced by sigma\+Y().


\begin{DoxyCode}
984 \{
985 
986         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;  
987         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps};
988 
989         \textcolor{comment}{// test qubit valid}
990         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
991 
992         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealIn=stateVecIn.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagIn=stateVecIn.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
993         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecRealOut=stateVecOut.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}, *stateVecImagOut=stateVecOut.
      \hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
994 
995         \textcolor{keywordtype}{int} realSign=1, imagSign=1;
996         \textcolor{keywordflow}{if} (updateUpper) imagSign=-1;
997         \textcolor{keywordflow}{else} realSign = -1;
998 
999 \textcolor{preprocessor}{# ifdef \_OPENMP}
1000 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
1001 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
1002 \textcolor{preprocessor}{        shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,realSign,imagSign) \(\backslash\)}
1003 \textcolor{preprocessor}{        private  (thisTask)}
1004 \textcolor{preprocessor}{# endif}
1005         \{
1006 \textcolor{preprocessor}{# ifdef \_OPENMP}
1007 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
1008 \textcolor{preprocessor}{# endif}
1009                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
1010                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisTask];
1011                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisTask];
1012                 \}
1013         \}
1014 \} 
\end{DoxyCode}
\mbox{\Hypertarget{qubits__internal_8h_afcbb1dcbe070ad0ed1a72a23251b6a83}\label{qubits__internal_8h_afcbb1dcbe070ad0ed1a72a23251b6a83}} 
\index{qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}!sigma\+Y\+Local@{sigma\+Y\+Local}}
\index{sigma\+Y\+Local@{sigma\+Y\+Local}!qubits\+\_\+internal.\+h@{qubits\+\_\+internal.\+h}}
\paragraph{\texorpdfstring{sigma\+Y\+Local()}{sigmaYLocal()}}
{\footnotesize\ttfamily void sigma\+Y\+Local (\begin{DoxyParamCaption}\item[{\hyperlink{structMultiQubit}{Multi\+Qubit}}]{multi\+Qubit,  }\item[{const int}]{rot\+Qubit }\end{DoxyParamCaption})}



Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. 

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of qubits \\
\hline
\mbox{\tt in}  & {\em rot\+Qubit} & qubit to rotate \\
\hline
\end{DoxyParams}


Definition at line 917 of file qubits.\+c.



References Complex\+Array\+::imag, Multi\+Qubit\+::num\+Amps, Multi\+Qubit\+::num\+Qubits, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by sigma\+Y().


\begin{DoxyCode}
918 \{
919         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock, sizeHalfBlock;
920         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisBlock, \textcolor{comment}{// current block}
921              indexUp,indexLo;    \textcolor{comment}{// current index and corresponding index in lower half block}
922 
923         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} stateRealUp,stateImagUp;
924         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} thisTask;         
925         \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numTasks=multiQubit.\hyperlink{structMultiQubit_ae16f47d8b725c914fb7f66b6498d79db}{numAmps}>>1;
926 
927         \textcolor{comment}{// test qubit valid}
928         assert (rotQubit >= 0 && rotQubit < multiQubit.\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits});
929 
930         \textcolor{comment}{// set dimensions}
931         sizeHalfBlock = 1LL << rotQubit;  
932         sizeBlock     = 2LL * sizeHalfBlock; 
933 
934         \textcolor{comment}{// Can't use multiQubit.stateVec as a private OMP var}
935         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecReal = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real};
936         \hyperlink{precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL} *stateVecImag = multiQubit.\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}.\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag};
937 
938 \textcolor{preprocessor}{# ifdef \_OPENMP}
939 \textcolor{preprocessor}{# pragma omp parallel \(\backslash\)}
940 \textcolor{preprocessor}{        default  (none) \(\backslash\)}
941 \textcolor{preprocessor}{        shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \(\backslash\)}
942 \textcolor{preprocessor}{        private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) }
943 \textcolor{preprocessor}{# endif}
944         \{
945 \textcolor{preprocessor}{# ifdef \_OPENMP}
946 \textcolor{preprocessor}{                # pragma omp for schedule (static)}
947 \textcolor{preprocessor}{# endif}
948                 \textcolor{keywordflow}{for} (thisTask=0; thisTask<numTasks; thisTask++) \{
949                         thisBlock   = thisTask / sizeHalfBlock;
950                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
951                         indexLo     = indexUp + sizeHalfBlock;
952 
953                         stateRealUp = stateVecReal[indexUp];
954                         stateImagUp = stateVecImag[indexUp];
955 
956                         stateVecReal[indexUp] = stateVecImag[indexLo];
957                         stateVecImag[indexUp] = -stateVecReal[indexLo];
958 
959                         stateVecReal[indexLo] = -stateImagUp;
960                         stateVecImag[indexLo] = stateRealUp;
961                 \} 
962         \}
963 \}
\end{DoxyCode}
