\hypertarget{qubits__env__mpi_8c}{
\subsection{qubits\_\-env\_\-mpi.c File Reference}
\label{qubits__env__mpi_8c}\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}}
}


An implementation of the API in \hyperlink{qubits_8h}{qubits.h} for an MPI environment.  
{\ttfamily \#include $<$unistd.h$>$}\par
{\ttfamily \#include $<$mpi.h$>$}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$stdio.h$>$}\par
{\ttfamily \#include $<$omp.h$>$}\par
{\ttfamily \#include \char`\"{}precision.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}qubits.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}qubits\_\-internal.h\char`\"{}}\par
\subsubsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}{\_\-BSD\_\-SOURCE}
\item 
\#define \hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}~0
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{isChunkToSkipInFindPZero} (int chunkId, long long int chunkSize, int measureQubit)
\begin{DoxyCompactList}\small\item\em Find chunks to skip when calculating probability of qubit being zero. \item\end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{chunkIsUpper} (int chunkId, long long int chunkSize, int rotQubit)
\begin{DoxyCompactList}\small\item\em Returns whether a given chunk in position chunkId is in the upper or lower half of a block. \item\end{DoxyCompactList}\item 
static void \hyperlink{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{getRotAngle} (int chunkIsUpper, \hyperlink{structComplex}{Complex} $\ast$rot1, \hyperlink{structComplex}{Complex} $\ast$rot2, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Get rotation values for a given chunk. \item\end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{getChunkPairId} (int chunkIsUpper, int chunkId, long long int chunkSize, int rotQubit)
\begin{DoxyCompactList}\small\item\em get position of corresponding chunk, holding values required to update values in my chunk (with chunkId) when rotating rotQubit. \item\end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{halfMatrixBlockFitsInChunk} (long long int chunkSize, int rotQubit)
\begin{DoxyCompactList}\small\item\em return whether the current qubit rotation will use blocks that fit within a single chunk. \item\end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{getChunkIdFromIndex} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\item 
void \hyperlink{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}{initQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} $\ast$env)
\begin{DoxyCompactList}\small\item\em Initialize QuEST environment. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{syncQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Guarantees that all code up to the given point has been executed on all nodes. \item\end{DoxyCompactList}\item 
int \hyperlink{qubits__env__mpi_8c_a877396e10f0e9aeead078664c51bb0e3}{syncQuESTSuccess} (\hyperlink{structQuESTEnv}{QuESTEnv} env, int successCode)
\begin{DoxyCompactList}\small\item\em Performs a logical AND on all successCodes held by all processes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}{closeQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Close QuEST environment. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}{reportQuESTEnv} (\hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Report information about the QuEST environment. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}{reportNodeList} (\hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Report a list of CPU hostnames and the rank that is running on each if running with MPI enabled and an error message otherwise. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}{getRealAmpEl} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the real component of the probability amplitude at an index in the state vector. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}{getImagAmpEl} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the imaginary component of the probability amplitude at an index in the state vector. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}{calcTotalProbability} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Calculate the probability of being in any state by taking the norm of the entire state vector. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int pairRank)
\item 
void \hyperlink{qubits__env__mpi_8c_a4ba468aa69f812efd1f964e10a45ca2f}{rotateQubit} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_abac5189a14bc12e79580ba0d75de796e}{controlRotateQubit} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, const int controlQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_acda82bebb0a62f419eec9c1e0575daad}{sigmaX} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a41f33b4f5f2bf697821591eb224cabb9}{controlNot} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, const int controlQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$ and apply a phase of -\/i or i, only for elements when control qubit is 1. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a7b022c75cef77be046bd5d61e38a581e}{sigmaY} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$ and apply a phase of -\/i or i. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ae275b94c1a483dda43bf4ec947635605}{phaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ad247d084dc7150893e9051a438a5807e}{hadamard} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2 -\/-\/ turn a $|$0$>$ into a $|$+$>$ and a $|$1$>$ into a $|$-\/$>$. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{findProbabilityOfOutcome} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, int outcome)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero or one state. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__env__mpi_8c_a88605f373c2401760aab0e08719e08dd}{measureInState} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measureQubit=0 or measureQubit=1 according to the value of outcome. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__env__mpi_8c_ae8fcabd3f22c6c9a9104e1807fb78f80}{filterOut111} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int idQubit1, const int idQubit2, const int idQubit3)
\begin{DoxyCompactList}\small\item\em Updates the state according to this scenario: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__env__mpi_8c_a909ba48b5a82c9f5c3a94d17a72b1aa3}{probOfFilterOut111} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int idQubit1, const int idQubit2, const int idQubit3)
\begin{DoxyCompactList}\small\item\em Evaluates the state according to this scenario: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. \item\end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
An implementation of the API in \hyperlink{qubits_8h}{qubits.h} for an MPI environment. 

Definition in file \hyperlink{qubits__env__mpi_8c_source}{qubits\_\-env\_\-mpi.c}.

\subsubsection{Define Documentation}
\hypertarget{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!\_\-BSD\_\-SOURCE@{\_\-BSD\_\-SOURCE}}
\index{\_\-BSD\_\-SOURCE@{\_\-BSD\_\-SOURCE}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{\_\-BSD\_\-SOURCE}]{\setlength{\rightskip}{0pt plus 5cm}\#define \_\-BSD\_\-SOURCE}\hfill}
\label{qubits__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}


Definition at line 5 of file qubits\_\-env\_\-mpi.c.\hypertarget{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!DEBUG@{DEBUG}}
\index{DEBUG@{DEBUG}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{DEBUG}]{\setlength{\rightskip}{0pt plus 5cm}\#define DEBUG~0}\hfill}
\label{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}


Definition at line 17 of file qubits\_\-env\_\-mpi.c.

\subsubsection{Function Documentation}
\hypertarget{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!calcTotalProbability@{calcTotalProbability}}
\index{calcTotalProbability@{calcTotalProbability}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{calcTotalProbability}]{\setlength{\rightskip}{0pt plus 5cm}REAL calcTotalProbability ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}


Calculate the probability of being in any state by taking the norm of the entire state vector. Should be equal to 1. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \end{DoxyParams}
\begin{DoxyReturn}{Returns}
total probability 
\end{DoxyReturn}


Definition at line 107 of file qubits\_\-env\_\-mpi.c.

References DEBUG, ComplexArray::imag, MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
107                                                 {
108   /* IJB - implemented using Kahan summation for greater accuracy at a slight flo
      ating
109      point operation overhead. For more details see https://en.wikipedia.org/wiki
      /Kahan_summation_algorithm */
110   /* Don't change the bracketing in this routine! */
111   REAL pTotal=0; 
112   REAL y, t, c;
113   REAL allRankTotals=0;
114   long long int index;
115   long long int numAmpsPerRank = multiQubit.numAmps;
116   c = 0.0;
117   for (index=0; index<numAmpsPerRank; index++){ 
118     /* Perform pTotal+=multiQubit.stateVec.real[index]*multiQubit.stateVec.real[i
      ndex]; by Kahan */
119     y = multiQubit.stateVec.real[index]*multiQubit.stateVec.real[index] - c;
120     t = pTotal + y;
121     c = ( t - pTotal ) - y;
122     pTotal = t;
123     /* Perform pTotal+=multiQubit.stateVec.imag[index]*multiQubit.stateVec.imag[i
      ndex]; by Kahan */
124     y = multiQubit.stateVec.imag[index]*multiQubit.stateVec.imag[index] - c;
125     t = pTotal + y;
126     c = ( t - pTotal ) - y;
127     pTotal = t;
128   } 
129   if (DEBUG) printf("before calc prob. %d\n", multiQubit.numChunks);
130   if (multiQubit.numChunks>1) MPI_Allreduce(&pTotal, &allRankTotals, 1, 
      MPI_QuEST_REAL, MPI_SUM, MPI_COMM_WORLD);
131   else allRankTotals=pTotal;
132   
133   return allRankTotals;
134 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!chunkIsUpper@{chunkIsUpper}}
\index{chunkIsUpper@{chunkIsUpper}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{chunkIsUpper}]{\setlength{\rightskip}{0pt plus 5cm}static int chunkIsUpper (int {\em chunkId}, \/  long long int {\em chunkSize}, \/  int {\em rotQubit})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_a814c41ee59e206c362f2eaf1def88be6}


Returns whether a given chunk in position chunkId is in the upper or lower half of a block. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkId}]id of chunk in state vector \item[\mbox{$\leftarrow$} {\em chunkSize}]number of amps in chunk \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit being rotated \end{DoxyParams}
\begin{DoxyReturn}{Returns}
1: chunk is in upper half of block, 0: chunk is in lower half of block fix -\/-\/ is this the same as isChunkToSkip? 
\end{DoxyReturn}


Definition at line 145 of file qubits\_\-env\_\-mpi.c.

Referenced by controlNot(), controlRotateQubit(), hadamard(), phaseGate(), rotateQubit(), sigmaX(), and sigmaY().


\begin{DoxyCode}
146 {       
147         long long int sizeHalfBlock = 1LL << (rotQubit);
148         long long int sizeBlock = sizeHalfBlock*2;
149         long long int posInBlock = (chunkId*chunkSize) % sizeBlock;
150         return posInBlock<sizeHalfBlock;
151 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!closeQuESTEnv@{closeQuESTEnv}}
\index{closeQuESTEnv@{closeQuESTEnv}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{closeQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void closeQuESTEnv ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}


Close QuEST environment. If something needs to be done to clean up the execution environment, such as finalizing MPI when running in distributed mode, it is handled here 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 55 of file qubits\_\-env\_\-mpi.c.


\begin{DoxyCode}
55                                 {
56         int finalized;
57         MPI_Finalized(&finalized);
58         if (!finalized) MPI_Finalize();
59         else printf("ERROR: Trying to close QuESTEnv multiple times. Ignoring\n")
      ;
60 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a41f33b4f5f2bf697821591eb224cabb9}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!controlNot@{controlNot}}
\index{controlNot@{controlNot}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{controlNot}]{\setlength{\rightskip}{0pt plus 5cm}void controlNot ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  const int {\em controlQubit})}\hfill}
\label{qubits__env__mpi_8c_a41f33b4f5f2bf697821591eb224cabb9}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$ and apply a phase of -\/i or i, only for elements when control qubit is 1. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform sigmaX rotation if this qubit is 1 \end{DoxyParams}


Definition at line 347 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), controlNotDistributed(), controlNotLocal(), exchangeStateVectors(), getChunkPairId(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::pairStateVec, and MultiQubit::stateVec.


\begin{DoxyCode}
348 {
349         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
350         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
351 
352         // rank's chunk is in upper half of block 
353         int rankIsUpper;
354         int pairRank; // rank of corresponding chunk
355 
356         if (useLocalDataOnly){
357                 // all values required to update state vector lie in this rank
358                 controlNotLocal(multiQubit, rotQubit, controlQubit);
359         } else {
360                 // need to get corresponding chunk of state vector from other ran
      k
361                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
362                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, rotQubit);
363                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
364                 // get corresponding values from my pair
365                 exchangeStateVectors(multiQubit, pairRank);
366                 // this rank's values are either in the upper of lower half of th
      e block. send values to rotateQubitDistributed
367                 // in the correct order
368                 if (rankIsUpper){
369                         controlNotDistributed(multiQubit,rotQubit,controlQubit,
370                                 multiQubit.pairStateVec, //in
371                                 multiQubit.stateVec); //out
372                 } else {
373                         controlNotDistributed(multiQubit,rotQubit,controlQubit,
374                                 multiQubit.pairStateVec, //in
375                                 multiQubit.stateVec); //out
376                 }
377         }
378 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_abac5189a14bc12e79580ba0d75de796e}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!controlRotateQubit@{controlRotateQubit}}
\index{controlRotateQubit@{controlRotateQubit}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{controlRotateQubit}]{\setlength{\rightskip}{0pt plus 5cm}void controlRotateQubit ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  const int {\em controlQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__env__mpi_8c_abac5189a14bc12e79580ba0d75de796e}


Rotate a single qubit in the state vector of probability amplitudes. Given two complex numbers alpha and beta and a control qubit, applies the operation: \par
 \mbox{[}alpha, -\/beta$\ast$ \par
 beta, alpha$\ast$\mbox{]} \par
 Only when the control qubit is one.

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}
alpha, beta must obey $|$alpha$|$$^\wedge$2 + $|$beta$|$$^\wedge$2 = 1


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform rotation if this qubit is 1 \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 282 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), controlRotateQubitDistributed(), controlRotateQubitLocal(), exchangeStateVectors(), getChunkPairId(), getRotAngle(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::pairStateVec, and MultiQubit::stateVec.


\begin{DoxyCode}
283 {
284         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
285         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
286         Complex rot1, rot2;
287 
288         // rank's chunk is in upper half of block 
289         int rankIsUpper;
290         int pairRank; // rank of corresponding chunk
291 
292         if (useLocalDataOnly){
293                 // all values required to update state vector lie in this rank
294                 controlRotateQubitLocal(multiQubit, rotQubit, controlQubit, alpha
      , beta);
295         } else {
296                 // need to get corresponding chunk of state vector from other ran
      k
297                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
298                 getRotAngle(rankIsUpper, &rot1, &rot2, alpha, beta);
299                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, rotQubit);
300                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
301                 // get corresponding values from my pair
302                 exchangeStateVectors(multiQubit, pairRank);
303                 
304                 // this rank's values are either in the upper of lower half of th
      e block. send values to rotateQubitDistributed
305                 // in the correct order
306                 if (rankIsUpper){
307                         controlRotateQubitDistributed(multiQubit,rotQubit,control
      Qubit,rot1,rot2,
308                                 multiQubit.stateVec, //upper
309                                 multiQubit.pairStateVec, //lower
310                                 multiQubit.stateVec); //output
311                 } else {
312                         controlRotateQubitDistributed(multiQubit,rotQubit,control
      Qubit,rot1,rot2,
313                                 multiQubit.pairStateVec, //upper
314                                 multiQubit.stateVec, //lower
315                                 multiQubit.stateVec); //output
316                 }
317         }
318 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!exchangeStateVectors@{exchangeStateVectors}}
\index{exchangeStateVectors@{exchangeStateVectors}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{exchangeStateVectors}]{\setlength{\rightskip}{0pt plus 5cm}void exchangeStateVectors ({\bf MultiQubit} {\em multiQubit}, \/  int {\em pairRank})}\hfill}
\label{qubits__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}


Definition at line 213 of file qubits\_\-env\_\-mpi.c.

References DEBUG, ComplexArray::imag, MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, MultiQubit::pairStateVec, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlNot(), controlRotateQubit(), hadamard(), rotateQubit(), sigmaX(), and sigmaY().


\begin{DoxyCode}
213                                                               {
214         // MPI send/receive vars
215         int TAG=100;
216         MPI_Status status;
217 
218         // Multiple messages are required as MPI uses int rather than long long i
      nt for count
219         // For openmpi, messages are further restricted to 2GB in size -- do this
       for all cases
220         // to be safe
221         long long int maxMessageCount = 1LL<<29;
222         if (sizeof(REAL)==8) maxMessageCount = (1LL<<28);
223         else if (sizeof(REAL)==16) maxMessageCount = (1LL<<27);
224 
225         if (multiQubit.numAmps<maxMessageCount) maxMessageCount = multiQubit.
      numAmps;
226         int numMessages = multiQubit.numAmps/maxMessageCount;
227         int i;
228         long long int offset;
229         if (DEBUG) printf("numMessages %d maxMessageCount %lld\n", numMessages, m
      axMessageCount);
230 
231         // send my state vector to pairRank's multiQubit.pairStateVec
232         // receive pairRank's state vector into multiQubit.pairStateVec
233         for (i=0; i<numMessages; i++){
234                 offset = i*maxMessageCount;
235                 MPI_Sendrecv(&multiQubit.stateVec.real[offset], maxMessageCount, 
      MPI_QuEST_REAL, pairRank, TAG,
236                                  &multiQubit.pairStateVec.real[offset], maxMessag
      eCount, MPI_QuEST_REAL,
237                                  pairRank, TAG, MPI_COMM_WORLD, &status);
238                 //printf("rank: %d err: %d\n", multiQubit.rank, err);
239                 MPI_Sendrecv(&multiQubit.stateVec.imag[offset], maxMessageCount, 
      MPI_QuEST_REAL, pairRank, TAG,
240                                 &multiQubit.pairStateVec.imag[offset], maxMessage
      Count, MPI_QuEST_REAL,
241                                 pairRank, TAG, MPI_COMM_WORLD, &status);
242         }
243 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ae8fcabd3f22c6c9a9104e1807fb78f80}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!filterOut111@{filterOut111}}
\index{filterOut111@{filterOut111}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{filterOut111}]{\setlength{\rightskip}{0pt plus 5cm}REAL filterOut111 ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em idQubit1}, \/  const int {\em idQubit2}, \/  const int {\em idQubit3})}\hfill}
\label{qubits__env__mpi_8c_ae8fcabd3f22c6c9a9104e1807fb78f80}


Updates the state according to this scenario: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. The function returns the probability of this outcome (if zero, it will exit with error) 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em idQubit1,idQubit2,idQubit3}]specified qubits \end{DoxyParams}
\begin{DoxyReturn}{Returns}
Total probability that the 3 qubits are not all in the 1 state. 
\end{DoxyReturn}


Definition at line 522 of file qubits\_\-env\_\-mpi.c.

References filterOut111Local(), probOfFilterOut111(), and REAL.


\begin{DoxyCode}
523 {
524         REAL stateProb=0;
525         stateProb = probOfFilterOut111(multiQubit, idQubit1, idQubit2, idQubit3);
      
526         if (stateProb != 0) filterOut111Local(multiQubit, idQubit1, idQubit2, idQ
      ubit3, stateProb);
527         return stateProb;
528 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!findProbabilityOfOutcome@{findProbabilityOfOutcome}}
\index{findProbabilityOfOutcome@{findProbabilityOfOutcome}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{findProbabilityOfOutcome}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfOutcome ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  int {\em outcome})}\hfill}
\label{qubits__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}


Measure the probability of a specified qubit being in the zero or one state. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em outcome}]to measure the probability of -\/-\/ either zero or one \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being either zero or one 
\end{DoxyReturn}


Definition at line 481 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, findProbabilityOfZeroDistributed(), findProbabilityOfZeroLocal(), halfMatrixBlockFitsInChunk(), isChunkToSkipInFindPZero(), MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, and REAL.

Referenced by measureInState().


\begin{DoxyCode}
482 {
483         REAL stateProb=0, totalStateProb=0;
484         int skipValuesWithinRank = halfMatrixBlockFitsInChunk(multiQubit.numAmps,
       measureQubit);
485         if (skipValuesWithinRank) {
486                 stateProb = findProbabilityOfZeroLocal(multiQubit, measureQubit);
      
487         } else {
488                 if (!isChunkToSkipInFindPZero(multiQubit.chunkId, multiQubit.
      numAmps, measureQubit)){
489                         stateProb = findProbabilityOfZeroDistributed(multiQubit, 
      measureQubit);
490                 } else stateProb = 0;
491         }
492         MPI_Allreduce(&stateProb, &totalStateProb, 1, MPI_QuEST_REAL, MPI_SUM, MP
      I_COMM_WORLD);
493         if (outcome==1) totalStateProb = 1.0 - totalStateProb;
494         return totalStateProb;
495 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getChunkIdFromIndex@{getChunkIdFromIndex}}
\index{getChunkIdFromIndex@{getChunkIdFromIndex}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getChunkIdFromIndex}]{\setlength{\rightskip}{0pt plus 5cm}int getChunkIdFromIndex ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}


Definition at line 83 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::numAmps.

Referenced by getImagAmpEl(), and getRealAmpEl().


\begin{DoxyCode}
83                                                                    {
84         return index/multiQubit.numAmps; // this is numAmpsPerChunk
85 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getChunkPairId@{getChunkPairId}}
\index{getChunkPairId@{getChunkPairId}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getChunkPairId}]{\setlength{\rightskip}{0pt plus 5cm}static int getChunkPairId (int {\em chunkIsUpper}, \/  int {\em chunkId}, \/  long long int {\em chunkSize}, \/  int {\em rotQubit})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_af5bdeedf4a445b539d329c3000859f5a}


get position of corresponding chunk, holding values required to update values in my chunk (with chunkId) when rotating rotQubit. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkIsUpper}]1: chunk is in upper half of block, 0: chunk is in lower half \item[\mbox{$\leftarrow$} {\em chunkId}]id of chunk in state vector \item[\mbox{$\leftarrow$} {\em chunkSize}]number of amps in chunk \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit being rotated \end{DoxyParams}
\begin{DoxyReturn}{Returns}
chunkId of chunk required to rotate rotQubit 
\end{DoxyReturn}


Definition at line 187 of file qubits\_\-env\_\-mpi.c.

Referenced by controlNot(), controlRotateQubit(), hadamard(), rotateQubit(), sigmaX(), and sigmaY().


\begin{DoxyCode}
188 {
189         long long int sizeHalfBlock = 1LL << (rotQubit);
190         int chunksPerHalfBlock = sizeHalfBlock/chunkSize;
191         if (chunkIsUpper){
192                 return chunkId + chunksPerHalfBlock;
193         } else {
194                 return chunkId - chunksPerHalfBlock;
195         }
196 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getImagAmpEl@{getImagAmpEl}}
\index{getImagAmpEl@{getImagAmpEl}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getImagAmpEl}]{\setlength{\rightskip}{0pt plus 5cm}REAL getImagAmpEl ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})}\hfill}
\label{qubits__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}


Get the imaginary component of the probability amplitude at an index in the state vector. For debugging purposes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \item[\mbox{$\leftarrow$} {\em index}]index in state vector of probability amplitudes \end{DoxyParams}
\begin{DoxyReturn}{Returns}
imaginary component at that index 
\end{DoxyReturn}


Definition at line 97 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, getChunkIdFromIndex(), ComplexArray::imag, MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, REAL, and MultiQubit::stateVec.

Referenced by getProbEl().


\begin{DoxyCode}
97                                                              {
98         int chunkId = getChunkIdFromIndex(multiQubit, index);
99         REAL el; 
100         if (multiQubit.chunkId==chunkId){
101                 el = multiQubit.stateVec.imag[index-chunkId*multiQubit.numAmps];
102         }
103         MPI_Bcast(&el, 1, MPI_QuEST_REAL, chunkId, MPI_COMM_WORLD);
104         return el; 
105 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getRealAmpEl@{getRealAmpEl}}
\index{getRealAmpEl@{getRealAmpEl}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getRealAmpEl}]{\setlength{\rightskip}{0pt plus 5cm}REAL getRealAmpEl ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})}\hfill}
\label{qubits__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}


Get the real component of the probability amplitude at an index in the state vector. For debugging purposes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \item[\mbox{$\leftarrow$} {\em index}]index in state vector of probability amplitudes \end{DoxyParams}
\begin{DoxyReturn}{Returns}
real component at that index 
\end{DoxyReturn}


Definition at line 87 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, getChunkIdFromIndex(), MPI\_\-QuEST\_\-REAL, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by getProbEl().


\begin{DoxyCode}
87                                                              {
88         int chunkId = getChunkIdFromIndex(multiQubit, index);
89         REAL el; 
90         if (multiQubit.chunkId==chunkId){
91                 el = multiQubit.stateVec.real[index-chunkId*multiQubit.numAmps];
92         }
93         MPI_Bcast(&el, 1, MPI_QuEST_REAL, chunkId, MPI_COMM_WORLD);
94         return el; 
95 } 
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getRotAngle@{getRotAngle}}
\index{getRotAngle@{getRotAngle}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getRotAngle}]{\setlength{\rightskip}{0pt plus 5cm}static void getRotAngle (int {\em chunkIsUpper}, \/  {\bf Complex} $\ast$ {\em rot1}, \/  {\bf Complex} $\ast$ {\em rot2}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}


Get rotation values for a given chunk. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkIsUpper}]1: chunk is in upper half of block, 0: chunk is in lower half\item[\mbox{$\rightarrow$} {\em rot1,rot2}]rotation values to use, allocated for upper/lower such that \begin{DoxyVerb}
stateUpper = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 or \begin{DoxyVerb}
stateLower = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 \item[\mbox{$\leftarrow$} {\em alpha,beta}]initial rotation values \end{DoxyParams}


Definition at line 166 of file qubits\_\-env\_\-mpi.c.

References Complex::imag, and Complex::real.

Referenced by controlRotateQubit(), and rotateQubit().


\begin{DoxyCode}
167 {
168         if (chunkIsUpper){
169                 *rot1=alpha;
170                 rot2->real=-beta.real;
171                 rot2->imag=-beta.imag;
172         } else {
173                 *rot1=beta;
174                 *rot2=alpha;
175         }
176 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ad247d084dc7150893e9051a438a5807e}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!hadamard@{hadamard}}
\index{hadamard@{hadamard}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{hadamard}]{\setlength{\rightskip}{0pt plus 5cm}void hadamard ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit})}\hfill}
\label{qubits__env__mpi_8c_ad247d084dc7150893e9051a438a5807e}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2 -\/-\/ turn a $|$0$>$ into a $|$+$>$ and a $|$1$>$ into a $|$-\/$>$. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \end{DoxyParams}


Definition at line 425 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), hadamardDistributed(), hadamardLocal(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::pairStateVec, and MultiQubit::stateVec.


\begin{DoxyCode}
426 {
427         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
428         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
429 
430         // rank's chunk is in upper half of block 
431         int rankIsUpper;
432         int pairRank; // rank of corresponding chunk
433 
434         if (useLocalDataOnly){
435                 // all values required to update state vector lie in this rank
436                 hadamardLocal(multiQubit, rotQubit);
437         } else {
438                 // need to get corresponding chunk of state vector from other ran
      k
439                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
440                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, rotQubit);
441                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
442                 // get corresponding values from my pair
443                 exchangeStateVectors(multiQubit, pairRank);
444                 // this rank's values are either in the upper of lower half of th
      e block. send values to rotateQubitDistributed
445                 // in the correct order
446                 if (rankIsUpper){
447                         hadamardDistributed(multiQubit,rotQubit,
448                                 multiQubit.stateVec, //upper
449                                 multiQubit.pairStateVec, //lower
450                                 multiQubit.stateVec, rankIsUpper); //output
451                 } else {
452                         hadamardDistributed(multiQubit,rotQubit,
453                                 multiQubit.pairStateVec, //upper
454                                 multiQubit.stateVec, //lower
455                                 multiQubit.stateVec, rankIsUpper); //output
456                 }
457         }
458 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!halfMatrixBlockFitsInChunk@{halfMatrixBlockFitsInChunk}}
\index{halfMatrixBlockFitsInChunk@{halfMatrixBlockFitsInChunk}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{halfMatrixBlockFitsInChunk}]{\setlength{\rightskip}{0pt plus 5cm}static int halfMatrixBlockFitsInChunk (long long int {\em chunkSize}, \/  int {\em rotQubit})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_a6d968d42f466bd03cea5edba456e10f7}


return whether the current qubit rotation will use blocks that fit within a single chunk. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkSize}]number of amps in chunk \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit being rotated \end{DoxyParams}
\begin{DoxyReturn}{Returns}
1: one chunk fits in one block 0: chunk is larger than block 
\end{DoxyReturn}


Definition at line 206 of file qubits\_\-env\_\-mpi.c.

Referenced by controlNot(), controlRotateQubit(), findProbabilityOfOutcome(), hadamard(), measureInState(), phaseGate(), rotateQubit(), sigmaX(), and sigmaY().


\begin{DoxyCode}
207 {
208         long long int sizeHalfBlock = 1LL << (rotQubit);
209         if (chunkSize > sizeHalfBlock) return 1;
210         else return 0;
211 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!initQuESTEnv@{initQuESTEnv}}
\index{initQuESTEnv@{initQuESTEnv}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{initQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void initQuESTEnv ({\bf QuESTEnv} $\ast$ {\em env})}\hfill}
\label{qubits__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}


Initialize QuEST environment. If something needs to be done to set up the execution environment, such as initializing MPI when running in distributed mode, it is handled here 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 25 of file qubits\_\-env\_\-mpi.c.

References DEBUG, QuESTEnv::numRanks, and QuESTEnv::rank.


\begin{DoxyCode}
25                                 {
26         // init MPI environment
27         int rank, numRanks, initialized;
28         MPI_Initialized(&initialized);
29         if (!initialized){
30                 MPI_Init(NULL, NULL);
31                 MPI_Comm_size(MPI_COMM_WORLD, &numRanks);
32                 MPI_Comm_rank(MPI_COMM_WORLD, &rank);
33 
34                 if (DEBUG) {
35                         char hostName[256];
36                         int hostNameLen;
37                         MPI_Get_processor_name(hostName, &hostNameLen);
38                         printf("rank %d on host %s\n", rank, hostName);
39                 }
40                 env->rank=rank;
41                 env->numRanks=numRanks;
42         } else printf("ERROR: Trying to initialize QuESTEnv multiple times. Ignor
      ing\n");
43 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!isChunkToSkipInFindPZero@{isChunkToSkipInFindPZero}}
\index{isChunkToSkipInFindPZero@{isChunkToSkipInFindPZero}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{isChunkToSkipInFindPZero}]{\setlength{\rightskip}{0pt plus 5cm}static int isChunkToSkipInFindPZero (int {\em chunkId}, \/  long long int {\em chunkSize}, \/  int {\em measureQubit})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}


Find chunks to skip when calculating probability of qubit being zero. When calculating probability of a bit q being zero, sum up 2$^\wedge$q values, then skip 2$^\wedge$q values, etc. This function finds if an entire chunk is in the range of values to be skipped


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkId}]id of chunk in state vector \item[\mbox{$\leftarrow$} {\em chunkSize}]number of amps in chunk \item[\mbox{$\leftarrow$} {\em measureQubi}]qubit being measured \end{DoxyParams}
\begin{DoxyReturn}{Returns}
int -\/-\/ 1: skip, 0: don't skip 
\end{DoxyReturn}


Definition at line 472 of file qubits\_\-env\_\-mpi.c.

Referenced by findProbabilityOfOutcome(), and measureInState().


\begin{DoxyCode}
473 {
474         long long int sizeHalfBlock = 1LL << (measureQubit);
475         int numChunksToSkip = sizeHalfBlock/chunkSize;
476         // calculate probability by summing over numChunksToSkip, then skipping n
      umChunksToSkip, etc
477         int bitToCheck = chunkId & numChunksToSkip;
478         return bitToCheck;
479 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a88605f373c2401760aab0e08719e08dd}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!measureInState@{measureInState}}
\index{measureInState@{measureInState}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{measureInState}]{\setlength{\rightskip}{0pt plus 5cm}REAL measureInState ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  int {\em outcome})}\hfill}
\label{qubits__env__mpi_8c_a88605f373c2401760aab0e08719e08dd}


Update the state vector to be consistent with measuring measureQubit=0 or measureQubit=1 according to the value of outcome. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that an outcome has been measured on the qubit indicated by measureQubit (where his label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 if outcome=0 or measureQubit=1 if outcome=1. It then returns the probability of making this measurement.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em outcome}]to measure the probability of and set the state to -\/-\/ either zero or one \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being either zero or one 
\end{DoxyReturn}


Definition at line 498 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, findProbabilityOfOutcome(), halfMatrixBlockFitsInChunk(), isChunkToSkipInFindPZero(), measureInStateDistributedRenorm(), measureInStateDistributedSetZero(), measureInStateLocal(), MultiQubit::numAmps, and REAL.


\begin{DoxyCode}
499 {
500         REAL totalStateProb=findProbabilityOfOutcome(multiQubit, measureQubit, ou
      tcome);
501         int skipValuesWithinRank = halfMatrixBlockFitsInChunk(multiQubit.numAmps,
       measureQubit);
502         if (totalStateProb != 0){
503                 if (skipValuesWithinRank) {
504                         measureInStateLocal(multiQubit, measureQubit, totalStateP
      rob, outcome);
505                 } else {
506                         if (!isChunkToSkipInFindPZero(multiQubit.chunkId, multiQu
      bit.numAmps, measureQubit)){
507                                 // chunk has amps for q=0
508                                 if (outcome==0) measureInStateDistributedRenorm(m
      ultiQubit, measureQubit, 
509                                                 totalStateProb);
510                                 else measureInStateDistributedSetZero(multiQubit,
       measureQubit);
511                         } else {
512                                 // chunk has amps for q=1
513                                 if (outcome==1) measureInStateDistributedRenorm(m
      ultiQubit, measureQubit, 
514                                                 totalStateProb);
515                                 else measureInStateDistributedSetZero(multiQubit,
       measureQubit);
516                         }
517                 }
518         }
519         return totalStateProb;
520 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ae275b94c1a483dda43bf4ec947635605}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!phaseGate@{phaseGate}}
\index{phaseGate@{phaseGate}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{phaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__env__mpi_8c_ae275b94c1a483dda43bf4ec947635605}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em type}]the type of phase gate to apply -\/-\/ one of \{SIGMA\_\-Z, S\_\-GATE, T\_\-GATE\} \end{DoxyParams}


Definition at line 409 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, phaseGateDistributed(), and phaseGateLocal().


\begin{DoxyCode}
410 {
411         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
412         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
413 
414         // rank's chunk is in upper half of block 
415         int rankIsUpper;
416 
417         if (useLocalDataOnly){
418                 phaseGateLocal(multiQubit, rotQubit, type);
419         } else {
420                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
421                 if (!rankIsUpper) phaseGateDistributed(multiQubit, rotQubit, type
      );
422         }
423 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a909ba48b5a82c9f5c3a94d17a72b1aa3}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!probOfFilterOut111@{probOfFilterOut111}}
\index{probOfFilterOut111@{probOfFilterOut111}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{probOfFilterOut111}]{\setlength{\rightskip}{0pt plus 5cm}REAL probOfFilterOut111 ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em idQubit1}, \/  const int {\em idQubit2}, \/  const int {\em idQubit3})}\hfill}
\label{qubits__env__mpi_8c_a909ba48b5a82c9f5c3a94d17a72b1aa3}


Evaluates the state according to this scenario: we ask \char`\"{}are these 3 qubits in 111\char`\"{} and the answer is \char`\"{}no\char`\"{}. The function returns the probability of this outcome (if zero, it will exit with error) 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em idQubit1,idQubit2,idQubit3}]specified qubits \end{DoxyParams}
\begin{DoxyReturn}{Returns}
Total probability that the 3 qubits are not all in the 1 state. 
\end{DoxyReturn}


Definition at line 530 of file qubits\_\-env\_\-mpi.c.

References MPI\_\-QuEST\_\-REAL, probOfFilterOut111Local(), and REAL.

Referenced by filterOut111().


\begin{DoxyCode}
531 {
532         REAL stateProb=0, totalStateProb=0;
533         stateProb = probOfFilterOut111Local(multiQubit, idQubit1, idQubit2, idQub
      it3);
534         MPI_Allreduce(&stateProb, &totalStateProb, 1, MPI_QuEST_REAL, MPI_SUM, MP
      I_COMM_WORLD);
535         return totalStateProb;
536 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!reportNodeList@{reportNodeList}}
\index{reportNodeList@{reportNodeList}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{reportNodeList}]{\setlength{\rightskip}{0pt plus 5cm}void reportNodeList ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}


Report a list of CPU hostnames and the rank that is running on each if running with MPI enabled and an error message otherwise. For debugging purposes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 77 of file qubits\_\-env\_\-mpi.c.

References QuESTEnv::rank.


\begin{DoxyCode}
77                                  {
78         char hostName[256];
79         gethostname(hostName, 255);
80         printf("hostname on rank %d: %s\n", env.rank, hostName);
81 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!reportQuESTEnv@{reportQuESTEnv}}
\index{reportQuESTEnv@{reportQuESTEnv}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{reportQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void reportQuESTEnv ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}


Report information about the QuEST environment. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 62 of file qubits\_\-env\_\-mpi.c.

References QuESTEnv::numRanks, QuESTEnv::rank, and REAL.


\begin{DoxyCode}
62                                  {
63         if (env.rank==0){
64                 printf("EXECUTION ENVIRONMENT:\n"); 
65                 printf("Running distributed (MPI) version\n");
66                 printf("Number of ranks is %d\n", env.numRanks);
67 # ifdef _OPENMP
68                 printf("OpenMP enabled\n");
69                 printf("Number of threads available is %d\n", omp_get_max_threads
      ());
70 # else
71                 printf("OpenMP disabled\n");
72 # endif 
73                 printf("Precision: size of REAL is %ld bytes\n", sizeof(REAL));
74         }
75 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a4ba468aa69f812efd1f964e10a45ca2f}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!rotateQubit@{rotateQubit}}
\index{rotateQubit@{rotateQubit}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{rotateQubit}]{\setlength{\rightskip}{0pt plus 5cm}void rotateQubit ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__env__mpi_8c_a4ba468aa69f812efd1f964e10a45ca2f}


Rotate a single qubit in the state vector of probability amplitudes. Given two complex numbers alpha and beta, applies the operation \par
 \mbox{[}alpha, -\/beta$\ast$ \par
 beta, alpha$\ast$\mbox{]} \par


\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}
alpha, beta must obey $|$alpha$|$$^\wedge$2 + $|$beta$|$$^\wedge$2 = 1


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 245 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), getRotAngle(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::pairStateVec, rotateQubitDistributed(), rotateQubitLocal(), and MultiQubit::stateVec.

Referenced by rotateQubitByAngle().


\begin{DoxyCode}
246 {
247         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
248         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
249         Complex rot1, rot2;
250 
251         // rank's chunk is in upper half of block 
252         int rankIsUpper;
253         int pairRank; // rank of corresponding chunk
254 
255         if (useLocalDataOnly){
256                 // all values required to update state vector lie in this rank
257                 rotateQubitLocal(multiQubit, rotQubit, alpha, beta);
258         } else {
259                 // need to get corresponding chunk of state vector from other ran
      k
260                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
261                 getRotAngle(rankIsUpper, &rot1, &rot2, alpha, beta);
262                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, rotQubit);
263                 // get corresponding values from my pair
264                 exchangeStateVectors(multiQubit, pairRank);
265 
266                 // this rank's values are either in the upper of lower half of th
      e block. 
267                 // send values to rotateQubitDistributed in the correct order
268                 if (rankIsUpper){
269                         rotateQubitDistributed(multiQubit,rotQubit,rot1,rot2,
270                                 multiQubit.stateVec, //upper
271                                 multiQubit.pairStateVec, //lower
272                                 multiQubit.stateVec); //output
273                 } else {
274                         rotateQubitDistributed(multiQubit,rotQubit,rot1,rot2,
275                                 multiQubit.pairStateVec, //upper
276                                 multiQubit.stateVec, //lower
277                                 multiQubit.stateVec); //output
278                 }
279         }
280 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_acda82bebb0a62f419eec9c1e0575daad}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!sigmaX@{sigmaX}}
\index{sigmaX@{sigmaX}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{sigmaX}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaX ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit})}\hfill}
\label{qubits__env__mpi_8c_acda82bebb0a62f419eec9c1e0575daad}


Rotate a single qubit by \{\{0,1\},\{1,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \end{DoxyParams}


Definition at line 320 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::pairStateVec, sigmaXDistributed(), sigmaXLocal(), and MultiQubit::stateVec.


\begin{DoxyCode}
321 {
322         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
323         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
324 
325         // rank's chunk is in upper half of block 
326         int rankIsUpper;
327         int pairRank; // rank of corresponding chunk
328 
329         if (useLocalDataOnly){
330                 // all values required to update state vector lie in this rank
331                 sigmaXLocal(multiQubit, rotQubit);
332         } else {
333                 // need to get corresponding chunk of state vector from other ran
      k
334                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
335                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, rotQubit);
336                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
337                 // get corresponding values from my pair
338                 exchangeStateVectors(multiQubit, pairRank);
339                 // this rank's values are either in the upper of lower half of th
      e block. sigmaX just replaces
340                 // this rank's values with pair values
341                 sigmaXDistributed(multiQubit, rotQubit,
342                         multiQubit.pairStateVec, // in
343                         multiQubit.stateVec); // out
344         }
345 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a7b022c75cef77be046bd5d61e38a581e}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!sigmaY@{sigmaY}}
\index{sigmaY@{sigmaY}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{sigmaY}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaY ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit})}\hfill}
\label{qubits__env__mpi_8c_a7b022c75cef77be046bd5d61e38a581e}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}\} -\/-\/ swap $|$0$>$ and $|$1$>$ and apply a phase of -\/i or i. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \end{DoxyParams}


fix -\/-\/ put duplicate code (sigmaX, sigmaY) in seperate function 

Definition at line 380 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), exchangeStateVectors(), getChunkPairId(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::pairStateVec, sigmaYDistributed(), sigmaYLocal(), and MultiQubit::stateVec.


\begin{DoxyCode}
381 {
382         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
383         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
384 
385         // rank's chunk is in upper half of block 
386         int rankIsUpper;
387         int pairRank; // rank of corresponding chunk
388 
389         if (useLocalDataOnly){
390                 // all values required to update state vector lie in this rank
391                 sigmaYLocal(multiQubit, rotQubit);
392         } else {
394                 // need to get corresponding chunk of state vector from other ran
      k
395                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
396                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, rotQubit);
397                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
398                 // get corresponding values from my pair
399                 exchangeStateVectors(multiQubit, pairRank);
400                 // this rank's values are either in the upper of lower half of th
      e block. sigmaX just replaces
401                 // this rank's values with pair values
402                 sigmaYDistributed(multiQubit,rotQubit,
403                         multiQubit.pairStateVec, // in
404                         multiQubit.stateVec, // out
405                         rankIsUpper);
406         }
407 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!syncQuESTEnv@{syncQuESTEnv}}
\index{syncQuESTEnv@{syncQuESTEnv}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{syncQuESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void syncQuESTEnv ({\bf QuESTEnv} {\em env})}\hfill}
\label{qubits__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}


Guarantees that all code up to the given point has been executed on all nodes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 45 of file qubits\_\-env\_\-mpi.c.

Referenced by initializeStateFromSingleFile(), and reportStateToScreen().


\begin{DoxyCode}
45                                {
46         MPI_Barrier(MPI_COMM_WORLD);
47 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a877396e10f0e9aeead078664c51bb0e3}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!syncQuESTSuccess@{syncQuESTSuccess}}
\index{syncQuESTSuccess@{syncQuESTSuccess}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{syncQuESTSuccess}]{\setlength{\rightskip}{0pt plus 5cm}int syncQuESTSuccess ({\bf QuESTEnv} {\em env}, \/  int {\em successCode})}\hfill}
\label{qubits__env__mpi_8c_a877396e10f0e9aeead078664c51bb0e3}


Performs a logical AND on all successCodes held by all processes. If any one process has a zero successCode all processes will return a zero success code. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \item[\mbox{$\leftarrow$} {\em successCode}]1 if process task succeeded, 0 if process task failed \end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if all processes succeeded, 0 if any one process failed 
\end{DoxyReturn}


Definition at line 49 of file qubits\_\-env\_\-mpi.c.


\begin{DoxyCode}
49                                                    {
50         int totalSuccess;
51         MPI_Allreduce(&successCode, &totalSuccess, 1, MPI_INT, MPI_LAND, MPI_COMM
      _WORLD);
52         return totalSuccess;
53 }
\end{DoxyCode}
