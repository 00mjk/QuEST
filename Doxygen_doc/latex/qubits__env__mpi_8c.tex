\hypertarget{qubits__env__mpi_8c}{
\subsection{qubits\_\-env\_\-mpi.c File Reference}
\label{qubits__env__mpi_8c}\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}}
}


An implementation of the API in \hyperlink{qubits_8h}{qubits.h} for an MPI environment.  
{\ttfamily \#include $<$mpi.h$>$}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$stdio.h$>$}\par
{\ttfamily \#include $<$omp.h$>$}\par
{\ttfamily \#include \char`\"{}qubits.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}qubits\_\-internal.h\char`\"{}}\par
\subsubsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}~0
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{qubits__env__mpi_8c_a7cad4a087e3fc919efeb9d22ec451481}{isChunkToSkipInFindPZero} (int chunkId, int chunkSize, int measureQubit)
\begin{DoxyCompactList}\small\item\em Find chunks to skip when calculating probability of qubit being zero. \item\end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_ac6f2d948c6afc21ecd934a9794f27271}{chunkIsUpper} (int chunkId, int chunkSize, int rotQubit)
\begin{DoxyCompactList}\small\item\em Returns whether a given chunk in position chunkId is in the upper or lower half of a block. \item\end{DoxyCompactList}\item 
static void \hyperlink{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{getRotAngle} (int chunkIsUpper, \hyperlink{structComplex}{Complex} $\ast$rot1, \hyperlink{structComplex}{Complex} $\ast$rot2, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Get rotation values for a given chunk. \item\end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_af639d6bba9782cb708fb7f9bc406f28b}{getChunkPairId} (int chunkIsUpper, int chunkId, int chunkSize, int rotQubit)
\begin{DoxyCompactList}\small\item\em get position of corresponding chunk, holding values required to update values in my chunk (with chunkId) when rotating rotQubit. \item\end{DoxyCompactList}\item 
static int \hyperlink{qubits__env__mpi_8c_acb89022e532cdb58441d5e2254a08dfb}{halfMatrixBlockFitsInChunk} (int chunkSize, int rotQubit)
\begin{DoxyCompactList}\small\item\em return whether the current qubit rotation will use blocks that fit within a single chunk. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a652d8c53f8f1cfb096133791de2b219d}{initQUESTEnv} (\hyperlink{structQUESTEnv}{QUESTEnv} $\ast$env)
\begin{DoxyCompactList}\small\item\em Initialize QUEST environment. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a83dffc500bf5b4e41dd63ba1ea9422ae}{syncQUESTEnv} (\hyperlink{structQUESTEnv}{QUESTEnv} env)
\begin{DoxyCompactList}\small\item\em Guarantees that all code up to the given point has been executed on all nodes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_ad7494473d827399d7fd9c327ea3a23e6}{closeQUESTEnv} (\hyperlink{structQUESTEnv}{QUESTEnv} env)
\begin{DoxyCompactList}\small\item\em Close QUEST environment. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_aa5d0566a6ef6519ff7b5241915fbf170}{reportQUESTEnv} (\hyperlink{structQUESTEnv}{QUESTEnv} env)
\begin{DoxyCompactList}\small\item\em Report information about the QUEST environment. \item\end{DoxyCompactList}\item 
double \hyperlink{qubits__env__mpi_8c_a2205c8fde15213df52040dc3df233090}{calcTotalProbability} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Calculate the probability of being in any state by taking the norm of the entire state vector. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__env__mpi_8c_a4ba468aa69f812efd1f964e10a45ca2f}{rotateQubit} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. \item\end{DoxyCompactList}\item 
double \hyperlink{qubits__env__mpi_8c_af31016680d01044cee9321d4cae32703}{findProbabilityOfZero} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state. \item\end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
An implementation of the API in \hyperlink{qubits_8h}{qubits.h} for an MPI environment. 

Definition in file \hyperlink{qubits__env__mpi_8c_source}{qubits\_\-env\_\-mpi.c}.

\subsubsection{Define Documentation}
\hypertarget{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!DEBUG@{DEBUG}}
\index{DEBUG@{DEBUG}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{DEBUG}]{\setlength{\rightskip}{0pt plus 5cm}\#define DEBUG~0}\hfill}
\label{qubits__env__mpi_8c_ad72dbcf6d0153db1b8d8a58001feed83}


Definition at line 11 of file qubits\_\-env\_\-mpi.c.

\subsubsection{Function Documentation}
\hypertarget{qubits__env__mpi_8c_a2205c8fde15213df52040dc3df233090}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!calcTotalProbability@{calcTotalProbability}}
\index{calcTotalProbability@{calcTotalProbability}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{calcTotalProbability}]{\setlength{\rightskip}{0pt plus 5cm}double calcTotalProbability ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits__env__mpi_8c_a2205c8fde15213df52040dc3df233090}


Calculate the probability of being in any state by taking the norm of the entire state vector. Should be equal to 1. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \end{DoxyParams}
\begin{DoxyReturn}{Returns}
total probability 
\end{DoxyReturn}


Definition at line 83 of file qubits\_\-env\_\-mpi.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, and MultiQubit::stateVec.

Referenced by main().


\begin{DoxyCode}
83                                                   {
84         double pTotal=0; 
85         double allRankTotals=0;
86         long long int index;
87         long long int numAmpsPerRank = multiQubit.numAmps;
88         for (index=0; index<numAmpsPerRank; index++){ 
89                 pTotal+=multiQubit.stateVec.real[index]*multiQubit.stateVec.real[
      index];      
90                 pTotal+=multiQubit.stateVec.imag[index]*multiQubit.stateVec.imag[
      index];      
91         } 
92         if (DEBUG) printf("before calc prob. %d\n", multiQubit.numChunks);
93         if (multiQubit.numChunks>1) MPI_Allreduce(&pTotal, &allRankTotals, 1, MPI
      _DOUBLE, MPI_SUM, MPI_COMM_WORLD);
94         else allRankTotals=pTotal;
95 
96         return allRankTotals;
97 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ac6f2d948c6afc21ecd934a9794f27271}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!chunkIsUpper@{chunkIsUpper}}
\index{chunkIsUpper@{chunkIsUpper}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{chunkIsUpper}]{\setlength{\rightskip}{0pt plus 5cm}static int chunkIsUpper (int {\em chunkId}, \/  int {\em chunkSize}, \/  int {\em rotQubit})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_ac6f2d948c6afc21ecd934a9794f27271}


Returns whether a given chunk in position chunkId is in the upper or lower half of a block. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkId}]id of chunk in state vector \item[\mbox{$\leftarrow$} {\em chunkSize}]number of amps in chunk \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit being rotated \end{DoxyParams}
\begin{DoxyReturn}{Returns}
1: chunk is in upper half of block, 0: chunk is in lower half of block 
\end{DoxyReturn}


Definition at line 108 of file qubits\_\-env\_\-mpi.c.

Referenced by rotateQubit().


\begin{DoxyCode}
109 {       
110         long long int sizeHalfBlock = 1LL << (rotQubit);
111         long long int sizeBlock = sizeHalfBlock*2;
112         long long int posInBlock = (chunkId*chunkSize) % sizeBlock;
113         return posInBlock<sizeHalfBlock;
114 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_ad7494473d827399d7fd9c327ea3a23e6}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!closeQUESTEnv@{closeQUESTEnv}}
\index{closeQUESTEnv@{closeQUESTEnv}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{closeQUESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void closeQUESTEnv ({\bf QUESTEnv} {\em env})}\hfill}
\label{qubits__env__mpi_8c_ad7494473d827399d7fd9c327ea3a23e6}


Close QUEST environment. If something needs to be done to clean up the execution environment, such as finalizing MPI when running in distributed mode, it is handled here 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 42 of file qubits\_\-env\_\-mpi.c.

Referenced by main().


\begin{DoxyCode}
42                                 {
43         int finalized;
44         MPI_Finalized(&finalized);
45         if (!finalized) MPI_Finalize();
46         else printf("ERROR: Trying to close QUESTEnv multiple times. Ignoring\n")
      ;
47 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_af31016680d01044cee9321d4cae32703}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!findProbabilityOfZero@{findProbabilityOfZero}}
\index{findProbabilityOfZero@{findProbabilityOfZero}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{findProbabilityOfZero}]{\setlength{\rightskip}{0pt plus 5cm}double findProbabilityOfZero ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__env__mpi_8c_af31016680d01044cee9321d4cae32703}


Measure the probability of a specified qubit being in the zero state. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 224 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, findProbabilityOfZeroDistributed(), findProbabilityOfZeroLocal(), halfMatrixBlockFitsInChunk(), isChunkToSkipInFindPZero(), and MultiQubit::numAmps.


\begin{DoxyCode}
226 {
227         double stateProb=0, totalStateProb=0;
228         int skipValuesWithinRank = halfMatrixBlockFitsInChunk(multiQubit.numAmps,
       measureQubit);
229         if (skipValuesWithinRank) {
230                 stateProb = findProbabilityOfZeroLocal(multiQubit, measureQubit);
      
231         } else {
232                 if (!isChunkToSkipInFindPZero(multiQubit.chunkId, multiQubit.
      numAmps, measureQubit)){
233                         stateProb = findProbabilityOfZeroDistributed(multiQubit, 
      measureQubit);
234                 } else stateProb = 0;
235         }
236         MPI_Allreduce(&stateProb, &totalStateProb, 1, MPI_DOUBLE, MPI_SUM, MPI_CO
      MM_WORLD);
237         return totalStateProb;
238 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_af639d6bba9782cb708fb7f9bc406f28b}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getChunkPairId@{getChunkPairId}}
\index{getChunkPairId@{getChunkPairId}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getChunkPairId}]{\setlength{\rightskip}{0pt plus 5cm}static int getChunkPairId (int {\em chunkIsUpper}, \/  int {\em chunkId}, \/  int {\em chunkSize}, \/  int {\em rotQubit})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_af639d6bba9782cb708fb7f9bc406f28b}


get position of corresponding chunk, holding values required to update values in my chunk (with chunkId) when rotating rotQubit. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkIsUpper}]1: chunk is in upper half of block, 0: chunk is in lower half \item[\mbox{$\leftarrow$} {\em chunkId}]id of chunk in state vector \item[\mbox{$\leftarrow$} {\em chunkSize}]number of amps in chunk \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit being rotated \end{DoxyParams}
\begin{DoxyReturn}{Returns}
chunkId of chunk required to rotate rotQubit 
\end{DoxyReturn}


Definition at line 150 of file qubits\_\-env\_\-mpi.c.

Referenced by rotateQubit().


\begin{DoxyCode}
151 {
152         long long int sizeHalfBlock = 1LL << (rotQubit);
153         int chunksPerHalfBlock = sizeHalfBlock/chunkSize;
154         if (chunkIsUpper){
155                 return chunkId + chunksPerHalfBlock;
156         } else {
157                 return chunkId - chunksPerHalfBlock;
158         }
159 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!getRotAngle@{getRotAngle}}
\index{getRotAngle@{getRotAngle}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{getRotAngle}]{\setlength{\rightskip}{0pt plus 5cm}static void getRotAngle (int {\em chunkIsUpper}, \/  {\bf Complex} $\ast$ {\em rot1}, \/  {\bf Complex} $\ast$ {\em rot2}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}


Get rotation values for a given chunk. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkIsUpper}]1: chunk is in upper half of block, 0: chunk is in lower half\item[\mbox{$\rightarrow$} {\em rot1,rot2}]rotation values to use, allocated for upper/lower such that \begin{DoxyVerb}
stateUpper = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 or \begin{DoxyVerb}
stateLower = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 \item[\mbox{$\leftarrow$} {\em alpha,beta}]initial rotation values \end{DoxyParams}


Definition at line 129 of file qubits\_\-env\_\-mpi.c.

References Complex::imag, and Complex::real.

Referenced by rotateQubit().


\begin{DoxyCode}
130 {
131         if (chunkIsUpper){
132                 *rot1=alpha;
133                 rot2->real=-beta.real;
134                 rot2->imag=-beta.imag;
135         } else {
136                 *rot1=beta;
137                 *rot2=alpha;
138         }
139 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_acb89022e532cdb58441d5e2254a08dfb}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!halfMatrixBlockFitsInChunk@{halfMatrixBlockFitsInChunk}}
\index{halfMatrixBlockFitsInChunk@{halfMatrixBlockFitsInChunk}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{halfMatrixBlockFitsInChunk}]{\setlength{\rightskip}{0pt plus 5cm}static int halfMatrixBlockFitsInChunk (int {\em chunkSize}, \/  int {\em rotQubit})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_acb89022e532cdb58441d5e2254a08dfb}


return whether the current qubit rotation will use blocks that fit within a single chunk. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkSize}]number of amps in chunk \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit being rotated \end{DoxyParams}
\begin{DoxyReturn}{Returns}
1: one chunk fits in one block 0: chunk is larger than block 
\end{DoxyReturn}


Definition at line 169 of file qubits\_\-env\_\-mpi.c.

Referenced by findProbabilityOfZero(), and rotateQubit().


\begin{DoxyCode}
170 {
171         long long int sizeHalfBlock = 1LL << (rotQubit);
172         if (chunkSize > sizeHalfBlock) return 1;
173         else return 0;
174 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a652d8c53f8f1cfb096133791de2b219d}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!initQUESTEnv@{initQUESTEnv}}
\index{initQUESTEnv@{initQUESTEnv}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{initQUESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void initQUESTEnv ({\bf QUESTEnv} $\ast$ {\em env})}\hfill}
\label{qubits__env__mpi_8c_a652d8c53f8f1cfb096133791de2b219d}


Initialize QUEST environment. If something needs to be done to set up the execution environment, such as initializing MPI when running in distributed mode, it is handled here 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em env}]object representing the execution environment. A single instance is used for each program \end{DoxyParams}


Definition at line 18 of file qubits\_\-env\_\-mpi.c.

References DEBUG, QUESTEnv::numRanks, and QUESTEnv::rank.

Referenced by main().


\begin{DoxyCode}
18                                 {
19         // init MPI environment
20         int rank, numRanks, initialized;
21         MPI_Initialized(&initialized);
22         if (!initialized){
23                 MPI_Init(NULL, NULL);
24                 MPI_Comm_size(MPI_COMM_WORLD, &numRanks);
25                 MPI_Comm_rank(MPI_COMM_WORLD, &rank);
26 
27                 if (DEBUG) {
28                         char hostName[256];
29                         int hostNameLen;
30                         MPI_Get_processor_name(hostName, &hostNameLen);
31                         printf("rank %d on host %s\n", rank, hostName);
32                 }
33                 env->rank=rank;
34                 env->numRanks=numRanks;
35         } else printf("ERROR: Trying to initialize QUESTEnv multiple times. Ignor
      ing\n");
36 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a7cad4a087e3fc919efeb9d22ec451481}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!isChunkToSkipInFindPZero@{isChunkToSkipInFindPZero}}
\index{isChunkToSkipInFindPZero@{isChunkToSkipInFindPZero}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{isChunkToSkipInFindPZero}]{\setlength{\rightskip}{0pt plus 5cm}static int isChunkToSkipInFindPZero (int {\em chunkId}, \/  int {\em chunkSize}, \/  int {\em measureQubit})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits__env__mpi_8c_a7cad4a087e3fc919efeb9d22ec451481}


Find chunks to skip when calculating probability of qubit being zero. When calculating probability of a bit q being zero, sum up 2$^\wedge$q values, then skip 2$^\wedge$q values, etc. This function finds if an entire chunk is in the range of values to be skipped


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em chunkId}]id of chunk in state vector \item[\mbox{$\leftarrow$} {\em chunkSize}]number of amps in chunk \item[\mbox{$\leftarrow$} {\em measureQubi}]qubit being measured \end{DoxyParams}
\begin{DoxyReturn}{Returns}
int -\/-\/ 1: skip, 0: don't skip 
\end{DoxyReturn}


Definition at line 75 of file qubits\_\-env\_\-mpi.c.

Referenced by findProbabilityOfZero().


\begin{DoxyCode}
75                                                                                  
      {
76         long long int sizeHalfBlock = 1LL << (measureQubit);
77         int numChunksToSkip = sizeHalfBlock/chunkSize;
78         // calculate probability by summing over numChunksToSkip, then skipping n
      umChunksToSkip, etc
79         int bitToCheck = chunkId & numChunksToSkip;
80         return bitToCheck;
81 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_aa5d0566a6ef6519ff7b5241915fbf170}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!reportQUESTEnv@{reportQUESTEnv}}
\index{reportQUESTEnv@{reportQUESTEnv}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{reportQUESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void reportQUESTEnv ({\bf QUESTEnv} {\em env})}\hfill}
\label{qubits__env__mpi_8c_aa5d0566a6ef6519ff7b5241915fbf170}


Report information about the QUEST environment. 

Definition at line 49 of file qubits\_\-env\_\-mpi.c.

References QUESTEnv::numRanks, and QUESTEnv::rank.

Referenced by main().


\begin{DoxyCode}
49                                  {
50         if (env.rank==0){
51                 printf("EXECUTION ENVIRONMENT:\n"); 
52                 printf("Running distributed (MPI) version\n");
53                 printf("Number of ranks is %d\n", env.numRanks);
54 # ifdef _OPENMP
55                 printf("OpenMP enabled\n");
56                 printf("Number of threads available is %d\n", omp_get_max_threads
      ());
57 # else
58                 printf("OpenMP disabled\n");
59 # endif 
60         }
61 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a4ba468aa69f812efd1f964e10a45ca2f}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!rotateQubit@{rotateQubit}}
\index{rotateQubit@{rotateQubit}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{rotateQubit}]{\setlength{\rightskip}{0pt plus 5cm}void rotateQubit ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__env__mpi_8c_a4ba468aa69f812efd1f964e10a45ca2f}


Rotate a single qubit in the state vector of probability amplitudes, given the angle rotation arguments. alphaRe = cos(angle1) $\ast$ cos(angle2) \par
 alphaIm = cos(angle1) $\ast$ sin(angle2) \par
 betaRe = sin(angle1) $\ast$ cos(angle3) \par
 betaIm = sin(angle1) $\ast$ sin(angle3) \par


\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 176 of file qubits\_\-env\_\-mpi.c.

References MultiQubit::chunkId, chunkIsUpper(), getChunkPairId(), getRotAngle(), halfMatrixBlockFitsInChunk(), ComplexArray::imag, MultiQubit::numAmps, MultiQubit::pairStateVec, ComplexArray::real, rotateQubitDistributed(), rotateQubitLocal(), and MultiQubit::stateVec.

Referenced by main().


\begin{DoxyCode}
178 {
179         // flag to require memory exchange. 1: an entire block fits on one rank, 
      0: at most half a block fits on one rank
180         int useLocalDataOnly = halfMatrixBlockFitsInChunk(multiQubit.numAmps, rot
      Qubit);
181         Complex rot1, rot2;
182 
183         // rank's chunk is in upper half of block 
184         int rankIsUpper;
185         int pairRank; // rank of corresponding chunk
186 
187         // MPI send/receive vars
188         int TAG=100;
189         MPI_Status status;
190 
191         if (useLocalDataOnly){
192                 // all values required to update state vector lie in this rank
193                 rotateQubitLocal(multiQubit, rotQubit, alpha, beta);
194         } else {
195                 // need to get corresponding chunk of state vector from other ran
      k
196                 rankIsUpper = chunkIsUpper(multiQubit.chunkId, multiQubit.
      numAmps, rotQubit);
197                 getRotAngle(rankIsUpper, &rot1, &rot2, alpha, beta);
198                 pairRank = getChunkPairId(rankIsUpper, multiQubit.chunkId, multiQ
      ubit.numAmps, rotQubit);
199                 //printf("%d rank has pair rank: %d\n", multiQubit.rank, pairRank
      );
200                 // get corresponding values from my pair
201                 MPI_Sendrecv(multiQubit.stateVec.real, multiQubit.numAmps, MPI_DO
      UBLE, pairRank, TAG,
202                                  multiQubit.pairStateVec.real, multiQubit.
      numAmps, MPI_DOUBLE, pairRank, TAG,
203                                  MPI_COMM_WORLD, &status);
204                 //printf("rank: %d err: %d\n", multiQubit.rank, err);
205                 MPI_Sendrecv(multiQubit.stateVec.imag, multiQubit.numAmps, MPI_DO
      UBLE, pairRank, TAG,
206                                 multiQubit.pairStateVec.imag, multiQubit.numAmps,
       MPI_DOUBLE, pairRank, TAG,
207                                 MPI_COMM_WORLD, &status);
208                 // this rank's values are either in the upper of lower half of th
      e block. send values to rotateQubitDistributed
209                 // in the correct order
210                 if (rankIsUpper){
211                         rotateQubitDistributed(multiQubit,rotQubit,rot1,rot2,
212                                 multiQubit.stateVec, //upper
213                                 multiQubit.pairStateVec, //lower
214                                 multiQubit.stateVec); //output
215                 } else {
216                         rotateQubitDistributed(multiQubit,rotQubit,rot1,rot2,
217                                 multiQubit.pairStateVec, //upper
218                                 multiQubit.stateVec, //lower
219                                 multiQubit.stateVec); //output
220                 }
221         }
222 }
\end{DoxyCode}
\hypertarget{qubits__env__mpi_8c_a83dffc500bf5b4e41dd63ba1ea9422ae}{
\index{qubits\_\-env\_\-mpi.c@{qubits\_\-env\_\-mpi.c}!syncQUESTEnv@{syncQUESTEnv}}
\index{syncQUESTEnv@{syncQUESTEnv}!qubits_env_mpi.c@{qubits\_\-env\_\-mpi.c}}
\paragraph[{syncQUESTEnv}]{\setlength{\rightskip}{0pt plus 5cm}void syncQUESTEnv ({\bf QUESTEnv} {\em env})}\hfill}
\label{qubits__env__mpi_8c_a83dffc500bf5b4e41dd63ba1ea9422ae}


Guarantees that all code up to the given point has been executed on all nodes. 

Definition at line 38 of file qubits\_\-env\_\-mpi.c.


\begin{DoxyCode}
38                                {
39         MPI_Barrier(MPI_COMM_WORLD);
40 }
\end{DoxyCode}
