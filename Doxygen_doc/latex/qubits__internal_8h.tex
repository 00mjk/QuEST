\hypertarget{qubits__internal_8h}{
\subsection{qubits\_\-internal.h File Reference}
\label{qubits__internal_8h}\index{qubits\_\-internal.h@{qubits\_\-internal.h}}
}


Internal functions used to implement the public facing API in \hyperlink{qubits_8h}{qubits.h}.  
{\ttfamily \#include \char`\"{}precision.h\char`\"{}}\par
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{qubits__internal_8h_a33a8d60ae759d25a096c88b337db6c9f}{compactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a6c49fefa672918a70b031923363cb580}{compactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a5fd78353771c9a34832e7a3b1e90f4db}{unitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits__internal_8h_af538f02e700f4d022044fc71030a6953}{unitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a2f5b808392caec4eb775bb3aabfa25d2}{controlledCompactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, const int controlQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ac874e5c65f9bbb64fa3058a7638bfc15}{controlledCompactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, const int controlQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a0af39b13cf3a043975fce768f3507657}{controlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, const int controlQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a9903d9da1c523a84728e4e4870f22949}{controlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, const int controlQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a32cb91618b5fcd79b54be8d8760b713d}{multiControlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, long long int mask, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a54f4c82568e9433515c4480cdb536e27}{multiControlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, long long int mask, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_aa9e640bb2d0458c937c6a87dfeca0f23}{sigmaXLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a5958808b2f2f05937921ba7dabe5a171}{sigmaXDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_afcbb1dcbe070ad0ed1a72a23251b6a83}{sigmaYLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a0471f6b547ce8270ef85170b7f4f0214}{sigmaYDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a0711416fceaf63c67b496e123e845c69}{hadamardLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ac835c194bd547240a35f0b028db1d658}{hadamardDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a6a736aeb3532898019fe7c27010edc6a}{phaseGateLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a38a05c7e749e806b182ef3b89878bfc4}{phaseGateDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}{controlledNotLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\} for elements where controlQubit is one. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}{controlledNotDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{findProbabilityOfZeroLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{findProbabilityOfZeroDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}{collapseToOutcomeLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int measureQubit, REAL totalProbability, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, const REAL totalProbability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Set all amplitudes in one chunk to 0. \item\end{DoxyCompactList}\item 
int \hyperlink{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}{validateMatrixIsUnitary} (\hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
int \hyperlink{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}{validateAlphaBeta} (\hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
int \hyperlink{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}{validateUnitVector} (REAL ux, REAL uy, REAL uz)
\item 
void \hyperlink{qubits__internal_8h_ae275b94c1a483dda43bf4ec947635605}{phaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}{exitWithError} (int errorCode, const char $\ast$func)
\item 
void \hyperlink{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert} (int isValid, int errorCode, const char $\ast$func)
\end{DoxyCompactItemize}
\subsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \hyperlink{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}{errorCodes} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
Internal functions used to implement the public facing API in \hyperlink{qubits_8h}{qubits.h}. Do not call these functions directly. In general, \hyperlink{qubits__env__local_8c}{qubits\_\-env\_\-local.c} and \hyperlink{qubits__env__mpi_8c}{qubits\_\-env\_\-mpi.c} will implement the public API by choosing the correct function or combination of functions to use from those included here. 

Definition in file \hyperlink{qubits__internal_8h_source}{qubits\_\-internal.h}.

\subsubsection{Function Documentation}
\hypertarget{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}}
\index{collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeDistributedRenorm}]{\setlength{\rightskip}{0pt plus 5cm}REAL collapseToOutcomeDistributedRenorm ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  const REAL {\em totalProbability})}\hfill}
\label{qubits__internal_8h_a7a1f63ec3c42d9ad72f1f01c14a885db}


Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that the value 'outcome' has been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being zero \end{DoxyParams}


Definition at line 2071 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome().


\begin{DoxyCode}
2072 {
2073         // ----- temp variables
2074         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
2075         long long int numTasks=multiQubit.numAmps;
2076         // (good for shared memory parallelism)
2077 
2078         REAL renorm=1/sqrt(totalProbability);
2079         
2080         REAL *stateVecReal = multiQubit.stateVec.real;
2081         REAL *stateVecImag = multiQubit.stateVec.imag;
2082 
2083 # ifdef _OPENMP
2084 # pragma omp parallel \
2085         shared    (numTasks,stateVecReal,stateVecImag) \
2086         private   (thisTask)
2087 # endif
2088         {
2089 # ifdef _OPENMP
2090                 # pragma omp for schedule  (static)
2091 # endif
2092                 for (thisTask=0; thisTask<numTasks; thisTask++) {
2093                         // summation -- simple implementation
2094                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
2095                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
2096                 }
2097         }
2098         return totalProbability;
2099 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}}
\index{collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeDistributedSetZero}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeDistributedSetZero ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a78908fe8e75a21fd4f7fa7dff05d6be1}


Set all amplitudes in one chunk to 0. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that a zero have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}


Definition at line 2114 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome().


\begin{DoxyCode}
2115 {
2116         // ----- temp variables
2117         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
2118         long long int numTasks=multiQubit.numAmps;
2119         // (good for shared memory parallelism)
2120 
2121         // ---------------------------------------------------------------- //
2122         //            find probability                                      //
2123         // ---------------------------------------------------------------- //
2124 
2125         REAL *stateVecReal = multiQubit.stateVec.real;
2126         REAL *stateVecImag = multiQubit.stateVec.imag;
2127 
2128 # ifdef _OPENMP
2129 # pragma omp parallel \
2130         shared    (numTasks,stateVecReal,stateVecImag) \
2131         private   (thisTask)
2132 # endif
2133         {
2134 # ifdef _OPENMP
2135                 # pragma omp for schedule  (static)
2136 # endif
2137                 for (thisTask=0; thisTask<numTasks; thisTask++) {
2138                         // summation -- simple implementation
2139                         stateVecReal[thisTask] = 0;
2140                         stateVecImag[thisTask] = 0;
2141                 }
2142         }
2143 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!collapseToOutcomeLocal@{collapseToOutcomeLocal}}
\index{collapseToOutcomeLocal@{collapseToOutcomeLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{collapseToOutcomeLocal}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeLocal ({\bf MultiQubit} {\em multiQubit}, \/  int {\em measureQubit}, \/  REAL {\em totalProbability}, \/  int {\em outcome})}\hfill}
\label{qubits__internal_8h_a01d9a8b7ff0e09ec399e158389783aa9}


Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. Performs an irreversible change to the state vector: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being either zero or one \item[\mbox{$\leftarrow$} {\em outcome}]to measure the probability of and set the state to -\/-\/ either zero or one \end{DoxyParams}


Definition at line 1988 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome().


\begin{DoxyCode}
1989 {
1990         // ----- sizes
1991         long long int sizeBlock,                                           // siz
      e of blocks
1992         sizeHalfBlock;                                       // size of blocks ha
      lved
1993         // ----- indices
1994         long long int thisBlock,                                           // cur
      rent block
1995              index;                                               // current inde
      x for first half block
1996         // ----- measured probability
1997         REAL   renorm;                                    // probability (returne
      d) value
1998         // ----- temp variables
1999         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
2000         // (good for shared memory parallelism)
2001         long long int numTasks=multiQubit.numAmps>>1;
2002 
2003         // ---------------------------------------------------------------- //
2004         //            dimensions                                            //
2005         // ---------------------------------------------------------------- //
2006         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
2007         // and then the number to skip
2008         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
2009         
2010         renorm=1/sqrt(totalProbability);
2011         REAL *stateVecReal = multiQubit.stateVec.real;
2012         REAL *stateVecImag = multiQubit.stateVec.imag;
2013 
2014 
2015 # ifdef _OPENMP
2016 # pragma omp parallel \
2017         default (none) \
2018         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,re
      norm,outcome) \
2019         private   (thisTask,thisBlock,index)
2020 # endif
2021         {
2022                 if (outcome==0){
2023                         // measure qubit is 0
2024 # ifdef _OPENMP
2025                         # pragma omp for schedule  (static)
2026 # endif
2027                         for (thisTask=0; thisTask<numTasks; thisTask++) {
2028                                 thisBlock = thisTask / sizeHalfBlock;
2029                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
2030                                 stateVecReal[index]=stateVecReal[index]*renorm;
2031                                 stateVecImag[index]=stateVecImag[index]*renorm;
2032 
2033                                 stateVecReal[index+sizeHalfBlock]=0;
2034                                 stateVecImag[index+sizeHalfBlock]=0;
2035                         }
2036                 } else {
2037                         // measure qubit is 1
2038 # ifdef _OPENMP
2039                         # pragma omp for schedule  (static)
2040 # endif
2041                         for (thisTask=0; thisTask<numTasks; thisTask++) {
2042                                 thisBlock = thisTask / sizeHalfBlock;
2043                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
2044                                 stateVecReal[index]=0;
2045                                 stateVecImag[index]=0;
2046 
2047                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[in
      dex+sizeHalfBlock]*renorm;
2048                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[in
      dex+sizeHalfBlock]*renorm;
2049                         }
2050                 }
2051         }
2052 
2053 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a6c49fefa672918a70b031923363cb580}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!compactUnitaryDistributed@{compactUnitaryDistributed}}
\index{compactUnitaryDistributed@{compactUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{compactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a6c49fefa672918a70b031923363cb580}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 646 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by compactUnitary().


\begin{DoxyCode}
651 {
652 
653         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
654         long long int thisTask;  
655         const long long int numTasks=multiQubit.numAmps;
656 
657         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
658         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
659         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
660         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
661         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
662 
663 # ifdef _OPENMP
664 # pragma omp parallel \
665         default  (none) \
666         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
667                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
668         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
669 # endif
670         {
671 # ifdef _OPENMP
672                 # pragma omp for schedule (static)
673 # endif
674                 for (thisTask=0; thisTask<numTasks; thisTask++) {
675                         // store current state vector values in temp variables
676                         stateRealUp = stateVecRealUp[thisTask];
677                         stateImagUp = stateVecImagUp[thisTask];
678 
679                         stateRealLo = stateVecRealLo[thisTask];
680                         stateImagLo = stateVecImagLo[thisTask];
681 
682                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
683                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
684                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
685                 }
686         }
687 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a33a8d60ae759d25a096c88b337db6c9f}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!compactUnitaryLocal@{compactUnitaryLocal}}
\index{compactUnitaryLocal@{compactUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{compactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_a33a8d60ae759d25a096c88b337db6c9f}


Rotate a single qubit in the state vector of probability amplitudes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 507 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by compactUnitary().


\begin{DoxyCode}
508 {
509         long long int sizeBlock, sizeHalfBlock;
510         long long int thisBlock, // current block
511              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
512 
513         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
514         long long int thisTask;         
515         const long long int numTasks=multiQubit.numAmps>>1;
516 
517         // set dimensions
518         sizeHalfBlock = 1LL << rotQubit;  
519         sizeBlock     = 2LL * sizeHalfBlock; 
520 
521         // Can't use multiQubit.stateVec as a private OMP var
522         REAL *stateVecReal = multiQubit.stateVec.real;
523         REAL *stateVecImag = multiQubit.stateVec.imag;
524         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
525         REAL betaImag=beta.imag, betaReal=beta.real;
526 
527 # ifdef _OPENMP
528 # pragma omp parallel \
529         default  (none) \
530         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
531         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
532 # endif
533         {
534 # ifdef _OPENMP
535                 # pragma omp for schedule (static)
536 # endif
537                 for (thisTask=0; thisTask<numTasks; thisTask++) {
538 
539                         thisBlock   = thisTask / sizeHalfBlock;
540                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
541                         indexLo     = indexUp + sizeHalfBlock;
542 
543                         // store current state vector values in temp variables
544                         stateRealUp = stateVecReal[indexUp];
545                         stateImagUp = stateVecImag[indexUp];
546 
547                         stateRealLo = stateVecReal[indexLo];
548                         stateImagLo = stateVecImag[indexLo];
549 
550                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
551                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag
      *stateImagUp 
552                                 - betaReal*stateRealLo - betaImag*stateImagLo;
553                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag
      *stateRealUp 
554                                 - betaReal*stateImagLo + betaImag*stateRealLo;
555 
556                         // state[indexLo] = beta  * state[indexUp] + conj(alpha) 
      * state[indexLo]
557                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*s
      tateImagUp 
558                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
559                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*s
      tateRealUp 
560                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
561                 } 
562         }
563 
564 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ac874e5c65f9bbb64fa3058a7638bfc15}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}}
\index{controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledCompactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  const int {\em controlQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_ac874e5c65f9bbb64fa3058a7638bfc15}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 991 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
996 {
997 
998         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
999         long long int thisTask;  
1000         const long long int numTasks=multiQubit.numAmps;
1001         const long long int chunkSize=multiQubit.numAmps;
1002         const long long int chunkId=multiQubit.chunkId;
1003 
1004         int controlBit;
1005 
1006     REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
1007         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
1008         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1009         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1010         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1011 
1012 # ifdef _OPENMP
1013 # pragma omp parallel \
1014         default  (none) \
1015         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1016                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
1017         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
1018 # endif
1019         {
1020 # ifdef _OPENMP
1021                 # pragma omp for schedule (static)
1022 # endif
1023                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1024                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
1025                         if (controlBit){
1026                                 // store current state vector values in temp vari
      ables
1027                                 stateRealUp = stateVecRealUp[thisTask];
1028                                 stateImagUp = stateVecImagUp[thisTask];
1029 
1030                                 stateRealLo = stateVecRealLo[thisTask];
1031                                 stateImagLo = stateVecImagLo[thisTask];
1032 
1033                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
1034                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp 
      - rot1Imag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
1035                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp 
      + rot1Imag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
1036                         }
1037                 }
1038         }
1039 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a2f5b808392caec4eb775bb3aabfa25d2}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}}
\index{controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledCompactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  const int {\em controlQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_a2f5b808392caec4eb775bb3aabfa25d2}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. Only perform the rotation for elements where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform rotation if this qubit is 1 \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 760 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
762 {
763         long long int sizeBlock, sizeHalfBlock;
764         long long int thisBlock, // current block
765              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
766 
767         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
768         long long int thisTask;         
769         const long long int numTasks=multiQubit.numAmps>>1;
770         const long long int chunkSize=multiQubit.numAmps;
771         const long long int chunkId=multiQubit.chunkId;
772 
773         int controlBit;
774 
775     // set dimensions
776         sizeHalfBlock = 1LL << rotQubit;  
777         sizeBlock     = 2LL * sizeHalfBlock; 
778 
779         // Can't use multiQubit.stateVec as a private OMP var
780         REAL *stateVecReal = multiQubit.stateVec.real;
781         REAL *stateVecImag = multiQubit.stateVec.imag;
782         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
783         REAL betaImag=beta.imag, betaReal=beta.real;
784 
785 # ifdef _OPENMP
786 # pragma omp parallel \
787         default  (none) \
788         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
789         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
790 # endif
791         {
792 # ifdef _OPENMP
793                 # pragma omp for schedule (static)
794 # endif
795                 for (thisTask=0; thisTask<numTasks; thisTask++) {
796 
797                         thisBlock   = thisTask / sizeHalfBlock;
798                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
799                         indexLo     = indexUp + sizeHalfBlock;
800 
801                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
802                         if (controlBit){
803                                 // store current state vector values in temp vari
      ables
804                                 stateRealUp = stateVecReal[indexUp];
805                                 stateImagUp = stateVecImag[indexUp];
806 
807                                 stateRealLo = stateVecReal[indexLo];
808                                 stateImagLo = stateVecImag[indexLo];
809 
810                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
811                                 stateVecReal[indexUp] = alphaReal*stateRealUp - a
      lphaImag*stateImagUp 
812                                         - betaReal*stateRealLo - betaImag*stateIm
      agLo;
813                                 stateVecImag[indexUp] = alphaReal*stateImagUp + a
      lphaImag*stateRealUp 
814                                         - betaReal*stateImagLo + betaImag*stateRe
      alLo;
815 
816                                 // state[indexLo] = beta  * state[indexUp] + conj
      (alpha) * state[indexLo]
817                                 stateVecReal[indexLo] = betaReal*stateRealUp - be
      taImag*stateImagUp 
818                                         + alphaReal*stateRealLo + alphaImag*state
      ImagLo;
819                                 stateVecImag[indexLo] = betaReal*stateImagUp + be
      taImag*stateRealUp 
820                                         + alphaReal*stateImagLo - alphaImag*state
      RealLo;
821                         }
822                 } 
823         }
824 
825 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledNotDistributed@{controlledNotDistributed}}
\index{controlledNotDistributed@{controlledNotDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledNotDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a05875a70b539a3efb28d027823403f34}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk. Only perform the rotation for elements where controlQubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1338 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by controlledNot().


\begin{DoxyCode}
1341 {
1342 
1343         long long int thisTask;  
1344         const long long int numTasks=multiQubit.numAmps;
1345         const long long int chunkSize=multiQubit.numAmps;
1346         const long long int chunkId=multiQubit.chunkId;
1347 
1348         int controlBit;
1349 
1350         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1351         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1352 
1353 # ifdef _OPENMP
1354 # pragma omp parallel \
1355         default  (none) \
1356         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1357         private  (thisTask,controlBit)
1358 # endif
1359         {
1360 # ifdef _OPENMP
1361                 # pragma omp for schedule (static)
1362 # endif
1363                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1364                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
1365                         if (controlBit){
1366                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTa
      sk];
1367                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTa
      sk];
1368                         }
1369                 }
1370         }
1371 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledNotLocal@{controlledNotLocal}}
\index{controlledNotLocal@{controlledNotLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledNotLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits__internal_8h_ad357a43e80e3baf013975b1b70942f4c}


Rotate a single qubit by \{\{0,1\},\{1,0\} for elements where controlQubit is one. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \end{DoxyParams}


Definition at line 1272 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledNot().


\begin{DoxyCode}
1273 {
1274         long long int sizeBlock, sizeHalfBlock;
1275         long long int thisBlock, // current block
1276              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1277 
1278         REAL stateRealUp,stateImagUp;
1279         long long int thisTask;         
1280         const long long int numTasks=multiQubit.numAmps>>1;
1281         const long long int chunkSize=multiQubit.numAmps;
1282         const long long int chunkId=multiQubit.chunkId;
1283 
1284         int controlBit;
1285 
1286         // set dimensions
1287         sizeHalfBlock = 1LL << targetQubit;  
1288         sizeBlock     = 2LL * sizeHalfBlock; 
1289 
1290 
1291         // Can't use multiQubit.stateVec as a private OMP var
1292         REAL *stateVecReal = multiQubit.stateVec.real;
1293         REAL *stateVecImag = multiQubit.stateVec.imag;
1294 
1295 # ifdef _OPENMP
1296 # pragma omp parallel \
1297         default  (none) \
1298         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1299         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,co
      ntrolBit) 
1300 # endif
1301         {
1302 # ifdef _OPENMP
1303                 # pragma omp for schedule (static)
1304 # endif
1305                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1306                         thisBlock   = thisTask / sizeHalfBlock;
1307                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1308                         indexLo     = indexUp + sizeHalfBlock;
1309 
1310                         controlBit = extractBit(controlQubit, indexUp+chunkId*chu
      nkSize);
1311                         if (controlBit){
1312                                 stateRealUp = stateVecReal[indexUp];
1313                                 stateImagUp = stateVecImag[indexUp];
1314 
1315                                 stateVecReal[indexUp] = stateVecReal[indexLo];
1316                                 stateVecImag[indexUp] = stateVecImag[indexLo];
1317 
1318                                 stateVecReal[indexLo] = stateRealUp;
1319                                 stateVecImag[indexLo] = stateImagUp;
1320                         }
1321                 } 
1322         }
1323 
1324 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9903d9da1c523a84728e4e4870f22949}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledUnitaryDistributed@{controlledUnitaryDistributed}}
\index{controlledUnitaryDistributed@{controlledUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  const int {\em controlQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a9903d9da1c523a84728e4e4870f22949}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1054 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledUnitary().


\begin{DoxyCode}
1059 {
1060 
1061         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1062         long long int thisTask;  
1063         const long long int numTasks=multiQubit.numAmps;
1064         const long long int chunkSize=multiQubit.numAmps;
1065         const long long int chunkId=multiQubit.chunkId;
1066 
1067         int controlBit;
1068 
1069         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
1070         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
1071         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1072         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1073         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1074 
1075 # ifdef _OPENMP
1076 # pragma omp parallel \
1077         default  (none) \
1078         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1079                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
1080         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
1081 # endif
1082         {
1083 # ifdef _OPENMP
1084                 # pragma omp for schedule (static)
1085 # endif
1086                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1087                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
1088                         if (controlBit){
1089                                 // store current state vector values in temp vari
      ables
1090                                 stateRealUp = stateVecRealUp[thisTask];
1091                                 stateImagUp = stateVecImagUp[thisTask];
1092 
1093                                 stateRealLo = stateVecRealLo[thisTask];
1094                                 stateImagLo = stateVecImagLo[thisTask];
1095 
1096                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
1097                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
1098                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
1099                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
1100                         }
1101                 }
1102         }
1103 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a0af39b13cf3a043975fce768f3507657}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!controlledUnitaryLocal@{controlledUnitaryLocal}}
\index{controlledUnitaryLocal@{controlledUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{controlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  const int {\em controlQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_a0af39b13cf3a043975fce768f3507657}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. Only perform the rotation for elements where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform rotation if this qubit is 1 \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 912 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledUnitary().


\begin{DoxyCode}
914 {
915         long long int sizeBlock, sizeHalfBlock;
916         long long int thisBlock, // current block
917              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
918 
919         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
920         long long int thisTask;         
921         const long long int numTasks=multiQubit.numAmps>>1;
922         const long long int chunkSize=multiQubit.numAmps;
923         const long long int chunkId=multiQubit.chunkId;
924 
925         int controlBit;
926 
927     // set dimensions
928         sizeHalfBlock = 1LL << rotQubit;  
929         sizeBlock     = 2LL * sizeHalfBlock; 
930 
931         // Can't use multiQubit.stateVec as a private OMP var
932         REAL *stateVecReal = multiQubit.stateVec.real;
933         REAL *stateVecImag = multiQubit.stateVec.imag;
934 
935 # ifdef _OPENMP
936 # pragma omp parallel \
937         default  (none) \
938         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
939         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
940 # endif
941         {
942 # ifdef _OPENMP
943                 # pragma omp for schedule (static)
944 # endif
945                 for (thisTask=0; thisTask<numTasks; thisTask++) {
946 
947                         thisBlock   = thisTask / sizeHalfBlock;
948                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
949                         indexLo     = indexUp + sizeHalfBlock;
950 
951                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
952                         if (controlBit){
953                                 // store current state vector values in temp vari
      ables
954                                 stateRealUp = stateVecReal[indexUp];
955                                 stateImagUp = stateVecImag[indexUp];
956 
957                                 stateRealLo = stateVecReal[indexLo];
958                                 stateImagLo = stateVecImag[indexLo];
959 
960 
961                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
962                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
963                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
964                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
965                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
966 
967                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
968                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
969                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
970                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
971                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
972                         }
973                 } 
974         }
975 
976 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!exitWithError@{exitWithError}}
\index{exitWithError@{exitWithError}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{exitWithError}]{\setlength{\rightskip}{0pt plus 5cm}void exitWithError (int {\em errorCode}, \/  const char $\ast$ {\em func})}\hfill}
\label{qubits__internal_8h_ae5f9019826f35e8b51b1716cfe397b45}


Definition at line 192 of file qubits\_\-env\_\-local.c.

References errorCodes.

Referenced by QuESTAssert().


\begin{DoxyCode}
192                                                    {
193     printf("!!!\n");
194     printf("QuEST Error in function %s: %s\n", func, errorCodes[errorCode]);
195     printf("!!!\n");
196     printf("exiting..\n");
197     exit(errorCode);
198 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}}
\index{findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{findProbabilityOfZeroDistributed}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a9ac9bb717a889f09d307eda9f0b65957}


Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. Size of regions to skip is a multiple of chunkSize.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1830 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1832 {
1833         // ----- measured probability
1834         REAL   totalProbability;                                    // probabilit
      y (returned) value
1835         // ----- temp variables
1836         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1837         long long int numTasks=multiQubit.numAmps;
1838 
1839         // ---------------------------------------------------------------- //
1840         //            find probability                                      //
1841         // ---------------------------------------------------------------- //
1842 
1843         // initialise returned value
1844         totalProbability = 0.0;
1845 
1846         REAL *stateVecReal = multiQubit.stateVec.real;
1847         REAL *stateVecImag = multiQubit.stateVec.imag;
1848 
1849 # ifdef _OPENMP
1850 # pragma omp parallel \
1851         shared    (numTasks,stateVecReal,stateVecImag) \
1852         private   (thisTask) \
1853         reduction ( +:totalProbability )
1854 # endif
1855         {
1856 # ifdef _OPENMP
1857                 # pragma omp for schedule  (static)
1858 # endif
1859                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1860                         // summation -- simple implementation
1861                         totalProbability += stateVecReal[thisTask]*stateVecReal[t
      hisTask]
1862                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
1863 
1864                         /*
1865                         // summation -- kahan correction
1866                         y = stateVecReal[thisTask]*stateVecReal[thisTask]
1867                         + stateVecImag[thisTask]*stateVecImag[thisTask] - c;
1868                         t = totalProbability + y;
1869                         c = (t - totalProbability) - y;
1870                         totalProbability = t;
1871                         */
1872 
1873                 }
1874         }
1875 
1876         return totalProbability;
1877 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}}
\index{findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{findProbabilityOfZeroLocal}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits__internal_8h_a7c02cd0e1b4eac19771a0525f023249e}


Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1757 of file qubits.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1759 {
1760         // ----- sizes
1761         long long int sizeBlock,                                           // siz
      e of blocks
1762         sizeHalfBlock;                                       // size of blocks ha
      lved
1763         // ----- indices
1764         long long int thisBlock,                                           // cur
      rent block
1765              index;                                               // current inde
      x for first half block
1766         // ----- measured probability
1767         REAL   totalProbability;                                    // probabilit
      y (returned) value
1768         // ----- temp variables
1769         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1770         long long int numTasks=multiQubit.numAmps>>1;
1771 
1772         // ---------------------------------------------------------------- //
1773         //            dimensions                                            //
1774         // ---------------------------------------------------------------- //
1775         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1776         // and then the number to skip
1777         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1778 
1779         // initialise returned value
1780         totalProbability = 0.0;
1781 
1782         // initialise correction for kahan summation
1783         if (DEBUG) printf("sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\n",sizeHa
      lfBlock,sizeBlock,numTasks);
1784 
1785         REAL *stateVecReal = multiQubit.stateVec.real;
1786         REAL *stateVecImag = multiQubit.stateVec.imag;
1787 
1788 # ifdef _OPENMP
1789 # pragma omp parallel \
1790         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
      
1791         private   (thisTask,thisBlock,index) \
1792         reduction ( +:totalProbability )
1793 # endif 
1794         {
1795 # ifdef _OPENMP
1796                 # pragma omp for schedule  (static)
1797 # endif
1798                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1799                         thisBlock = thisTask / sizeHalfBlock;
1800                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
      
1801 
1802                         if (index<0){ printf("ABORTING as index=%Ld with thisBloc
      k = %Ld  thisTask=%Ld \n", index,thisBlock,thisTask); exit(1);}
1803 
1804                         // summation -- simple implementation
1805                         totalProbability += stateVecReal[index]*stateVecReal[inde
      x]
1806                                 + stateVecImag[index]*stateVecImag[index];
1807 
1808                         /*
1809                         // summation -- kahan correction
1810                         y = stateVecReal[index]*stateVecReal[index]
1811                         + stateVecImag[index]*stateVecImag[index] - c;
1812                         t = totalProbability + y;
1813                         c = (t - totalProbability) - y;
1814                         totalProbability = t;
1815                         */
1816 
1817                 }
1818         }
1819         return totalProbability;
1820 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ac835c194bd547240a35f0b028db1d658}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!hadamardDistributed@{hadamardDistributed}}
\index{hadamardDistributed@{hadamardDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{hadamardDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits__internal_8h_ac835c194bd547240a35f0b028db1d658}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1544 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by hadamard().


\begin{DoxyCode}
1549 {
1550 
1551         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1552         long long int thisTask;  
1553         const long long int numTasks=multiQubit.numAmps;
1554 
1555         int sign;
1556         if (updateUpper) sign=1;
1557         else sign=-1;
1558 
1559         REAL recRoot2 = 1.0/sqrt(2);
1560 
1561         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1562         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1563         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1564 
1565 # ifdef _OPENMP
1566 # pragma omp parallel \
1567         default  (none) \
1568         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1569                         recRoot2, sign) \
1570         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1571 # endif
1572         {
1573 # ifdef _OPENMP
1574                 # pragma omp for schedule (static)
1575 # endif
1576                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1577                         // store current state vector values in temp variables
1578                         stateRealUp = stateVecRealUp[thisTask];
1579                         stateImagUp = stateVecImagUp[thisTask];
1580 
1581                         stateRealLo = stateVecRealLo[thisTask];
1582                         stateImagLo = stateVecImagLo[thisTask];
1583 
1584                         stateVecRealOut[thisTask] = recRoot2*(stateRealUp + sign*
      stateRealLo);
1585                         stateVecImagOut[thisTask] = recRoot2*(stateImagUp + sign*
      stateImagLo);
1586                 }
1587         }
1588 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a0711416fceaf63c67b496e123e845c69}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!hadamardLocal@{hadamardLocal}}
\index{hadamardLocal@{hadamardLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{hadamardLocal}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit})}\hfill}
\label{qubits__internal_8h_a0711416fceaf63c67b496e123e845c69}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \end{DoxyParams}


Definition at line 1482 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by hadamard().


\begin{DoxyCode}
1483 {
1484         long long int sizeBlock, sizeHalfBlock;
1485         long long int thisBlock, // current block
1486              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1487 
1488         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1489         long long int thisTask;         
1490         const long long int numTasks=multiQubit.numAmps>>1;
1491 
1492         // set dimensions
1493         sizeHalfBlock = 1LL << rotQubit;  
1494         sizeBlock     = 2LL * sizeHalfBlock; 
1495 
1496         // Can't use multiQubit.stateVec as a private OMP var
1497         REAL *stateVecReal = multiQubit.stateVec.real;
1498         REAL *stateVecImag = multiQubit.stateVec.imag;
1499 
1500         REAL recRoot2 = 1.0/sqrt(2);
1501 
1502 # ifdef _OPENMP
1503 # pragma omp parallel \
1504         default  (none) \
1505         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \
      
1506         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
1507 # endif
1508         {
1509 # ifdef _OPENMP
1510                 # pragma omp for schedule (static)
1511 # endif
1512                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1513                         thisBlock   = thisTask / sizeHalfBlock;
1514                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1515                         indexLo     = indexUp + sizeHalfBlock;
1516 
1517                         stateRealUp = stateVecReal[indexUp];
1518                         stateImagUp = stateVecImag[indexUp];
1519 
1520                         stateRealLo = stateVecReal[indexLo];
1521                         stateImagLo = stateVecImag[indexLo];
1522 
1523                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateReal
      Lo);
1524                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImag
      Lo);
1525 
1526                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateReal
      Lo);
1527                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImag
      Lo);
1528                 } 
1529         }
1530 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a54f4c82568e9433515c4480cdb536e27}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}}
\index{multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{multiControlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  long long int {\em mask}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a54f4c82568e9433515c4480cdb536e27}


Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where all the control qubits are 1.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1118 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
1125 {
1126 
1127         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1128         long long int thisTask;  
1129         const long long int numTasks=multiQubit.numAmps;
1130         const long long int chunkSize=multiQubit.numAmps;
1131         const long long int chunkId=multiQubit.chunkId;
1132 
1133         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
1134         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
1135         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1136         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1137         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1138 
1139 # ifdef _OPENMP
1140 # pragma omp parallel \
1141         default  (none) \
1142         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1143                         rot1Real,rot1Imag, rot2Real,rot2Imag, mask) \
1144         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1145 # endif
1146         {
1147 # ifdef _OPENMP
1148                 # pragma omp for schedule (static)
1149 # endif
1150                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1151                         if (mask == (mask & (thisTask+chunkId*chunkSize)) ){
1152                                 // store current state vector values in temp vari
      ables
1153                                 stateRealUp = stateVecRealUp[thisTask];
1154                                 stateImagUp = stateVecImagUp[thisTask];
1155 
1156                                 stateRealLo = stateVecRealLo[thisTask];
1157                                 stateImagLo = stateVecImagLo[thisTask];
1158 
1159                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
1160                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
1161                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
1162                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
1163                         }
1164                 }
1165         }
1166 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a32cb91618b5fcd79b54be8d8760b713d}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!multiControlledUnitaryLocal@{multiControlledUnitaryLocal}}
\index{multiControlledUnitaryLocal@{multiControlledUnitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{multiControlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  long long int {\em mask}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_a32cb91618b5fcd79b54be8d8760b713d}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a control qubit. Only perform the rotation for elements where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]perform rotation if this qubit is 1 \item[\mbox{$\leftarrow$} {\em alpha}]rotation angle \item[\mbox{$\leftarrow$} {\em beta}]rotation angle \end{DoxyParams}


Definition at line 838 of file qubits.c.

References MultiQubit::chunkId, Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
840 {
841         long long int sizeBlock, sizeHalfBlock;
842         long long int thisBlock, // current block
843              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
844 
845         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
846         long long int thisTask;         
847         const long long int numTasks=multiQubit.numAmps>>1;
848         const long long int chunkSize=multiQubit.numAmps;
849         const long long int chunkId=multiQubit.chunkId;
850 
851         // set dimensions
852         sizeHalfBlock = 1LL << rotQubit;  
853         sizeBlock     = 2LL * sizeHalfBlock; 
854 
855         // Can't use multiQubit.stateVec as a private OMP var
856         REAL *stateVecReal = multiQubit.stateVec.real;
857         REAL *stateVecImag = multiQubit.stateVec.imag;
858 
859 # ifdef _OPENMP
860 # pragma omp parallel \
861         default  (none) \
862         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u, mask) \
863         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
864 # endif
865         {
866 # ifdef _OPENMP
867                 # pragma omp for schedule (static)
868 # endif
869                 for (thisTask=0; thisTask<numTasks; thisTask++) {
870 
871                         thisBlock   = thisTask / sizeHalfBlock;
872                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
873                         indexLo     = indexUp + sizeHalfBlock;
874 
875                         if (mask == (mask & (indexUp+chunkId*chunkSize)) ){
876                                 // store current state vector values in temp vari
      ables
877                                 stateRealUp = stateVecReal[indexUp];
878                                 stateImagUp = stateVecImag[indexUp];
879 
880                                 stateRealLo = stateVecReal[indexLo];
881                                 stateImagLo = stateVecImag[indexLo];
882 
883 
884                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
885                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
886                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
887                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
888                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
889 
890                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
891                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
892                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
893                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
894                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
895                         }
896                 } 
897         }
898 
899 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae275b94c1a483dda43bf4ec947635605}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGate@{phaseGate}}
\index{phaseGate@{phaseGate}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_ae275b94c1a483dda43bf4ec947635605}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em type}]the type of phase gate to apply -\/-\/ one of \{SIGMA\_\-Z, S\_\-GATE, T\_\-GATE\} \end{DoxyParams}


Definition at line 153 of file qubits\_\-env\_\-local.c.

References MultiQubit::chunkId, chunkIsUpper(), halfMatrixBlockFitsInChunk(), MultiQubit::numAmps, MultiQubit::numQubits, phaseGateDistributed(), phaseGateLocal(), and QuESTAssert().

Referenced by sGate(), sigmaZ(), and tGate().


\begin{DoxyCode}
154 {
155     QuESTAssert(rotQubit >= 0 && rotQubit < multiQubit.numQubits, 1, __func__);
156         phaseGateLocal(multiQubit, rotQubit, type);
157 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a38a05c7e749e806b182ef3b89878bfc4}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGateDistributed@{phaseGateDistributed}}
\index{phaseGateDistributed@{phaseGateDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGateDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_a38a05c7e749e806b182ef3b89878bfc4}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em type}]the type of phase gate to apply -\/-\/ one of \{SIGMA\_\-Z, S\_\-GATE, T\_\-GATE\} \end{DoxyParams}


Definition at line 1680 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1681 {
1682         REAL stateRealLo,stateImagLo;
1683         long long int thisTask;         
1684         const long long int numTasks=multiQubit.numAmps;
1685 
1686         // Can't use multiQubit.stateVec as a private OMP var
1687         REAL *stateVecReal = multiQubit.stateVec.real;
1688         REAL *stateVecImag = multiQubit.stateVec.imag;
1689 
1690         REAL recRoot2 = 1.0/sqrt(2);
1691 
1692 # ifdef _OPENMP
1693 # pragma omp parallel \
1694         default  (none) \
1695         shared   (stateVecReal,stateVecImag, recRoot2, type) \
1696         private  (thisTask,stateRealLo,stateImagLo) 
1697 # endif
1698         {
1699                 if (type==SIGMA_Z){
1700 # ifdef _OPENMP
1701                         # pragma omp for schedule (static)
1702 # endif
1703                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1704                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
      
1705                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
      
1706                         } 
1707                 } else if (type==S_GATE){
1708 # ifdef _OPENMP
1709                         # pragma omp for schedule (static)
1710 # endif
1711                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1712                                 stateRealLo = stateVecReal[thisTask];
1713                                 stateImagLo = stateVecImag[thisTask];
1714 
1715                                 stateVecReal[thisTask] = -stateImagLo;
1716                                 stateVecImag[thisTask] = stateRealLo;
1717                         } 
1718                 } else if (type==T_GATE){
1719 # ifdef _OPENMP
1720                         # pragma omp for schedule (static)
1721 # endif
1722                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1723                                 stateRealLo = stateVecReal[thisTask];
1724                                 stateImagLo = stateVecImag[thisTask];
1725 
1726                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo 
      - stateImagLo);
1727                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo 
      + stateImagLo);
1728                         } 
1729                 } else printf("Type %d is an invalid phase gate\n", type);
1730         }
1731 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a6a736aeb3532898019fe7c27010edc6a}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!phaseGateLocal@{phaseGateLocal}}
\index{phaseGateLocal@{phaseGateLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{phaseGateLocal}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits__internal_8h_a6a736aeb3532898019fe7c27010edc6a}


Rotate a single qubit by \{\{1,0\},\{0,p\}\} where p is a phase term determined by the type argument. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em type}]the type of phase gate to apply -\/-\/ one of \{SIGMA\_\-Z, S\_\-GATE, T\_\-GATE\} \end{DoxyParams}


fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod? 

Definition at line 1597 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1598 {
1599         long long int sizeBlock, sizeHalfBlock;
1600         long long int thisBlock, // current block
1601              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1602 
1603         REAL stateRealLo,stateImagLo;
1604         long long int thisTask;         
1605         const long long int numTasks=multiQubit.numAmps>>1;
1606 
1607         // set dimensions
1608         sizeHalfBlock = 1LL << rotQubit;  
1609         sizeBlock     = 2LL * sizeHalfBlock; 
1610 
1611         // Can't use multiQubit.stateVec as a private OMP var
1612         REAL *stateVecReal = multiQubit.stateVec.real;
1613         REAL *stateVecImag = multiQubit.stateVec.imag;
1614 
1615         REAL recRoot2 = 1.0/sqrt(2);
1616 
1617 # ifdef _OPENMP
1618 # pragma omp parallel \
1619         default  (none) \
1620         shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type
      ) \
1621         private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) 
1622 # endif
1623         {
1624                 if (type==SIGMA_Z){
1625 # ifdef _OPENMP
1626                         # pragma omp for schedule (static)
1627 # endif
1628                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1630                                 thisBlock   = thisTask / sizeHalfBlock;
1631                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1632                                 indexLo     = indexUp + sizeHalfBlock;
1633 
1634                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
1635                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
1636                         } 
1637                 } 
1638                 
1639                 else if (type==S_GATE){
1640 # ifdef _OPENMP
1641                         # pragma omp for schedule (static)
1642 # endif
1643                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1645                                 thisBlock   = thisTask / sizeHalfBlock;
1646                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1647                                 indexLo     = indexUp + sizeHalfBlock;
1648                                 stateRealLo = stateVecReal[indexLo];
1649                                 stateImagLo = stateVecImag[indexLo];
1650 
1651                                 stateVecReal[indexLo] = -stateImagLo;
1652                                 stateVecImag[indexLo] = stateRealLo;
1653                         } 
1654                 } else if (type==T_GATE){
1655 # ifdef _OPENMP
1656                         # pragma omp for schedule (static)
1657 # endif
1658                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1660                                 thisBlock   = thisTask / sizeHalfBlock;
1661                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1662                                 indexLo     = indexUp + sizeHalfBlock;
1663                                 stateRealLo = stateVecReal[indexLo];
1664                                 stateImagLo = stateVecImag[indexLo];
1665 
1666                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo -
       stateImagLo);
1667                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo +
       stateImagLo);
1668                         } 
1669                 } else printf("Type %d is an invalid phase gate\n", type);
1670         }
1671 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!QuESTAssert@{QuESTAssert}}
\index{QuESTAssert@{QuESTAssert}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{QuESTAssert}]{\setlength{\rightskip}{0pt plus 5cm}void QuESTAssert (int {\em isValid}, \/  int {\em errorCode}, \/  const char $\ast$ {\em func})}\hfill}
\label{qubits__internal_8h_a3587b9d533e633ccf1abf9ad2ce45d8d}


Definition at line 200 of file qubits\_\-env\_\-local.c.

References exitWithError().

Referenced by collapseToOutcome(), compactUnitary(), controlledCompactUnitary(), controlledNot(), controlledPhaseGate(), controlledUnitary(), findProbabilityOfOutcome(), hadamard(), multiControlledPhaseGate(), multiControlledUnitary(), phaseGate(), sigmaX(), sigmaY(), and unitary().


\begin{DoxyCode}
200                                                               {
201     if (!isValid) exitWithError(errorCode, func);
202 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a5958808b2f2f05937921ba7dabe5a171}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaXDistributed@{sigmaXDistributed}}
\index{sigmaXDistributed@{sigmaXDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaXDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_a5958808b2f2f05937921ba7dabe5a171}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1235 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaX().


\begin{DoxyCode}
1238 {
1239 
1240         long long int thisTask;  
1241         const long long int numTasks=multiQubit.numAmps;
1242 
1243         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1244         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1245 
1246 # ifdef _OPENMP
1247 # pragma omp parallel \
1248         default  (none) \
1249         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1250         private  (thisTask)
1251 # endif
1252         {
1253 # ifdef _OPENMP
1254                 # pragma omp for schedule (static)
1255 # endif
1256                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1257                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
1258                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
1259                 }
1260         }
1261 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_aa9e640bb2d0458c937c6a87dfeca0f23}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaXLocal@{sigmaXLocal}}
\index{sigmaXLocal@{sigmaXLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaXLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit})}\hfill}
\label{qubits__internal_8h_aa9e640bb2d0458c937c6a87dfeca0f23}


Rotate a single qubit by \{\{0,1\},\{1,0\}. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \end{DoxyParams}


Definition at line 1175 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaX().


\begin{DoxyCode}
1176 {
1177         long long int sizeBlock, sizeHalfBlock;
1178         long long int thisBlock, // current block
1179              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1180 
1181         REAL stateRealUp,stateImagUp;
1182         long long int thisTask;         
1183         const long long int numTasks=multiQubit.numAmps>>1;
1184 
1185         // set dimensions
1186         sizeHalfBlock = 1LL << rotQubit;  
1187         sizeBlock     = 2LL * sizeHalfBlock; 
1188 
1189         // Can't use multiQubit.stateVec as a private OMP var
1190         REAL *stateVecReal = multiQubit.stateVec.real;
1191         REAL *stateVecImag = multiQubit.stateVec.imag;
1192 
1193 # ifdef _OPENMP
1194 # pragma omp parallel \
1195         default  (none) \
1196         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1197         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1198 # endif
1199         {
1200 # ifdef _OPENMP
1201                 # pragma omp for schedule (static)
1202 # endif
1203                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1204                         thisBlock   = thisTask / sizeHalfBlock;
1205                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1206                         indexLo     = indexUp + sizeHalfBlock;
1207 
1208                         stateRealUp = stateVecReal[indexUp];
1209                         stateImagUp = stateVecImag[indexUp];
1210 
1211                         stateVecReal[indexUp] = stateVecReal[indexLo];
1212                         stateVecImag[indexUp] = stateVecImag[indexLo];
1213 
1214                         stateVecReal[indexLo] = stateRealUp;
1215                         stateVecImag[indexLo] = stateImagUp;
1216                 } 
1217         }
1218 
1219 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a0471f6b547ce8270ef85170b7f4f0214}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaYDistributed@{sigmaYDistributed}}
\index{sigmaYDistributed@{sigmaYDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaYDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits__internal_8h_a0471f6b547ce8270ef85170b7f4f0214}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1442 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaY().


\begin{DoxyCode}
1446 {
1447 
1448         long long int thisTask;  
1449         const long long int numTasks=multiQubit.numAmps;
1450 
1451         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1452         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1453 
1454         int realSign=1, imagSign=1;
1455         if (updateUpper) imagSign=-1;
1456         else realSign = -1;
1457 
1458 # ifdef _OPENMP
1459 # pragma omp parallel \
1460         default  (none) \
1461         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,r
      ealSign,imagSign) \
1462         private  (thisTask)
1463 # endif
1464         {
1465 # ifdef _OPENMP
1466                 # pragma omp for schedule (static)
1467 # endif
1468                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1469                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisT
      ask];
1470                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisT
      ask];
1471                 }
1472         }
1473 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_afcbb1dcbe070ad0ed1a72a23251b6a83}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!sigmaYLocal@{sigmaYLocal}}
\index{sigmaYLocal@{sigmaYLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{sigmaYLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit})}\hfill}
\label{qubits__internal_8h_afcbb1dcbe070ad0ed1a72a23251b6a83}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \end{DoxyParams}


Definition at line 1382 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaY().


\begin{DoxyCode}
1383 {
1384         long long int sizeBlock, sizeHalfBlock;
1385         long long int thisBlock, // current block
1386              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1387 
1388         REAL stateRealUp,stateImagUp;
1389         long long int thisTask;         
1390         const long long int numTasks=multiQubit.numAmps>>1;
1391 
1392         // set dimensions
1393         sizeHalfBlock = 1LL << rotQubit;  
1394         sizeBlock     = 2LL * sizeHalfBlock; 
1395 
1396         // Can't use multiQubit.stateVec as a private OMP var
1397         REAL *stateVecReal = multiQubit.stateVec.real;
1398         REAL *stateVecImag = multiQubit.stateVec.imag;
1399 
1400 # ifdef _OPENMP
1401 # pragma omp parallel \
1402         default  (none) \
1403         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1404         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1405 # endif
1406         {
1407 # ifdef _OPENMP
1408                 # pragma omp for schedule (static)
1409 # endif
1410                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1411                         thisBlock   = thisTask / sizeHalfBlock;
1412                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1413                         indexLo     = indexUp + sizeHalfBlock;
1414 
1415                         stateRealUp = stateVecReal[indexUp];
1416                         stateImagUp = stateVecImag[indexUp];
1417 
1418                         stateVecReal[indexUp] = stateVecImag[indexLo];
1419                         stateVecImag[indexUp] = -stateVecReal[indexLo];
1420 
1421                         stateVecReal[indexLo] = -stateImagUp;
1422                         stateVecImag[indexLo] = stateRealUp;
1423                 } 
1424         }
1425 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_af538f02e700f4d022044fc71030a6953}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!unitaryDistributed@{unitaryDistributed}}
\index{unitaryDistributed@{unitaryDistributed}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{unitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits__internal_8h_af538f02e700f4d022044fc71030a6953}


Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em u}]unitary matrix to apply \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 704 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by unitary().


\begin{DoxyCode}
709 {
710 
711         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
712         long long int thisTask;  
713         const long long int numTasks=multiQubit.numAmps;
714 
715         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
716         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
717         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
718         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
719         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
720 
721 
722 # ifdef _OPENMP
723 # pragma omp parallel \
724         default  (none) \
725         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
726                         rot1Real, rot1Imag, rot2Real, rot2Imag) \
727         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
728 # endif
729         {
730 # ifdef _OPENMP
731                 # pragma omp for schedule (static)
732 # endif
733                 for (thisTask=0; thisTask<numTasks; thisTask++) {
734                         // store current state vector values in temp variables
735                         stateRealUp = stateVecRealUp[thisTask];
736                         stateImagUp = stateVecImagUp[thisTask];
737 
738                         stateRealLo = stateVecRealLo[thisTask];
739                         stateImagLo = stateVecImagLo[thisTask];
740 
741                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp 
742                                 + rot2Real*stateRealLo - rot2Imag*stateImagLo;
743                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp 
744                                 + rot2Real*stateImagLo + rot2Imag*stateRealLo;
745                 }
746         }
747 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a5fd78353771c9a34832e7a3b1e90f4db}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!unitaryLocal@{unitaryLocal}}
\index{unitaryLocal@{unitaryLocal}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{unitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_a5fd78353771c9a34832e7a3b1e90f4db}


Definition at line 575 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by unitary().


\begin{DoxyCode}
576 {
577         long long int sizeBlock, sizeHalfBlock;
578         long long int thisBlock, // current block
579              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
580 
581         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
582         long long int thisTask;         
583         const long long int numTasks=multiQubit.numAmps>>1;
584 
585         // set dimensions
586         sizeHalfBlock = 1LL << rotQubit;  
587         sizeBlock     = 2LL * sizeHalfBlock; 
588 
589         // Can't use multiQubit.stateVec as a private OMP var
590         REAL *stateVecReal = multiQubit.stateVec.real;
591         REAL *stateVecImag = multiQubit.stateVec.imag;
592 
593 # ifdef _OPENMP
594 # pragma omp parallel \
595         default  (none) \
596         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
597         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
598 # endif
599         {
600 # ifdef _OPENMP
601                 # pragma omp for schedule (static)
602 # endif
603                 for (thisTask=0; thisTask<numTasks; thisTask++) {
604 
605                         thisBlock   = thisTask / sizeHalfBlock;
606                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
607                         indexLo     = indexUp + sizeHalfBlock;
608 
609                         // store current state vector values in temp variables
610                         stateRealUp = stateVecReal[indexUp];
611                         stateImagUp = stateVecImag[indexUp];
612 
613                         stateRealLo = stateVecReal[indexLo];
614                         stateImagLo = stateVecImag[indexLo];
615 
616 
617                         // state[indexUp] = u00 * state[indexUp] + u01 * state[in
      dexLo]
618                         stateVecReal[indexUp] = u.r0c0.real*stateRealUp - u.r0c0.
      imag*stateImagUp 
619                                 + u.r0c1.real*stateRealLo - u.r0c1.imag*stateImag
      Lo;
620                         stateVecImag[indexUp] = u.r0c0.real*stateImagUp + u.r0c0.
      imag*stateRealUp 
621                                 + u.r0c1.real*stateImagLo + u.r0c1.imag*stateReal
      Lo;
622 
623                         // state[indexLo] = u10  * state[indexUp] + u11 * state[i
      ndexLo]
624                         stateVecReal[indexLo] = u.r1c0.real*stateRealUp  - u.
      r1c0.imag*stateImagUp 
625                                 + u.r1c1.real*stateRealLo  -  u.r1c1.imag*stateIm
      agLo;
626                         stateVecImag[indexLo] = u.r1c0.real*stateImagUp + u.r1c0.
      imag*stateRealUp 
627                                 + u.r1c1.real*stateImagLo + u.r1c1.imag*stateReal
      Lo;
628 
629                 } 
630         }
631 } 
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateAlphaBeta@{validateAlphaBeta}}
\index{validateAlphaBeta@{validateAlphaBeta}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateAlphaBeta}]{\setlength{\rightskip}{0pt plus 5cm}int validateAlphaBeta ({\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits__internal_8h_ae2b2c14a07dd7d50ff86032a3ca101d7}


Definition at line 408 of file qubits.c.

References Complex::imag, Complex::real, and REAL\_\-EPS.

Referenced by compactUnitary(), and controlledCompactUnitary().


\begin{DoxyCode}
408                                                   {
409         if ( fabs(alpha.real*alpha.real 
410                 + alpha.imag*alpha.imag
411                 + beta.real*beta.real 
412                 + beta.imag*beta.imag - 1) > REAL_EPS ) return 0;
413         else return 1;
414 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateMatrixIsUnitary@{validateMatrixIsUnitary}}
\index{validateMatrixIsUnitary@{validateMatrixIsUnitary}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateMatrixIsUnitary}]{\setlength{\rightskip}{0pt plus 5cm}int validateMatrixIsUnitary ({\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits__internal_8h_ae4fea133d1a8f09ff8da03038100adb2}


Definition at line 383 of file qubits.c.

References Complex::imag, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, and REAL\_\-EPS.

Referenced by controlledUnitary(), multiControlledUnitary(), and unitary().


\begin{DoxyCode}
383                                              {
384 
385         if ( fabs(u.r0c0.real*u.r0c0.real 
386                 + u.r0c0.imag*u.r0c0.imag
387                 + u.r1c0.real*u.r1c0.real
388                 + u.r1c0.imag*u.r1c0.imag - 1) > REAL_EPS ) return 0;
389     // check
390         if ( fabs(u.r0c1.real*u.r0c1.real 
391                 + u.r0c1.imag*u.r0c1.imag
392                 + u.r1c1.real*u.r1c1.real
393                 + u.r1c1.imag*u.r1c1.imag - 1) > REAL_EPS ) return 0;
394 
395         if ( fabs(u.r0c0.real*u.r0c1.real 
396                 + u.r0c0.imag*u.r0c1.imag
397                 + u.r1c0.real*u.r1c1.real
398                 + u.r1c0.imag*u.r1c1.imag) > REAL_EPS ) return 0;
399 
400         if ( fabs(u.r0c1.real*u.r0c0.imag
401                 - u.r0c0.real*u.r0c1.imag
402                 + u.r1c1.real*u.r1c0.imag
403                 - u.r1c0.real*u.r1c1.imag) > REAL_EPS ) return 0;
404 
405         return 1;
406 }
\end{DoxyCode}
\hypertarget{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!validateUnitVector@{validateUnitVector}}
\index{validateUnitVector@{validateUnitVector}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{validateUnitVector}]{\setlength{\rightskip}{0pt plus 5cm}int validateUnitVector (REAL {\em ux}, \/  REAL {\em uy}, \/  REAL {\em uz})}\hfill}
\label{qubits__internal_8h_a71c14976f63cfcda70026fa20ee531fe}


Definition at line 416 of file qubits.c.

References REAL\_\-EPS.


\begin{DoxyCode}
416                                                  {
417         if ( fabs(sqrt(ux*ux + uy*uy + uz*uz) - 1) > REAL_EPS ) return 0;
418         else return 1;
419 }
\end{DoxyCode}


\subsubsection{Variable Documentation}
\hypertarget{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}{
\index{qubits\_\-internal.h@{qubits\_\-internal.h}!errorCodes@{errorCodes}}
\index{errorCodes@{errorCodes}!qubits_internal.h@{qubits\_\-internal.h}}
\paragraph[{errorCodes}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ {\bf errorCodes}\mbox{[}$\,$\mbox{]}}\hfill}
\label{qubits__internal_8h_aac1637696885c75b73a1ecf381cea713}


Definition at line 17 of file qubits.c.

Referenced by exitWithError().