\hypertarget{QuEST__env__mpi_8c}{}\subsection{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c File Reference}
\label{QuEST__env__mpi_8c}\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}


An implementation of the A\+PI in qubits.\+h for an M\+PI environment.  


{\ttfamily \#include $<$unistd.\+h$>$}\newline
{\ttfamily \#include $<$mpi.\+h$>$}\newline
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include $<$math.\+h$>$}\newline
{\ttfamily \#include \char`\"{}Qu\+E\+S\+T\+\_\+precision.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}Qu\+E\+S\+T.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}Qu\+E\+S\+T\+\_\+internal.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}mt19937ar.\+h\char`\"{}}\newline
{\ttfamily \#include $<$time.\+h$>$}\newline
{\ttfamily \#include $<$sys/types.\+h$>$}\newline
\subsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{QuEST__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}}
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}} \mbox{\hyperlink{QuEST__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}{calc\+Total\+Probability}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit)
\begin{DoxyCompactList}\small\item\em Calculate the probability of being in any state by taking the norm of the entire state vector. \end{DoxyCompactList}\item 
static int \mbox{\hyperlink{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunk\+Is\+Upper}} (int chunk\+Id, long long int chunk\+Size, int target\+Qubit)
\begin{DoxyCompactList}\small\item\em Returns whether a given chunk in position chunk\+Id is in the upper or lower half of a block. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}{close\+Qu\+E\+S\+T\+Env}} (\mbox{\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env}} env)
\begin{DoxyCompactList}\small\item\em Close Qu\+E\+ST environment. \end{DoxyCompactList}\item 
\mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}} \mbox{\hyperlink{QuEST__env__mpi_8c_a07418ebac70fd9ae5d051d089961631d}{collapse\+To\+Outcome}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, const int measure\+Qubit, int outcome)
\begin{DoxyCompactList}\small\item\em Updates the state vector to be consistent with measuring the measure qubit in the given outcome (0 or 1), and returns the probability of such a measurement outcome. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_a03b13dfcabd8c59b50dbdd3af44ba8b2}{compact\+Unitary}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, const int target\+Qubit, \mbox{\hyperlink{structComplex}{Complex}} alpha, \mbox{\hyperlink{structComplex}{Complex}} beta)
\begin{DoxyCompactList}\small\item\em Apply a single-\/qubit unitary parameterised by two given complex scalars. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_ab4812953bc457405b3aa05a4c2f64f4a}{controlled\+Compact\+Unitary}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, const int control\+Qubit, const int target\+Qubit, \mbox{\hyperlink{structComplex}{Complex}} alpha, \mbox{\hyperlink{structComplex}{Complex}} beta)
\begin{DoxyCompactList}\small\item\em Apply a controlled unitary (single control, single target) parameterised by two given complex scalars. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_a67576895bbc65463481a8ea24d9b1e22}{controlled\+Not}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, const int control\+Qubit, const int target\+Qubit)
\begin{DoxyCompactList}\small\item\em Apply the controlled not (single control, single target) gate, also known as the c-\/X, c-\/sigma-\/X, c-\/\+Pauli-\/X and c-\/bit-\/flip gate. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_a8a701526263392599aa21d0d0f05d9d8}{controlled\+Unitary}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, const int control\+Qubit, const int target\+Qubit, \mbox{\hyperlink{structComplexMatrix2}{Complex\+Matrix2}} u)
\begin{DoxyCompactList}\small\item\em Apply a general controlled unitary (single control, single target), which can include a global phase factor. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchange\+State\+Vectors}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, int pair\+Rank)
\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_ae5f9019826f35e8b51b1716cfe397b45}{exit\+With\+Error}} (int error\+Code, const char $\ast$func)
\item 
\mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}} \mbox{\hyperlink{QuEST__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{find\+Probability\+Of\+Outcome}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, const int measure\+Qubit, int outcome)
\begin{DoxyCompactList}\small\item\em Gives the probability of a specified qubit being measured in the given outcome (0 or 1). \end{DoxyCompactList}\item 
static int \mbox{\hyperlink{QuEST__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{get\+Chunk\+Id\+From\+Index}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, long long int index)
\item 
static int \mbox{\hyperlink{QuEST__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{get\+Chunk\+Pair\+Id}} (int \mbox{\hyperlink{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunk\+Is\+Upper}}, int chunk\+Id, long long int chunk\+Size, int target\+Qubit)
\begin{DoxyCompactList}\small\item\em get position of corresponding chunk, holding values required to update values in my chunk (with chunk\+Id) when rotating target\+Qubit. \end{DoxyCompactList}\item 
\mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}} \mbox{\hyperlink{QuEST__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}{get\+Imag\+Amp\+El}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the imaginary component of the complex probability amplitude at an index in the state vector. \end{DoxyCompactList}\item 
\mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}} \mbox{\hyperlink{QuEST__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}{get\+Real\+Amp\+El}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the real component of the complex probability amplitude at an index in the state vector. \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{QuEST__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{get\+Rot\+Angle}} (int \mbox{\hyperlink{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunk\+Is\+Upper}}, \mbox{\hyperlink{structComplex}{Complex}} $\ast$rot1, \mbox{\hyperlink{structComplex}{Complex}} $\ast$rot2, \mbox{\hyperlink{structComplex}{Complex}} alpha, \mbox{\hyperlink{structComplex}{Complex}} beta)
\begin{DoxyCompactList}\small\item\em Get rotation values for a given chunk. \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{QuEST__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}{get\+Rot\+Angle\+From\+Unitary\+Matrix}} (int \mbox{\hyperlink{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunk\+Is\+Upper}}, \mbox{\hyperlink{structComplex}{Complex}} $\ast$rot1, \mbox{\hyperlink{structComplex}{Complex}} $\ast$rot2, \mbox{\hyperlink{structComplexMatrix2}{Complex\+Matrix2}} u)
\begin{DoxyCompactList}\small\item\em Get rotation values for a given chunk given a unitary matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_aa09b5dd93de6df1384b8f2c0041749ab}{hadamard}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, const int target\+Qubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit Hadamard gate. \end{DoxyCompactList}\item 
static int \mbox{\hyperlink{QuEST__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{half\+Matrix\+Block\+Fits\+In\+Chunk}} (long long int chunk\+Size, int target\+Qubit)
\begin{DoxyCompactList}\small\item\em return whether the current qubit rotation will use blocks that fit within a single chunk. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}{init\+Qu\+E\+S\+T\+Env}} (\mbox{\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env}} $\ast$env)
\begin{DoxyCompactList}\small\item\em Initialize the Qu\+E\+ST environment. \end{DoxyCompactList}\item 
static int \mbox{\hyperlink{QuEST__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero}} (int chunk\+Id, long long int chunk\+Size, int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Find chunks to skip when calculating probability of qubit being zero. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{QuEST__env__mpi_8c_ad5774247d836267175c664cd0e451bcb}{measure}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, int measure\+Qubit)
\begin{DoxyCompactList}\small\item\em Measures a single qubit, collapsing it randomly to 0 or 1. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{QuEST__env__mpi_8c_a2ac46e470c750bf93c754e06c64b0a7a}{measure\+With\+Stats}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, int measure\+Qubit, \mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}} $\ast$state\+Prob)
\begin{DoxyCompactList}\small\item\em Measures a single qubit, collapsing it randomly to 0 or 1, and additionally gives the probability of that outcome. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_ae395a79690283ed81106afadd7a8cd8a}{multi\+Controlled\+Unitary}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, int $\ast$control\+Qubits, const int num\+Control\+Qubits, const int target\+Qubit, \mbox{\hyperlink{structComplexMatrix2}{Complex\+Matrix2}} u)
\begin{DoxyCompactList}\small\item\em Apply a general multiple-\/control single-\/target unitary, which can include a global phase factor. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_aae7a8a7f1ccbddb7f76b6c52b746bb43}{phase\+Gate}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, const int target\+Qubit, enum \mbox{\hyperlink{QuEST_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type}} type)
\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{Qu\+E\+S\+T\+Assert}} (int is\+Valid, int error\+Code, const char $\ast$func)
\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}{report\+Node\+List}} (\mbox{\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env}} env)
\begin{DoxyCompactList}\small\item\em Report a list of C\+PU hostnames and the rank that is running on each if running with M\+PI enabled and an error message otherwise. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}{report\+Qu\+E\+S\+T\+Env}} (\mbox{\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env}} env)
\begin{DoxyCompactList}\small\item\em Report information about the Qu\+E\+ST environment. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_a86e396e06b7d527cac20ba0108872423}{sigmaX}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, const int target\+Qubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit sigma-\/X (also known as the X, Pauli-\/X, N\+OT or bit-\/flip) gate. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_a1f54d70a42403f7e1c2e2c2007332f61}{sigmaY}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, const int target\+Qubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit sigma-\/Y (also known as the Y or Pauli-\/Y) gate. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}{sync\+Qu\+E\+S\+T\+Env}} (\mbox{\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env}} env)
\begin{DoxyCompactList}\small\item\em Guarantees that all code up to the given point has been executed on all nodes (if running in distributed mode) \end{DoxyCompactList}\item 
int \mbox{\hyperlink{QuEST__env__mpi_8c_ac7e38d768a1bd79019f88cc1e6295092}{sync\+Qu\+E\+S\+T\+Success}} (int success\+Code)
\begin{DoxyCompactList}\small\item\em Performs a logical A\+ND on all success\+Codes held by all processes. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{QuEST__env__mpi_8c_a7a0877e33700f6bad48adb51b7b3fb67}{unitary}} (\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}} multi\+Qubit, const int target\+Qubit, \mbox{\hyperlink{structComplexMatrix2}{Complex\+Matrix2}} u)
\begin{DoxyCompactList}\small\item\em Apply a general single-\/qubit unitary (including a global phase factor). \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
An implementation of the A\+PI in qubits.\+h for an M\+PI environment. 



\subsubsection{Macro Definition Documentation}
\mbox{\Hypertarget{QuEST__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}\label{QuEST__env__mpi_8c_ad3d8a3bd0c0b677acef144f2c2ef6d73}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE@{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}}
\index{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE@{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{\+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}{\_BSD\_SOURCE}}
{\footnotesize\ttfamily \#define \+\_\+\+B\+S\+D\+\_\+\+S\+O\+U\+R\+CE}



Definition at line 8 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



\subsubsection{Function Documentation}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}\label{QuEST__env__mpi_8c_a818a4c7cd7252d2b10b896b12fa431d3}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!calc\+Total\+Probability@{calc\+Total\+Probability}}
\index{calc\+Total\+Probability@{calc\+Total\+Probability}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{calc\+Total\+Probability()}{calcTotalProbability()}}
{\footnotesize\ttfamily \mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}} calc\+Total\+Probability (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit }\end{DoxyParamCaption})}



Calculate the probability of being in any state by taking the norm of the entire state vector. 

Should be equal to 1.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing a set of qubits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
total probability 
\end{DoxyReturn}


Definition at line 114 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Complex\+Array\+::imag, M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks, Multi\+Qubit\+::num\+Chunks, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
114                                                 \{
115     \textcolor{comment}{// Implemented using Kahan summation for greater accuracy at a slight floating}
116     \textcolor{comment}{//   point operation overhead. For more details see
       https://en.wikipedia.org/wiki/Kahan\_summation\_algorithm}
117     \mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}} pTotal=0; 
118     \mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}} y, t, c;
119     \mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}} allRankTotals=0;
120     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} index;
121     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} numAmpsPerRank = multiQubit.\mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}};
122     c = 0.0;
123     \textcolor{keywordflow}{for} (index=0; index<numAmpsPerRank; index++)\{ 
124         \textcolor{comment}{// Perform pTotal+=multiQubit.stateVec.real[index]*multiQubit.stateVec.real[index]; by Kahan}
125         y = multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}.\mbox{\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}}[index]*multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}.
      \mbox{\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}}[index] - c;
126         t = pTotal + y;
127         \textcolor{comment}{// Don't change the bracketing on the following line}
128         c = ( t - pTotal ) - y;
129         pTotal = t;
130         \textcolor{comment}{// Perform pTotal+=multiQubit.stateVec.imag[index]*multiQubit.stateVec.imag[index]; by Kahan}
131         y = multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}.\mbox{\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}}[index]*multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}.
      \mbox{\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}}[index] - c;
132         t = pTotal + y;
133         \textcolor{comment}{// Don't change the bracketing on the following line}
134         c = ( t - pTotal ) - y;
135         pTotal = t;
136     \} 
137     \textcolor{keywordflow}{if} (multiQubit.\mbox{\hyperlink{structMultiQubit_acd43f2f57991709c9e94f73662c972b2}{numChunks}}>1) MPI\_Allreduce(&pTotal, &allRankTotals, 1, 
      \mbox{\hyperlink{QuEST__precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}}, MPI\_SUM, MPI\_COMM\_WORLD);
138     \textcolor{keywordflow}{else} allRankTotals=pTotal;
139 
140     \textcolor{keywordflow}{return} allRankTotals;
141 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}\label{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!chunk\+Is\+Upper@{chunk\+Is\+Upper}}
\index{chunk\+Is\+Upper@{chunk\+Is\+Upper}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{chunk\+Is\+Upper()}{chunkIsUpper()}}
{\footnotesize\ttfamily static int chunk\+Is\+Upper (\begin{DoxyParamCaption}\item[{int}]{chunk\+Id,  }\item[{long long int}]{chunk\+Size,  }\item[{int}]{target\+Qubit }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Returns whether a given chunk in position chunk\+Id is in the upper or lower half of a block. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Id} & id of chunk in state vector \\
\hline
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit being rotated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1\+: chunk is in upper half of block, 0\+: chunk is in lower half of block fix -- is this the same as is\+Chunk\+To\+Skip? 
\end{DoxyReturn}


Definition at line 152 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



Referenced by compact\+Unitary(), controlled\+Compact\+Unitary(), controlled\+Not(), controlled\+Unitary(), get\+Chunk\+Pair\+Id(), get\+Rot\+Angle(), get\+Rot\+Angle\+From\+Unitary\+Matrix(), hadamard(), multi\+Controlled\+Unitary(), phase\+Gate(), sigma\+X(), sigma\+Y(), and unitary().


\begin{DoxyCode}
153 \{       
154     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (targetQubit);
155     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeBlock = sizeHalfBlock*2;
156     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} posInBlock = (chunkId*chunkSize) % sizeBlock;
157     \textcolor{keywordflow}{return} posInBlock<sizeHalfBlock;
158 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}\label{QuEST__env__mpi_8c_abd4bc926cd3f9b65610bb228d0c59fe0}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!close\+Qu\+E\+S\+T\+Env@{close\+Qu\+E\+S\+T\+Env}}
\index{close\+Qu\+E\+S\+T\+Env@{close\+Qu\+E\+S\+T\+Env}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{close\+Qu\+E\+S\+T\+Env()}{closeQuESTEnv()}}
{\footnotesize\ttfamily void close\+Qu\+E\+S\+T\+Env (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env}}}]{env }\end{DoxyParamCaption})}



Close Qu\+E\+ST environment. 

If something needs to be done to clean up the execution environment, such as finalizing M\+PI when running in distributed mode, it is handled here


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 62 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.


\begin{DoxyCode}
62                                 \{
63     \textcolor{keywordtype}{int} finalized;
64     MPI\_Finalized(&finalized);
65     \textcolor{keywordflow}{if} (!finalized) MPI\_Finalize();
66     \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"ERROR: Trying to close QuESTEnv multiple times. Ignoring\(\backslash\)n"});
67 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a07418ebac70fd9ae5d051d089961631d}\label{QuEST__env__mpi_8c_a07418ebac70fd9ae5d051d089961631d}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!collapse\+To\+Outcome@{collapse\+To\+Outcome}}
\index{collapse\+To\+Outcome@{collapse\+To\+Outcome}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{collapse\+To\+Outcome()}{collapseToOutcome()}}
{\footnotesize\ttfamily \mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}} collapse\+To\+Outcome (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit,  }\item[{int}]{outcome }\end{DoxyParamCaption})}



Updates the state vector to be consistent with measuring the measure qubit in the given outcome (0 or 1), and returns the probability of such a measurement outcome. 

This is effectively performing a measurement and forcing the outcome. This is an irreversible change to the state vector, whereby incompatible states in the state vector are given zero amplitude and the remaining states are renormalised. Exits with error if the given outcome has $\sim$zero probability, and so cannot be collapsed into.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt in}  & {\em outcome} & to force the measure qubit to enter \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of the (forced) measurement outcome 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily measure\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}), or if {\ttfamily outcome} is not in \{0, 1\}, or if the probability of {\ttfamily outcome} is zero (within machine epsilon) \\
\hline
\end{DoxyExceptions}


Definition at line 680 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, collapse\+To\+Outcome\+Distributed\+Renorm(), collapse\+To\+Outcome\+Distributed\+Set\+Zero(), collapse\+To\+Outcome\+Local(), find\+Probability\+Of\+Outcome(), half\+Matrix\+Block\+Fits\+In\+Chunk(), is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero(), Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks, Multi\+Qubit\+::num\+Qubits, Qu\+E\+S\+T\+Assert(), R\+E\+AL, and R\+E\+A\+L\+\_\+\+E\+PS.


\begin{DoxyCode}
681 \{
682     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(measureQubit >= 0 && measureQubit < multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 2, \_\_func\_\_);
683     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}((outcome==0 || outcome==1), 10, \_\_func\_\_);
684 
685     \mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}} totalStateProb=\mbox{\hyperlink{QuEST__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{findProbabilityOfOutcome}}(multiQubit, measureQubit, 
      outcome);
686     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(fabs(totalStateProb)>\mbox{\hyperlink{QuEST__precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS}}, 8, \_\_func\_\_);
687 
688     \textcolor{keywordtype}{int} skipValuesWithinRank = \mbox{\hyperlink{QuEST__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}}(multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, measureQubit);
689     \textcolor{keywordflow}{if} (skipValuesWithinRank) \{
690         \mbox{\hyperlink{QuEST_8c_a01d9a8b7ff0e09ec399e158389783aa9}{collapseToOutcomeLocal}}(multiQubit, measureQubit, totalStateProb, outcome);
691     \} \textcolor{keywordflow}{else} \{
692         \textcolor{keywordflow}{if} (!\mbox{\hyperlink{QuEST__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{isChunkToSkipInFindPZero}}(multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, measureQubit))\{
693             \textcolor{comment}{// chunk has amps for q=0}
694             \textcolor{keywordflow}{if} (outcome==0) \mbox{\hyperlink{QuEST_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm}}(multiQubit
      , measureQubit, 
695                     totalStateProb);
696             \textcolor{keywordflow}{else} \mbox{\hyperlink{QuEST_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero}}(multiQubit, 
      measureQubit);
697         \} \textcolor{keywordflow}{else} \{
698             \textcolor{comment}{// chunk has amps for q=1}
699             \textcolor{keywordflow}{if} (outcome==1) \mbox{\hyperlink{QuEST_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm}}(multiQubit
      , measureQubit, 
700                     totalStateProb);
701             \textcolor{keywordflow}{else} \mbox{\hyperlink{QuEST_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero}}(multiQubit, 
      measureQubit);
702         \}
703     \}
704     \textcolor{keywordflow}{return} totalStateProb;
705 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a03b13dfcabd8c59b50dbdd3af44ba8b2}\label{QuEST__env__mpi_8c_a03b13dfcabd8c59b50dbdd3af44ba8b2}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!compact\+Unitary@{compact\+Unitary}}
\index{compact\+Unitary@{compact\+Unitary}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{compact\+Unitary()}{compactUnitary()}}
{\footnotesize\ttfamily void compact\+Unitary (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{const int}]{target\+Qubit,  }\item[{\mbox{\hyperlink{structComplex}{Complex}}}]{alpha,  }\item[{\mbox{\hyperlink{structComplex}{Complex}}}]{beta }\end{DoxyParamCaption})}



Apply a single-\/qubit unitary parameterised by two given complex scalars. 

Given valid complex numbers $\alpha$ and $\beta$, applies the unitary \[ U = \begin{pmatrix} \alpha & -\beta^* \\ \beta & \alpha^* \end{pmatrix} \] which is general up to a global phase factor. ~\newline
Valid $\alpha$, $\beta$ satisfy $|\alpha|^2 + |\beta|^2 = 1$.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {U}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to operate on \\
\hline
\mbox{\tt in}  & {\em alpha} & complex unitary parameter (row 1, column 1) \\
\hline
\mbox{\tt in}  & {\em beta} & complex unitary parameter (row 2, column 1) \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily target\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}), or if {\ttfamily alpha}, {\ttfamily beta} don\textquotesingle{}t satisfy $\vert${\ttfamily alpha$\vert$$^\wedge$2} + $\vert${\ttfamily beta$\vert$$^\wedge$2} = 1. \\
\hline
\end{DoxyExceptions}


Definition at line 274 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), compact\+Unitary\+Distributed(), compact\+Unitary\+Local(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), get\+Rot\+Angle(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), Multi\+Qubit\+::state\+Vec, and validate\+Alpha\+Beta().



Referenced by rotate\+Around\+Axis().


\begin{DoxyCode}
275 \{
276     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(targetQubit >= 0 && targetQubit < multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 1, \_\_func\_\_);
277     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(\mbox{\hyperlink{QuEST_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}{validateAlphaBeta}}(alpha, beta), 6, \_\_func\_\_);
278 
279     \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block fits
       on one rank}
280     \textcolor{keywordtype}{int} useLocalDataOnly = \mbox{\hyperlink{QuEST__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}}(multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
281     \mbox{\hyperlink{structComplex}{Complex}} rot1, rot2;
282 
283     \textcolor{comment}{// rank's chunk is in upper half of block }
284     \textcolor{keywordtype}{int} rankIsUpper;
285     \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
286 
287     \textcolor{keywordflow}{if} (useLocalDataOnly)\{
288         \textcolor{comment}{// all values required to update state vector lie in this rank}
289         \mbox{\hyperlink{QuEST_8c_a9cee2d8716667a3318420a3b672f5b92}{compactUnitaryLocal}}(multiQubit, targetQubit, alpha, beta);
290     \} \textcolor{keywordflow}{else} \{
291         \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
292         rankIsUpper = \mbox{\hyperlink{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}}(multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
293         \mbox{\hyperlink{QuEST__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{getRotAngle}}(rankIsUpper, &rot1, &rot2, alpha, beta);
294         pairRank = \mbox{\hyperlink{QuEST__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}}(rankIsUpper, multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
295         \textcolor{comment}{// get corresponding values from my pair}
296         \mbox{\hyperlink{QuEST__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}}(multiQubit, pairRank);
297 
298         \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. }
299         \textcolor{comment}{// send values to compactUnitaryDistributed in the correct order}
300         \textcolor{keywordflow}{if} (rankIsUpper)\{
301             \mbox{\hyperlink{QuEST_8c_a20ee1878a63ae6112e8845f4a8787592}{compactUnitaryDistributed}}(multiQubit,targetQubit,rot1,rot2,
302                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}, \textcolor{comment}{//upper}
303                     multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}, \textcolor{comment}{//lower}
304                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}); \textcolor{comment}{//output}
305         \} \textcolor{keywordflow}{else} \{
306             \mbox{\hyperlink{QuEST_8c_a20ee1878a63ae6112e8845f4a8787592}{compactUnitaryDistributed}}(multiQubit,targetQubit,rot1,rot2,
307                     multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}, \textcolor{comment}{//upper}
308                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}, \textcolor{comment}{//lower}
309                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}); \textcolor{comment}{//output}
310         \}
311     \}
312 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_ab4812953bc457405b3aa05a4c2f64f4a}\label{QuEST__env__mpi_8c_ab4812953bc457405b3aa05a4c2f64f4a}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!controlled\+Compact\+Unitary@{controlled\+Compact\+Unitary}}
\index{controlled\+Compact\+Unitary@{controlled\+Compact\+Unitary}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{controlled\+Compact\+Unitary()}{controlledCompactUnitary()}}
{\footnotesize\ttfamily void controlled\+Compact\+Unitary (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{const int}]{control\+Qubit,  }\item[{const int}]{target\+Qubit,  }\item[{\mbox{\hyperlink{structComplex}{Complex}}}]{alpha,  }\item[{\mbox{\hyperlink{structComplex}{Complex}}}]{beta }\end{DoxyParamCaption})}



Apply a controlled unitary (single control, single target) parameterised by two given complex scalars. 

Given valid complex numbers $\alpha$ and $\beta$, applies the two-\/qubit unitary \[ \begin{pmatrix} 1 \\ & 1 \\ & & \alpha & -\beta^* \\ & & \beta & \alpha^* \end{pmatrix} \] to the control and target qubits. Valid $\alpha$, $\beta$ satisfy $|\alpha|^2 + |\beta|^2 = 1$. The target unitary is general up to a global phase factor. ~\newline
 \[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {control}; \node[draw=none] at (-3.5, 0) {target}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 1); \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$U_{\alpha, \beta}$}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & apply the target unitary if this qubit has value 1 \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit on which to apply the target unitary \\
\hline
\mbox{\tt in}  & {\em alpha} & complex unitary parameter (row 1, column 1) \\
\hline
\mbox{\tt in}  & {\em beta} & complex unitary parameter (row 2, column 1) \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if either {\ttfamily control\+Qubit} or {\ttfamily target\+Qubit} are outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}) or are equal, or if {\ttfamily alpha}, {\ttfamily beta} don\textquotesingle{}t satisfy $\vert${\ttfamily alpha$\vert$$^\wedge$2} + $\vert${\ttfamily beta$\vert$$^\wedge$2} = 1. \\
\hline
\end{DoxyExceptions}


Definition at line 356 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), controlled\+Compact\+Unitary\+Distributed(), controlled\+Compact\+Unitary\+Local(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), get\+Rot\+Angle(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), Multi\+Qubit\+::state\+Vec, and validate\+Alpha\+Beta().



Referenced by controlled\+Rotate\+Around\+Axis().


\begin{DoxyCode}
357 \{
358     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(targetQubit >= 0 && targetQubit < multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 1, \_\_func\_\_);
359     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(controlQubit >= 0 && controlQubit < multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 2, \_\_func\_\_);
360     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(controlQubit != targetQubit, 3, \_\_func\_\_);
361     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(\mbox{\hyperlink{QuEST_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}{validateAlphaBeta}}(alpha, beta), 6, \_\_func\_\_);
362 
363     \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block fits
       on one rank}
364     \textcolor{keywordtype}{int} useLocalDataOnly = \mbox{\hyperlink{QuEST__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}}(multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
365     \mbox{\hyperlink{structComplex}{Complex}} rot1, rot2;
366 
367     \textcolor{comment}{// rank's chunk is in upper half of block }
368     \textcolor{keywordtype}{int} rankIsUpper;
369     \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
370 
371     \textcolor{keywordflow}{if} (useLocalDataOnly)\{
372         \textcolor{comment}{// all values required to update state vector lie in this rank}
373         \mbox{\hyperlink{QuEST_8c_afc77657651d52c47403b44b923a098a8}{controlledCompactUnitaryLocal}}(multiQubit, controlQubit, targetQubit, 
      alpha, beta);
374     \} \textcolor{keywordflow}{else} \{
375         \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
376         rankIsUpper = \mbox{\hyperlink{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}}(multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
377         \mbox{\hyperlink{QuEST__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}{getRotAngle}}(rankIsUpper, &rot1, &rot2, alpha, beta);
378         pairRank = \mbox{\hyperlink{QuEST__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}}(rankIsUpper, multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
379         \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
380         \textcolor{comment}{// get corresponding values from my pair}
381         \mbox{\hyperlink{QuEST__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}}(multiQubit, pairRank);
382 
383         \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. send values to
       controlledCompactUnitaryDistributed}
384         \textcolor{comment}{// in the correct order}
385         \textcolor{keywordflow}{if} (rankIsUpper)\{
386             \mbox{\hyperlink{QuEST_8c_a717855e835e3161e08c18cdc15325d27}{controlledCompactUnitaryDistributed}}(multiQubit,controlQubit,
      targetQubit,rot1,rot2,
387                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}, \textcolor{comment}{//upper}
388                     multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}, \textcolor{comment}{//lower}
389                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}); \textcolor{comment}{//output}
390         \} \textcolor{keywordflow}{else} \{
391             \mbox{\hyperlink{QuEST_8c_a717855e835e3161e08c18cdc15325d27}{controlledCompactUnitaryDistributed}}(multiQubit,controlQubit,
      targetQubit,rot1,rot2,
392                     multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}, \textcolor{comment}{//upper}
393                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}, \textcolor{comment}{//lower}
394                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}); \textcolor{comment}{//output}
395         \}
396     \}
397 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a67576895bbc65463481a8ea24d9b1e22}\label{QuEST__env__mpi_8c_a67576895bbc65463481a8ea24d9b1e22}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!controlled\+Not@{controlled\+Not}}
\index{controlled\+Not@{controlled\+Not}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{controlled\+Not()}{controlledNot()}}
{\footnotesize\ttfamily void controlled\+Not (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{const int}]{control\+Qubit,  }\item[{const int}]{target\+Qubit }\end{DoxyParamCaption})}



Apply the controlled not (single control, single target) gate, also known as the c-\/X, c-\/sigma-\/X, c-\/\+Pauli-\/X and c-\/bit-\/flip gate. 

This applies sigmaX to the target qubit if the control qubit has value 1. This effects the two-\/qubit unitary \[ \begin{pmatrix} 1 \\ & 1 \\\ & & & 1 \\ & & 1 \end{pmatrix} \] on the control and target qubits.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {control}; \node[draw=none] at (-3.5, 0) {target}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, -.5); \draw (-2,0) -- (2, 0); \draw (0, 0) circle (.5); \end{tikzpicture} } \] ~\newline
 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & nots the target if this qubit is 1 \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to not \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if either {\ttfamily control\+Qubit} or {\ttfamily target\+Qubit} are outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}), or are equal. \\
\hline
\end{DoxyExceptions}


Definition at line 518 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), controlled\+Not\+Distributed(), controlled\+Not\+Local(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
519 \{
520     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(targetQubit >= 0 && targetQubit < multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 1, \_\_func\_\_);
521     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(controlQubit >= 0 && controlQubit < multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 2, \_\_func\_\_);
522     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(controlQubit != targetQubit, 3, \_\_func\_\_);
523 
524     \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block fits
       on one rank}
525     \textcolor{keywordtype}{int} useLocalDataOnly = \mbox{\hyperlink{QuEST__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}}(multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
526 
527     \textcolor{comment}{// rank's chunk is in upper half of block }
528     \textcolor{keywordtype}{int} rankIsUpper;
529     \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
530 
531     \textcolor{keywordflow}{if} (useLocalDataOnly)\{
532         \textcolor{comment}{// all values required to update state vector lie in this rank}
533         \mbox{\hyperlink{QuEST_8c_ad357a43e80e3baf013975b1b70942f4c}{controlledNotLocal}}(multiQubit, controlQubit, targetQubit);
534     \} \textcolor{keywordflow}{else} \{
535         \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
536         rankIsUpper = \mbox{\hyperlink{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}}(multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
537         pairRank = \mbox{\hyperlink{QuEST__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}}(rankIsUpper, multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
538         \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
539         \textcolor{comment}{// get corresponding values from my pair}
540         \mbox{\hyperlink{QuEST__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}}(multiQubit, pairRank);
541         \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. send values to
       controlledNot}
542         \textcolor{comment}{// in the correct order}
543         \textcolor{keywordflow}{if} (rankIsUpper)\{
544             \mbox{\hyperlink{QuEST_8c_a05875a70b539a3efb28d027823403f34}{controlledNotDistributed}}(multiQubit,controlQubit,targetQubit,
545                     multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}, \textcolor{comment}{//in}
546                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}); \textcolor{comment}{//out}
547         \} \textcolor{keywordflow}{else} \{
548             \mbox{\hyperlink{QuEST_8c_a05875a70b539a3efb28d027823403f34}{controlledNotDistributed}}(multiQubit,controlQubit,targetQubit,
549                     multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}, \textcolor{comment}{//in}
550                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}); \textcolor{comment}{//out}
551         \}
552     \}
553 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a8a701526263392599aa21d0d0f05d9d8}\label{QuEST__env__mpi_8c_a8a701526263392599aa21d0d0f05d9d8}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!controlled\+Unitary@{controlled\+Unitary}}
\index{controlled\+Unitary@{controlled\+Unitary}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{controlled\+Unitary()}{controlledUnitary()}}
{\footnotesize\ttfamily void controlled\+Unitary (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{const int}]{control\+Qubit,  }\item[{const int}]{target\+Qubit,  }\item[{\mbox{\hyperlink{structComplexMatrix2}{Complex\+Matrix2}}}]{u }\end{DoxyParamCaption})}



Apply a general controlled unitary (single control, single target), which can include a global phase factor. 

The given unitary is applied to the target qubit if the control qubit has value 1, effecting the two-\/qubit unitary \[ \begin{pmatrix} 1 \\ & 1 \\ & & u_{00} & u_{01}\\ & & u_{10} & u_{11} \end{pmatrix} \] on the control and target qubits.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {control}; \node[draw=none] at (-3.5, 0) {target}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 1); \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {U}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em control\+Qubit} & apply unitary if this qubit is 1 \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to operate on \\
\hline
\mbox{\tt in}  & {\em u} & single-\/qubit unitary matrix to apply \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if either {\ttfamily control\+Qubit} or {\ttfamily target\+Qubit} are outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}) or are equal, or if {\ttfamily u} is not unitary. \\
\hline
\end{DoxyExceptions}


Definition at line 399 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), controlled\+Unitary\+Distributed(), controlled\+Unitary\+Local(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), get\+Rot\+Angle\+From\+Unitary\+Matrix(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), Multi\+Qubit\+::state\+Vec, and validate\+Matrix\+Is\+Unitary().


\begin{DoxyCode}
401 \{
402     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(targetQubit >= 0 && targetQubit < multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 1, \_\_func\_\_);
403     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(controlQubit >= 0 && controlQubit < multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 2, \_\_func\_\_);
404     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(controlQubit != targetQubit, 3, \_\_func\_\_);
405     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(\mbox{\hyperlink{QuEST_8c_ae4fea133d1a8f09ff8da03038100adb2}{validateMatrixIsUnitary}}(u), 5, \_\_func\_\_);
406 
407     \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block fits
       on one rank}
408     \textcolor{keywordtype}{int} useLocalDataOnly = \mbox{\hyperlink{QuEST__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}}(multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
409     \mbox{\hyperlink{structComplex}{Complex}} rot1, rot2;
410 
411     \textcolor{comment}{// rank's chunk is in upper half of block }
412     \textcolor{keywordtype}{int} rankIsUpper;
413     \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
414 
415     \textcolor{keywordflow}{if} (useLocalDataOnly)\{
416         \textcolor{comment}{// all values required to update state vector lie in this rank}
417         \mbox{\hyperlink{QuEST_8c_a8a4afcff70195a306c082b8ed8d4e09a}{controlledUnitaryLocal}}(multiQubit, controlQubit, targetQubit, u);
418     \} \textcolor{keywordflow}{else} \{
419         \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
420         rankIsUpper = \mbox{\hyperlink{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}}(multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
421         \mbox{\hyperlink{QuEST__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}{getRotAngleFromUnitaryMatrix}}(rankIsUpper, &rot1, &rot2, u);
422         pairRank = \mbox{\hyperlink{QuEST__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}}(rankIsUpper, multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
423         \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
424         \textcolor{comment}{// get corresponding values from my pair}
425         \mbox{\hyperlink{QuEST__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}}(multiQubit, pairRank);
426 
427         \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. send values to
       controlledUnitaryDistributed}
428         \textcolor{comment}{// in the correct order}
429         \textcolor{keywordflow}{if} (rankIsUpper)\{
430             \mbox{\hyperlink{QuEST_8c_a642093063a1f889f61a1311f6d6f2d3f}{controlledUnitaryDistributed}}(multiQubit,controlQubit,targetQubit,
      rot1,rot2,
431                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}, \textcolor{comment}{//upper}
432                     multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}, \textcolor{comment}{//lower}
433                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}); \textcolor{comment}{//output}
434         \} \textcolor{keywordflow}{else} \{
435             \mbox{\hyperlink{QuEST_8c_a642093063a1f889f61a1311f6d6f2d3f}{controlledUnitaryDistributed}}(multiQubit,controlQubit,targetQubit,
      rot1,rot2,
436                     multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}, \textcolor{comment}{//upper}
437                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}, \textcolor{comment}{//lower}
438                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}); \textcolor{comment}{//output}
439         \}
440     \}
441 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}\label{QuEST__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!exchange\+State\+Vectors@{exchange\+State\+Vectors}}
\index{exchange\+State\+Vectors@{exchange\+State\+Vectors}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{exchange\+State\+Vectors()}{exchangeStateVectors()}}
{\footnotesize\ttfamily void exchange\+State\+Vectors (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{int}]{pair\+Rank }\end{DoxyParamCaption})}



Definition at line 244 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Complex\+Array\+::imag, M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks, Multi\+Qubit\+::pair\+State\+Vec, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by compact\+Unitary(), controlled\+Compact\+Unitary(), controlled\+Not(), controlled\+Unitary(), hadamard(), multi\+Controlled\+Unitary(), sigma\+X(), sigma\+Y(), and unitary().


\begin{DoxyCode}
244                                                               \{
245     \textcolor{comment}{// MPI send/receive vars}
246     \textcolor{keywordtype}{int} TAG=100;
247     MPI\_Status status;
248 
249     \textcolor{comment}{// Multiple messages are required as MPI uses int rather than long long int for count}
250     \textcolor{comment}{// For openmpi, messages are further restricted to 2GB in size -- do this for all cases}
251     \textcolor{comment}{// to be safe}
252     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} maxMessageCount = 1LL<<29;
253     \textcolor{keywordflow}{if} (\textcolor{keyword}{sizeof}(\mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}})==8) maxMessageCount = (1LL<<28);
254     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\textcolor{keyword}{sizeof}(\mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}})==16) maxMessageCount = (1LL<<27);
255 
256     \textcolor{keywordflow}{if} (multiQubit.\mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}<maxMessageCount) maxMessageCount = 
      multiQubit.\mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}};
257     \textcolor{keywordtype}{int} numMessages = multiQubit.\mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}/maxMessageCount;
258     \textcolor{keywordtype}{int} i;
259     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} offset;
260     \textcolor{comment}{// send my state vector to pairRank's multiQubit.pairStateVec}
261     \textcolor{comment}{// receive pairRank's state vector into multiQubit.pairStateVec}
262     \textcolor{keywordflow}{for} (i=0; i<numMessages; i++)\{
263         offset = i*maxMessageCount;
264         MPI\_Sendrecv(&multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}.\mbox{\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}}[offset], maxMessageCount, 
      \mbox{\hyperlink{QuEST__precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}}, pairRank, TAG,
265                 &multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}.\mbox{\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}}[offset], maxMessageCount, 
      \mbox{\hyperlink{QuEST__precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}},
266                 pairRank, TAG, MPI\_COMM\_WORLD, &status);
267         \textcolor{comment}{//printf("rank: %d err: %d\(\backslash\)n", multiQubit.rank, err);}
268         MPI\_Sendrecv(&multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}.\mbox{\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}}[offset], maxMessageCount, 
      \mbox{\hyperlink{QuEST__precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}}, pairRank, TAG,
269                 &multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}.\mbox{\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}}[offset], maxMessageCount, 
      \mbox{\hyperlink{QuEST__precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}},
270                 pairRank, TAG, MPI\_COMM\_WORLD, &status);
271     \}
272 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_ae5f9019826f35e8b51b1716cfe397b45}\label{QuEST__env__mpi_8c_ae5f9019826f35e8b51b1716cfe397b45}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!exit\+With\+Error@{exit\+With\+Error}}
\index{exit\+With\+Error@{exit\+With\+Error}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{exit\+With\+Error()}{exitWithError()}}
{\footnotesize\ttfamily void exit\+With\+Error (\begin{DoxyParamCaption}\item[{int}]{error\+Code,  }\item[{const char $\ast$}]{func }\end{DoxyParamCaption})}



Definition at line 754 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References error\+Codes.



Referenced by Qu\+E\+S\+T\+Assert().


\begin{DoxyCode}
754                                                    \{
755     printf(\textcolor{stringliteral}{"!!!\(\backslash\)n"});
756     printf(\textcolor{stringliteral}{"QuEST Error in function %s: %s\(\backslash\)n"}, func, \mbox{\hyperlink{QuEST_8c_aac1637696885c75b73a1ecf381cea713}{errorCodes}}[errorCode]);
757     printf(\textcolor{stringliteral}{"!!!\(\backslash\)n"});
758     printf(\textcolor{stringliteral}{"exiting..\(\backslash\)n"});
759     MPI\_Abort(MPI\_COMM\_WORLD, errorCode);
760 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}\label{QuEST__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!find\+Probability\+Of\+Outcome@{find\+Probability\+Of\+Outcome}}
\index{find\+Probability\+Of\+Outcome@{find\+Probability\+Of\+Outcome}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{find\+Probability\+Of\+Outcome()}{findProbabilityOfOutcome()}}
{\footnotesize\ttfamily \mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}} find\+Probability\+Of\+Outcome (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{const int}]{measure\+Qubit,  }\item[{int}]{outcome }\end{DoxyParamCaption})}



Gives the probability of a specified qubit being measured in the given outcome (0 or 1). 

This performs no actual measurement and does not change the state of the qubits.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to study \\
\hline
\mbox{\tt in}  & {\em outcome} & for which to find the probability of the qubit being measured in \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measure\+Qubit being measured in the given outcome 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily measure\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}), or if {\ttfamily outcome} is not in \{0, 1\}. \\
\hline
\end{DoxyExceptions}


Definition at line 661 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, find\+Probability\+Of\+Zero\+Distributed(), find\+Probability\+Of\+Zero\+Local(), half\+Matrix\+Block\+Fits\+In\+Chunk(), is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero(), M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks, Multi\+Qubit\+::num\+Qubits, Qu\+E\+S\+T\+Assert(), and R\+E\+AL.



Referenced by collapse\+To\+Outcome(), and measure\+With\+Stats().


\begin{DoxyCode}
662 \{
663     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(measureQubit >= 0 && measureQubit < multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 2, \_\_func\_\_);
664 
665     \mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}} stateProb=0, totalStateProb=0;
666     \textcolor{keywordtype}{int} skipValuesWithinRank = \mbox{\hyperlink{QuEST__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}}(multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, measureQubit);
667     \textcolor{keywordflow}{if} (skipValuesWithinRank) \{
668         stateProb = \mbox{\hyperlink{QuEST_8c_a7c02cd0e1b4eac19771a0525f023249e}{findProbabilityOfZeroLocal}}(multiQubit, measureQubit);
669     \} \textcolor{keywordflow}{else} \{
670         \textcolor{keywordflow}{if} (!\mbox{\hyperlink{QuEST__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{isChunkToSkipInFindPZero}}(multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, measureQubit))\{
671             stateProb = \mbox{\hyperlink{QuEST_8c_a9ac9bb717a889f09d307eda9f0b65957}{findProbabilityOfZeroDistributed}}(multiQubit, 
      measureQubit);
672         \} \textcolor{keywordflow}{else} stateProb = 0;
673     \}
674     MPI\_Allreduce(&stateProb, &totalStateProb, 1, \mbox{\hyperlink{QuEST__precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}}, MPI\_SUM, MPI\_COMM\_WORLD);
675     \textcolor{keywordflow}{if} (outcome==1) totalStateProb = 1.0 - totalStateProb;
676     \textcolor{keywordflow}{return} totalStateProb;
677 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}\label{QuEST__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!get\+Chunk\+Id\+From\+Index@{get\+Chunk\+Id\+From\+Index}}
\index{get\+Chunk\+Id\+From\+Index@{get\+Chunk\+Id\+From\+Index}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{get\+Chunk\+Id\+From\+Index()}{getChunkIdFromIndex()}}
{\footnotesize\ttfamily int get\+Chunk\+Id\+From\+Index (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{long long int}]{index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 90 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks.



Referenced by get\+Imag\+Amp\+El(), and get\+Real\+Amp\+El().


\begin{DoxyCode}
90                                                                    \{
91     \textcolor{keywordflow}{return} index/multiQubit.\mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}; \textcolor{comment}{// this is numAmpsPerChunk}
92 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}\label{QuEST__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!get\+Chunk\+Pair\+Id@{get\+Chunk\+Pair\+Id}}
\index{get\+Chunk\+Pair\+Id@{get\+Chunk\+Pair\+Id}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{get\+Chunk\+Pair\+Id()}{getChunkPairId()}}
{\footnotesize\ttfamily static int get\+Chunk\+Pair\+Id (\begin{DoxyParamCaption}\item[{int}]{chunk\+Is\+Upper,  }\item[{int}]{chunk\+Id,  }\item[{long long int}]{chunk\+Size,  }\item[{int}]{target\+Qubit }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



get position of corresponding chunk, holding values required to update values in my chunk (with chunk\+Id) when rotating target\+Qubit. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Is\+Upper} & 1\+: chunk is in upper half of block, 0\+: chunk is in lower half \\
\hline
\mbox{\tt in}  & {\em chunk\+Id} & id of chunk in state vector \\
\hline
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit being rotated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
chunk\+Id of chunk required to rotate target\+Qubit 
\end{DoxyReturn}


Definition at line 219 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References chunk\+Is\+Upper().



Referenced by compact\+Unitary(), controlled\+Compact\+Unitary(), controlled\+Not(), controlled\+Unitary(), hadamard(), multi\+Controlled\+Unitary(), sigma\+X(), sigma\+Y(), and unitary().


\begin{DoxyCode}
220 \{
221     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (targetQubit);
222     \textcolor{keywordtype}{int} chunksPerHalfBlock = sizeHalfBlock/chunkSize;
223     \textcolor{keywordflow}{if} (\mbox{\hyperlink{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}})\{
224         \textcolor{keywordflow}{return} chunkId + chunksPerHalfBlock;
225     \} \textcolor{keywordflow}{else} \{
226         \textcolor{keywordflow}{return} chunkId - chunksPerHalfBlock;
227     \}
228 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}\label{QuEST__env__mpi_8c_a3615f76fd5f57008d9b74bbd10533dd0}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!get\+Imag\+Amp\+El@{get\+Imag\+Amp\+El}}
\index{get\+Imag\+Amp\+El@{get\+Imag\+Amp\+El}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{get\+Imag\+Amp\+El()}{getImagAmpEl()}}
{\footnotesize\ttfamily \mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}} get\+Imag\+Amp\+El (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{long long int}]{index }\end{DoxyParamCaption})}



Get the imaginary component of the complex probability amplitude at an index in the state vector. 

For debugging purposes.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing a set of qubits \\
\hline
\mbox{\tt in}  & {\em index} & index in state vector of probability amplitudes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
imaginary component at that index 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily index} is outside \mbox{[}0, $2^{N}$) where $N = $ {\ttfamily multi\+Qubit.\+num\+Qubits} \\
\hline
\end{DoxyExceptions}


Definition at line 104 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, get\+Chunk\+Id\+From\+Index(), Complex\+Array\+::imag, M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by get\+Prob\+El().


\begin{DoxyCode}
104                                                              \{
105     \textcolor{keywordtype}{int} chunkId = \mbox{\hyperlink{QuEST__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{getChunkIdFromIndex}}(multiQubit, index);
106     \mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}} el; 
107     \textcolor{keywordflow}{if} (multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}==chunkId)\{
108         el = multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}.\mbox{\hyperlink{structComplexArray_a79dde47c7ae530c79cebfdf57b225968}{imag}}[index-chunkId*multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}];
109     \}
110     MPI\_Bcast(&el, 1, \mbox{\hyperlink{QuEST__precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}}, chunkId, MPI\_COMM\_WORLD);
111     \textcolor{keywordflow}{return} el; 
112 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}\label{QuEST__env__mpi_8c_a317b786f577fa6bc136ea7f0ee7330a7}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!get\+Real\+Amp\+El@{get\+Real\+Amp\+El}}
\index{get\+Real\+Amp\+El@{get\+Real\+Amp\+El}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{get\+Real\+Amp\+El()}{getRealAmpEl()}}
{\footnotesize\ttfamily \mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}} get\+Real\+Amp\+El (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{long long int}]{index }\end{DoxyParamCaption})}



Get the real component of the complex probability amplitude at an index in the state vector. 

For debugging purposes.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em multi\+Qubit} & object representing a set of qubits \\
\hline
\mbox{\tt in}  & {\em index} & index in state vector of probability amplitudes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
real component at that index 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily index} is outside \mbox{[}0, $2^{N}$) where $N = $ {\ttfamily multi\+Qubit.\+num\+Qubits} \\
\hline
\end{DoxyExceptions}


Definition at line 94 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, get\+Chunk\+Id\+From\+Index(), M\+P\+I\+\_\+\+Qu\+E\+S\+T\+\_\+\+R\+E\+AL, Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks, Complex\+Array\+::real, R\+E\+AL, and Multi\+Qubit\+::state\+Vec.



Referenced by get\+Prob\+El().


\begin{DoxyCode}
94                                                              \{
95     \textcolor{keywordtype}{int} chunkId = \mbox{\hyperlink{QuEST__env__mpi_8c_a8605e6a6295174cb4661156eaa709ec4}{getChunkIdFromIndex}}(multiQubit, index);
96     \mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}} el; 
97     \textcolor{keywordflow}{if} (multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}==chunkId)\{
98         el = multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}.\mbox{\hyperlink{structComplexArray_a4195cac6c784ea1b6271f1c7dba1548a}{real}}[index-chunkId*multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}];
99     \}
100     MPI\_Bcast(&el, 1, \mbox{\hyperlink{QuEST__precision_8h_a750ad290949ef7dc4afdfbd8231a5057}{MPI\_QuEST\_REAL}}, chunkId, MPI\_COMM\_WORLD);
101     \textcolor{keywordflow}{return} el; 
102 \} 
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}\label{QuEST__env__mpi_8c_adb4b0373425b282abed27742d0ce0872}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!get\+Rot\+Angle@{get\+Rot\+Angle}}
\index{get\+Rot\+Angle@{get\+Rot\+Angle}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{get\+Rot\+Angle()}{getRotAngle()}}
{\footnotesize\ttfamily static void get\+Rot\+Angle (\begin{DoxyParamCaption}\item[{int}]{chunk\+Is\+Upper,  }\item[{\mbox{\hyperlink{structComplex}{Complex}} $\ast$}]{rot1,  }\item[{\mbox{\hyperlink{structComplex}{Complex}} $\ast$}]{rot2,  }\item[{\mbox{\hyperlink{structComplex}{Complex}}}]{alpha,  }\item[{\mbox{\hyperlink{structComplex}{Complex}}}]{beta }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Get rotation values for a given chunk. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Is\+Upper} & 1\+: chunk is in upper half of block, 0\+: chunk is in lower half\\
\hline
\mbox{\tt out}  & {\em rot1,rot2} & rotation values to use, allocated for upper/lower such that \begin{DoxyVerb}stateUpper = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 or \begin{DoxyVerb}stateLower = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em alpha,beta} & initial rotation values \\
\hline
\end{DoxyParams}


Definition at line 174 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References chunk\+Is\+Upper(), Complex\+::imag, and Complex\+::real.



Referenced by compact\+Unitary(), and controlled\+Compact\+Unitary().


\begin{DoxyCode}
175 \{
176     \textcolor{keywordflow}{if} (\mbox{\hyperlink{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}})\{
177         *rot1=alpha;
178         rot2->\mbox{\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}}=-beta.\mbox{\hyperlink{structComplex_a479ad939835457595fcca3ca55c06283}{real}};
179         rot2->\mbox{\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}}=-beta.\mbox{\hyperlink{structComplex_a1151948284b21c0052f203f23ab931d9}{imag}};
180     \} \textcolor{keywordflow}{else} \{
181         *rot1=beta;
182         *rot2=alpha;
183     \}
184 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}\label{QuEST__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!get\+Rot\+Angle\+From\+Unitary\+Matrix@{get\+Rot\+Angle\+From\+Unitary\+Matrix}}
\index{get\+Rot\+Angle\+From\+Unitary\+Matrix@{get\+Rot\+Angle\+From\+Unitary\+Matrix}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{get\+Rot\+Angle\+From\+Unitary\+Matrix()}{getRotAngleFromUnitaryMatrix()}}
{\footnotesize\ttfamily static void get\+Rot\+Angle\+From\+Unitary\+Matrix (\begin{DoxyParamCaption}\item[{int}]{chunk\+Is\+Upper,  }\item[{\mbox{\hyperlink{structComplex}{Complex}} $\ast$}]{rot1,  }\item[{\mbox{\hyperlink{structComplex}{Complex}} $\ast$}]{rot2,  }\item[{\mbox{\hyperlink{structComplexMatrix2}{Complex\+Matrix2}}}]{u }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Get rotation values for a given chunk given a unitary matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Is\+Upper} & 1\+: chunk is in upper half of block, 0\+: chunk is in lower half\\
\hline
\mbox{\tt out}  & {\em rot1,rot2} & rotation values to use, allocated for upper/lower such that \begin{DoxyVerb}stateUpper = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 or \begin{DoxyVerb}stateLower = rot1 * stateUpper + conj(rot2)  * stateLower
\end{DoxyVerb}
 \\
\hline
\mbox{\tt in}  & {\em u} & unitary matrix operation \\
\hline
\end{DoxyParams}


Definition at line 199 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References chunk\+Is\+Upper(), Complex\+Matrix2\+::r0c0, Complex\+Matrix2\+::r0c1, Complex\+Matrix2\+::r1c0, and Complex\+Matrix2\+::r1c1.



Referenced by controlled\+Unitary(), multi\+Controlled\+Unitary(), and unitary().


\begin{DoxyCode}
200 \{
201     \textcolor{keywordflow}{if} (\mbox{\hyperlink{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}})\{
202         *rot1=u.\mbox{\hyperlink{structComplexMatrix2_ae72b4458233b077a636beee1892e81ff}{r0c0}};
203         *rot2=u.\mbox{\hyperlink{structComplexMatrix2_a0f3932f055a8b05cef361bce25d51172}{r0c1}};
204     \} \textcolor{keywordflow}{else} \{
205         *rot1=u.\mbox{\hyperlink{structComplexMatrix2_ab98282015ed2065e53fbc9638e2583ab}{r1c0}};
206         *rot2=u.\mbox{\hyperlink{structComplexMatrix2_a763007c3070802373549ba0350f83c8a}{r1c1}};
207     \}
208 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_aa09b5dd93de6df1384b8f2c0041749ab}\label{QuEST__env__mpi_8c_aa09b5dd93de6df1384b8f2c0041749ab}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!hadamard@{hadamard}}
\index{hadamard@{hadamard}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{hadamard()}{hadamard()}}
{\footnotesize\ttfamily void hadamard (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{const int}]{target\+Qubit }\end{DoxyParamCaption})}



Apply the single-\/qubit Hadamard gate. 

This takes $|0\rangle$ to $|+\rangle$ and $|1\rangle$ to $|-\rangle$, and is equivalent to a rotation of $\pi$ around the x-\/axis then $\pi/2$ about the y-\/axis on the Bloch-\/sphere. I.\+e. \[ \frac{1}{\sqrt{2}} \begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix} \] ~\newline
 \[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {H}; \end{tikzpicture} } \] ~\newline
 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to operate on \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily target\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}). \\
\hline
\end{DoxyExceptions}


Definition at line 604 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), hadamard\+Distributed(), hadamard\+Local(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
605 \{
606     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(targetQubit >= 0 && targetQubit < multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 1, \_\_func\_\_);
607 
608     \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block fits
       on one rank}
609     \textcolor{keywordtype}{int} useLocalDataOnly = \mbox{\hyperlink{QuEST__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}}(multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
610 
611     \textcolor{comment}{// rank's chunk is in upper half of block }
612     \textcolor{keywordtype}{int} rankIsUpper;
613     \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
614 
615     \textcolor{keywordflow}{if} (useLocalDataOnly)\{
616         \textcolor{comment}{// all values required to update state vector lie in this rank}
617         \mbox{\hyperlink{QuEST_8c_aa9f0718b4dd794a3e1b143e3b153bfc5}{hadamardLocal}}(multiQubit, targetQubit);
618     \} \textcolor{keywordflow}{else} \{
619         \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
620         rankIsUpper = \mbox{\hyperlink{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}}(multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
621         pairRank = \mbox{\hyperlink{QuEST__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}}(rankIsUpper, multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
622         \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
623         \textcolor{comment}{// get corresponding values from my pair}
624         \mbox{\hyperlink{QuEST__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}}(multiQubit, pairRank);
625         \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. send values to
       hadamardDistributed}
626         \textcolor{comment}{// in the correct order}
627         \textcolor{keywordflow}{if} (rankIsUpper)\{
628             \mbox{\hyperlink{QuEST_8c_ae6a897066979fc52d977007d959ca09d}{hadamardDistributed}}(multiQubit,targetQubit,
629                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}, \textcolor{comment}{//upper}
630                     multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}, \textcolor{comment}{//lower}
631                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}, rankIsUpper); \textcolor{comment}{//output}
632         \} \textcolor{keywordflow}{else} \{
633             \mbox{\hyperlink{QuEST_8c_ae6a897066979fc52d977007d959ca09d}{hadamardDistributed}}(multiQubit,targetQubit,
634                     multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}, \textcolor{comment}{//upper}
635                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}, \textcolor{comment}{//lower}
636                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}, rankIsUpper); \textcolor{comment}{//output}
637         \}
638     \}
639 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}\label{QuEST__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!half\+Matrix\+Block\+Fits\+In\+Chunk@{half\+Matrix\+Block\+Fits\+In\+Chunk}}
\index{half\+Matrix\+Block\+Fits\+In\+Chunk@{half\+Matrix\+Block\+Fits\+In\+Chunk}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{half\+Matrix\+Block\+Fits\+In\+Chunk()}{halfMatrixBlockFitsInChunk()}}
{\footnotesize\ttfamily static int half\+Matrix\+Block\+Fits\+In\+Chunk (\begin{DoxyParamCaption}\item[{long long int}]{chunk\+Size,  }\item[{int}]{target\+Qubit }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



return whether the current qubit rotation will use blocks that fit within a single chunk. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit being rotated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1\+: one chunk fits in one block 0\+: chunk is larger than block 
\end{DoxyReturn}


Definition at line 237 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



Referenced by collapse\+To\+Outcome(), compact\+Unitary(), controlled\+Compact\+Unitary(), controlled\+Not(), controlled\+Unitary(), find\+Probability\+Of\+Outcome(), hadamard(), measure\+With\+Stats(), multi\+Controlled\+Unitary(), phase\+Gate(), sigma\+X(), sigma\+Y(), and unitary().


\begin{DoxyCode}
238 \{
239     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (targetQubit);
240     \textcolor{keywordflow}{if} (chunkSize > sizeHalfBlock) \textcolor{keywordflow}{return} 1;
241     \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} 0;
242 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}\label{QuEST__env__mpi_8c_ad84a3ce68d1ca02b4e3f741ea45b6054}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!init\+Qu\+E\+S\+T\+Env@{init\+Qu\+E\+S\+T\+Env}}
\index{init\+Qu\+E\+S\+T\+Env@{init\+Qu\+E\+S\+T\+Env}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{init\+Qu\+E\+S\+T\+Env()}{initQuESTEnv()}}
{\footnotesize\ttfamily void init\+Qu\+E\+S\+T\+Env (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env}} $\ast$}]{env }\end{DoxyParamCaption})}



Initialize the Qu\+E\+ST environment. 

If something needs to be done to set up the execution environment, such as initializing M\+PI when running in distributed mode, it is handled here


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 35 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Qu\+E\+S\+T\+Env\+::num\+Ranks, Qu\+E\+S\+T\+Seed\+Random\+Default(), and Qu\+E\+S\+T\+Env\+::rank.


\begin{DoxyCode}
35                                 \{
36     \textcolor{comment}{// init MPI environment}
37     \textcolor{keywordtype}{int} rank, numRanks, initialized;
38     MPI\_Initialized(&initialized);
39     \textcolor{keywordflow}{if} (!initialized)\{
40         MPI\_Init(NULL, NULL);
41         MPI\_Comm\_size(MPI\_COMM\_WORLD, &numRanks);
42         MPI\_Comm\_rank(MPI\_COMM\_WORLD, &rank);
43 
44         env->\mbox{\hyperlink{structQuESTEnv_aa648bb336cf8598467cb62db00b9cee8}{rank}}=rank;
45         env->\mbox{\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks}}=numRanks;
46 
47     \} \textcolor{keywordflow}{else} printf(\textcolor{stringliteral}{"ERROR: Trying to initialize QuESTEnv multiple times. Ignoring\(\backslash\)n"});
48         
49         \mbox{\hyperlink{QuEST_8c_a30b2a5228b8a21419db8aa82fa5e3167}{QuESTSeedRandomDefault}}();
50 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}\label{QuEST__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero@{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero}}
\index{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero@{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero()}{isChunkToSkipInFindPZero()}}
{\footnotesize\ttfamily static int is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero (\begin{DoxyParamCaption}\item[{int}]{chunk\+Id,  }\item[{long long int}]{chunk\+Size,  }\item[{int}]{measure\+Qubit }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Find chunks to skip when calculating probability of qubit being zero. 

When calculating probability of a bit q being zero, sum up 2$^\wedge$q values, then skip 2$^\wedge$q values, etc. This function finds if an entire chunk is in the range of values to be skipped


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em chunk\+Id} & id of chunk in state vector \\
\hline
\mbox{\tt in}  & {\em chunk\+Size} & number of amps in chunk \\
\hline
\mbox{\tt in}  & {\em measure\+Qubi} & qubit being measured \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int -- 1\+: skip, 0\+: don\textquotesingle{}t skip 
\end{DoxyReturn}


Definition at line 652 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



Referenced by collapse\+To\+Outcome(), find\+Probability\+Of\+Outcome(), and measure\+With\+Stats().


\begin{DoxyCode}
653 \{
654     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} sizeHalfBlock = 1LL << (measureQubit);
655     \textcolor{keywordtype}{int} numChunksToSkip = sizeHalfBlock/chunkSize;
656     \textcolor{comment}{// calculate probability by summing over numChunksToSkip, then skipping numChunksToSkip, etc}
657     \textcolor{keywordtype}{int} bitToCheck = chunkId & numChunksToSkip;
658     \textcolor{keywordflow}{return} bitToCheck;
659 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_ad5774247d836267175c664cd0e451bcb}\label{QuEST__env__mpi_8c_ad5774247d836267175c664cd0e451bcb}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!measure@{measure}}
\index{measure@{measure}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{measure()}{measure()}}
{\footnotesize\ttfamily int measure (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{int}]{measure\+Qubit }\end{DoxyParamCaption})}



Measures a single qubit, collapsing it randomly to 0 or 1. 

Outcome probabilities are weighted by the state vector, which is irreversibly changed after collapse to be consistent with the outcome.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the measurement outcome, 0 or 1 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily measure\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}) \\
\hline
\end{DoxyExceptions}


Definition at line 708 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References measure\+With\+Stats(), Multi\+Qubit\+::num\+Qubits, Qu\+E\+S\+T\+Assert(), and R\+E\+AL.


\begin{DoxyCode}
708                                                     \{
709     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(measureQubit >= 0 && measureQubit < multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 2, \_\_func\_\_);
710     \mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}} stateProb; 
711     \textcolor{keywordflow}{return} \mbox{\hyperlink{QuEST__env__mpi_8c_a2ac46e470c750bf93c754e06c64b0a7a}{measureWithStats}}(multiQubit, measureQubit, &stateProb); 
712 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a2ac46e470c750bf93c754e06c64b0a7a}\label{QuEST__env__mpi_8c_a2ac46e470c750bf93c754e06c64b0a7a}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!measure\+With\+Stats@{measure\+With\+Stats}}
\index{measure\+With\+Stats@{measure\+With\+Stats}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{measure\+With\+Stats()}{measureWithStats()}}
{\footnotesize\ttfamily int measure\+With\+Stats (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{int}]{measure\+Qubit,  }\item[{\mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{R\+E\+AL}} $\ast$}]{state\+Prob }\end{DoxyParamCaption})}



Measures a single qubit, collapsing it randomly to 0 or 1, and additionally gives the probability of that outcome. 

Outcome probabilities are weighted by the state vector, which is irreversibly changed after collapse to be consistent with the outcome.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em measure\+Qubit} & qubit to measure \\
\hline
\mbox{\tt out}  & {\em state\+Prob} & a pointer to a R\+E\+AL which is set to the probability of the occurred outcome \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the measurement outcome, 0 or 1 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily measure\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}) \\
\hline
\end{DoxyExceptions}


Definition at line 714 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, collapse\+To\+Outcome\+Distributed\+Renorm(), collapse\+To\+Outcome\+Distributed\+Set\+Zero(), collapse\+To\+Outcome\+Local(), find\+Probability\+Of\+Outcome(), genrand\+\_\+real1(), half\+Matrix\+Block\+Fits\+In\+Chunk(), is\+Chunk\+To\+Skip\+In\+Find\+P\+Zero(), Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks, Multi\+Qubit\+::num\+Qubits, Qu\+E\+S\+T\+Assert(), R\+E\+AL, and R\+E\+A\+L\+\_\+\+E\+PS.



Referenced by measure().


\begin{DoxyCode}
714                                                                               \{
715     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(measureQubit >= 0 && measureQubit < multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 2, \_\_func\_\_);
716 
717     \textcolor{keywordtype}{int} outcome;
718     \textcolor{comment}{// find probability of qubit being in state 1}
719     \mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}} stateProbInternal = \mbox{\hyperlink{QuEST__env__mpi_8c_ad315c941a51bc053d39ebfa2040fd32e}{findProbabilityOfOutcome}}(multiQubit, measureQubit,
       1);
720 
721     \textcolor{comment}{// we can't collapse to a state that has a probability too close to zero}
722     \textcolor{keywordflow}{if} (stateProbInternal<\mbox{\hyperlink{QuEST__precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS}}) outcome=0;
723     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (1-stateProbInternal<\mbox{\hyperlink{QuEST__precision_8h_aebb5e6716e06431296af4d1a71744dec}{REAL\_EPS}}) outcome=1;
724     \textcolor{keywordflow}{else} \{
725         \textcolor{comment}{// ok. both P(0) and P(1) are large enough to resolve}
726         \textcolor{comment}{// generate random float on [0,1]}
727         \textcolor{keywordtype}{float} randNum = \mbox{\hyperlink{mt19937ar_8c_ac94ab75771800274ed1a2bedeca86f04}{genrand\_real1}}();
728         \textcolor{keywordflow}{if} (randNum<=stateProbInternal) outcome = 1;
729         \textcolor{keywordflow}{else} outcome = 0;
730     \} 
731     \textcolor{keywordflow}{if} (outcome==0) stateProbInternal = 1-stateProbInternal;
732 
733     \textcolor{keywordtype}{int} skipValuesWithinRank = \mbox{\hyperlink{QuEST__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}}(multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, measureQubit);
734     \textcolor{keywordflow}{if} (skipValuesWithinRank) \{
735         \mbox{\hyperlink{QuEST_8c_a01d9a8b7ff0e09ec399e158389783aa9}{collapseToOutcomeLocal}}(multiQubit, measureQubit, stateProbInternal, outcome);
736     \} \textcolor{keywordflow}{else} \{
737         \textcolor{keywordflow}{if} (!\mbox{\hyperlink{QuEST__env__mpi_8c_af0ea25f00987af4c53f17c9cca62ab41}{isChunkToSkipInFindPZero}}(multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, measureQubit))\{
738             \textcolor{comment}{// chunk has amps for q=0}
739             \textcolor{keywordflow}{if} (outcome==0) \mbox{\hyperlink{QuEST_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm}}(multiQubit
      , measureQubit, 
740                     stateProbInternal);
741             \textcolor{keywordflow}{else} \mbox{\hyperlink{QuEST_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero}}(multiQubit, 
      measureQubit);
742         \} \textcolor{keywordflow}{else} \{
743             \textcolor{comment}{// chunk has amps for q=1}
744             \textcolor{keywordflow}{if} (outcome==1) \mbox{\hyperlink{QuEST_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm}}(multiQubit
      , measureQubit, 
745                     stateProbInternal);
746             \textcolor{keywordflow}{else} \mbox{\hyperlink{QuEST_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero}}(multiQubit, 
      measureQubit);
747         \}
748     \}
749 
750     *stateProb = stateProbInternal;
751     \textcolor{keywordflow}{return} outcome;
752 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_ae395a79690283ed81106afadd7a8cd8a}\label{QuEST__env__mpi_8c_ae395a79690283ed81106afadd7a8cd8a}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!multi\+Controlled\+Unitary@{multi\+Controlled\+Unitary}}
\index{multi\+Controlled\+Unitary@{multi\+Controlled\+Unitary}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{multi\+Controlled\+Unitary()}{multiControlledUnitary()}}
{\footnotesize\ttfamily void multi\+Controlled\+Unitary (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{int $\ast$}]{control\+Qubits,  }\item[{const int}]{num\+Control\+Qubits,  }\item[{const int}]{target\+Qubit,  }\item[{\mbox{\hyperlink{structComplexMatrix2}{Complex\+Matrix2}}}]{u }\end{DoxyParamCaption})}



Apply a general multiple-\/control single-\/target unitary, which can include a global phase factor. 

Any number of control qubits can be specified, and if all have value 1, the given unitary is applied to the target qubit. This effects the many-\/qubit unitary \[ \begin{pmatrix} 1 \\ & 1 \\\ & & \ddots \\ & & & u_{00} & u_{01}\\ & & & u_{10} & u_{11} \end{pmatrix} \] on the control and target qubits. The given 2x2 Complex\+Matrix must be unitary, otherwise an error is thrown.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 3) {controls}; \node[draw=none] at (-3.5, 0) {target}; \node[draw=none] at (0, 6) {$\vdots$}; \draw (0, 5) -- (0, 4); \draw (-2, 4) -- (2, 4); \draw[fill=black] (0, 4) circle (.2); \draw (0, 4) -- (0, 2); \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 1); \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {U}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em control\+Qubits} & applies unitary if all qubits in this array equal 1 \\
\hline
\mbox{\tt in}  & {\em num\+Control\+Qubits} & number of control qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to operate on \\
\hline
\mbox{\tt in}  & {\em u} & single-\/qubit unitary matrix to apply \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily num\+Control\+Qubits} is outside \mbox{[}1, {\ttfamily multi\+Qubit.\+num\+Qubits}\mbox{]}), or if any qubit index ({\ttfamily target\+Qubit} or one in {\ttfamily control\+Qubits}) is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}\mbox{]}), or if {\ttfamily control\+Qubits} contains {\ttfamily target\+Qubit}, or if {\ttfamily u} is not unitary. \\
\hline
\end{DoxyExceptions}


Definition at line 443 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), get\+Rot\+Angle\+From\+Unitary\+Matrix(), half\+Matrix\+Block\+Fits\+In\+Chunk(), multi\+Controlled\+Unitary\+Distributed(), multi\+Controlled\+Unitary\+Local(), Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), Multi\+Qubit\+::state\+Vec, and validate\+Matrix\+Is\+Unitary().


\begin{DoxyCode}
444 \{
445     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(targetQubit >= 0 && targetQubit < multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 1, \_\_func\_\_);
446     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(numControlQubits > 0 && numControlQubits <= multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 4, \_\_func\_\_);
447     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(\mbox{\hyperlink{QuEST_8c_ae4fea133d1a8f09ff8da03038100adb2}{validateMatrixIsUnitary}}(u), 5, \_\_func\_\_);
448 
449     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} mask=0;
450     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<numControlQubits; i++) mask = mask | (1LL<<controlQubits[i]);
451     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(mask >=0 && mask <= (1LL<<multiQubit.\mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}})-1, 2, \_\_func\_\_);
452     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}((mask & (1LL<<targetQubit)) != (1LL<<targetQubit), 3, \_\_func\_\_);
453 
454     \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block fits
       on one rank}
455     \textcolor{keywordtype}{int} useLocalDataOnly = \mbox{\hyperlink{QuEST__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}}(multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
456     \mbox{\hyperlink{structComplex}{Complex}} rot1, rot2;
457 
458     \textcolor{comment}{// rank's chunk is in upper half of block }
459     \textcolor{keywordtype}{int} rankIsUpper;
460     \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
461 
462     \textcolor{keywordflow}{if} (useLocalDataOnly)\{
463         \textcolor{comment}{// all values required to update state vector lie in this rank}
464         \mbox{\hyperlink{QuEST_8c_a1309eabcba3cb97fbc3cd2e606d17766}{multiControlledUnitaryLocal}}(multiQubit, targetQubit, mask, u);
465     \} \textcolor{keywordflow}{else} \{
466         \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
467         rankIsUpper = \mbox{\hyperlink{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}}(multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
468         \mbox{\hyperlink{QuEST__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}{getRotAngleFromUnitaryMatrix}}(rankIsUpper, &rot1, &rot2, u);
469         pairRank = \mbox{\hyperlink{QuEST__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}}(rankIsUpper, multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
470         \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
471         \textcolor{comment}{// get corresponding values from my pair}
472         \mbox{\hyperlink{QuEST__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}}(multiQubit, pairRank);
473 
474         \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. send values to
       multiControlledUnitaryDistributed}
475         \textcolor{comment}{// in the correct order}
476         \textcolor{keywordflow}{if} (rankIsUpper)\{
477             \mbox{\hyperlink{QuEST_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{multiControlledUnitaryDistributed}}(multiQubit,targetQubit,mask,
      rot1,rot2,
478                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}, \textcolor{comment}{//upper}
479                     multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}, \textcolor{comment}{//lower}
480                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}); \textcolor{comment}{//output}
481         \} \textcolor{keywordflow}{else} \{
482             \mbox{\hyperlink{QuEST_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{multiControlledUnitaryDistributed}}(multiQubit,targetQubit,mask,
      rot1,rot2,
483                     multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}, \textcolor{comment}{//upper}
484                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}, \textcolor{comment}{//lower}
485                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}); \textcolor{comment}{//output}
486         \}
487     \}
488 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_aae7a8a7f1ccbddb7f76b6c52b746bb43}\label{QuEST__env__mpi_8c_aae7a8a7f1ccbddb7f76b6c52b746bb43}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!phase\+Gate@{phase\+Gate}}
\index{phase\+Gate@{phase\+Gate}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{phase\+Gate()}{phaseGate()}}
{\footnotesize\ttfamily void phase\+Gate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{const int}]{target\+Qubit,  }\item[{enum \mbox{\hyperlink{QuEST_8h_a5739021c733cecc49647956b2f7338ea}{phase\+Gate\+Type}}}]{type }\end{DoxyParamCaption})}



Definition at line 586 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks, Multi\+Qubit\+::num\+Qubits, phase\+Gate\+Distributed(), phase\+Gate\+Local(), and Qu\+E\+S\+T\+Assert().


\begin{DoxyCode}
587 \{
588     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(targetQubit >= 0 && targetQubit < multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 1, \_\_func\_\_);
589 
590     \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block fits
       on one rank}
591     \textcolor{keywordtype}{int} useLocalDataOnly = \mbox{\hyperlink{QuEST__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}}(multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
592 
593     \textcolor{comment}{// rank's chunk is in upper half of block }
594     \textcolor{keywordtype}{int} rankIsUpper;
595 
596     \textcolor{keywordflow}{if} (useLocalDataOnly)\{
597         \mbox{\hyperlink{QuEST_8c_a3a54566b73ac84c312d7da4f56ffbc3b}{phaseGateLocal}}(multiQubit, targetQubit, type);
598     \} \textcolor{keywordflow}{else} \{
599         rankIsUpper = \mbox{\hyperlink{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}}(multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
600         \textcolor{keywordflow}{if} (!rankIsUpper) \mbox{\hyperlink{QuEST_8c_af832ed00b02a0597b7fe0b714032c54a}{phaseGateDistributed}}(multiQubit, targetQubit, type);
601     \}
602 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}\label{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!Qu\+E\+S\+T\+Assert@{Qu\+E\+S\+T\+Assert}}
\index{Qu\+E\+S\+T\+Assert@{Qu\+E\+S\+T\+Assert}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{Qu\+E\+S\+T\+Assert()}{QuESTAssert()}}
{\footnotesize\ttfamily void Qu\+E\+S\+T\+Assert (\begin{DoxyParamCaption}\item[{int}]{is\+Valid,  }\item[{int}]{error\+Code,  }\item[{const char $\ast$}]{func }\end{DoxyParamCaption})}



Definition at line 762 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References exit\+With\+Error().



Referenced by collapse\+To\+Outcome(), compact\+Unitary(), controlled\+Compact\+Unitary(), controlled\+Not(), controlled\+Unitary(), find\+Probability\+Of\+Outcome(), hadamard(), measure(), measure\+With\+Stats(), multi\+Controlled\+Unitary(), phase\+Gate(), sigma\+X(), sigma\+Y(), and unitary().


\begin{DoxyCode}
762                                                               \{
763     \textcolor{keywordflow}{if} (!isValid) \mbox{\hyperlink{QuEST__env__mpi_8c_ae5f9019826f35e8b51b1716cfe397b45}{exitWithError}}(errorCode, func);
764 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}\label{QuEST__env__mpi_8c_a62da5b58d8ce84e6f4d24be1b872294e}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!report\+Node\+List@{report\+Node\+List}}
\index{report\+Node\+List@{report\+Node\+List}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{report\+Node\+List()}{reportNodeList()}}
{\footnotesize\ttfamily void report\+Node\+List (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env}}}]{env }\end{DoxyParamCaption})}



Report a list of C\+PU hostnames and the rank that is running on each if running with M\+PI enabled and an error message otherwise. 

For debugging purposes. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 84 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Qu\+E\+S\+T\+Env\+::rank.


\begin{DoxyCode}
84                                  \{
85     \textcolor{keywordtype}{char} hostName[256];
86     gethostname(hostName, 255);
87     printf(\textcolor{stringliteral}{"hostname on rank %d: %s\(\backslash\)n"}, env.\mbox{\hyperlink{structQuESTEnv_aa648bb336cf8598467cb62db00b9cee8}{rank}}, hostName);
88 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}\label{QuEST__env__mpi_8c_af8a14ae79c3fb2c0b5f6255cc37bebf9}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!report\+Qu\+E\+S\+T\+Env@{report\+Qu\+E\+S\+T\+Env}}
\index{report\+Qu\+E\+S\+T\+Env@{report\+Qu\+E\+S\+T\+Env}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{report\+Qu\+E\+S\+T\+Env()}{reportQuESTEnv()}}
{\footnotesize\ttfamily void report\+Qu\+E\+S\+T\+Env (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env}}}]{env }\end{DoxyParamCaption})}



Report information about the Qu\+E\+ST environment. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 69 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Qu\+E\+S\+T\+Env\+::num\+Ranks, Qu\+E\+S\+T\+Env\+::rank, and R\+E\+AL.


\begin{DoxyCode}
69                                  \{
70     \textcolor{keywordflow}{if} (env.\mbox{\hyperlink{structQuESTEnv_aa648bb336cf8598467cb62db00b9cee8}{rank}}==0)\{
71         printf(\textcolor{stringliteral}{"EXECUTION ENVIRONMENT:\(\backslash\)n"}); 
72         printf(\textcolor{stringliteral}{"Running distributed (MPI) version\(\backslash\)n"});
73         printf(\textcolor{stringliteral}{"Number of ranks is %d\(\backslash\)n"}, env.\mbox{\hyperlink{structQuESTEnv_af22aacd7c9905accae28484785c193b4}{numRanks}});
74 \textcolor{preprocessor}{# ifdef \_OPENMP}
75         printf(\textcolor{stringliteral}{"OpenMP enabled\(\backslash\)n"});
76         printf(\textcolor{stringliteral}{"Number of threads available is %d\(\backslash\)n"}, omp\_get\_max\_threads());
77 \textcolor{preprocessor}{# else}
78         printf(\textcolor{stringliteral}{"OpenMP disabled\(\backslash\)n"});
79 \textcolor{preprocessor}{# endif }
80         printf(\textcolor{stringliteral}{"Precision: size of REAL is %ld bytes\(\backslash\)n"}, \textcolor{keyword}{sizeof}(\mbox{\hyperlink{QuEST__precision_8h_a4b654506f18b8bfd61ad2a29a7e38c25}{REAL}}));
81     \}
82 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a86e396e06b7d527cac20ba0108872423}\label{QuEST__env__mpi_8c_a86e396e06b7d527cac20ba0108872423}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!sigmaX@{sigmaX}}
\index{sigmaX@{sigmaX}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{sigma\+X()}{sigmaX()}}
{\footnotesize\ttfamily void sigmaX (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{const int}]{target\+Qubit }\end{DoxyParamCaption})}



Apply the single-\/qubit sigma-\/X (also known as the X, Pauli-\/X, N\+OT or bit-\/flip) gate. 

This is a rotation of $\pi$ around the x-\/axis on the Bloch sphere. I.\+e. \[ \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix} \] ~\newline
 \[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (2, 0); \draw (0, 0) circle (.5); \draw (0, .5) -- (0, -.5); \end{tikzpicture} } \] ~\newline
 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to operate on \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily target\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}). \\
\hline
\end{DoxyExceptions}


Definition at line 489 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), sigma\+X\+Distributed(), sigma\+X\+Local(), and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
490 \{
491     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(targetQubit >= 0 && targetQubit < multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 1, \_\_func\_\_);
492 
493     \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block fits
       on one rank}
494     \textcolor{keywordtype}{int} useLocalDataOnly = \mbox{\hyperlink{QuEST__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}}(multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
495 
496     \textcolor{comment}{// rank's chunk is in upper half of block }
497     \textcolor{keywordtype}{int} rankIsUpper;
498     \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
499 
500     \textcolor{keywordflow}{if} (useLocalDataOnly)\{
501         \textcolor{comment}{// all values required to update state vector lie in this rank}
502         \mbox{\hyperlink{QuEST_8c_a74822fd86bb5d81766e6e8dbdcd62df1}{sigmaXLocal}}(multiQubit, targetQubit);
503     \} \textcolor{keywordflow}{else} \{
504         \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
505         rankIsUpper = \mbox{\hyperlink{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}}(multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
506         pairRank = \mbox{\hyperlink{QuEST__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}}(rankIsUpper, multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
507         \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
508         \textcolor{comment}{// get corresponding values from my pair}
509         \mbox{\hyperlink{QuEST__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}}(multiQubit, pairRank);
510         \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. sigmaX just replaces}
511         \textcolor{comment}{// this rank's values with pair values}
512         \mbox{\hyperlink{QuEST_8c_a2275fff50824fe47485890ff5a857785}{sigmaXDistributed}}(multiQubit, targetQubit,
513                 multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}, \textcolor{comment}{// in}
514                 multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}); \textcolor{comment}{// out}
515     \}
516 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a1f54d70a42403f7e1c2e2c2007332f61}\label{QuEST__env__mpi_8c_a1f54d70a42403f7e1c2e2c2007332f61}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!sigmaY@{sigmaY}}
\index{sigmaY@{sigmaY}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{sigma\+Y()}{sigmaY()}}
{\footnotesize\ttfamily void sigmaY (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{const int}]{target\+Qubit }\end{DoxyParamCaption})}



Apply the single-\/qubit sigma-\/Y (also known as the Y or Pauli-\/Y) gate. 

This is a rotation of $\pi$ around the Y-\/axis on the Bloch sphere. I.\+e. \[ \begin{pmatrix} 0 & -i \\ i & 0 \end{pmatrix} \] ~\newline
 \[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$\sigma_y$}; \end{tikzpicture} } \] ~\newline
 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to operate on \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily target\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}). \\
\hline
\end{DoxyExceptions}
fix -- put duplicate code (sigmaX, sigmaY) in seperate function 

Definition at line 555 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), sigma\+Y\+Distributed(), sigma\+Y\+Local(), and Multi\+Qubit\+::state\+Vec.


\begin{DoxyCode}
556 \{
557     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(targetQubit >= 0 && targetQubit < multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 1, \_\_func\_\_);
558 
559     \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block fits
       on one rank}
560     \textcolor{keywordtype}{int} useLocalDataOnly = \mbox{\hyperlink{QuEST__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}}(multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
561 
562     \textcolor{comment}{// rank's chunk is in upper half of block }
563     \textcolor{keywordtype}{int} rankIsUpper;
564     \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
565 
566     \textcolor{keywordflow}{if} (useLocalDataOnly)\{
567         \textcolor{comment}{// all values required to update state vector lie in this rank}
568         \mbox{\hyperlink{QuEST_8c_a81fbfaed65a742a7dfd622e17652245e}{sigmaYLocal}}(multiQubit, targetQubit);
569     \} \textcolor{keywordflow}{else} \{
571         \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
572         rankIsUpper = \mbox{\hyperlink{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}}(multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
573         pairRank = \mbox{\hyperlink{QuEST__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}}(rankIsUpper, multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
574         \textcolor{comment}{//printf("%d rank has pair rank: %d\(\backslash\)n", multiQubit.rank, pairRank);}
575         \textcolor{comment}{// get corresponding values from my pair}
576         \mbox{\hyperlink{QuEST__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}}(multiQubit, pairRank);
577         \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. sigmaX just replaces}
578         \textcolor{comment}{// this rank's values with pair values}
579         \mbox{\hyperlink{QuEST_8c_af5ef5166f00c0572354b4ac53dcf40cf}{sigmaYDistributed}}(multiQubit,targetQubit,
580                 multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}, \textcolor{comment}{// in}
581                 multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}, \textcolor{comment}{// out}
582                 rankIsUpper);
583     \}
584 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}\label{QuEST__env__mpi_8c_a8d31fe2d1ad4d01e2a1f5f6b8bc15b77}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!sync\+Qu\+E\+S\+T\+Env@{sync\+Qu\+E\+S\+T\+Env}}
\index{sync\+Qu\+E\+S\+T\+Env@{sync\+Qu\+E\+S\+T\+Env}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{sync\+Qu\+E\+S\+T\+Env()}{syncQuESTEnv()}}
{\footnotesize\ttfamily void sync\+Qu\+E\+S\+T\+Env (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structQuESTEnv}{Qu\+E\+S\+T\+Env}}}]{env }\end{DoxyParamCaption})}



Guarantees that all code up to the given point has been executed on all nodes (if running in distributed mode) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\end{DoxyParams}


Definition at line 52 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



Referenced by initialize\+State\+From\+Single\+File(), and report\+State\+To\+Screen().


\begin{DoxyCode}
52                                \{
53     MPI\_Barrier(MPI\_COMM\_WORLD);
54 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_ac7e38d768a1bd79019f88cc1e6295092}\label{QuEST__env__mpi_8c_ac7e38d768a1bd79019f88cc1e6295092}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!sync\+Qu\+E\+S\+T\+Success@{sync\+Qu\+E\+S\+T\+Success}}
\index{sync\+Qu\+E\+S\+T\+Success@{sync\+Qu\+E\+S\+T\+Success}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{sync\+Qu\+E\+S\+T\+Success()}{syncQuESTSuccess()}}
{\footnotesize\ttfamily int sync\+Qu\+E\+S\+T\+Success (\begin{DoxyParamCaption}\item[{int}]{success\+Code }\end{DoxyParamCaption})}



Performs a logical A\+ND on all success\+Codes held by all processes. 

If any one process has a zero success\+Code all processes will return a zero success code.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em env} & object representing the execution environment. A single instance is used for each program \\
\hline
\mbox{\tt in}  & {\em success\+Code} & 1 if process task succeeded, 0 if process task failed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if all processes succeeded, 0 if any one process failed 
\end{DoxyReturn}


Definition at line 56 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.


\begin{DoxyCode}
56                                      \{
57     \textcolor{keywordtype}{int} totalSuccess;
58     MPI\_Allreduce(&successCode, &totalSuccess, 1, MPI\_INT, MPI\_LAND, MPI\_COMM\_WORLD);
59     \textcolor{keywordflow}{return} totalSuccess;
60 \}
\end{DoxyCode}
\mbox{\Hypertarget{QuEST__env__mpi_8c_a7a0877e33700f6bad48adb51b7b3fb67}\label{QuEST__env__mpi_8c_a7a0877e33700f6bad48adb51b7b3fb67}} 
\index{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}!unitary@{unitary}}
\index{unitary@{unitary}!Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c@{Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c}}
\paragraph{\texorpdfstring{unitary()}{unitary()}}
{\footnotesize\ttfamily void unitary (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structMultiQubit}{Multi\+Qubit}}}]{multi\+Qubit,  }\item[{const int}]{target\+Qubit,  }\item[{\mbox{\hyperlink{structComplexMatrix2}{Complex\+Matrix2}}}]{u }\end{DoxyParamCaption})}



Apply a general single-\/qubit unitary (including a global phase factor). 

The passed 2x2 Complex\+Matrix must be unitary, otherwise an error is thrown.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {U}; \end{tikzpicture} } \]


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em multi\+Qubit} & object representing the set of all qubits \\
\hline
\mbox{\tt in}  & {\em target\+Qubit} & qubit to operate on \\
\hline
\mbox{\tt in}  & {\em u} & unitary matrix to apply \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em exit\+With\+Error} & if {\ttfamily target\+Qubit} is outside \mbox{[}0, {\ttfamily multi\+Qubit.\+num\+Qubits}), or matrix {\ttfamily u} is not unitary. \\
\hline
\end{DoxyExceptions}


Definition at line 314 of file Qu\+E\+S\+T\+\_\+env\+\_\+mpi.\+c.



References Multi\+Qubit\+::chunk\+Id, chunk\+Is\+Upper(), exchange\+State\+Vectors(), get\+Chunk\+Pair\+Id(), get\+Rot\+Angle\+From\+Unitary\+Matrix(), half\+Matrix\+Block\+Fits\+In\+Chunk(), Multi\+Qubit\+::num\+Amps\+Divided\+By\+Num\+Chunks, Multi\+Qubit\+::num\+Qubits, Multi\+Qubit\+::pair\+State\+Vec, Qu\+E\+S\+T\+Assert(), Multi\+Qubit\+::state\+Vec, unitary\+Distributed(), unitary\+Local(), and validate\+Matrix\+Is\+Unitary().


\begin{DoxyCode}
315 \{
316     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(targetQubit >= 0 && targetQubit < multiQubit.
      \mbox{\hyperlink{structMultiQubit_ab5b9795bdc6fb5855e1974dcbbaeb36f}{numQubits}}, 1, \_\_func\_\_);
317     \mbox{\hyperlink{QuEST__env__mpi_8c_a3587b9d533e633ccf1abf9ad2ce45d8d}{QuESTAssert}}(\mbox{\hyperlink{QuEST_8c_ae4fea133d1a8f09ff8da03038100adb2}{validateMatrixIsUnitary}}(u), 5, \_\_func\_\_);
318 
319     \textcolor{comment}{// flag to require memory exchange. 1: an entire block fits on one rank, 0: at most half a block fits
       on one rank}
320     \textcolor{keywordtype}{int} useLocalDataOnly = \mbox{\hyperlink{QuEST__env__mpi_8c_a4d043bb0cee54a5f94faf3ffc34a6790}{halfMatrixBlockFitsInChunk}}(multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
321     \mbox{\hyperlink{structComplex}{Complex}} rot1, rot2;
322 
323     \textcolor{comment}{// rank's chunk is in upper half of block }
324     \textcolor{keywordtype}{int} rankIsUpper;
325     \textcolor{keywordtype}{int} pairRank; \textcolor{comment}{// rank of corresponding chunk}
326 
327     \textcolor{keywordflow}{if} (useLocalDataOnly)\{
328         \textcolor{comment}{// all values required to update state vector lie in this rank}
329         \mbox{\hyperlink{QuEST_8c_ac134fb45b0a7248c5d15e16eb7139a35}{unitaryLocal}}(multiQubit, targetQubit, u);
330     \} \textcolor{keywordflow}{else} \{
331         \textcolor{comment}{// need to get corresponding chunk of state vector from other rank}
332         rankIsUpper = \mbox{\hyperlink{QuEST__env__mpi_8c_a0552889d6f57d9e0ed8b209bf426482d}{chunkIsUpper}}(multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
333         \mbox{\hyperlink{QuEST__env__mpi_8c_a5c9b2f129bdffaaba9857f6eddecbb17}{getRotAngleFromUnitaryMatrix}}(rankIsUpper, &rot1, &rot2, u);
334         pairRank = \mbox{\hyperlink{QuEST__env__mpi_8c_a7dba097f23f5d48dfdc9f3250444e2e4}{getChunkPairId}}(rankIsUpper, multiQubit.\mbox{\hyperlink{structMultiQubit_ab10c88249fa3825d6227ceec01d37e37}{chunkId}}, multiQubit.
      \mbox{\hyperlink{structMultiQubit_a04c9f5254af58e4c4a54712eb32e7082}{numAmpsDividedByNumChunks}}, targetQubit);
335         \textcolor{comment}{// get corresponding values from my pair}
336         \mbox{\hyperlink{QuEST__env__mpi_8c_a7682c9a3fd592d34ec15ba8fa172f104}{exchangeStateVectors}}(multiQubit, pairRank);
337 
338         \textcolor{comment}{// this rank's values are either in the upper of lower half of the block. }
339         \textcolor{comment}{// send values to compactUnitaryDistributed in the correct order}
340         \textcolor{keywordflow}{if} (rankIsUpper)\{
341             \mbox{\hyperlink{QuEST_8c_a2343b7240118e89aa615e2c9140b770b}{unitaryDistributed}}(multiQubit,targetQubit,rot1,rot2,
342                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}, \textcolor{comment}{//upper}
343                     multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}, \textcolor{comment}{//lower}
344                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}); \textcolor{comment}{//output}
345         \} \textcolor{keywordflow}{else} \{
346             \mbox{\hyperlink{QuEST_8c_a2343b7240118e89aa615e2c9140b770b}{unitaryDistributed}}(multiQubit,targetQubit,rot1,rot2,
347                     multiQubit.\mbox{\hyperlink{structMultiQubit_a76f7db4eab52d2b30f58f973ada809c5}{pairStateVec}}, \textcolor{comment}{//upper}
348                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}, \textcolor{comment}{//lower}
349                     multiQubit.\mbox{\hyperlink{structMultiQubit_a45483190d6b01ef6b2f98f2bec9ab94f}{stateVec}}); \textcolor{comment}{//output}
350         \}
351     \}
352 
353 
354 \}
\end{DoxyCode}
