\hypertarget{qubits_8c}{
\subsection{qubits.c File Reference}
\label{qubits_8c}\index{qubits.c@{qubits.c}}
}


The core of the QuEST Library.  
{\ttfamily \#include $<$math.h$>$}\par
{\ttfamily \#include $<$stdio.h$>$}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$assert.h$>$}\par
{\ttfamily \#include \char`\"{}precision.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}qubits.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}qubits\_\-internal.h\char`\"{}}\par
{\ttfamily \#include $<$omp.h$>$}\par
\subsubsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{DEBUG}~0
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{qubits_8c_a100463f6ec212c76a5fad99579000505}{extractBit} (const int locationOfBitFromRight, const long long int theEncodedNumber)
\begin{DoxyCompactList}\small\item\em Get the value of the bit at a particular index in a number. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a9c02591bc64c2918503afa231d90d83f}{createMultiQubit} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit, int numQubits, \hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Create a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}{destroyMultiQubit} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, \hyperlink{structQuESTEnv}{QuESTEnv} env)
\begin{DoxyCompactList}\small\item\em Deallocate a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}{reportState} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Print the current state vector of probability amplitudes for a set of qubits to file. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a842d6884e063a5865a2232cba56b65ac}{reportStateToScreen} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, \hyperlink{structQuESTEnv}{QuESTEnv} env, int reportRank)
\begin{DoxyCompactList}\small\item\em Print the current state vector of probability amplitudes for a set of qubits to standard out. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}{reportMultiQubitParams} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit)
\begin{DoxyCompactList}\small\item\em Report metainformation about a set of qubits: number of qubits, number of probability amplitudes. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a8f10aabf9f607f19093aee54630caa21}{getEnvironmentString} (\hyperlink{structQuESTEnv}{QuESTEnv} env, \hyperlink{structMultiQubit}{MultiQubit} multiQubit, char str\mbox{[}200\mbox{]})
\item 
void \hyperlink{qubits_8c_acb5b2eff794339090004d29f02a70d9a}{initStateZero} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit)
\begin{DoxyCompactList}\small\item\em Initialise a set of $ N $ qubits to the classical zero state $ {| 0 \rangle}^{\otimes N} $. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}{initStatePlus} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit)
\begin{DoxyCompactList}\small\item\em Initialise a set of $ N $ qubits to the plus state $ {| + \rangle}^{\otimes N} = \frac{1}{\sqrt{2^N}} (| 0 \rangle + | 1 \rangle)^{\otimes N} $. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a7169fd0442cbc3418f3fac4d13363ca2}{initStateOfSingleQubit} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit, int qubitId, int outcome)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes such that one qubit is set to 'outcome' and all other qubits are in an equal superposition of zero and one. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}{initStateDebug} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit)
\begin{DoxyCompactList}\small\item\em Initialise the state vector of probability amplitudes to an (unphysical) state with each component of each probability amplitude a unique floating point value. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a433876ee9f3bcc54af346300f571fc3c}{initializeStateFromSingleFile} (\hyperlink{structMultiQubit}{MultiQubit} $\ast$multiQubit, char filename\mbox{[}200\mbox{]}, \hyperlink{structQuESTEnv}{QuESTEnv} env)
\item 
int \hyperlink{qubits_8c_a793584932ae384c82e7e42db7d35d18d}{compareStates} (\hyperlink{structMultiQubit}{MultiQubit} mq1, \hyperlink{structMultiQubit}{MultiQubit} mq2, REAL precision)
\item 
int \hyperlink{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}{validateMatrixIsUnitary} (\hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
int \hyperlink{qubits_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}{validateAlphaBeta} (\hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
int \hyperlink{qubits_8c_a71c14976f63cfcda70026fa20ee531fe}{validateUnitVector} (REAL ux, REAL uy, REAL uz)
\item 
void \hyperlink{qubits_8c_a7fadb225fc385db789e844c87fcba9e1}{rotateAroundAxis} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle, \hyperlink{structVector}{Vector} unitAxis)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around a given vector on the Bloch-\/sphere. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a6cc7fa705a2f2e6b486b49c5589d5df5}{rotateX} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around the X-\/axis of the Bloch-\/sphere. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ace0d3592d38a990e81a434c4e9681500}{rotateY} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around the Y-\/axis of the Bloch-\/sphere. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_abd621412ad30c1b034f4ce153c4afe10}{rotateZ} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int rotQubit, REAL angle)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by a given angle around the Z-\/axis of the Bloch-\/sphere (also known as a phase shift gate). \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a9cee2d8716667a3318420a3b672f5b92}{compactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits_8c_ac134fb45b0a7248c5d15e16eb7139a35}{unitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits_8c_a20ee1878a63ae6112e8845f4a8787592}{compactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a2343b7240118e89aa615e2c9140b770b}{unitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_afc77657651d52c47403b44b923a098a8}{controlledCompactUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} alpha, \hyperlink{structComplex}{Complex} beta)
\item 
void \hyperlink{qubits_8c_a1309eabcba3cb97fbc3cd2e606d17766}{multiControlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits_8c_a8a4afcff70195a306c082b8ed8d4e09a}{controlledUnitaryLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexMatrix2}{ComplexMatrix2} u)
\item 
void \hyperlink{qubits_8c_a717855e835e3161e08c18cdc15325d27}{controlledCompactUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a642093063a1f889f61a1311f6d6f2d3f}{controlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{multiControlledUnitaryDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, long long int mask, \hyperlink{structComplex}{Complex} rot1, \hyperlink{structComplex}{Complex} rot2, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a74822fd86bb5d81766e6e8dbdcd62df1}{sigmaXLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits_8c_a2275fff50824fe47485890ff5a857785}{sigmaXDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_ad357a43e80e3baf013975b1b70942f4c}{controlledNotLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit)
\item 
void \hyperlink{qubits_8c_a05875a70b539a3efb28d027823403f34}{controlledNotDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int controlQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,1\},\{1,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a81fbfaed65a742a7dfd622e17652245e}{sigmaYLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits_8c_af5ef5166f00c0572354b4ac53dcf40cf}{sigmaYDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecIn, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_aa9f0718b4dd794a3e1b143e3b153bfc5}{hadamardLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\item 
void \hyperlink{qubits_8c_ae6a897066979fc52d977007d959ca09d}{hadamardDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, \hyperlink{structComplexArray}{ComplexArray} stateVecUp, \hyperlink{structComplexArray}{ComplexArray} stateVecLo, \hyperlink{structComplexArray}{ComplexArray} stateVecOut, int updateUpper)
\begin{DoxyCompactList}\small\item\em Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a3a54566b73ac84c312d7da4f56ffbc3b}{phaseGateLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits_8c_af832ed00b02a0597b7fe0b714032c54a}{phaseGateDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit, enum \hyperlink{qubits_8h_a5739021c733cecc49647956b2f7338ea}{phaseGateType} type)
\item 
void \hyperlink{qubits_8c_aebaab86326779de55d335cfea3efde8f}{sigmaZ} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit sigma-\/Z (also known as the Z, Pauli-\/Z or phase-\/flip) gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_adda6c47876a7676488ed0565a19eaa65}{sGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit S gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_af764ea63a2e870098f4e1ce08562942e}{tGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int targetQubit)
\begin{DoxyCompactList}\small\item\em Apply the single-\/qubit T gate. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}{findProbabilityOfZeroLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}{findProbabilityOfZeroDistributed} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a11a96159191cbf1b01a1080e7f045aac}{controlledPhaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int idQubit1, const int idQubit2)
\begin{DoxyCompactList}\small\item\em Apply the (two-\/qubit) controlled phase gate, also known as the controlled sigmaZ gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_afc1835c6b43b6e59ce7df7b13f274fc7}{multiControlledPhaseGate} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int $\ast$controlQubits, int numControlQubits)
\begin{DoxyCompactList}\small\item\em Apply the multiple-\/qubit controlled phase gate, also known as the multiple-\/qubit controlled sigmaZ gate. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a01d9a8b7ff0e09ec399e158389783aa9}{collapseToOutcomeLocal} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, int measureQubit, REAL totalProbability, int outcome)
\begin{DoxyCompactList}\small\item\em Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{collapseToOutcomeDistributedRenorm} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit, const REAL totalProbability)
\begin{DoxyCompactList}\small\item\em Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. \item\end{DoxyCompactList}\item 
void \hyperlink{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{collapseToOutcomeDistributedSetZero} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, const int measureQubit)
\begin{DoxyCompactList}\small\item\em Set all amplitudes in one chunk to 0. \item\end{DoxyCompactList}\item 
REAL \hyperlink{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}{getProbEl} (\hyperlink{structMultiQubit}{MultiQubit} multiQubit, long long int index)
\begin{DoxyCompactList}\small\item\em Get the probability of the state at an index in the full state vector. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \hyperlink{qubits_8c_aac1637696885c75b73a1ecf381cea713}{errorCodes} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
The core of the QuEST Library. 

Definition in file \hyperlink{qubits_8c_source}{qubits.c}.

\subsubsection{Define Documentation}
\hypertarget{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}{
\index{qubits.c@{qubits.c}!DEBUG@{DEBUG}}
\index{DEBUG@{DEBUG}!qubits.c@{qubits.c}}
\paragraph[{DEBUG}]{\setlength{\rightskip}{0pt plus 5cm}\#define DEBUG~0}\hfill}
\label{qubits_8c_ad72dbcf6d0153db1b8d8a58001feed83}


Definition at line 15 of file qubits.c.

Referenced by calcTotalProbability(), exchangeStateVectors(), findProbabilityOfZeroLocal(), initQuESTEnv(), initStateOfSingleQubit(), initStatePlus(), and initStateZero().

\subsubsection{Function Documentation}
\hypertarget{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}{
\index{qubits.c@{qubits.c}!collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}}
\index{collapseToOutcomeDistributedRenorm@{collapseToOutcomeDistributedRenorm}!qubits.c@{qubits.c}}
\paragraph[{collapseToOutcomeDistributedRenorm}]{\setlength{\rightskip}{0pt plus 5cm}REAL collapseToOutcomeDistributedRenorm ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit}, \/  const REAL {\em totalProbability})}\hfill}
\label{qubits_8c_a7a1f63ec3c42d9ad72f1f01c14a885db}


Renormalise parts of the state vector where measureQubit=0 or 1, based on the total probability of that qubit being in state 0 or 1. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that the value 'outcome' has been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles the renormalisation.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being zero \end{DoxyParams}


Definition at line 1872 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1873 {
1874         // ----- temp variables
1875         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1876         long long int numTasks=multiQubit.numAmps;
1877         // (good for shared memory parallelism)
1878 
1879         REAL renorm=1/sqrt(totalProbability);
1880         
1881         REAL *stateVecReal = multiQubit.stateVec.real;
1882         REAL *stateVecImag = multiQubit.stateVec.imag;
1883 
1884 # ifdef _OPENMP
1885 # pragma omp parallel \
1886         shared    (numTasks,stateVecReal,stateVecImag) \
1887         private   (thisTask)
1888 # endif
1889         {
1890 # ifdef _OPENMP
1891                 # pragma omp for schedule  (static)
1892 # endif
1893                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1894                         // summation -- simple implementation
1895                         stateVecReal[thisTask] = stateVecReal[thisTask]*renorm;
1896                         stateVecImag[thisTask] = stateVecImag[thisTask]*renorm;
1897                 }
1898         }
1899         return totalProbability;
1900 }
\end{DoxyCode}
\hypertarget{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}{
\index{qubits.c@{qubits.c}!collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}}
\index{collapseToOutcomeDistributedSetZero@{collapseToOutcomeDistributedSetZero}!qubits.c@{qubits.c}}
\paragraph[{collapseToOutcomeDistributedSetZero}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeDistributedSetZero ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits_8c_a78908fe8e75a21fd4f7fa7dff05d6be1}


Set all amplitudes in one chunk to 0. Measure in Zero performs an irreversible change to the state vector: it updates the vector according to the event that a zero have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1. In the distributed version, one block (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) is spread over multiple chunks, meaning that each chunks performs only renormalisation or only setting amplitudes to 0. This function handles setting amplitudes to 0.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}


Definition at line 1914 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1915 {
1916         // ----- temp variables
1917         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1918         long long int numTasks=multiQubit.numAmps;
1919         // (good for shared memory parallelism)
1920 
1921         // ---------------------------------------------------------------- //
1922         //            find probability                                      //
1923         // ---------------------------------------------------------------- //
1924 
1925         REAL *stateVecReal = multiQubit.stateVec.real;
1926         REAL *stateVecImag = multiQubit.stateVec.imag;
1927 
1928 # ifdef _OPENMP
1929 # pragma omp parallel \
1930         shared    (numTasks,stateVecReal,stateVecImag) \
1931         private   (thisTask)
1932 # endif
1933         {
1934 # ifdef _OPENMP
1935                 # pragma omp for schedule  (static)
1936 # endif
1937                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1938                         // summation -- simple implementation
1939                         stateVecReal[thisTask] = 0;
1940                         stateVecImag[thisTask] = 0;
1941                 }
1942         }
1943 }
\end{DoxyCode}
\hypertarget{qubits_8c_a01d9a8b7ff0e09ec399e158389783aa9}{
\index{qubits.c@{qubits.c}!collapseToOutcomeLocal@{collapseToOutcomeLocal}}
\index{collapseToOutcomeLocal@{collapseToOutcomeLocal}!qubits.c@{qubits.c}}
\paragraph[{collapseToOutcomeLocal}]{\setlength{\rightskip}{0pt plus 5cm}void collapseToOutcomeLocal ({\bf MultiQubit} {\em multiQubit}, \/  int {\em measureQubit}, \/  REAL {\em totalProbability}, \/  int {\em outcome})}\hfill}
\label{qubits_8c_a01d9a8b7ff0e09ec399e158389783aa9}


Update the state vector to be consistent with measuring measureQubit=0 if outcome=0 and measureQubit=1 if outcome=1. Performs an irreversible change to the state vector: it updates the vector according to the event that an outcome have been measured on the qubit indicated by measureQubit (where this label starts from 0, of course). It achieves this by setting all inconsistent amplitudes to 0 and then renormalising based on the total probability of measuring measureQubit=0 or 1 according to the value of outcome. In the local version, one or more blocks (with measureQubit=0 in the first half of the block and measureQubit=1 in the second half of the block) fit entirely into one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \item[\mbox{$\leftarrow$} {\em totalProbability}]probability of qubit measureQubit being either zero or one \item[\mbox{$\leftarrow$} {\em outcome}]to measure the probability of and set the state to -\/-\/ either zero or one \end{DoxyParams}


Definition at line 1790 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by collapseToOutcome(), and measureWithStats().


\begin{DoxyCode}
1791 {
1792         // ----- sizes
1793         long long int sizeBlock,                                           // siz
      e of blocks
1794         sizeHalfBlock;                                       // size of blocks ha
      lved
1795         // ----- indices
1796         long long int thisBlock,                                           // cur
      rent block
1797              index;                                               // current inde
      x for first half block
1798         // ----- measured probability
1799         REAL   renorm;                                    // probability (returne
      d) value
1800         // ----- temp variables
1801         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1802         // (good for shared memory parallelism)
1803         long long int numTasks=multiQubit.numAmps>>1;
1804 
1805         // ---------------------------------------------------------------- //
1806         //            dimensions                                            //
1807         // ---------------------------------------------------------------- //
1808         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1809         // and then the number to skip
1810         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1811         
1812         renorm=1/sqrt(totalProbability);
1813         REAL *stateVecReal = multiQubit.stateVec.real;
1814         REAL *stateVecImag = multiQubit.stateVec.imag;
1815 
1816 
1817 # ifdef _OPENMP
1818 # pragma omp parallel \
1819         default (none) \
1820         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag,re
      norm,outcome) \
1821         private   (thisTask,thisBlock,index)
1822 # endif
1823         {
1824                 if (outcome==0){
1825                         // measure qubit is 0
1826 # ifdef _OPENMP
1827                         # pragma omp for schedule  (static)
1828 # endif
1829                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1830                                 thisBlock = thisTask / sizeHalfBlock;
1831                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
1832                                 stateVecReal[index]=stateVecReal[index]*renorm;
1833                                 stateVecImag[index]=stateVecImag[index]*renorm;
1834 
1835                                 stateVecReal[index+sizeHalfBlock]=0;
1836                                 stateVecImag[index+sizeHalfBlock]=0;
1837                         }
1838                 } else {
1839                         // measure qubit is 1
1840 # ifdef _OPENMP
1841                         # pragma omp for schedule  (static)
1842 # endif
1843                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1844                                 thisBlock = thisTask / sizeHalfBlock;
1845                                 index     = thisBlock*sizeBlock + thisTask%sizeHa
      lfBlock;
1846                                 stateVecReal[index]=0;
1847                                 stateVecImag[index]=0;
1848 
1849                                 stateVecReal[index+sizeHalfBlock]=stateVecReal[in
      dex+sizeHalfBlock]*renorm;
1850                                 stateVecImag[index+sizeHalfBlock]=stateVecImag[in
      dex+sizeHalfBlock]*renorm;
1851                         }
1852                 }
1853         }
1854 
1855 }
\end{DoxyCode}
\hypertarget{qubits_8c_a20ee1878a63ae6112e8845f4a8787592}{
\index{qubits.c@{qubits.c}!compactUnitaryDistributed@{compactUnitaryDistributed}}
\index{compactUnitaryDistributed@{compactUnitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{compactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a20ee1878a63ae6112e8845f4a8787592}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta, and a subset of the state vector with upper and lower block values stored seperately. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 547 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by compactUnitary().


\begin{DoxyCode}
552 {
553 
554         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
555         long long int thisTask;  
556         const long long int numTasks=multiQubit.numAmps;
557 
558         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
559         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
560         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
561         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
562         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
563 
564 # ifdef _OPENMP
565 # pragma omp parallel \
566         default  (none) \
567         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
568                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
569         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
570 # endif
571         {
572 # ifdef _OPENMP
573                 # pragma omp for schedule (static)
574 # endif
575                 for (thisTask=0; thisTask<numTasks; thisTask++) {
576                         // store current state vector values in temp variables
577                         stateRealUp = stateVecRealUp[thisTask];
578                         stateImagUp = stateVecImagUp[thisTask];
579 
580                         stateRealLo = stateVecRealLo[thisTask];
581                         stateImagLo = stateVecImagLo[thisTask];
582 
583                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
584                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
585                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
586                 }
587         }
588 }
\end{DoxyCode}
\hypertarget{qubits_8c_a9cee2d8716667a3318420a3b672f5b92}{
\index{qubits.c@{qubits.c}!compactUnitaryLocal@{compactUnitaryLocal}}
\index{compactUnitaryLocal@{compactUnitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{compactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void compactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits_8c_a9cee2d8716667a3318420a3b672f5b92}


Definition at line 418 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by compactUnitary().


\begin{DoxyCode}
419 {
420         long long int sizeBlock, sizeHalfBlock;
421         long long int thisBlock, // current block
422              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
423 
424         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
425         long long int thisTask;         
426         const long long int numTasks=multiQubit.numAmps>>1;
427 
428         // set dimensions
429         sizeHalfBlock = 1LL << targetQubit;  
430         sizeBlock     = 2LL * sizeHalfBlock; 
431 
432         // Can't use multiQubit.stateVec as a private OMP var
433         REAL *stateVecReal = multiQubit.stateVec.real;
434         REAL *stateVecImag = multiQubit.stateVec.imag;
435         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
436         REAL betaImag=beta.imag, betaReal=beta.real;
437 
438 # ifdef _OPENMP
439 # pragma omp parallel \
440         default  (none) \
441         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
442         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
443 # endif
444         {
445 # ifdef _OPENMP
446                 # pragma omp for schedule (static)
447 # endif
448                 for (thisTask=0; thisTask<numTasks; thisTask++) {
449 
450                         thisBlock   = thisTask / sizeHalfBlock;
451                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
452                         indexLo     = indexUp + sizeHalfBlock;
453 
454                         // store current state vector values in temp variables
455                         stateRealUp = stateVecReal[indexUp];
456                         stateImagUp = stateVecImag[indexUp];
457 
458                         stateRealLo = stateVecReal[indexLo];
459                         stateImagLo = stateVecImag[indexLo];
460 
461                         // state[indexUp] = alpha * state[indexUp] - conj(beta)  
      * state[indexLo]
462                         stateVecReal[indexUp] = alphaReal*stateRealUp - alphaImag
      *stateImagUp 
463                                 - betaReal*stateRealLo - betaImag*stateImagLo;
464                         stateVecImag[indexUp] = alphaReal*stateImagUp + alphaImag
      *stateRealUp 
465                                 - betaReal*stateImagLo + betaImag*stateRealLo;
466 
467                         // state[indexLo] = beta  * state[indexUp] + conj(alpha) 
      * state[indexLo]
468                         stateVecReal[indexLo] = betaReal*stateRealUp - betaImag*s
      tateImagUp 
469                                 + alphaReal*stateRealLo + alphaImag*stateImagLo;
470                         stateVecImag[indexLo] = betaReal*stateImagUp + betaImag*s
      tateRealUp 
471                                 + alphaReal*stateImagLo - alphaImag*stateRealLo;
472                 } 
473         }
474 
475 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a793584932ae384c82e7e42db7d35d18d}{
\index{qubits.c@{qubits.c}!compareStates@{compareStates}}
\index{compareStates@{compareStates}!qubits.c@{qubits.c}}
\paragraph[{compareStates}]{\setlength{\rightskip}{0pt plus 5cm}int compareStates ({\bf MultiQubit} {\em mq1}, \/  {\bf MultiQubit} {\em mq2}, \/  REAL {\em precision})}\hfill}
\label{qubits_8c_a793584932ae384c82e7e42db7d35d18d}


Definition at line 327 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
327                                                                  {
328         REAL diff;
329         int chunkSize = mq1.numAmps;
330         for (int i=0; i<chunkSize; i++){
331                 diff = mq1.stateVec.real[i] - mq2.stateVec.real[i];
332                 if (diff<0) diff *= -1;
333                 if (diff>precision) return 0;
334                 diff = mq1.stateVec.imag[i] - mq2.stateVec.imag[i];
335                 if (diff<0) diff *= -1;
336                 if (diff>precision) return 0;
337         }
338         return 1;
339 }
\end{DoxyCode}
\hypertarget{qubits_8c_a717855e835e3161e08c18cdc15325d27}{
\index{qubits.c@{qubits.c}!controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}}
\index{controlledCompactUnitaryDistributed@{controlledCompactUnitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{controlledCompactUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a717855e835e3161e08c18cdc15325d27}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 857 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
862 {
863 
864         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
865         long long int thisTask;  
866         const long long int numTasks=multiQubit.numAmps;
867         const long long int chunkSize=multiQubit.numAmps;
868         const long long int chunkId=multiQubit.chunkId;
869 
870         int controlBit;
871 
872     REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
873         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
874         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
875         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
876         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
877 
878 # ifdef _OPENMP
879 # pragma omp parallel \
880         default  (none) \
881         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
882                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
883         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
884 # endif
885         {
886 # ifdef _OPENMP
887                 # pragma omp for schedule (static)
888 # endif
889                 for (thisTask=0; thisTask<numTasks; thisTask++) {
890                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
891                         if (controlBit){
892                                 // store current state vector values in temp vari
      ables
893                                 stateRealUp = stateVecRealUp[thisTask];
894                                 stateImagUp = stateVecImagUp[thisTask];
895 
896                                 stateRealLo = stateVecRealLo[thisTask];
897                                 stateImagLo = stateVecImagLo[thisTask];
898 
899                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
900                                 stateVecRealOut[thisTask] = rot1Real*stateRealUp 
      - rot1Imag*stateImagUp + rot2Real*stateRealLo + rot2Imag*stateImagLo;
901                                 stateVecImagOut[thisTask] = rot1Real*stateImagUp 
      + rot1Imag*stateRealUp + rot2Real*stateImagLo - rot2Imag*stateRealLo;
902                         }
903                 }
904         }
905 }
\end{DoxyCode}
\hypertarget{qubits_8c_afc77657651d52c47403b44b923a098a8}{
\index{qubits.c@{qubits.c}!controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}}
\index{controlledCompactUnitaryLocal@{controlledCompactUnitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{controlledCompactUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledCompactUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits_8c_afc77657651d52c47403b44b923a098a8}


Definition at line 648 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledCompactUnitary().


\begin{DoxyCode}
650 {
651         long long int sizeBlock, sizeHalfBlock;
652         long long int thisBlock, // current block
653              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
654 
655         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
656         long long int thisTask;         
657         const long long int numTasks=multiQubit.numAmps>>1;
658         const long long int chunkSize=multiQubit.numAmps;
659         const long long int chunkId=multiQubit.chunkId;
660 
661         int controlBit;
662 
663     // set dimensions
664         sizeHalfBlock = 1LL << targetQubit;  
665         sizeBlock     = 2LL * sizeHalfBlock; 
666 
667         // Can't use multiQubit.stateVec as a private OMP var
668         REAL *stateVecReal = multiQubit.stateVec.real;
669         REAL *stateVecImag = multiQubit.stateVec.imag;
670         REAL alphaImag=alpha.imag, alphaReal=alpha.real;
671         REAL betaImag=beta.imag, betaReal=beta.real;
672 
673 # ifdef _OPENMP
674 # pragma omp parallel \
675         default  (none) \
676         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, alphaReal,a
      lphaImag, betaReal,betaImag) \
677         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
678 # endif
679         {
680 # ifdef _OPENMP
681                 # pragma omp for schedule (static)
682 # endif
683                 for (thisTask=0; thisTask<numTasks; thisTask++) {
684 
685                         thisBlock   = thisTask / sizeHalfBlock;
686                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
687                         indexLo     = indexUp + sizeHalfBlock;
688 
689                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
690                         if (controlBit){
691                                 // store current state vector values in temp vari
      ables
692                                 stateRealUp = stateVecReal[indexUp];
693                                 stateImagUp = stateVecImag[indexUp];
694 
695                                 stateRealLo = stateVecReal[indexLo];
696                                 stateImagLo = stateVecImag[indexLo];
697 
698                                 // state[indexUp] = alpha * state[indexUp] - conj
      (beta)  * state[indexLo]
699                                 stateVecReal[indexUp] = alphaReal*stateRealUp - a
      lphaImag*stateImagUp 
700                                         - betaReal*stateRealLo - betaImag*stateIm
      agLo;
701                                 stateVecImag[indexUp] = alphaReal*stateImagUp + a
      lphaImag*stateRealUp 
702                                         - betaReal*stateImagLo + betaImag*stateRe
      alLo;
703 
704                                 // state[indexLo] = beta  * state[indexUp] + conj
      (alpha) * state[indexLo]
705                                 stateVecReal[indexLo] = betaReal*stateRealUp - be
      taImag*stateImagUp 
706                                         + alphaReal*stateRealLo + alphaImag*state
      ImagLo;
707                                 stateVecImag[indexLo] = betaReal*stateImagUp + be
      taImag*stateRealUp 
708                                         + alphaReal*stateImagLo - alphaImag*state
      RealLo;
709                         }
710                 } 
711         }
712 
713 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a05875a70b539a3efb28d027823403f34}{
\index{qubits.c@{qubits.c}!controlledNotDistributed@{controlledNotDistributed}}
\index{controlledNotDistributed@{controlledNotDistributed}!qubits.c@{qubits.c}}
\paragraph[{controlledNotDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a05875a70b539a3efb28d027823403f34}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk. Only perform the rotation for elements where controlQubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1186 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by controlledNot().


\begin{DoxyCode}
1189 {
1190 
1191         long long int thisTask;  
1192         const long long int numTasks=multiQubit.numAmps;
1193         const long long int chunkSize=multiQubit.numAmps;
1194         const long long int chunkId=multiQubit.chunkId;
1195 
1196         int controlBit;
1197 
1198         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1199         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1200 
1201 # ifdef _OPENMP
1202 # pragma omp parallel \
1203         default  (none) \
1204         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1205         private  (thisTask,controlBit)
1206 # endif
1207         {
1208 # ifdef _OPENMP
1209                 # pragma omp for schedule (static)
1210 # endif
1211                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1212                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
1213                         if (controlBit){
1214                                 stateVecRealOut[thisTask] = stateVecRealIn[thisTa
      sk];
1215                                 stateVecImagOut[thisTask] = stateVecImagIn[thisTa
      sk];
1216                         }
1217                 }
1218         }
1219 } 
\end{DoxyCode}
\hypertarget{qubits_8c_ad357a43e80e3baf013975b1b70942f4c}{
\index{qubits.c@{qubits.c}!controlledNotLocal@{controlledNotLocal}}
\index{controlledNotLocal@{controlledNotLocal}!qubits.c@{qubits.c}}
\paragraph[{controlledNotLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledNotLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_ad357a43e80e3baf013975b1b70942f4c}


Definition at line 1121 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledNot().


\begin{DoxyCode}
1122 {
1123         long long int sizeBlock, sizeHalfBlock;
1124         long long int thisBlock, // current block
1125              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1126 
1127         REAL stateRealUp,stateImagUp;
1128         long long int thisTask;         
1129         const long long int numTasks=multiQubit.numAmps>>1;
1130         const long long int chunkSize=multiQubit.numAmps;
1131         const long long int chunkId=multiQubit.chunkId;
1132 
1133         int controlBit;
1134 
1135         // set dimensions
1136         sizeHalfBlock = 1LL << targetQubit;  
1137         sizeBlock     = 2LL * sizeHalfBlock; 
1138 
1139 
1140         // Can't use multiQubit.stateVec as a private OMP var
1141         REAL *stateVecReal = multiQubit.stateVec.real;
1142         REAL *stateVecImag = multiQubit.stateVec.imag;
1143 
1144 # ifdef _OPENMP
1145 # pragma omp parallel \
1146         default  (none) \
1147         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1148         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,co
      ntrolBit) 
1149 # endif
1150         {
1151 # ifdef _OPENMP
1152                 # pragma omp for schedule (static)
1153 # endif
1154                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1155                         thisBlock   = thisTask / sizeHalfBlock;
1156                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1157                         indexLo     = indexUp + sizeHalfBlock;
1158 
1159                         controlBit = extractBit(controlQubit, indexUp+chunkId*chu
      nkSize);
1160                         if (controlBit){
1161                                 stateRealUp = stateVecReal[indexUp];
1162                                 stateImagUp = stateVecImag[indexUp];
1163 
1164                                 stateVecReal[indexUp] = stateVecReal[indexLo];
1165                                 stateVecImag[indexUp] = stateVecImag[indexLo];
1166 
1167                                 stateVecReal[indexLo] = stateRealUp;
1168                                 stateVecImag[indexLo] = stateImagUp;
1169                         }
1170                 } 
1171         }
1172 
1173 }
\end{DoxyCode}
\hypertarget{qubits_8c_a11a96159191cbf1b01a1080e7f045aac}{
\index{qubits.c@{qubits.c}!controlledPhaseGate@{controlledPhaseGate}}
\index{controlledPhaseGate@{controlledPhaseGate}!qubits.c@{qubits.c}}
\paragraph[{controlledPhaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void controlledPhaseGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em idQubit1}, \/  const int {\em idQubit2})}\hfill}
\label{qubits_8c_a11a96159191cbf1b01a1080e7f045aac}


Apply the (two-\/qubit) controlled phase gate, also known as the controlled sigmaZ gate. For each state, if both input qubits have value one, multiply the amplitude of that state by -\/1. This applies the two-\/qubit unitary: \[ \begin{pmatrix} 1 \\ & 1 \\\ & & 1 \\ & & & -1 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {idQubit1}; \node[draw=none] at (-3.5, 0) {idQubit2}; \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 0); \draw (-2,0) -- (2, 0); \draw[fill=black] (0, 0) circle (.2); \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em idQubit1,idQubit2}]qubits to operate upon \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily idQubit1} or {\ttfamily idQubit2} are outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or are equal \end{DoxyExceptions}


Definition at line 1703 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
1704 {
1705         long long int index;
1706         long long int stateVecSize;
1707         int bit1, bit2;
1708 
1709         const long long int chunkSize=multiQubit.numAmps;
1710         const long long int chunkId=multiQubit.chunkId;
1711 
1712     QuESTAssert(idQubit1 >= 0 && idQubit1 < multiQubit.numQubits, 2, __func__);
1713     QuESTAssert(idQubit2 >= 0 && idQubit2 < multiQubit.numQubits, 1, __func__);
1714     QuESTAssert(idQubit1 != idQubit2, 3, __func__);
1715 
1716         // dimension of the state vector
1717         stateVecSize = multiQubit.numAmps;
1718         REAL *stateVecReal = multiQubit.stateVec.real;
1719         REAL *stateVecImag = multiQubit.stateVec.imag;
1720 
1721 # ifdef _OPENMP
1722 # pragma omp parallel for \
1723         default  (none)                      \
1724         shared   (stateVecSize, stateVecReal,stateVecImag ) \
1725         private  (index,bit1,bit2)                     \
1726         schedule (static)
1727 # endif
1728         for (index=0; index<stateVecSize; index++) {
1729                 bit1 = extractBit (idQubit1, index+chunkId*chunkSize);
1730                 bit2 = extractBit (idQubit2, index+chunkId*chunkSize);
1731                 if (bit1 && bit2) {
1732                         stateVecReal [index] = - stateVecReal [index];
1733                         stateVecImag [index] = - stateVecImag [index];
1734                 }
1735         }
1736 }
\end{DoxyCode}
\hypertarget{qubits_8c_a642093063a1f889f61a1311f6d6f2d3f}{
\index{qubits.c@{qubits.c}!controlledUnitaryDistributed@{controlledUnitaryDistributed}}
\index{controlledUnitaryDistributed@{controlledUnitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{controlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a642093063a1f889f61a1311f6d6f2d3f}


Rotate a single qubit in the state vector of probability amplitudes, given two complex numbers alpha and beta and a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where the control qubit is one.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 920 of file qubits.c.

References MultiQubit::chunkId, extractBit(), ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by controlledUnitary().


\begin{DoxyCode}
925 {
926 
927         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
928         long long int thisTask;  
929         const long long int numTasks=multiQubit.numAmps;
930         const long long int chunkSize=multiQubit.numAmps;
931         const long long int chunkId=multiQubit.chunkId;
932 
933         int controlBit;
934 
935         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
936         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
937         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
938         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
939         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
940 
941 # ifdef _OPENMP
942 # pragma omp parallel \
943         default  (none) \
944         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
945                         rot1Real,rot1Imag, rot2Real,rot2Imag) \
946         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo,contro
      lBit)
947 # endif
948         {
949 # ifdef _OPENMP
950                 # pragma omp for schedule (static)
951 # endif
952                 for (thisTask=0; thisTask<numTasks; thisTask++) {
953                         controlBit = extractBit (controlQubit, thisTask+chunkId*c
      hunkSize);
954                         if (controlBit){
955                                 // store current state vector values in temp vari
      ables
956                                 stateRealUp = stateVecRealUp[thisTask];
957                                 stateImagUp = stateVecImagUp[thisTask];
958 
959                                 stateRealLo = stateVecRealLo[thisTask];
960                                 stateImagLo = stateVecImagLo[thisTask];
961 
962                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
963                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
964                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
965                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
966                         }
967                 }
968         }
969 }
\end{DoxyCode}
\hypertarget{qubits_8c_a8a4afcff70195a306c082b8ed8d4e09a}{
\index{qubits.c@{qubits.c}!controlledUnitaryLocal@{controlledUnitaryLocal}}
\index{controlledUnitaryLocal@{controlledUnitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{controlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void controlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em controlQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8c_a8a4afcff70195a306c082b8ed8d4e09a}


Definition at line 778 of file qubits.c.

References MultiQubit::chunkId, extractBit(), Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by controlledUnitary().


\begin{DoxyCode}
780 {
781         long long int sizeBlock, sizeHalfBlock;
782         long long int thisBlock, // current block
783              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
784 
785         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
786         long long int thisTask;         
787         const long long int numTasks=multiQubit.numAmps>>1;
788         const long long int chunkSize=multiQubit.numAmps;
789         const long long int chunkId=multiQubit.chunkId;
790 
791         int controlBit;
792 
793     // set dimensions
794         sizeHalfBlock = 1LL << targetQubit;  
795         sizeBlock     = 2LL * sizeHalfBlock; 
796 
797         // Can't use multiQubit.stateVec as a private OMP var
798         REAL *stateVecReal = multiQubit.stateVec.real;
799         REAL *stateVecImag = multiQubit.stateVec.imag;
800 
801 # ifdef _OPENMP
802 # pragma omp parallel \
803         default  (none) \
804         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
805         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo,controlBit) 
806 # endif
807         {
808 # ifdef _OPENMP
809                 # pragma omp for schedule (static)
810 # endif
811                 for (thisTask=0; thisTask<numTasks; thisTask++) {
812 
813                         thisBlock   = thisTask / sizeHalfBlock;
814                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
815                         indexLo     = indexUp + sizeHalfBlock;
816 
817                         controlBit = extractBit (controlQubit, indexUp+chunkId*ch
      unkSize);
818                         if (controlBit){
819                                 // store current state vector values in temp vari
      ables
820                                 stateRealUp = stateVecReal[indexUp];
821                                 stateImagUp = stateVecImag[indexUp];
822 
823                                 stateRealLo = stateVecReal[indexLo];
824                                 stateImagLo = stateVecImag[indexLo];
825 
826 
827                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
828                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
829                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
830                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
831                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
832 
833                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
834                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
835                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
836                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
837                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
838                         }
839                 } 
840         }
841 
842 }
\end{DoxyCode}
\hypertarget{qubits_8c_a9c02591bc64c2918503afa231d90d83f}{
\index{qubits.c@{qubits.c}!createMultiQubit@{createMultiQubit}}
\index{createMultiQubit@{createMultiQubit}!qubits.c@{qubits.c}}
\paragraph[{createMultiQubit}]{\setlength{\rightskip}{0pt plus 5cm}void createMultiQubit ({\bf MultiQubit} $\ast$ {\em multiQubit}, \/  int {\em numQubits}, \/  {\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8c_a9c02591bc64c2918503afa231d90d83f}


Create a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. Allocate space for state vector of probability amplitudes, including space for temporary values to be copied from one other chunk if running the distributed version. Define properties related to the size of the set of qubits. initStateZero should be called after this to initialise the qubits to the zero state.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]a pointer to an object representing the set of qubits \item[\mbox{$\leftarrow$} {\em numQubits}]number of qubits in the system \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily numQubits} $<$= 0 \end{DoxyExceptions}


Definition at line 36 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, MultiQubit::numQubits, QuESTEnv::numRanks, MultiQubit::pairStateVec, QuESTAssert(), QuESTEnv::rank, ComplexArray::real, and MultiQubit::stateVec.


\begin{DoxyCode}
37 {
38     QuESTAssert(numQubits>0, 9, __func__);
39         long long int numAmps = 1L << numQubits;
40         long long int numAmpsPerRank = numAmps/env.numRanks;
41 
42         multiQubit->stateVec.real = malloc(numAmpsPerRank * sizeof(*(multiQubit->
      stateVec.real)));
43         multiQubit->stateVec.imag = malloc(numAmpsPerRank * sizeof(*(multiQubit->
      stateVec.imag)));
44         if (env.numRanks>1){
45                 multiQubit->pairStateVec.real = malloc(numAmpsPerRank * sizeof(*(
      multiQubit->pairStateVec.real)));
46                 multiQubit->pairStateVec.imag = malloc(numAmpsPerRank * sizeof(*(
      multiQubit->pairStateVec.imag)));
47         }
48 
49         if ( (!(multiQubit->stateVec.real) || !(multiQubit->stateVec.imag))
50                  && numAmpsPerRank ) {
51                 printf("Could not allocate memory!");
52                 exit (EXIT_FAILURE);
53         }
54 
55         if ( env.numRanks>1 && (!(multiQubit->pairStateVec.real) || !(multiQubit-
      >pairStateVec.imag))
56                  && numAmpsPerRank ) {
57                 printf("Could not allocate memory!");
58                 exit (EXIT_FAILURE);
59         }
60 
61         multiQubit->numQubits = numQubits;
62         multiQubit->numAmps = numAmpsPerRank;
63         multiQubit->chunkId = env.rank;
64         multiQubit->numChunks = env.numRanks;
65 
66 }
\end{DoxyCode}
\hypertarget{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}{
\index{qubits.c@{qubits.c}!destroyMultiQubit@{destroyMultiQubit}}
\index{destroyMultiQubit@{destroyMultiQubit}!qubits.c@{qubits.c}}
\paragraph[{destroyMultiQubit}]{\setlength{\rightskip}{0pt plus 5cm}void destroyMultiQubit ({\bf MultiQubit} {\em multiQubit}, \/  {\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8c_ae5d6acc322314d7a3d8a2eccf00d3b19}


Deallocate a \hyperlink{structMultiQubit}{MultiQubit} object representing a set of qubits. Free memory allocated to state vector of probability amplitudes, including temporary vector for values copied from another chunk if running the distributed version.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object to be deallocated \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}


Definition at line 68 of file qubits.c.

References ComplexArray::imag, QuESTEnv::numRanks, MultiQubit::pairStateVec, ComplexArray::real, and MultiQubit::stateVec.


\begin{DoxyCode}
68                                                            {
69         free(multiQubit.stateVec.real);
70         free(multiQubit.stateVec.imag);
71         if (env.numRanks>1){
72                 free(multiQubit.pairStateVec.real);
73                 free(multiQubit.pairStateVec.imag);
74         }
75 }
\end{DoxyCode}
\hypertarget{qubits_8c_a100463f6ec212c76a5fad99579000505}{
\index{qubits.c@{qubits.c}!extractBit@{extractBit}}
\index{extractBit@{extractBit}!qubits.c@{qubits.c}}
\paragraph[{extractBit}]{\setlength{\rightskip}{0pt plus 5cm}static int extractBit (const int {\em locationOfBitFromRight}, \/  const long long int {\em theEncodedNumber})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}\hfill}
\label{qubits_8c_a100463f6ec212c76a5fad99579000505}


Get the value of the bit at a particular index in a number. SCB edit: new definition of extractBit is much faster $\ast$$\ast$$\ast$ 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em locationOfBitFromRight}]location of bit in theEncodedNumber \item[\mbox{$\leftarrow$} {\em theEncodedNumber}]number to search \end{DoxyParams}
\begin{DoxyReturn}{Returns}
the value of the bit in theEncodedNumber 
\end{DoxyReturn}


Definition at line 1698 of file qubits.c.

Referenced by controlledCompactUnitaryDistributed(), controlledCompactUnitaryLocal(), controlledNotDistributed(), controlledNotLocal(), controlledPhaseGate(), controlledUnitaryDistributed(), controlledUnitaryLocal(), and initStateOfSingleQubit().


\begin{DoxyCode}
1699 {
1700         return (theEncodedNumber & ( 1LL << locationOfBitFromRight )) >> location
      OfBitFromRight;
1701 }
\end{DoxyCode}
\hypertarget{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}{
\index{qubits.c@{qubits.c}!findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}}
\index{findProbabilityOfZeroDistributed@{findProbabilityOfZeroDistributed}!qubits.c@{qubits.c}}
\paragraph[{findProbabilityOfZeroDistributed}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits_8c_a9ac9bb717a889f09d307eda9f0b65957}


Measure the probability of a specified qubit being in the zero state across all amplitudes held in this chunk. Size of regions to skip is a multiple of chunkSize.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1643 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1645 {
1646         // ----- measured probability
1647         REAL   totalProbability;                                    // probabilit
      y (returned) value
1648         // ----- temp variables
1649         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1650         long long int numTasks=multiQubit.numAmps;
1651 
1652         // ---------------------------------------------------------------- //
1653         //            find probability                                      //
1654         // ---------------------------------------------------------------- //
1655 
1656         // initialise returned value
1657         totalProbability = 0.0;
1658 
1659         REAL *stateVecReal = multiQubit.stateVec.real;
1660         REAL *stateVecImag = multiQubit.stateVec.imag;
1661 
1662 # ifdef _OPENMP
1663 # pragma omp parallel \
1664         shared    (numTasks,stateVecReal,stateVecImag) \
1665         private   (thisTask) \
1666         reduction ( +:totalProbability )
1667 # endif
1668         {
1669 # ifdef _OPENMP
1670                 # pragma omp for schedule  (static)
1671 # endif
1672                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1673                         // summation -- simple implementation
1674                         totalProbability += stateVecReal[thisTask]*stateVecReal[t
      hisTask]
1675                                 + stateVecImag[thisTask]*stateVecImag[thisTask];
1676 
1677                         /*
1678                         // summation -- kahan correction
1679                         y = stateVecReal[thisTask]*stateVecReal[thisTask]
1680                         + stateVecImag[thisTask]*stateVecImag[thisTask] - c;
1681                         t = totalProbability + y;
1682                         c = (t - totalProbability) - y;
1683                         totalProbability = t;
1684                         */
1685 
1686                 }
1687         }
1688 
1689         return totalProbability;
1690 }
\end{DoxyCode}
\hypertarget{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}{
\index{qubits.c@{qubits.c}!findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}}
\index{findProbabilityOfZeroLocal@{findProbabilityOfZeroLocal}!qubits.c@{qubits.c}}
\paragraph[{findProbabilityOfZeroLocal}]{\setlength{\rightskip}{0pt plus 5cm}REAL findProbabilityOfZeroLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em measureQubit})}\hfill}
\label{qubits_8c_a7c02cd0e1b4eac19771a0525f023249e}


Measure the total probability of a specified qubit being in the zero state across all amplitudes in this chunk. Size of regions to skip is less than the size of one chunk.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em measureQubit}]qubit to measure \end{DoxyParams}
\begin{DoxyReturn}{Returns}
probability of qubit measureQubit being zero 
\end{DoxyReturn}


Definition at line 1571 of file qubits.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by findProbabilityOfOutcome().


\begin{DoxyCode}
1573 {
1574         // ----- sizes
1575         long long int sizeBlock,                                           // siz
      e of blocks
1576         sizeHalfBlock;                                       // size of blocks ha
      lved
1577         // ----- indices
1578         long long int thisBlock,                                           // cur
      rent block
1579              index;                                               // current inde
      x for first half block
1580         // ----- measured probability
1581         REAL   totalProbability;                                    // probabilit
      y (returned) value
1582         // ----- temp variables
1583         long long int thisTask;                                   // task based a
      pproach for expose loop with small granularity
1584         long long int numTasks=multiQubit.numAmps>>1;
1585 
1586         // ---------------------------------------------------------------- //
1587         //            dimensions                                            //
1588         // ---------------------------------------------------------------- //
1589         sizeHalfBlock = 1LL << (measureQubit);                       // number of
       state vector elements to sum,
1590         // and then the number to skip
1591         sizeBlock     = 2LL * sizeHalfBlock;                           // size of
       blocks (pairs of measure and skip entries)
1592 
1593         // initialise returned value
1594         totalProbability = 0.0;
1595 
1596         // initialise correction for kahan summation
1597         if (DEBUG) printf("sizeHalfBlock=%Ld sizeBlock=%Ld numTasks=%Ld\n",sizeHa
      lfBlock,sizeBlock,numTasks);
1598 
1599         REAL *stateVecReal = multiQubit.stateVec.real;
1600         REAL *stateVecImag = multiQubit.stateVec.imag;
1601 
1602 # ifdef _OPENMP
1603 # pragma omp parallel \
1604         shared    (numTasks,sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
      
1605         private   (thisTask,thisBlock,index) \
1606         reduction ( +:totalProbability )
1607 # endif 
1608         {
1609 # ifdef _OPENMP
1610                 # pragma omp for schedule  (static)
1611 # endif
1612                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1613                         thisBlock = thisTask / sizeHalfBlock;
1614                         index     = thisBlock*sizeBlock + thisTask%sizeHalfBlock;
      
1615 
1616                         if (index<0){ printf("ABORTING as index=%Ld with thisBloc
      k = %Ld  thisTask=%Ld \n", index,thisBlock,thisTask); exit(1);}
1617 
1618                         // summation -- simple implementation
1619                         totalProbability += stateVecReal[index]*stateVecReal[inde
      x]
1620                                 + stateVecImag[index]*stateVecImag[index];
1621 
1622                         /*
1623                         // summation -- kahan correction
1624                         y = stateVecReal[index]*stateVecReal[index]
1625                         + stateVecImag[index]*stateVecImag[index] - c;
1626                         t = totalProbability + y;
1627                         c = (t - totalProbability) - y;
1628                         totalProbability = t;
1629                         */
1630 
1631                 }
1632         }
1633         return totalProbability;
1634 }
\end{DoxyCode}
\hypertarget{qubits_8c_a8f10aabf9f607f19093aee54630caa21}{
\index{qubits.c@{qubits.c}!getEnvironmentString@{getEnvironmentString}}
\index{getEnvironmentString@{getEnvironmentString}!qubits.c@{qubits.c}}
\paragraph[{getEnvironmentString}]{\setlength{\rightskip}{0pt plus 5cm}void getEnvironmentString ({\bf QuESTEnv} {\em env}, \/  {\bf MultiQubit} {\em multiQubit}, \/  char {\em str}\mbox{[}200\mbox{]})}\hfill}
\label{qubits_8c_a8f10aabf9f607f19093aee54630caa21}


Definition at line 128 of file qubits.c.

References MultiQubit::numQubits, and QuESTEnv::numRanks.


\begin{DoxyCode}
128                                                                              {
129         int numThreads=1;
130 # ifdef _OPENMP
131         numThreads=omp_get_max_threads(); 
132 # endif
133         sprintf(str, "%dqubits_CPU_%dranksx%dthreads", multiQubit.numQubits, env.
      numRanks, numThreads);
134 }
\end{DoxyCode}
\hypertarget{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}{
\index{qubits.c@{qubits.c}!getProbEl@{getProbEl}}
\index{getProbEl@{getProbEl}!qubits.c@{qubits.c}}
\paragraph[{getProbEl}]{\setlength{\rightskip}{0pt plus 5cm}REAL getProbEl ({\bf MultiQubit} {\em multiQubit}, \/  long long int {\em index})}\hfill}
\label{qubits_8c_a799b10447d6dbdaf960a4d3eedd22014}


Get the probability of the state at an index in the full state vector. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em multiQubit}]object representing a set of qubits \item[\mbox{$\leftarrow$} {\em index}]index in state vector of probability amplitudes \end{DoxyParams}
\begin{DoxyReturn}{Returns}
realEl$\ast$realEl + imagEl$\ast$imagEl 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily index} is outside \mbox{[}0, $2^{N}$) where $N = $ {\ttfamily multiQubit.numQubits} \end{DoxyExceptions}


Definition at line 1945 of file qubits.c.

References getImagAmpEl(), getRealAmpEl(), and REAL.


\begin{DoxyCode}
1945                                                           {
1946         REAL real;
1947         REAL imag;
1948         real = getRealAmpEl(multiQubit, index);
1949         imag = getImagAmpEl(multiQubit, index);
1950         return real*real + imag*imag;
1951 }
\end{DoxyCode}
\hypertarget{qubits_8c_ae6a897066979fc52d977007d959ca09d}{
\index{qubits.c@{qubits.c}!hadamardDistributed@{hadamardDistributed}}
\index{hadamardDistributed@{hadamardDistributed}!qubits.c@{qubits.c}}
\paragraph[{hadamardDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits_8c_ae6a897066979fc52d977007d959ca09d}


Rotate a single qubit by \{\{1,1\},\{1,-\/1\}\}/sqrt2. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1374 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by hadamard().


\begin{DoxyCode}
1379 {
1380 
1381         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1382         long long int thisTask;  
1383         const long long int numTasks=multiQubit.numAmps;
1384 
1385         int sign;
1386         if (updateUpper) sign=1;
1387         else sign=-1;
1388 
1389         REAL recRoot2 = 1.0/sqrt(2);
1390 
1391         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1392         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1393         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1394 
1395 # ifdef _OPENMP
1396 # pragma omp parallel \
1397         default  (none) \
1398         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1399                         recRoot2, sign) \
1400         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1401 # endif
1402         {
1403 # ifdef _OPENMP
1404                 # pragma omp for schedule (static)
1405 # endif
1406                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1407                         // store current state vector values in temp variables
1408                         stateRealUp = stateVecRealUp[thisTask];
1409                         stateImagUp = stateVecImagUp[thisTask];
1410 
1411                         stateRealLo = stateVecRealLo[thisTask];
1412                         stateImagLo = stateVecImagLo[thisTask];
1413 
1414                         stateVecRealOut[thisTask] = recRoot2*(stateRealUp + sign*
      stateRealLo);
1415                         stateVecImagOut[thisTask] = recRoot2*(stateImagUp + sign*
      stateImagLo);
1416                 }
1417         }
1418 }
\end{DoxyCode}
\hypertarget{qubits_8c_aa9f0718b4dd794a3e1b143e3b153bfc5}{
\index{qubits.c@{qubits.c}!hadamardLocal@{hadamardLocal}}
\index{hadamardLocal@{hadamardLocal}!qubits.c@{qubits.c}}
\paragraph[{hadamardLocal}]{\setlength{\rightskip}{0pt plus 5cm}void hadamardLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_aa9f0718b4dd794a3e1b143e3b153bfc5}


Definition at line 1313 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by hadamard().


\begin{DoxyCode}
1314 {
1315         long long int sizeBlock, sizeHalfBlock;
1316         long long int thisBlock, // current block
1317              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1318 
1319         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
1320         long long int thisTask;         
1321         const long long int numTasks=multiQubit.numAmps>>1;
1322 
1323         // set dimensions
1324         sizeHalfBlock = 1LL << targetQubit;  
1325         sizeBlock     = 2LL * sizeHalfBlock; 
1326 
1327         // Can't use multiQubit.stateVec as a private OMP var
1328         REAL *stateVecReal = multiQubit.stateVec.real;
1329         REAL *stateVecImag = multiQubit.stateVec.imag;
1330 
1331         REAL recRoot2 = 1.0/sqrt(2);
1332 
1333 # ifdef _OPENMP
1334 # pragma omp parallel \
1335         default  (none) \
1336         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, recRoot2) \
      
1337         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
1338 # endif
1339         {
1340 # ifdef _OPENMP
1341                 # pragma omp for schedule (static)
1342 # endif
1343                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1344                         thisBlock   = thisTask / sizeHalfBlock;
1345                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1346                         indexLo     = indexUp + sizeHalfBlock;
1347 
1348                         stateRealUp = stateVecReal[indexUp];
1349                         stateImagUp = stateVecImag[indexUp];
1350 
1351                         stateRealLo = stateVecReal[indexLo];
1352                         stateImagLo = stateVecImag[indexLo];
1353 
1354                         stateVecReal[indexUp] = recRoot2*(stateRealUp + stateReal
      Lo);
1355                         stateVecImag[indexUp] = recRoot2*(stateImagUp + stateImag
      Lo);
1356 
1357                         stateVecReal[indexLo] = recRoot2*(stateRealUp - stateReal
      Lo);
1358                         stateVecImag[indexLo] = recRoot2*(stateImagUp - stateImag
      Lo);
1359                 } 
1360         }
1361 }
\end{DoxyCode}
\hypertarget{qubits_8c_a433876ee9f3bcc54af346300f571fc3c}{
\index{qubits.c@{qubits.c}!initializeStateFromSingleFile@{initializeStateFromSingleFile}}
\index{initializeStateFromSingleFile@{initializeStateFromSingleFile}!qubits.c@{qubits.c}}
\paragraph[{initializeStateFromSingleFile}]{\setlength{\rightskip}{0pt plus 5cm}void initializeStateFromSingleFile ({\bf MultiQubit} $\ast$ {\em multiQubit}, \/  char {\em filename}\mbox{[}200\mbox{]}, \/  {\bf QuESTEnv} {\em env})}\hfill}
\label{qubits_8c_a433876ee9f3bcc54af346300f571fc3c}


fix -\/-\/ format needs to work for single precision values 

Definition at line 292 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, MultiQubit::stateVec, and syncQuESTEnv().


\begin{DoxyCode}
292                                                                                  
                 {
293         long long int chunkSize, stateVecSize;
294         long long int indexInChunk, totalIndex;
295 
296         chunkSize = multiQubit->numAmps;
297         stateVecSize = chunkSize*multiQubit->numChunks;
298 
299         REAL *stateVecReal = multiQubit->stateVec.real;
300         REAL *stateVecImag = multiQubit->stateVec.imag;
301         
302         FILE *fp;
303         char line[200];
304 
305         for (int rank=0; rank<(multiQubit->numChunks); rank++){
306                 if (rank==multiQubit->chunkId){
307                         fp = fopen(filename, "r");
308                         indexInChunk = 0; totalIndex = 0;
309                         while (fgets(line, sizeof(char)*200, fp) != NULL && total
      Index<stateVecSize){
310                                 if (line[0]!='#'){
311                                         int chunkId = totalIndex/chunkSize;
312                                         if (chunkId==multiQubit->chunkId){
314                                                 sscanf(line, "%lf, %lf", &(stateV
      ecReal[indexInChunk]), 
315                                                                 &(stateVecImag[in
      dexInChunk]));
316                                                 indexInChunk += 1;
317                                         }
318                                         totalIndex += 1;
319                                 }
320                         }       
321                         fclose(fp);
322                 }
323                 syncQuESTEnv(env);
324         }
325 }
\end{DoxyCode}
\hypertarget{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}{
\index{qubits.c@{qubits.c}!initStateDebug@{initStateDebug}}
\index{initStateDebug@{initStateDebug}!qubits.c@{qubits.c}}
\paragraph[{initStateDebug}]{\setlength{\rightskip}{0pt plus 5cm}void initStateDebug ({\bf MultiQubit} $\ast$ {\em multiQubit})}\hfill}
\label{qubits_8c_a03b3577a891731d505bc4b879fcca9d3}


Initialise the state vector of probability amplitudes to an (unphysical) state with each component of each probability amplitude a unique floating point value. For debugging processes 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \end{DoxyParams}


Definition at line 260 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
261 {
262         long long int chunkSize;
263         long long int index;
264 
265         // dimension of the state vector
266         chunkSize = multiQubit->numAmps;
267 
268         // Can't use multiQubit->stateVec as a private OMP var
269         REAL *stateVecReal = multiQubit->stateVec.real;
270         REAL *stateVecImag = multiQubit->stateVec.imag;
271 
272         REAL chunkOffset = (2.0*chunkSize*multiQubit->chunkId)/10.0;
273 
274         // initialise the state to |0000..0000>
275 # ifdef _OPENMP
276 # pragma omp parallel \
277         default  (none) \
278         shared   (chunkSize, stateVecReal, stateVecImag, chunkOffset) \
279         private  (index) 
280 # endif
281         {
282 # ifdef _OPENMP
283                 # pragma omp for schedule (static)
284 # endif
285                 for (index=0; index<chunkSize; index++) {
286                         stateVecReal[index] = chunkOffset + (index*2.0)/10.0;
287                         stateVecImag[index] = chunkOffset + (index*2.0+1.0)/10.0;
      
288                 }
289         }
290 }
\end{DoxyCode}
\hypertarget{qubits_8c_a7169fd0442cbc3418f3fac4d13363ca2}{
\index{qubits.c@{qubits.c}!initStateOfSingleQubit@{initStateOfSingleQubit}}
\index{initStateOfSingleQubit@{initStateOfSingleQubit}!qubits.c@{qubits.c}}
\paragraph[{initStateOfSingleQubit}]{\setlength{\rightskip}{0pt plus 5cm}void initStateOfSingleQubit ({\bf MultiQubit} $\ast$ {\em multiQubit}, \/  int {\em qubitId}, \/  int {\em outcome})}\hfill}
\label{qubits_8c_a7169fd0442cbc3418f3fac4d13363ca2}


Initialise the state vector of probability amplitudes such that one qubit is set to 'outcome' and all other qubits are in an equal superposition of zero and one. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits to be initialised \item[\mbox{$\leftarrow$} {\em qubitId}]id of qubit to set to state 'outcome' \item[\mbox{$\leftarrow$} {\em value}]of qubit 'qubitId' \end{DoxyParams}


Definition at line 213 of file qubits.c.

References MultiQubit::chunkId, DEBUG, extractBit(), ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
214 {
215         long long int chunkSize, stateVecSize;
216         long long int index;
217         int bit;
218         const long long int chunkId=multiQubit->chunkId;
219 
220         // dimension of the state vector
221         chunkSize = multiQubit->numAmps;
222         stateVecSize = chunkSize*multiQubit->numChunks;
223         REAL normFactor = 1.0/sqrt((REAL)stateVecSize/2.0);
224 
225         // Can't use multiQubit->stateVec as a private OMP var
226         REAL *stateVecReal = multiQubit->stateVec.real;
227         REAL *stateVecImag = multiQubit->stateVec.imag;
228 
229         // initialise the state to |0000..0000>
230 # ifdef _OPENMP
231 # pragma omp parallel \
232         default  (none) \
233         shared   (chunkSize, stateVecReal, stateVecImag, normFactor, qubitId, out
      come) \
234         private  (index, bit) 
235 # endif
236         {
237 # ifdef _OPENMP
238                 # pragma omp for schedule (static)
239 # endif
240                 for (index=0; index<chunkSize; index++) {
241                         bit = extractBit(qubitId, index+chunkId*chunkSize);
242                         if (bit==outcome) {
243                                 stateVecReal[index] = normFactor;
244                                 stateVecImag[index] = 0.0;
245                         } else {
246                                 stateVecReal[index] = 0.0;
247                                 stateVecImag[index] = 0.0;
248                         }
249                 }
250         }
251         if (DEBUG) printf("COMPLETED INIT\n");
252 }
\end{DoxyCode}
\hypertarget{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}{
\index{qubits.c@{qubits.c}!initStatePlus@{initStatePlus}}
\index{initStatePlus@{initStatePlus}!qubits.c@{qubits.c}}
\paragraph[{initStatePlus}]{\setlength{\rightskip}{0pt plus 5cm}void initStatePlus ({\bf MultiQubit} $\ast$ {\em multiQubit})}\hfill}
\label{qubits_8c_a43bcb279fc9717fbd06a19cdef48b9d8}


Initialise a set of $ N $ qubits to the plus state $ {| + \rangle}^{\otimes N} = \frac{1}{\sqrt{2^N}} (| 0 \rangle + | 1 \rangle)^{\otimes N} $. This is the product state of $N$ qubits where every classical state is uniformly populated with real coefficient $\frac{1}{\sqrt{2^N}}$. This is equivalent to applying a Hadamard to every qubit in the zero state: $ \hat{H}^{\otimes N} {|0\rangle}^{\otimes N} $


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]a pointer to the object representing the set of qubits to be initialised \end{DoxyParams}


Definition at line 174 of file qubits.c.

References DEBUG, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
175 {
176         long long int chunkSize, stateVecSize;
177         long long int index;
178 
179         // dimension of the state vector
180         chunkSize = multiQubit->numAmps;
181         stateVecSize = chunkSize*multiQubit->numChunks;
182         REAL normFactor = 1.0/sqrt((REAL)stateVecSize);
183 
184         // Can't use multiQubit->stateVec as a private OMP var
185         REAL *stateVecReal = multiQubit->stateVec.real;
186         REAL *stateVecImag = multiQubit->stateVec.imag;
187 
188         // initialise the state to |0000..0000>
189 # ifdef _OPENMP
190 # pragma omp parallel \
191         default  (none) \
192         shared   (chunkSize, stateVecReal, stateVecImag, normFactor) \
193         private  (index) 
194 # endif
195         {
196 # ifdef _OPENMP
197                 # pragma omp for schedule (static)
198 # endif
199                 for (index=0; index<chunkSize; index++) {
200                         stateVecReal[index] = normFactor;
201                         stateVecImag[index] = 0.0;
202                 }
203         }
204         if (DEBUG) printf("COMPLETED INIT\n");
205 }
\end{DoxyCode}
\hypertarget{qubits_8c_acb5b2eff794339090004d29f02a70d9a}{
\index{qubits.c@{qubits.c}!initStateZero@{initStateZero}}
\index{initStateZero@{initStateZero}!qubits.c@{qubits.c}}
\paragraph[{initStateZero}]{\setlength{\rightskip}{0pt plus 5cm}void initStateZero ({\bf MultiQubit} $\ast$ {\em multiQubit})}\hfill}
\label{qubits_8c_acb5b2eff794339090004d29f02a70d9a}


Initialise a set of $ N $ qubits to the classical zero state $ {| 0 \rangle}^{\otimes N} $. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]a pointer to the object representing the set of all qubits to initialise \end{DoxyParams}


Definition at line 136 of file qubits.c.

References MultiQubit::chunkId, DEBUG, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
137 {
138         long long int stateVecSize;
139         long long int index;
140 
141         // dimension of the state vector
142         stateVecSize = multiQubit->numAmps;
143 
144         // Can't use multiQubit->stateVec as a private OMP var
145         REAL *stateVecReal = multiQubit->stateVec.real;
146         REAL *stateVecImag = multiQubit->stateVec.imag;
147 
148         // initialise the state to |0000..0000>
149 # ifdef _OPENMP
150 # pragma omp parallel \
151         default  (none) \
152         shared   (stateVecSize, stateVecReal, stateVecImag) \
153         private  (index) 
154 # endif
155         {
156 # ifdef _OPENMP
157                 # pragma omp for schedule (static)
158 # endif
159                 for (index=0; index<stateVecSize; index++) {
160                         stateVecReal[index] = 0.0;
161                         stateVecImag[index] = 0.0;
162                 }
163         }
164 
165         if (multiQubit->chunkId==0){
166                 // zero state |0000..0000> has probability 1
167                 stateVecReal[0] = 1.0;
168                 stateVecImag[0] = 0.0;
169         }
170 
171         if (DEBUG) printf("COMPLETED INIT\n");
172 }
\end{DoxyCode}
\hypertarget{qubits_8c_afc1835c6b43b6e59ce7df7b13f274fc7}{
\index{qubits.c@{qubits.c}!multiControlledPhaseGate@{multiControlledPhaseGate}}
\index{multiControlledPhaseGate@{multiControlledPhaseGate}!qubits.c@{qubits.c}}
\paragraph[{multiControlledPhaseGate}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledPhaseGate ({\bf MultiQubit} {\em multiQubit}, \/  int $\ast$ {\em controlQubits}, \/  int {\em numControlQubits})}\hfill}
\label{qubits_8c_afc1835c6b43b6e59ce7df7b13f274fc7}


Apply the multiple-\/qubit controlled phase gate, also known as the multiple-\/qubit controlled sigmaZ gate. For each state, if all control qubits have value one, multiply the amplitude of that state by -\/1. This applies the many-\/qubit unitary: \[ \begin{pmatrix} 1 \\ & 1 \\\ & & \ddots \\ & & & 1 \\ & & & & -1 \end{pmatrix} \] on the control qubits.

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 2) {controls}; \node[draw=none] at (0, 6) {$\vdots$}; \draw (0, 5) -- (0, 4); \draw (-2, 4) -- (2, 4); \draw[fill=black] (0, 4) circle (.2); \draw (0, 4) -- (0, 2); \draw (-2, 2) -- (2, 2); \draw[fill=black] (0, 2) circle (.2); \draw (0, 2) -- (0, 0); \draw (-2,0) -- (2, 0); \draw[fill=black] (0, 0) circle (.2); \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em controlQubits}]array of input qubits \item[\mbox{$\leftarrow$} {\em numControlQubits}]number of input qubits \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily numControlQubits} is outside \mbox{[}1, {\ttfamily multiQubit.numQubits}) \end{DoxyExceptions}


Definition at line 1738 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numQubits, QuESTAssert(), ComplexArray::real, REAL, and MultiQubit::stateVec.


\begin{DoxyCode}
1739 {
1740         long long int index;
1741         long long int stateVecSize;
1742         
1743         const long long int chunkSize=multiQubit.numAmps;
1744         const long long int chunkId=multiQubit.chunkId;
1745 
1746     QuESTAssert(numControlQubits > 0 && numControlQubits <= multiQubit.numQubits,
       4, __func__);
1747     long long int mask=0;
1748     for (int i=0; i<numControlQubits; i++) mask = mask | (1LL<<controlQubits[i]);
      
1749     QuESTAssert(mask >=0 && mask <= (1LL<<multiQubit.numQubits)-1, 2, __func__);
1750 
1751         stateVecSize = multiQubit.numAmps;
1752         REAL *stateVecReal = multiQubit.stateVec.real;
1753         REAL *stateVecImag = multiQubit.stateVec.imag;
1754 
1755 # ifdef _OPENMP
1756 # pragma omp parallel \
1757         default  (none)                      \
1758         shared   (stateVecSize, stateVecReal,stateVecImag, mask ) \
1759         private  (index)
1760 # endif
1761         {
1762 # ifdef _OPENMP
1763                 # pragma omp for schedule (static)
1764 # endif
1765                 for (index=0; index<stateVecSize; index++) {
1766                         if (mask == (mask & (index+chunkId*chunkSize)) ){
1767                                 stateVecReal [index] = - stateVecReal [index];
1768                                 stateVecImag [index] = - stateVecImag [index];
1769                         }
1770                 }
1771         }
1772 }
\end{DoxyCode}
\hypertarget{qubits_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}{
\index{qubits.c@{qubits.c}!multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}}
\index{multiControlledUnitaryDistributed@{multiControlledUnitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{multiControlledUnitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a9dbf856ebeea0cf0a3ee5aae6782f2d2}


Apply a unitary operation to a single qubit in the state vector of probability amplitudes, given a subset of the state vector with upper and lower block values stored seperately. Only perform the rotation where all the control qubits are 1.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em controlQubit}]qubit to determine whether or not to perform a rotation \item[\mbox{$\leftarrow$} {\em rot1}]rotation angle \item[\mbox{$\leftarrow$} {\em rot2}]rotation angle \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 984 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
991 {
992 
993         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
994         long long int thisTask;  
995         const long long int numTasks=multiQubit.numAmps;
996         const long long int chunkSize=multiQubit.numAmps;
997         const long long int chunkId=multiQubit.chunkId;
998 
999         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
1000         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
1001         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
1002         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
1003         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1004 
1005 # ifdef _OPENMP
1006 # pragma omp parallel \
1007         default  (none) \
1008         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
1009                         rot1Real,rot1Imag, rot2Real,rot2Imag, mask) \
1010         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
1011 # endif
1012         {
1013 # ifdef _OPENMP
1014                 # pragma omp for schedule (static)
1015 # endif
1016                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1017                         if (mask == (mask & (thisTask+chunkId*chunkSize)) ){
1018                                 // store current state vector values in temp vari
      ables
1019                                 stateRealUp = stateVecRealUp[thisTask];
1020                                 stateImagUp = stateVecImagUp[thisTask];
1021 
1022                                 stateRealLo = stateVecRealLo[thisTask];
1023                                 stateImagLo = stateVecImagLo[thisTask];
1024 
1025                 stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Imag*state
      ImagUp 
1026                     + rot2Real*stateRealLo - rot2Imag*stateImagLo;
1027                 stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Imag*state
      RealUp 
1028                     + rot2Real*stateImagLo + rot2Imag*stateRealLo;
1029                         }
1030                 }
1031         }
1032 }
\end{DoxyCode}
\hypertarget{qubits_8c_a1309eabcba3cb97fbc3cd2e606d17766}{
\index{qubits.c@{qubits.c}!multiControlledUnitaryLocal@{multiControlledUnitaryLocal}}
\index{multiControlledUnitaryLocal@{multiControlledUnitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{multiControlledUnitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void multiControlledUnitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  long long int {\em mask}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8c_a1309eabcba3cb97fbc3cd2e606d17766}


Definition at line 715 of file qubits.c.

References MultiQubit::chunkId, Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by multiControlledUnitary().


\begin{DoxyCode}
717 {
718         long long int sizeBlock, sizeHalfBlock;
719         long long int thisBlock, // current block
720              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
721 
722         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
723         long long int thisTask;         
724         const long long int numTasks=multiQubit.numAmps>>1;
725         const long long int chunkSize=multiQubit.numAmps;
726         const long long int chunkId=multiQubit.chunkId;
727 
728         // set dimensions
729         sizeHalfBlock = 1LL << targetQubit;  
730         sizeBlock     = 2LL * sizeHalfBlock; 
731 
732         // Can't use multiQubit.stateVec as a private OMP var
733         REAL *stateVecReal = multiQubit.stateVec.real;
734         REAL *stateVecImag = multiQubit.stateVec.imag;
735 
736 # ifdef _OPENMP
737 # pragma omp parallel \
738         default  (none) \
739         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u, mask) \
740         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
741 # endif
742         {
743 # ifdef _OPENMP
744                 # pragma omp for schedule (static)
745 # endif
746                 for (thisTask=0; thisTask<numTasks; thisTask++) {
747 
748                         thisBlock   = thisTask / sizeHalfBlock;
749                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
750                         indexLo     = indexUp + sizeHalfBlock;
751 
752                         if (mask == (mask & (indexUp+chunkId*chunkSize)) ){
753                                 // store current state vector values in temp vari
      ables
754                                 stateRealUp = stateVecReal[indexUp];
755                                 stateImagUp = stateVecImag[indexUp];
756 
757                                 stateRealLo = stateVecReal[indexLo];
758                                 stateImagLo = stateVecImag[indexLo];
759 
760 
761                                 // state[indexUp] = u00 * state[indexUp] + u01 * 
      state[indexLo]
762                                 stateVecReal[indexUp] = u.r0c0.real*stateRealUp -
       u.r0c0.imag*stateImagUp 
763                                         + u.r0c1.real*stateRealLo - u.r0c1.imag*s
      tateImagLo;
764                                 stateVecImag[indexUp] = u.r0c0.real*stateImagUp +
       u.r0c0.imag*stateRealUp 
765                                         + u.r0c1.real*stateImagLo + u.r0c1.imag*s
      tateRealLo;
766 
767                                 // state[indexLo] = u10  * state[indexUp] + u11 *
       state[indexLo]
768                                 stateVecReal[indexLo] = u.r1c0.real*stateRealUp  
      - u.r1c0.imag*stateImagUp 
769                                         + u.r1c1.real*stateRealLo  -  u.r1c1.
      imag*stateImagLo;
770                                 stateVecImag[indexLo] = u.r1c0.real*stateImagUp +
       u.r1c0.imag*stateRealUp 
771                                         + u.r1c1.real*stateImagLo + u.r1c1.imag*s
      tateRealLo;
772                         }
773                 } 
774         }
775 
776 }
\end{DoxyCode}
\hypertarget{qubits_8c_af832ed00b02a0597b7fe0b714032c54a}{
\index{qubits.c@{qubits.c}!phaseGateDistributed@{phaseGateDistributed}}
\index{phaseGateDistributed@{phaseGateDistributed}!qubits.c@{qubits.c}}
\paragraph[{phaseGateDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits_8c_af832ed00b02a0597b7fe0b714032c54a}


Definition at line 1496 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1497 {
1498         REAL stateRealLo,stateImagLo;
1499         long long int thisTask;         
1500         const long long int numTasks=multiQubit.numAmps;
1501 
1502         // Can't use multiQubit.stateVec as a private OMP var
1503         REAL *stateVecReal = multiQubit.stateVec.real;
1504         REAL *stateVecImag = multiQubit.stateVec.imag;
1505 
1506         REAL recRoot2 = 1.0/sqrt(2);
1507 
1508 # ifdef _OPENMP
1509 # pragma omp parallel \
1510         default  (none) \
1511         shared   (stateVecReal,stateVecImag, recRoot2, type) \
1512         private  (thisTask,stateRealLo,stateImagLo) 
1513 # endif
1514         {
1515                 if (type==SIGMA_Z){
1516 # ifdef _OPENMP
1517                         # pragma omp for schedule (static)
1518 # endif
1519                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1520                                 stateVecReal[thisTask] = -stateVecReal[thisTask];
      
1521                                 stateVecImag[thisTask] = -stateVecImag[thisTask];
      
1522                         } 
1523                 } else if (type==S_GATE){
1524 # ifdef _OPENMP
1525                         # pragma omp for schedule (static)
1526 # endif
1527                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1528                                 stateRealLo = stateVecReal[thisTask];
1529                                 stateImagLo = stateVecImag[thisTask];
1530 
1531                                 stateVecReal[thisTask] = -stateImagLo;
1532                                 stateVecImag[thisTask] = stateRealLo;
1533                         } 
1534                 } else if (type==T_GATE){
1535 # ifdef _OPENMP
1536                         # pragma omp for schedule (static)
1537 # endif
1538                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1539                                 stateRealLo = stateVecReal[thisTask];
1540                                 stateImagLo = stateVecImag[thisTask];
1541 
1542                                 stateVecReal[thisTask] = recRoot2 * (stateRealLo 
      - stateImagLo);
1543                                 stateVecImag[thisTask] = recRoot2 * (stateRealLo 
      + stateImagLo);
1544                         } 
1545                 } else printf("Type %d is an invalid phase gate\n", type);
1546         }
1547 }
\end{DoxyCode}
\hypertarget{qubits_8c_a3a54566b73ac84c312d7da4f56ffbc3b}{
\index{qubits.c@{qubits.c}!phaseGateLocal@{phaseGateLocal}}
\index{phaseGateLocal@{phaseGateLocal}!qubits.c@{qubits.c}}
\paragraph[{phaseGateLocal}]{\setlength{\rightskip}{0pt plus 5cm}void phaseGateLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  enum {\bf phaseGateType} {\em type})}\hfill}
\label{qubits_8c_a3a54566b73ac84c312d7da4f56ffbc3b}


fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod?

fix -\/-\/ can i rewrite this to not use mod? 

Definition at line 1420 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, S\_\-GATE, SIGMA\_\-Z, MultiQubit::stateVec, and T\_\-GATE.

Referenced by phaseGate().


\begin{DoxyCode}
1421 {
1422         long long int sizeBlock, sizeHalfBlock;
1423         long long int thisBlock, // current block
1424              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1425 
1426         REAL stateRealLo,stateImagLo;
1427         long long int thisTask;         
1428         const long long int numTasks=multiQubit.numAmps>>1;
1429 
1430         // set dimensions
1431         sizeHalfBlock = 1LL << targetQubit;  
1432         sizeBlock     = 2LL * sizeHalfBlock; 
1433 
1434         // Can't use multiQubit.stateVec as a private OMP var
1435         REAL *stateVecReal = multiQubit.stateVec.real;
1436         REAL *stateVecImag = multiQubit.stateVec.imag;
1437 
1438         REAL recRoot2 = 1.0/sqrt(2);
1439 
1440 # ifdef _OPENMP
1441 # pragma omp parallel \
1442         default  (none) \
1443         shared   (sizeBlock,sizeHalfBlock,stateVecReal,stateVecImag,recRoot2,type
      ) \
1444         private  (thisTask,thisBlock,indexUp,indexLo,stateRealLo,stateImagLo) 
1445 # endif
1446         {
1447                 if (type==SIGMA_Z){
1448 # ifdef _OPENMP
1449                         # pragma omp for schedule (static)
1450 # endif
1451                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1453                                 thisBlock   = thisTask / sizeHalfBlock;
1454                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1455                                 indexLo     = indexUp + sizeHalfBlock;
1456 
1457                                 stateVecReal[indexLo] = -stateVecReal[indexLo];
1458                                 stateVecImag[indexLo] = -stateVecImag[indexLo];
1459                         } 
1460                 } 
1461                 
1462                 else if (type==S_GATE){
1463 # ifdef _OPENMP
1464                         # pragma omp for schedule (static)
1465 # endif
1466                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1468                                 thisBlock   = thisTask / sizeHalfBlock;
1469                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1470                                 indexLo     = indexUp + sizeHalfBlock;
1471                                 stateRealLo = stateVecReal[indexLo];
1472                                 stateImagLo = stateVecImag[indexLo];
1473 
1474                                 stateVecReal[indexLo] = -stateImagLo;
1475                                 stateVecImag[indexLo] = stateRealLo;
1476                         } 
1477                 } else if (type==T_GATE){
1478 # ifdef _OPENMP
1479                         # pragma omp for schedule (static)
1480 # endif
1481                         for (thisTask=0; thisTask<numTasks; thisTask++) {
1483                                 thisBlock   = thisTask / sizeHalfBlock;
1484                                 indexUp     = thisBlock*sizeBlock + thisTask%size
      HalfBlock;
1485                                 indexLo     = indexUp + sizeHalfBlock;
1486                                 stateRealLo = stateVecReal[indexLo];
1487                                 stateImagLo = stateVecImag[indexLo];
1488 
1489                                 stateVecReal[indexLo] = recRoot2 * (stateRealLo -
       stateImagLo);
1490                                 stateVecImag[indexLo] = recRoot2 * (stateRealLo +
       stateImagLo);
1491                         } 
1492                 } else printf("Type %d is an invalid phase gate\n", type);
1493         }
1494 }
\end{DoxyCode}
\hypertarget{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}{
\index{qubits.c@{qubits.c}!reportMultiQubitParams@{reportMultiQubitParams}}
\index{reportMultiQubitParams@{reportMultiQubitParams}!qubits.c@{qubits.c}}
\paragraph[{reportMultiQubitParams}]{\setlength{\rightskip}{0pt plus 5cm}void reportMultiQubitParams ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits_8c_aa5e77e0e64f3a4a3d3f5cc7382bffcd9}


Report metainformation about a set of qubits: number of qubits, number of probability amplitudes. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em env}]object representing the execution environment (local, multinode etc) \end{DoxyParams}


Definition at line 117 of file qubits.c.

References MultiQubit::chunkId, MultiQubit::numChunks, and MultiQubit::numQubits.


\begin{DoxyCode}
117                                                   {
118         long long int numAmps = 1L << multiQubit.numQubits;
119         long long int numAmpsPerRank = numAmps/multiQubit.numChunks;
120         if (multiQubit.chunkId==0){
121                 printf("QUBITS:\n");
122                 printf("Number of qubits is %d.\n", multiQubit.numQubits);
123                 printf("Number of amps is %lld.\n", numAmps);
124                 printf("Number of amps per rank is %lld.\n", numAmpsPerRank);
125         }
126 }
\end{DoxyCode}
\hypertarget{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}{
\index{qubits.c@{qubits.c}!reportState@{reportState}}
\index{reportState@{reportState}!qubits.c@{qubits.c}}
\paragraph[{reportState}]{\setlength{\rightskip}{0pt plus 5cm}void reportState ({\bf MultiQubit} {\em multiQubit})}\hfill}
\label{qubits_8c_a96f4de9ce7fefc7680a44d601fc3d894}


Print the current state vector of probability amplitudes for a set of qubits to file. File format: \begin{DoxyVerb}
real, imag
realComponent1, imagComponent1
realComponent2, imagComponent2
...
realComponentN, imagComponentN
\end{DoxyVerb}


File naming convention:

For each node that the program runs on, a file 'state\_\-rank\_\-\mbox{[}node\_\-rank\mbox{]}.csv' is generated. If there is more than one node, ranks after the first do not include the header \begin{DoxyVerb}
real, imag
\end{DoxyVerb}
 so that files are easier to combine.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \end{DoxyParams}


Definition at line 78 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL\_\-STRING\_\-FORMAT, and MultiQubit::stateVec.


\begin{DoxyCode}
78                                        {
79         FILE *state;
80         char filename[100];
81         long long int index;
82         sprintf(filename, "state_rank_%d.csv", multiQubit.chunkId);
83         state = fopen(filename, "w");
84         if (multiQubit.chunkId==0) fprintf(state, "real, imag\n");
85 
86         for(index=0; index<multiQubit.numAmps; index++){
87                 fprintf(state, REAL_STRING_FORMAT "," REAL_STRING_FORMAT "\n", mu
      ltiQubit.stateVec.real[index], multiQubit.stateVec.imag[index]);
88         }
89         fclose(state);
90 }
\end{DoxyCode}
\hypertarget{qubits_8c_a842d6884e063a5865a2232cba56b65ac}{
\index{qubits.c@{qubits.c}!reportStateToScreen@{reportStateToScreen}}
\index{reportStateToScreen@{reportStateToScreen}!qubits.c@{qubits.c}}
\paragraph[{reportStateToScreen}]{\setlength{\rightskip}{0pt plus 5cm}void reportStateToScreen ({\bf MultiQubit} {\em multiQubit}, \/  {\bf QuESTEnv} {\em env}, \/  int {\em reportRank})}\hfill}
\label{qubits_8c_a842d6884e063a5865a2232cba56b65ac}


Print the current state vector of probability amplitudes for a set of qubits to standard out. For debugging purposes. Each rank should print output serially. Only print output for systems $<$= 5 qubits 

Definition at line 92 of file qubits.c.

References MultiQubit::chunkId, ComplexArray::imag, MultiQubit::numAmps, MultiQubit::numChunks, MultiQubit::numQubits, ComplexArray::real, REAL\_\-STRING\_\-FORMAT, MultiQubit::stateVec, and syncQuESTEnv().


\begin{DoxyCode}
92                                                                              {
93         long long int index;
94         int rank;
95         if (multiQubit.numQubits<=5){
96                 for (rank=0; rank<multiQubit.numChunks; rank++){
97                         if (multiQubit.chunkId==rank){
98                                 if (reportRank) {
99                                         printf("Reporting state from rank %d [\n"
      , multiQubit.chunkId);
100                                         //printf("\trank, index, real, imag\n");
101                                         printf("real, imag\n");
102                                 } else if (rank==0) {
103                                         printf("Reporting state [\n");
104                                         printf("real, imag\n");
105                                 }
106 
107                                 for(index=0; index<multiQubit.numAmps; index++){
108                                         printf(REAL_STRING_FORMAT ", " 
      REAL_STRING_FORMAT "\n", multiQubit.stateVec.real[index], multiQubit.stateVec.
      imag[index]);
109                                 }
110                                 if (reportRank || rank==multiQubit.numChunks-1) p
      rintf("]\n");
111                         }
112                         syncQuESTEnv(env);
113                 }
114         } else printf("Error: reportStateToScreen will not print output for syste
      ms of more than 5 qubits.\n");
115 }
\end{DoxyCode}
\hypertarget{qubits_8c_a7fadb225fc385db789e844c87fcba9e1}{
\index{qubits.c@{qubits.c}!rotateAroundAxis@{rotateAroundAxis}}
\index{rotateAroundAxis@{rotateAroundAxis}!qubits.c@{qubits.c}}
\paragraph[{rotateAroundAxis}]{\setlength{\rightskip}{0pt plus 5cm}void rotateAroundAxis ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle}, \/  {\bf Vector} {\em unitAxis})}\hfill}
\label{qubits_8c_a7fadb225fc385db789e844c87fcba9e1}


Rotate a single qubit by a given angle around a given vector on the Bloch-\/sphere. $\ast$ The vector must not be zero (else an error is thrown), but needn't be unit magnitude.


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \item[\mbox{$\leftarrow$} {\em axis}]vector around which to rotate \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily rotQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}), or if {\ttfamily axis} is the zero vector \end{DoxyExceptions}


Definition at line 379 of file qubits.c.

References compactUnitary(), Complex::imag, Complex::real, Vector::x, Vector::y, and Vector::z.


\begin{DoxyCode}
379                                                                                  
                  {
380         Complex alpha, beta;
381         alpha.real = cos(angle/2.0);
382         alpha.imag = -sin(angle/2.0)*unitAxis.z;        
383         beta.real = 0;
384         beta.imag = -sin(angle/2.0)*(unitAxis.x + unitAxis.y);
385         compactUnitary(multiQubit, rotQubit, alpha, beta);
386 }
\end{DoxyCode}
\hypertarget{qubits_8c_a6cc7fa705a2f2e6b486b49c5589d5df5}{
\index{qubits.c@{qubits.c}!rotateX@{rotateX}}
\index{rotateX@{rotateX}!qubits.c@{qubits.c}}
\paragraph[{rotateX}]{\setlength{\rightskip}{0pt plus 5cm}void rotateX ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8c_a6cc7fa705a2f2e6b486b49c5589d5df5}


Rotate a single qubit by a given angle around the X-\/axis of the Bloch-\/sphere. For angle $\theta$, applies \[ \begin{pmatrix} \cos\theta/2 & -i \sin \theta/2\\ -i \sin \theta/2 & \cos \theta/2 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {rot}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_x(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily rotQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 388 of file qubits.c.

References compactUnitary(), Complex::imag, Complex::real, Vector::x, Vector::y, and Vector::z.


\begin{DoxyCode}
388                                                                    {
389         Complex alpha, beta;
390     Vector unitAxis = {1, 0, 0};
391         alpha.real = cos(angle/2.0);
392         alpha.imag = -sin(angle/2.0)*unitAxis.z;        
393         beta.real = 0;
394         beta.imag = -sin(angle/2.0)*(unitAxis.x + unitAxis.y);
395         compactUnitary(multiQubit, rotQubit, alpha, beta);
396 }
\end{DoxyCode}
\hypertarget{qubits_8c_ace0d3592d38a990e81a434c4e9681500}{
\index{qubits.c@{qubits.c}!rotateY@{rotateY}}
\index{rotateY@{rotateY}!qubits.c@{qubits.c}}
\paragraph[{rotateY}]{\setlength{\rightskip}{0pt plus 5cm}void rotateY ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8c_ace0d3592d38a990e81a434c4e9681500}


Rotate a single qubit by a given angle around the Y-\/axis of the Bloch-\/sphere. For angle $\theta$, applies \[ \begin{pmatrix} \cos\theta/2 & \sin \theta/2\\ \sin \theta/2 & \cos \theta/2 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {rot}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_y(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily rotQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 398 of file qubits.c.

References compactUnitary(), Complex::imag, Complex::real, Vector::x, Vector::y, and Vector::z.


\begin{DoxyCode}
398                                                                    {
399         Complex alpha, beta;
400     Vector unitAxis = {0, 1, 0};
401         alpha.real = cos(angle/2.0);
402         alpha.imag = -sin(angle/2.0)*unitAxis.z;        
403         beta.real = 0;
404         beta.imag = -sin(angle/2.0)*(unitAxis.x + unitAxis.y);
405         compactUnitary(multiQubit, rotQubit, alpha, beta);
406 }
\end{DoxyCode}
\hypertarget{qubits_8c_abd621412ad30c1b034f4ce153c4afe10}{
\index{qubits.c@{qubits.c}!rotateZ@{rotateZ}}
\index{rotateZ@{rotateZ}!qubits.c@{qubits.c}}
\paragraph[{rotateZ}]{\setlength{\rightskip}{0pt plus 5cm}void rotateZ ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em rotQubit}, \/  REAL {\em angle})}\hfill}
\label{qubits_8c_abd621412ad30c1b034f4ce153c4afe10}


Rotate a single qubit by a given angle around the Z-\/axis of the Bloch-\/sphere (also known as a phase shift gate). For angle $\theta$, applies \[ \begin{pmatrix} \exp(-i \theta/2) & 0 \\ 0 & \exp(i \theta/2) \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {rot}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$R_z(\theta)$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em rotQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em angle}]angle by which to rotate in radians \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily rotQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 408 of file qubits.c.

References compactUnitary(), Complex::imag, Complex::real, Vector::x, Vector::y, and Vector::z.


\begin{DoxyCode}
408                                                                    {
409         Complex alpha, beta;
410     Vector unitAxis = {0, 0, 1};
411         alpha.real = cos(angle/2.0);
412         alpha.imag = -sin(angle/2.0)*unitAxis.z;        
413         beta.real = 0;
414         beta.imag = -sin(angle/2.0)*(unitAxis.x + unitAxis.y);
415         compactUnitary(multiQubit, rotQubit, alpha, beta);
416 }
\end{DoxyCode}
\hypertarget{qubits_8c_adda6c47876a7676488ed0565a19eaa65}{
\index{qubits.c@{qubits.c}!sGate@{sGate}}
\index{sGate@{sGate}!qubits.c@{qubits.c}}
\paragraph[{sGate}]{\setlength{\rightskip}{0pt plus 5cm}void sGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_adda6c47876a7676488ed0565a19eaa65}


Apply the single-\/qubit S gate. This is a rotation of $\pi/2$ around the Z-\/axis on the Bloch sphere, or the unitary: \[ \begin{pmatrix} 1 & 0 \\ 0 & i \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {S}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate upon \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) \end{DoxyExceptions}


Definition at line 1554 of file qubits.c.

References phaseGate(), and S\_\-GATE.


\begin{DoxyCode}
1555 {
1556                 phaseGate(multiQubit, targetQubit, S_GATE);
1557 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a2275fff50824fe47485890ff5a857785}{
\index{qubits.c@{qubits.c}!sigmaXDistributed@{sigmaXDistributed}}
\index{sigmaXDistributed@{sigmaXDistributed}!qubits.c@{qubits.c}}
\paragraph[{sigmaXDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a2275fff50824fe47485890ff5a857785}


Rotate a single qubit by \{\{0,1\},\{1,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1093 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaX().


\begin{DoxyCode}
1096 {
1097 
1098         long long int thisTask;  
1099         const long long int numTasks=multiQubit.numAmps;
1100 
1101         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1102         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1103 
1104 # ifdef _OPENMP
1105 # pragma omp parallel \
1106         default  (none) \
1107         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut) 
      \
1108         private  (thisTask)
1109 # endif
1110         {
1111 # ifdef _OPENMP
1112                 # pragma omp for schedule (static)
1113 # endif
1114                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1115                         stateVecRealOut[thisTask] = stateVecRealIn[thisTask];
1116                         stateVecImagOut[thisTask] = stateVecImagIn[thisTask];
1117                 }
1118         }
1119 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a74822fd86bb5d81766e6e8dbdcd62df1}{
\index{qubits.c@{qubits.c}!sigmaXLocal@{sigmaXLocal}}
\index{sigmaXLocal@{sigmaXLocal}!qubits.c@{qubits.c}}
\paragraph[{sigmaXLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaXLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_a74822fd86bb5d81766e6e8dbdcd62df1}


Definition at line 1034 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaX().


\begin{DoxyCode}
1035 {
1036         long long int sizeBlock, sizeHalfBlock;
1037         long long int thisBlock, // current block
1038              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1039 
1040         REAL stateRealUp,stateImagUp;
1041         long long int thisTask;         
1042         const long long int numTasks=multiQubit.numAmps>>1;
1043 
1044         // set dimensions
1045         sizeHalfBlock = 1LL << targetQubit;  
1046         sizeBlock     = 2LL * sizeHalfBlock; 
1047 
1048         // Can't use multiQubit.stateVec as a private OMP var
1049         REAL *stateVecReal = multiQubit.stateVec.real;
1050         REAL *stateVecImag = multiQubit.stateVec.imag;
1051 
1052 # ifdef _OPENMP
1053 # pragma omp parallel \
1054         default  (none) \
1055         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1056         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1057 # endif
1058         {
1059 # ifdef _OPENMP
1060                 # pragma omp for schedule (static)
1061 # endif
1062                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1063                         thisBlock   = thisTask / sizeHalfBlock;
1064                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1065                         indexLo     = indexUp + sizeHalfBlock;
1066 
1067                         stateRealUp = stateVecReal[indexUp];
1068                         stateImagUp = stateVecImag[indexUp];
1069 
1070                         stateVecReal[indexUp] = stateVecReal[indexLo];
1071                         stateVecImag[indexUp] = stateVecImag[indexLo];
1072 
1073                         stateVecReal[indexLo] = stateRealUp;
1074                         stateVecImag[indexLo] = stateImagUp;
1075                 } 
1076         }
1077 
1078 }
\end{DoxyCode}
\hypertarget{qubits_8c_af5ef5166f00c0572354b4ac53dcf40cf}{
\index{qubits.c@{qubits.c}!sigmaYDistributed@{sigmaYDistributed}}
\index{sigmaYDistributed@{sigmaYDistributed}!qubits.c@{qubits.c}}
\paragraph[{sigmaYDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexArray} {\em stateVecIn}, \/  {\bf ComplexArray} {\em stateVecOut}, \/  int {\em updateUpper})}\hfill}
\label{qubits_8c_af5ef5166f00c0572354b4ac53dcf40cf}


Rotate a single qubit by \{\{0,-\/i\},\{i,0\}. Operate on a subset of the state vector with upper and lower block values stored seperately. This rotation is just swapping upper and lower values, and stateVecIn must already be the correct section for this chunk

\begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em stateVecIn}]probability amplitudes in lower or upper half of a block depending on chunkId \item[\mbox{$\leftarrow$} {\em updateUpper}]flag, 1: updating upper values, 0: updating lower values in block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 1280 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, and REAL.

Referenced by sigmaY().


\begin{DoxyCode}
1284 {
1285 
1286         long long int thisTask;  
1287         const long long int numTasks=multiQubit.numAmps;
1288 
1289         REAL *stateVecRealIn=stateVecIn.real, *stateVecImagIn=stateVecIn.imag;
1290         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
1291 
1292         int realSign=1, imagSign=1;
1293         if (updateUpper) imagSign=-1;
1294         else realSign = -1;
1295 
1296 # ifdef _OPENMP
1297 # pragma omp parallel \
1298         default  (none) \
1299         shared   (stateVecRealIn,stateVecImagIn,stateVecRealOut,stateVecImagOut,r
      ealSign,imagSign) \
1300         private  (thisTask)
1301 # endif
1302         {
1303 # ifdef _OPENMP
1304                 # pragma omp for schedule (static)
1305 # endif
1306                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1307                         stateVecRealOut[thisTask] = realSign*stateVecImagIn[thisT
      ask];
1308                         stateVecImagOut[thisTask] = imagSign*stateVecRealIn[thisT
      ask];
1309                 }
1310         }
1311 } 
\end{DoxyCode}
\hypertarget{qubits_8c_a81fbfaed65a742a7dfd622e17652245e}{
\index{qubits.c@{qubits.c}!sigmaYLocal@{sigmaYLocal}}
\index{sigmaYLocal@{sigmaYLocal}!qubits.c@{qubits.c}}
\paragraph[{sigmaYLocal}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaYLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_a81fbfaed65a742a7dfd622e17652245e}


Definition at line 1221 of file qubits.c.

References ComplexArray::imag, MultiQubit::numAmps, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by sigmaY().


\begin{DoxyCode}
1222 {
1223         long long int sizeBlock, sizeHalfBlock;
1224         long long int thisBlock, // current block
1225              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
1226 
1227         REAL stateRealUp,stateImagUp;
1228         long long int thisTask;         
1229         const long long int numTasks=multiQubit.numAmps>>1;
1230 
1231         // set dimensions
1232         sizeHalfBlock = 1LL << targetQubit;  
1233         sizeBlock     = 2LL * sizeHalfBlock; 
1234 
1235         // Can't use multiQubit.stateVec as a private OMP var
1236         REAL *stateVecReal = multiQubit.stateVec.real;
1237         REAL *stateVecImag = multiQubit.stateVec.imag;
1238 
1239 # ifdef _OPENMP
1240 # pragma omp parallel \
1241         default  (none) \
1242         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag) \
1243         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp) 
1244 # endif
1245         {
1246 # ifdef _OPENMP
1247                 # pragma omp for schedule (static)
1248 # endif
1249                 for (thisTask=0; thisTask<numTasks; thisTask++) {
1250                         thisBlock   = thisTask / sizeHalfBlock;
1251                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
1252                         indexLo     = indexUp + sizeHalfBlock;
1253 
1254                         stateRealUp = stateVecReal[indexUp];
1255                         stateImagUp = stateVecImag[indexUp];
1256 
1257                         stateVecReal[indexUp] = stateVecImag[indexLo];
1258                         stateVecImag[indexUp] = -stateVecReal[indexLo];
1259 
1260                         stateVecReal[indexLo] = -stateImagUp;
1261                         stateVecImag[indexLo] = stateRealUp;
1262                 } 
1263         }
1264 }
\end{DoxyCode}
\hypertarget{qubits_8c_aebaab86326779de55d335cfea3efde8f}{
\index{qubits.c@{qubits.c}!sigmaZ@{sigmaZ}}
\index{sigmaZ@{sigmaZ}!qubits.c@{qubits.c}}
\paragraph[{sigmaZ}]{\setlength{\rightskip}{0pt plus 5cm}void sigmaZ ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_aebaab86326779de55d335cfea3efde8f}


Apply the single-\/qubit sigma-\/Z (also known as the Z, Pauli-\/Z or phase-\/flip) gate. This is a rotation of $\pi$ around the Z-\/axis (a phase shift) on the Bloch sphere. I.e. \[ \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {$\sigma_z$}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate on \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}). \end{DoxyExceptions}


Definition at line 1549 of file qubits.c.

References phaseGate(), and SIGMA\_\-Z.


\begin{DoxyCode}
1550 {
1551                 phaseGate(multiQubit, targetQubit, SIGMA_Z);
1552 }
\end{DoxyCode}
\hypertarget{qubits_8c_af764ea63a2e870098f4e1ce08562942e}{
\index{qubits.c@{qubits.c}!tGate@{tGate}}
\index{tGate@{tGate}!qubits.c@{qubits.c}}
\paragraph[{tGate}]{\setlength{\rightskip}{0pt plus 5cm}void tGate ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit})}\hfill}
\label{qubits_8c_af764ea63a2e870098f4e1ce08562942e}


Apply the single-\/qubit T gate. This is a rotation of $\pi/4$ around the Z-\/axis on the Bloch sphere, or the unitary: \[ \begin{pmatrix} 1 & 0 \\ 0 & \exp\left(i \frac{\pi}{4}\right) \end{pmatrix} \]

\[ \setlength{\fboxrule}{0.01pt} \fbox{ \begin{tikzpicture}[scale=.5] \node[draw=none] at (-3.5, 0) {target}; \draw (-2,0) -- (-1, 0); \draw (1, 0) -- (2, 0); \draw (-1,-1)--(-1,1)--(1,1)--(1,-1)--cycle; \node[draw=none] at (0, 0) {T}; \end{tikzpicture} } \]


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of all qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to operate upon \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em exitWithError}]if {\ttfamily targetQubit} is outside \mbox{[}0, {\ttfamily multiQubit.numQubits}) \end{DoxyExceptions}


Definition at line 1559 of file qubits.c.

References phaseGate(), and T\_\-GATE.


\begin{DoxyCode}
1560 {
1561                 phaseGate(multiQubit, targetQubit, T_GATE);
1562 }
\end{DoxyCode}
\hypertarget{qubits_8c_a2343b7240118e89aa615e2c9140b770b}{
\index{qubits.c@{qubits.c}!unitaryDistributed@{unitaryDistributed}}
\index{unitaryDistributed@{unitaryDistributed}!qubits.c@{qubits.c}}
\paragraph[{unitaryDistributed}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryDistributed ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf Complex} {\em rot1}, \/  {\bf Complex} {\em rot2}, \/  {\bf ComplexArray} {\em stateVecUp}, \/  {\bf ComplexArray} {\em stateVecLo}, \/  {\bf ComplexArray} {\em stateVecOut})}\hfill}
\label{qubits_8c_a2343b7240118e89aa615e2c9140b770b}


Apply a unitary operation to a single qubit given a subset of the state vector with upper and lower block values stored seperately. \begin{DoxyRemark}{Remarks}
Qubits are zero-\/based and the first qubit is the rightmost
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftrightarrow$} {\em multiQubit}]object representing the set of qubits \item[\mbox{$\leftarrow$} {\em targetQubit}]qubit to rotate \item[\mbox{$\leftarrow$} {\em u}]unitary matrix to apply \item[\mbox{$\leftarrow$} {\em stateVecUp}]probability amplitudes in upper half of a block \item[\mbox{$\leftarrow$} {\em stateVecLo}]probability amplitudes in lower half of a block \item[\mbox{$\rightarrow$} {\em stateVecOut}]array section to update (will correspond to either the lower or upper half of a block) \end{DoxyParams}


Definition at line 603 of file qubits.c.

References ComplexArray::imag, Complex::imag, MultiQubit::numAmps, ComplexArray::real, Complex::real, and REAL.

Referenced by unitary().


\begin{DoxyCode}
608 {
609 
610         REAL   stateRealUp,stateRealLo,stateImagUp,stateImagLo;
611         long long int thisTask;  
612         const long long int numTasks=multiQubit.numAmps;
613 
614         REAL rot1Real=rot1.real, rot1Imag=rot1.imag;
615         REAL rot2Real=rot2.real, rot2Imag=rot2.imag;
616         REAL *stateVecRealUp=stateVecUp.real, *stateVecImagUp=stateVecUp.imag;
617         REAL *stateVecRealLo=stateVecLo.real, *stateVecImagLo=stateVecLo.imag;
618         REAL *stateVecRealOut=stateVecOut.real, *stateVecImagOut=stateVecOut.
      imag;
619 
620 
621 # ifdef _OPENMP
622 # pragma omp parallel \
623         default  (none) \
624         shared   (stateVecRealUp,stateVecImagUp,stateVecRealLo,stateVecImagLo,sta
      teVecRealOut,stateVecImagOut, \
625                         rot1Real, rot1Imag, rot2Real, rot2Imag) \
626         private  (thisTask,stateRealUp,stateImagUp,stateRealLo,stateImagLo)
627 # endif
628         {
629 # ifdef _OPENMP
630                 # pragma omp for schedule (static)
631 # endif
632                 for (thisTask=0; thisTask<numTasks; thisTask++) {
633                         // store current state vector values in temp variables
634                         stateRealUp = stateVecRealUp[thisTask];
635                         stateImagUp = stateVecImagUp[thisTask];
636 
637                         stateRealLo = stateVecRealLo[thisTask];
638                         stateImagLo = stateVecImagLo[thisTask];
639 
640                         stateVecRealOut[thisTask] = rot1Real*stateRealUp - rot1Im
      ag*stateImagUp 
641                                 + rot2Real*stateRealLo - rot2Imag*stateImagLo;
642                         stateVecImagOut[thisTask] = rot1Real*stateImagUp + rot1Im
      ag*stateRealUp 
643                                 + rot2Real*stateImagLo + rot2Imag*stateRealLo;
644                 }
645         }
646 }
\end{DoxyCode}
\hypertarget{qubits_8c_ac134fb45b0a7248c5d15e16eb7139a35}{
\index{qubits.c@{qubits.c}!unitaryLocal@{unitaryLocal}}
\index{unitaryLocal@{unitaryLocal}!qubits.c@{qubits.c}}
\paragraph[{unitaryLocal}]{\setlength{\rightskip}{0pt plus 5cm}void unitaryLocal ({\bf MultiQubit} {\em multiQubit}, \/  const int {\em targetQubit}, \/  {\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8c_ac134fb45b0a7248c5d15e16eb7139a35}


Definition at line 477 of file qubits.c.

References Complex::imag, ComplexArray::imag, MultiQubit::numAmps, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, ComplexArray::real, REAL, and MultiQubit::stateVec.

Referenced by unitary().


\begin{DoxyCode}
478 {
479         long long int sizeBlock, sizeHalfBlock;
480         long long int thisBlock, // current block
481              indexUp,indexLo;    // current index and corresponding index in lowe
      r half block
482 
483         REAL stateRealUp,stateRealLo,stateImagUp,stateImagLo;
484         long long int thisTask;         
485         const long long int numTasks=multiQubit.numAmps>>1;
486 
487         // set dimensions
488         sizeHalfBlock = 1LL << targetQubit;  
489         sizeBlock     = 2LL * sizeHalfBlock; 
490 
491         // Can't use multiQubit.stateVec as a private OMP var
492         REAL *stateVecReal = multiQubit.stateVec.real;
493         REAL *stateVecImag = multiQubit.stateVec.imag;
494 
495 # ifdef _OPENMP
496 # pragma omp parallel \
497         default  (none) \
498         shared   (sizeBlock,sizeHalfBlock, stateVecReal,stateVecImag, u) \
499         private  (thisTask,thisBlock ,indexUp,indexLo, stateRealUp,stateImagUp,st
      ateRealLo,stateImagLo) 
500 # endif
501         {
502 # ifdef _OPENMP
503                 # pragma omp for schedule (static)
504 # endif
505                 for (thisTask=0; thisTask<numTasks; thisTask++) {
506 
507                         thisBlock   = thisTask / sizeHalfBlock;
508                         indexUp     = thisBlock*sizeBlock + thisTask%sizeHalfBloc
      k;
509                         indexLo     = indexUp + sizeHalfBlock;
510 
511                         // store current state vector values in temp variables
512                         stateRealUp = stateVecReal[indexUp];
513                         stateImagUp = stateVecImag[indexUp];
514 
515                         stateRealLo = stateVecReal[indexLo];
516                         stateImagLo = stateVecImag[indexLo];
517 
518 
519                         // state[indexUp] = u00 * state[indexUp] + u01 * state[in
      dexLo]
520                         stateVecReal[indexUp] = u.r0c0.real*stateRealUp - u.r0c0.
      imag*stateImagUp 
521                                 + u.r0c1.real*stateRealLo - u.r0c1.imag*stateImag
      Lo;
522                         stateVecImag[indexUp] = u.r0c0.real*stateImagUp + u.r0c0.
      imag*stateRealUp 
523                                 + u.r0c1.real*stateImagLo + u.r0c1.imag*stateReal
      Lo;
524 
525                         // state[indexLo] = u10  * state[indexUp] + u11 * state[i
      ndexLo]
526                         stateVecReal[indexLo] = u.r1c0.real*stateRealUp  - u.
      r1c0.imag*stateImagUp 
527                                 + u.r1c1.real*stateRealLo  -  u.r1c1.imag*stateIm
      agLo;
528                         stateVecImag[indexLo] = u.r1c0.real*stateImagUp + u.r1c0.
      imag*stateRealUp 
529                                 + u.r1c1.real*stateImagLo + u.r1c1.imag*stateReal
      Lo;
530 
531                 } 
532         }
533 } 
\end{DoxyCode}
\hypertarget{qubits_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}{
\index{qubits.c@{qubits.c}!validateAlphaBeta@{validateAlphaBeta}}
\index{validateAlphaBeta@{validateAlphaBeta}!qubits.c@{qubits.c}}
\paragraph[{validateAlphaBeta}]{\setlength{\rightskip}{0pt plus 5cm}int validateAlphaBeta ({\bf Complex} {\em alpha}, \/  {\bf Complex} {\em beta})}\hfill}
\label{qubits_8c_ae2b2c14a07dd7d50ff86032a3ca101d7}


Definition at line 366 of file qubits.c.

References Complex::imag, Complex::real, and REAL\_\-EPS.

Referenced by compactUnitary(), and controlledCompactUnitary().


\begin{DoxyCode}
366                                                   {
367         if ( fabs(alpha.real*alpha.real 
368                 + alpha.imag*alpha.imag
369                 + beta.real*beta.real 
370                 + beta.imag*beta.imag - 1) > REAL_EPS ) return 0;
371         else return 1;
372 }
\end{DoxyCode}
\hypertarget{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}{
\index{qubits.c@{qubits.c}!validateMatrixIsUnitary@{validateMatrixIsUnitary}}
\index{validateMatrixIsUnitary@{validateMatrixIsUnitary}!qubits.c@{qubits.c}}
\paragraph[{validateMatrixIsUnitary}]{\setlength{\rightskip}{0pt plus 5cm}int validateMatrixIsUnitary ({\bf ComplexMatrix2} {\em u})}\hfill}
\label{qubits_8c_ae4fea133d1a8f09ff8da03038100adb2}


Definition at line 341 of file qubits.c.

References Complex::imag, ComplexMatrix2::r0c0, ComplexMatrix2::r0c1, ComplexMatrix2::r1c0, ComplexMatrix2::r1c1, Complex::real, and REAL\_\-EPS.

Referenced by controlledUnitary(), multiControlledUnitary(), and unitary().


\begin{DoxyCode}
341                                              {
342 
343         if ( fabs(u.r0c0.real*u.r0c0.real 
344                 + u.r0c0.imag*u.r0c0.imag
345                 + u.r1c0.real*u.r1c0.real
346                 + u.r1c0.imag*u.r1c0.imag - 1) > REAL_EPS ) return 0;
347     // check
348         if ( fabs(u.r0c1.real*u.r0c1.real 
349                 + u.r0c1.imag*u.r0c1.imag
350                 + u.r1c1.real*u.r1c1.real
351                 + u.r1c1.imag*u.r1c1.imag - 1) > REAL_EPS ) return 0;
352 
353         if ( fabs(u.r0c0.real*u.r0c1.real 
354                 + u.r0c0.imag*u.r0c1.imag
355                 + u.r1c0.real*u.r1c1.real
356                 + u.r1c0.imag*u.r1c1.imag) > REAL_EPS ) return 0;
357 
358         if ( fabs(u.r0c1.real*u.r0c0.imag
359                 - u.r0c0.real*u.r0c1.imag
360                 + u.r1c1.real*u.r1c0.imag
361                 - u.r1c0.real*u.r1c1.imag) > REAL_EPS ) return 0;
362 
363         return 1;
364 }
\end{DoxyCode}
\hypertarget{qubits_8c_a71c14976f63cfcda70026fa20ee531fe}{
\index{qubits.c@{qubits.c}!validateUnitVector@{validateUnitVector}}
\index{validateUnitVector@{validateUnitVector}!qubits.c@{qubits.c}}
\paragraph[{validateUnitVector}]{\setlength{\rightskip}{0pt plus 5cm}int validateUnitVector (REAL {\em ux}, \/  REAL {\em uy}, \/  REAL {\em uz})}\hfill}
\label{qubits_8c_a71c14976f63cfcda70026fa20ee531fe}


Definition at line 374 of file qubits.c.

References REAL\_\-EPS.


\begin{DoxyCode}
374                                                  {
375         if ( fabs(sqrt(ux*ux + uy*uy + uz*uz) - 1) > REAL_EPS ) return 0;
376         else return 1;
377 }
\end{DoxyCode}


\subsubsection{Variable Documentation}
\hypertarget{qubits_8c_aac1637696885c75b73a1ecf381cea713}{
\index{qubits.c@{qubits.c}!errorCodes@{errorCodes}}
\index{errorCodes@{errorCodes}!qubits.c@{qubits.c}}
\paragraph[{errorCodes}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ {\bf errorCodes}\mbox{[}$\,$\mbox{]}}\hfill}
\label{qubits_8c_aac1637696885c75b73a1ecf381cea713}
{\bfseries Initial value:}
\begin{DoxyCode}
 {
    "Success",                                              
    "Invalid target qubit. Note qubits are zero indexed.",  
    "Invalid control qubit. Note qubits are zero indexed.", 
    "Control qubit cannot equal target qubit.",             
    "Invalid number of control qubits",                     
    "Invalid unitary matrix.",                              
    "Invalid rotation arguments.",                          
    "Invalid system size. Cannot print output for systems greater than 5 qubits."
      , 
    "Can't collapse to state with zero probability." 
    "Invalid number of qubits." 
    "Invalid measurement outcome -- must be either 0 or 1." 
}
\end{DoxyCode}


Definition at line 17 of file qubits.c.

Referenced by exitWithError().